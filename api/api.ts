/* tslint:disable */
/* eslint-disable */
/**
 * Jellyfin API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AccessSchedule
 */
export interface AccessSchedule {
    /**
     * 
     * @type {number}
     * @memberof AccessSchedule
     */
    Id: number;
    /**
     * 
     * @type {string}
     * @memberof AccessSchedule
     */
    UserId: string;
    /**
     * 
     * @type {DynamicDayOfWeek}
     * @memberof AccessSchedule
     */
    DayOfWeek: DynamicDayOfWeek;
    /**
     * 
     * @type {number}
     * @memberof AccessSchedule
     */
    StartHour: number;
    /**
     * 
     * @type {number}
     * @memberof AccessSchedule
     */
    EndHour: number;
}
/**
 * 
 * @export
 * @interface ActivityLogEntry
 */
export interface ActivityLogEntry {
    /**
     * 
     * @type {number}
     * @memberof ActivityLogEntry
     */
    Id?: number;
    /**
     * 
     * @type {string}
     * @memberof ActivityLogEntry
     */
    Name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ActivityLogEntry
     */
    Overview?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ActivityLogEntry
     */
    ShortOverview?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ActivityLogEntry
     */
    Type?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ActivityLogEntry
     */
    ItemId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ActivityLogEntry
     */
    Date?: string;
    /**
     * 
     * @type {string}
     * @memberof ActivityLogEntry
     */
    UserId?: string;
    /**
     * 
     * @type {string}
     * @memberof ActivityLogEntry
     * @deprecated
     */
    UserPrimaryImageTag?: string | null;
    /**
     * 
     * @type {LogLevel}
     * @memberof ActivityLogEntry
     */
    Severity?: LogLevel;
}
/**
 * 
 * @export
 * @interface ActivityLogEntryQueryResult
 */
export interface ActivityLogEntryQueryResult {
    /**
     * 
     * @type {Array<ActivityLogEntry>}
     * @memberof ActivityLogEntryQueryResult
     */
    Items?: Array<ActivityLogEntry> | null;
    /**
     * 
     * @type {number}
     * @memberof ActivityLogEntryQueryResult
     */
    TotalRecordCount?: number;
    /**
     * 
     * @type {number}
     * @memberof ActivityLogEntryQueryResult
     */
    StartIndex?: number;
}
/**
 * 
 * @export
 * @interface AddVirtualFolderDto
 */
export interface AddVirtualFolderDto {
    /**
     * 
     * @type {LibraryOptions}
     * @memberof AddVirtualFolderDto
     */
    LibraryOptions?: LibraryOptions;
}
/**
 * 
 * @export
 * @interface AlbumInfo
 */
export interface AlbumInfo {
    /**
     * 
     * @type {Array<string>}
     * @memberof AlbumInfo
     */
    AlbumArtists?: Array<string> | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof AlbumInfo
     */
    ArtistProviderIds?: { [key: string]: string; } | null;
    /**
     * 
     * @type {Array<SongInfo>}
     * @memberof AlbumInfo
     */
    SongInfos?: Array<SongInfo> | null;
    /**
     * 
     * @type {string}
     * @memberof AlbumInfo
     */
    Name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AlbumInfo
     */
    Path?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AlbumInfo
     */
    MetadataLanguage?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AlbumInfo
     */
    MetadataCountryCode?: string | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof AlbumInfo
     */
    ProviderIds?: { [key: string]: string; } | null;
    /**
     * 
     * @type {number}
     * @memberof AlbumInfo
     */
    Year?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AlbumInfo
     */
    IndexNumber?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AlbumInfo
     */
    ParentIndexNumber?: number | null;
    /**
     * 
     * @type {string}
     * @memberof AlbumInfo
     */
    PremiereDate?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof AlbumInfo
     */
    IsAutomated?: boolean;
}
/**
 * 
 * @export
 * @interface AlbumInfoRemoteSearchQuery
 */
export interface AlbumInfoRemoteSearchQuery {
    /**
     * 
     * @type {AlbumInfo}
     * @memberof AlbumInfoRemoteSearchQuery
     */
    SearchInfo?: AlbumInfo;
    /**
     * 
     * @type {string}
     * @memberof AlbumInfoRemoteSearchQuery
     */
    ItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof AlbumInfoRemoteSearchQuery
     */
    SearchProviderName?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof AlbumInfoRemoteSearchQuery
     */
    IncludeDisabledProviders?: boolean;
}
/**
 * 
 * @export
 * @interface AllThemeMediaResult
 */
export interface AllThemeMediaResult {
    /**
     * 
     * @type {ThemeMediaResult}
     * @memberof AllThemeMediaResult
     */
    ThemeVideosResult?: ThemeMediaResult;
    /**
     * 
     * @type {ThemeMediaResult}
     * @memberof AllThemeMediaResult
     */
    ThemeSongsResult?: ThemeMediaResult;
    /**
     * 
     * @type {ThemeMediaResult}
     * @memberof AllThemeMediaResult
     */
    SoundtrackSongsResult?: ThemeMediaResult;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum Architecture {
    X86 = 'X86',
    X64 = 'X64',
    Arm = 'Arm',
    Arm64 = 'Arm64'
}

/**
 * 
 * @export
 * @interface ArtistInfo
 */
export interface ArtistInfo {
    /**
     * 
     * @type {Array<SongInfo>}
     * @memberof ArtistInfo
     */
    SongInfos?: Array<SongInfo> | null;
    /**
     * 
     * @type {string}
     * @memberof ArtistInfo
     */
    Name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ArtistInfo
     */
    Path?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ArtistInfo
     */
    MetadataLanguage?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ArtistInfo
     */
    MetadataCountryCode?: string | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ArtistInfo
     */
    ProviderIds?: { [key: string]: string; } | null;
    /**
     * 
     * @type {number}
     * @memberof ArtistInfo
     */
    Year?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ArtistInfo
     */
    IndexNumber?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ArtistInfo
     */
    ParentIndexNumber?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ArtistInfo
     */
    PremiereDate?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ArtistInfo
     */
    IsAutomated?: boolean;
}
/**
 * 
 * @export
 * @interface ArtistInfoRemoteSearchQuery
 */
export interface ArtistInfoRemoteSearchQuery {
    /**
     * 
     * @type {ArtistInfo}
     * @memberof ArtistInfoRemoteSearchQuery
     */
    SearchInfo?: ArtistInfo;
    /**
     * 
     * @type {string}
     * @memberof ArtistInfoRemoteSearchQuery
     */
    ItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof ArtistInfoRemoteSearchQuery
     */
    SearchProviderName?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ArtistInfoRemoteSearchQuery
     */
    IncludeDisabledProviders?: boolean;
}
/**
 * 
 * @export
 * @interface AuthenticateUserByName
 */
export interface AuthenticateUserByName {
    /**
     * 
     * @type {string}
     * @memberof AuthenticateUserByName
     */
    Username?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AuthenticateUserByName
     */
    Pw?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AuthenticateUserByName
     */
    Password?: string | null;
}
/**
 * 
 * @export
 * @interface AuthenticationInfo
 */
export interface AuthenticationInfo {
    /**
     * 
     * @type {number}
     * @memberof AuthenticationInfo
     */
    Id?: number;
    /**
     * 
     * @type {string}
     * @memberof AuthenticationInfo
     */
    AccessToken?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AuthenticationInfo
     */
    DeviceId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AuthenticationInfo
     */
    AppName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AuthenticationInfo
     */
    AppVersion?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AuthenticationInfo
     */
    DeviceName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AuthenticationInfo
     */
    UserId?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AuthenticationInfo
     */
    IsActive?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AuthenticationInfo
     */
    DateCreated?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthenticationInfo
     */
    DateRevoked?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AuthenticationInfo
     */
    DateLastActivity?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthenticationInfo
     */
    UserName?: string | null;
}
/**
 * 
 * @export
 * @interface AuthenticationInfoQueryResult
 */
export interface AuthenticationInfoQueryResult {
    /**
     * 
     * @type {Array<AuthenticationInfo>}
     * @memberof AuthenticationInfoQueryResult
     */
    Items?: Array<AuthenticationInfo> | null;
    /**
     * 
     * @type {number}
     * @memberof AuthenticationInfoQueryResult
     */
    TotalRecordCount?: number;
    /**
     * 
     * @type {number}
     * @memberof AuthenticationInfoQueryResult
     */
    StartIndex?: number;
}
/**
 * 
 * @export
 * @interface AuthenticationResult
 */
export interface AuthenticationResult {
    /**
     * 
     * @type {UserDto}
     * @memberof AuthenticationResult
     */
    User?: UserDto;
    /**
     * 
     * @type {SessionInfo}
     * @memberof AuthenticationResult
     */
    SessionInfo?: SessionInfo;
    /**
     * 
     * @type {string}
     * @memberof AuthenticationResult
     */
    AccessToken?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AuthenticationResult
     */
    ServerId?: string | null;
}
/**
 * 
 * @export
 * @interface BaseItem
 */
export interface BaseItem {
    /**
     * 
     * @type {number}
     * @memberof BaseItem
     */
    Size?: number | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItem
     */
    Container?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItem
     */
    DateLastSaved?: string;
    /**
     * 
     * @type {Array<MediaUrl>}
     * @memberof BaseItem
     */
    RemoteTrailers?: Array<MediaUrl> | null;
    /**
     * 
     * @type {boolean}
     * @memberof BaseItem
     */
    IsHD?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BaseItem
     */
    IsShortcut?: boolean;
    /**
     * 
     * @type {string}
     * @memberof BaseItem
     */
    ShortcutPath?: string | null;
    /**
     * 
     * @type {number}
     * @memberof BaseItem
     */
    Width?: number;
    /**
     * 
     * @type {number}
     * @memberof BaseItem
     */
    Height?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof BaseItem
     */
    ExtraIds?: Array<string> | null;
    /**
     * 
     * @type {boolean}
     * @memberof BaseItem
     */
    SupportsExternalTransfer?: boolean;
}
/**
 * 
 * @export
 * @interface BaseItemDto
 */
export interface BaseItemDto {
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    Name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    OriginalTitle?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    ServerId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    Id?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    Etag?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    SourceType?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    PlaylistItemId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    DateCreated?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    DateLastMediaAdded?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    ExtraType?: string | null;
    /**
     * 
     * @type {number}
     * @memberof BaseItemDto
     */
    AirsBeforeSeasonNumber?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BaseItemDto
     */
    AirsAfterSeasonNumber?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BaseItemDto
     */
    AirsBeforeEpisodeNumber?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof BaseItemDto
     */
    CanDelete?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof BaseItemDto
     */
    CanDownload?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof BaseItemDto
     */
    HasSubtitles?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    PreferredMetadataLanguage?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    PreferredMetadataCountryCode?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof BaseItemDto
     */
    SupportsSync?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    Container?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    SortName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    ForcedSortName?: string | null;
    /**
     * 
     * @type {Video3DFormat}
     * @memberof BaseItemDto
     */
    Video3DFormat?: Video3DFormat;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    PremiereDate?: string | null;
    /**
     * 
     * @type {Array<ExternalUrl>}
     * @memberof BaseItemDto
     */
    ExternalUrls?: Array<ExternalUrl> | null;
    /**
     * 
     * @type {Array<MediaSourceInfo>}
     * @memberof BaseItemDto
     */
    MediaSources?: Array<MediaSourceInfo> | null;
    /**
     * 
     * @type {number}
     * @memberof BaseItemDto
     */
    CriticRating?: number | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof BaseItemDto
     */
    ProductionLocations?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    Path?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof BaseItemDto
     */
    EnableMediaSourceDisplay?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    OfficialRating?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    CustomRating?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    ChannelId?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    ChannelName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    Overview?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof BaseItemDto
     */
    Taglines?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof BaseItemDto
     */
    Genres?: Array<string> | null;
    /**
     * 
     * @type {number}
     * @memberof BaseItemDto
     */
    CommunityRating?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BaseItemDto
     */
    CumulativeRunTimeTicks?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BaseItemDto
     */
    RunTimeTicks?: number | null;
    /**
     * 
     * @type {PlayAccess}
     * @memberof BaseItemDto
     */
    PlayAccess?: PlayAccess;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    AspectRatio?: string | null;
    /**
     * 
     * @type {number}
     * @memberof BaseItemDto
     */
    ProductionYear?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof BaseItemDto
     */
    IsPlaceHolder?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    Number?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    ChannelNumber?: string | null;
    /**
     * 
     * @type {number}
     * @memberof BaseItemDto
     */
    IndexNumber?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BaseItemDto
     */
    IndexNumberEnd?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BaseItemDto
     */
    ParentIndexNumber?: number | null;
    /**
     * 
     * @type {Array<MediaUrl>}
     * @memberof BaseItemDto
     */
    RemoteTrailers?: Array<MediaUrl> | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof BaseItemDto
     */
    ProviderIds?: { [key: string]: string; } | null;
    /**
     * 
     * @type {boolean}
     * @memberof BaseItemDto
     */
    IsHD?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof BaseItemDto
     */
    IsFolder?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    ParentId?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    Type?: string | null;
    /**
     * 
     * @type {Array<BaseItemPerson>}
     * @memberof BaseItemDto
     */
    People?: Array<BaseItemPerson> | null;
    /**
     * 
     * @type {Array<NameGuidPair>}
     * @memberof BaseItemDto
     */
    Studios?: Array<NameGuidPair> | null;
    /**
     * 
     * @type {Array<NameGuidPair>}
     * @memberof BaseItemDto
     */
    GenreItems?: Array<NameGuidPair> | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    ParentLogoItemId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    ParentBackdropItemId?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof BaseItemDto
     */
    ParentBackdropImageTags?: Array<string> | null;
    /**
     * 
     * @type {number}
     * @memberof BaseItemDto
     */
    LocalTrailerCount?: number | null;
    /**
     * 
     * @type {UserItemDataDto}
     * @memberof BaseItemDto
     */
    UserData?: UserItemDataDto;
    /**
     * 
     * @type {number}
     * @memberof BaseItemDto
     */
    RecursiveItemCount?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BaseItemDto
     */
    ChildCount?: number | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    SeriesName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    SeriesId?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    SeasonId?: string;
    /**
     * 
     * @type {number}
     * @memberof BaseItemDto
     */
    SpecialFeatureCount?: number | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    DisplayPreferencesId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    Status?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    AirTime?: string | null;
    /**
     * 
     * @type {Array<DayOfWeek>}
     * @memberof BaseItemDto
     */
    AirDays?: Array<DayOfWeek> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof BaseItemDto
     */
    Tags?: Array<string> | null;
    /**
     * 
     * @type {number}
     * @memberof BaseItemDto
     */
    PrimaryImageAspectRatio?: number | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof BaseItemDto
     */
    Artists?: Array<string> | null;
    /**
     * 
     * @type {Array<NameGuidPair>}
     * @memberof BaseItemDto
     */
    ArtistItems?: Array<NameGuidPair> | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    Album?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    CollectionType?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    DisplayOrder?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    AlbumId?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    AlbumPrimaryImageTag?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    SeriesPrimaryImageTag?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    AlbumArtist?: string | null;
    /**
     * 
     * @type {Array<NameGuidPair>}
     * @memberof BaseItemDto
     */
    AlbumArtists?: Array<NameGuidPair> | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    SeasonName?: string | null;
    /**
     * 
     * @type {Array<MediaStream>}
     * @memberof BaseItemDto
     */
    MediaStreams?: Array<MediaStream> | null;
    /**
     * 
     * @type {VideoType}
     * @memberof BaseItemDto
     */
    VideoType?: VideoType;
    /**
     * 
     * @type {number}
     * @memberof BaseItemDto
     */
    PartCount?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BaseItemDto
     */
    MediaSourceCount?: number | null;
    /**
     * 
     * @type {BaseItemDtoImageTags}
     * @memberof BaseItemDto
     */
    ImageTags?: BaseItemDtoImageTags | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof BaseItemDto
     */
    BackdropImageTags?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof BaseItemDto
     */
    ScreenshotImageTags?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    ParentLogoImageTag?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    ParentArtItemId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    ParentArtImageTag?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    SeriesThumbImageTag?: string | null;
    /**
     * 
     * @type {BaseItemPersonImageBlurHashes}
     * @memberof BaseItemDto
     */
    ImageBlurHashes?: BaseItemPersonImageBlurHashes | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    SeriesStudio?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    ParentThumbItemId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    ParentThumbImageTag?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    ParentPrimaryImageItemId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    ParentPrimaryImageTag?: string | null;
    /**
     * 
     * @type {Array<ChapterInfo>}
     * @memberof BaseItemDto
     */
    Chapters?: Array<ChapterInfo> | null;
    /**
     * 
     * @type {LocationType}
     * @memberof BaseItemDto
     */
    LocationType?: LocationType;
    /**
     * 
     * @type {IsoType}
     * @memberof BaseItemDto
     */
    IsoType?: IsoType;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    MediaType?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    EndDate?: string | null;
    /**
     * 
     * @type {Array<MetadataField>}
     * @memberof BaseItemDto
     */
    LockedFields?: Array<MetadataField> | null;
    /**
     * 
     * @type {number}
     * @memberof BaseItemDto
     */
    TrailerCount?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BaseItemDto
     */
    MovieCount?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BaseItemDto
     */
    SeriesCount?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BaseItemDto
     */
    ProgramCount?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BaseItemDto
     */
    EpisodeCount?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BaseItemDto
     */
    SongCount?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BaseItemDto
     */
    AlbumCount?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BaseItemDto
     */
    ArtistCount?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BaseItemDto
     */
    MusicVideoCount?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof BaseItemDto
     */
    LockData?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof BaseItemDto
     */
    Width?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BaseItemDto
     */
    Height?: number | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    CameraMake?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    CameraModel?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    Software?: string | null;
    /**
     * 
     * @type {number}
     * @memberof BaseItemDto
     */
    ExposureTime?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BaseItemDto
     */
    FocalLength?: number | null;
    /**
     * 
     * @type {ImageOrientation}
     * @memberof BaseItemDto
     */
    ImageOrientation?: ImageOrientation;
    /**
     * 
     * @type {number}
     * @memberof BaseItemDto
     */
    Aperture?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BaseItemDto
     */
    ShutterSpeed?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BaseItemDto
     */
    Latitude?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BaseItemDto
     */
    Longitude?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BaseItemDto
     */
    Altitude?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BaseItemDto
     */
    IsoSpeedRating?: number | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    SeriesTimerId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    ProgramId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    ChannelPrimaryImageTag?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    StartDate?: string | null;
    /**
     * 
     * @type {number}
     * @memberof BaseItemDto
     */
    CompletionPercentage?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof BaseItemDto
     */
    IsRepeat?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    EpisodeTitle?: string | null;
    /**
     * 
     * @type {ChannelType}
     * @memberof BaseItemDto
     */
    ChannelType?: ChannelType;
    /**
     * 
     * @type {ProgramAudio}
     * @memberof BaseItemDto
     */
    Audio?: ProgramAudio;
    /**
     * 
     * @type {boolean}
     * @memberof BaseItemDto
     */
    IsMovie?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof BaseItemDto
     */
    IsSports?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof BaseItemDto
     */
    IsSeries?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof BaseItemDto
     */
    IsLive?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof BaseItemDto
     */
    IsNews?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof BaseItemDto
     */
    IsKids?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof BaseItemDto
     */
    IsPremiere?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDto
     */
    TimerId?: string | null;
    /**
     * 
     * @type {BaseItemDto}
     * @memberof BaseItemDto
     */
    CurrentProgram?: BaseItemDto;
}
/**
 * 
 * @export
 * @interface BaseItemDtoImageTags
 */
export interface BaseItemDtoImageTags {
    /**
     * 
     * @type {string}
     * @memberof BaseItemDtoImageTags
     */
    Primary?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDtoImageTags
     */
    Art?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDtoImageTags
     */
    Backdrop?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDtoImageTags
     */
    Banner?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDtoImageTags
     */
    Logo?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDtoImageTags
     */
    Thumb?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDtoImageTags
     */
    Disc?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDtoImageTags
     */
    Box?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDtoImageTags
     */
    Screenshot?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDtoImageTags
     */
    Menu?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDtoImageTags
     */
    Chapter?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDtoImageTags
     */
    BoxRear?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseItemDtoImageTags
     */
    Profile?: string;
}
/**
 * 
 * @export
 * @interface BaseItemDtoQueryResult
 */
export interface BaseItemDtoQueryResult {
    /**
     * 
     * @type {Array<BaseItemDto>}
     * @memberof BaseItemDtoQueryResult
     */
    Items?: Array<BaseItemDto> | null;
    /**
     * 
     * @type {number}
     * @memberof BaseItemDtoQueryResult
     */
    TotalRecordCount?: number;
    /**
     * 
     * @type {number}
     * @memberof BaseItemDtoQueryResult
     */
    StartIndex?: number;
}
/**
 * 
 * @export
 * @interface BaseItemPerson
 */
export interface BaseItemPerson {
    /**
     * 
     * @type {string}
     * @memberof BaseItemPerson
     */
    Name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemPerson
     */
    Id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemPerson
     */
    Role?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemPerson
     */
    Type?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BaseItemPerson
     */
    PrimaryImageTag?: string | null;
    /**
     * 
     * @type {BaseItemPersonImageBlurHashes}
     * @memberof BaseItemPerson
     */
    ImageBlurHashes?: BaseItemPersonImageBlurHashes | null;
}
/**
 * 
 * @export
 * @interface BaseItemPersonImageBlurHashes
 */
export interface BaseItemPersonImageBlurHashes {
    /**
     * 
     * @type {BaseItemPersonImageBlurHashesPrimary}
     * @memberof BaseItemPersonImageBlurHashes
     */
    Primary?: BaseItemPersonImageBlurHashesPrimary;
    /**
     * 
     * @type {BaseItemPersonImageBlurHashesPrimary}
     * @memberof BaseItemPersonImageBlurHashes
     */
    Art?: BaseItemPersonImageBlurHashesPrimary;
    /**
     * 
     * @type {BaseItemPersonImageBlurHashesPrimary}
     * @memberof BaseItemPersonImageBlurHashes
     */
    Backdrop?: BaseItemPersonImageBlurHashesPrimary;
    /**
     * 
     * @type {BaseItemPersonImageBlurHashesPrimary}
     * @memberof BaseItemPersonImageBlurHashes
     */
    Banner?: BaseItemPersonImageBlurHashesPrimary;
    /**
     * 
     * @type {BaseItemPersonImageBlurHashesPrimary}
     * @memberof BaseItemPersonImageBlurHashes
     */
    Logo?: BaseItemPersonImageBlurHashesPrimary;
    /**
     * 
     * @type {BaseItemPersonImageBlurHashesPrimary}
     * @memberof BaseItemPersonImageBlurHashes
     */
    Thumb?: BaseItemPersonImageBlurHashesPrimary;
    /**
     * 
     * @type {BaseItemPersonImageBlurHashesPrimary}
     * @memberof BaseItemPersonImageBlurHashes
     */
    Disc?: BaseItemPersonImageBlurHashesPrimary;
    /**
     * 
     * @type {BaseItemPersonImageBlurHashesPrimary}
     * @memberof BaseItemPersonImageBlurHashes
     */
    Box?: BaseItemPersonImageBlurHashesPrimary;
    /**
     * 
     * @type {BaseItemPersonImageBlurHashesPrimary}
     * @memberof BaseItemPersonImageBlurHashes
     */
    Screenshot?: BaseItemPersonImageBlurHashesPrimary;
    /**
     * 
     * @type {BaseItemPersonImageBlurHashesPrimary}
     * @memberof BaseItemPersonImageBlurHashes
     */
    Menu?: BaseItemPersonImageBlurHashesPrimary;
    /**
     * 
     * @type {BaseItemPersonImageBlurHashesPrimary}
     * @memberof BaseItemPersonImageBlurHashes
     */
    Chapter?: BaseItemPersonImageBlurHashesPrimary;
    /**
     * 
     * @type {BaseItemPersonImageBlurHashesPrimary}
     * @memberof BaseItemPersonImageBlurHashes
     */
    BoxRear?: BaseItemPersonImageBlurHashesPrimary;
    /**
     * 
     * @type {BaseItemPersonImageBlurHashesPrimary}
     * @memberof BaseItemPersonImageBlurHashes
     */
    Profile?: BaseItemPersonImageBlurHashesPrimary;
}
/**
 * 
 * @export
 * @interface BaseItemPersonImageBlurHashesPrimary
 */
export interface BaseItemPersonImageBlurHashesPrimary {
    /**
     * 
     * @type {string}
     * @memberof BaseItemPersonImageBlurHashesPrimary
     */
    string?: string;
}
/**
 * 
 * @export
 * @interface BookInfo
 */
export interface BookInfo {
    /**
     * 
     * @type {string}
     * @memberof BookInfo
     */
    SeriesName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BookInfo
     */
    Name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BookInfo
     */
    Path?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BookInfo
     */
    MetadataLanguage?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BookInfo
     */
    MetadataCountryCode?: string | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof BookInfo
     */
    ProviderIds?: { [key: string]: string; } | null;
    /**
     * 
     * @type {number}
     * @memberof BookInfo
     */
    Year?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BookInfo
     */
    IndexNumber?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BookInfo
     */
    ParentIndexNumber?: number | null;
    /**
     * 
     * @type {string}
     * @memberof BookInfo
     */
    PremiereDate?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof BookInfo
     */
    IsAutomated?: boolean;
}
/**
 * 
 * @export
 * @interface BookInfoRemoteSearchQuery
 */
export interface BookInfoRemoteSearchQuery {
    /**
     * 
     * @type {BookInfo}
     * @memberof BookInfoRemoteSearchQuery
     */
    SearchInfo?: BookInfo;
    /**
     * 
     * @type {string}
     * @memberof BookInfoRemoteSearchQuery
     */
    ItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof BookInfoRemoteSearchQuery
     */
    SearchProviderName?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof BookInfoRemoteSearchQuery
     */
    IncludeDisabledProviders?: boolean;
}
/**
 * 
 * @export
 * @interface BoxSetInfo
 */
export interface BoxSetInfo {
    /**
     * 
     * @type {string}
     * @memberof BoxSetInfo
     */
    Name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BoxSetInfo
     */
    Path?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BoxSetInfo
     */
    MetadataLanguage?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BoxSetInfo
     */
    MetadataCountryCode?: string | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof BoxSetInfo
     */
    ProviderIds?: { [key: string]: string; } | null;
    /**
     * 
     * @type {number}
     * @memberof BoxSetInfo
     */
    Year?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BoxSetInfo
     */
    IndexNumber?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BoxSetInfo
     */
    ParentIndexNumber?: number | null;
    /**
     * 
     * @type {string}
     * @memberof BoxSetInfo
     */
    PremiereDate?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof BoxSetInfo
     */
    IsAutomated?: boolean;
}
/**
 * 
 * @export
 * @interface BoxSetInfoRemoteSearchQuery
 */
export interface BoxSetInfoRemoteSearchQuery {
    /**
     * 
     * @type {BoxSetInfo}
     * @memberof BoxSetInfoRemoteSearchQuery
     */
    SearchInfo?: BoxSetInfo;
    /**
     * 
     * @type {string}
     * @memberof BoxSetInfoRemoteSearchQuery
     */
    ItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof BoxSetInfoRemoteSearchQuery
     */
    SearchProviderName?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof BoxSetInfoRemoteSearchQuery
     */
    IncludeDisabledProviders?: boolean;
}
/**
 * 
 * @export
 * @interface BrandingOptions
 */
export interface BrandingOptions {
    /**
     * 
     * @type {string}
     * @memberof BrandingOptions
     */
    LoginDisclaimer?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BrandingOptions
     */
    CustomCss?: string | null;
}
/**
 * 
 * @export
 * @interface ChannelFeatures
 */
export interface ChannelFeatures {
    /**
     * 
     * @type {string}
     * @memberof ChannelFeatures
     */
    Name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChannelFeatures
     */
    Id?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ChannelFeatures
     */
    CanSearch?: boolean;
    /**
     * 
     * @type {Array<ChannelMediaType>}
     * @memberof ChannelFeatures
     */
    MediaTypes?: Array<ChannelMediaType> | null;
    /**
     * 
     * @type {Array<ChannelMediaContentType>}
     * @memberof ChannelFeatures
     */
    ContentTypes?: Array<ChannelMediaContentType> | null;
    /**
     * 
     * @type {number}
     * @memberof ChannelFeatures
     */
    MaxPageSize?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ChannelFeatures
     */
    AutoRefreshLevels?: number | null;
    /**
     * 
     * @type {Array<ChannelItemSortField>}
     * @memberof ChannelFeatures
     */
    DefaultSortFields?: Array<ChannelItemSortField> | null;
    /**
     * 
     * @type {boolean}
     * @memberof ChannelFeatures
     */
    SupportsSortOrderToggle?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ChannelFeatures
     */
    SupportsLatestMedia?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ChannelFeatures
     */
    CanFilter?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ChannelFeatures
     */
    SupportsContentDownloading?: boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum ChannelItemSortField {
    Name = 'Name',
    CommunityRating = 'CommunityRating',
    PremiereDate = 'PremiereDate',
    DateCreated = 'DateCreated',
    Runtime = 'Runtime',
    PlayCount = 'PlayCount',
    CommunityPlayCount = 'CommunityPlayCount'
}

/**
 * 
 * @export
 * @interface ChannelMappingOptionsDto
 */
export interface ChannelMappingOptionsDto {
    /**
     * 
     * @type {Array<TunerChannelMapping>}
     * @memberof ChannelMappingOptionsDto
     */
    TunerChannels?: Array<TunerChannelMapping> | null;
    /**
     * 
     * @type {Array<NameIdPair>}
     * @memberof ChannelMappingOptionsDto
     */
    ProviderChannels?: Array<NameIdPair> | null;
    /**
     * 
     * @type {Array<NameValuePair>}
     * @memberof ChannelMappingOptionsDto
     */
    Mappings?: Array<NameValuePair> | null;
    /**
     * 
     * @type {string}
     * @memberof ChannelMappingOptionsDto
     */
    ProviderName?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum ChannelMediaContentType {
    Clip = 'Clip',
    Podcast = 'Podcast',
    Trailer = 'Trailer',
    Movie = 'Movie',
    Episode = 'Episode',
    Song = 'Song',
    MovieExtra = 'MovieExtra',
    TvExtra = 'TvExtra'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum ChannelMediaType {
    Audio = 'Audio',
    Video = 'Video',
    Photo = 'Photo'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum ChannelType {
    TV = 'TV',
    Radio = 'Radio'
}

/**
 * 
 * @export
 * @interface ChapterInfo
 */
export interface ChapterInfo {
    /**
     * 
     * @type {number}
     * @memberof ChapterInfo
     */
    StartPositionTicks?: number;
    /**
     * 
     * @type {string}
     * @memberof ChapterInfo
     */
    Name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChapterInfo
     */
    ImagePath?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChapterInfo
     */
    ImageDateModified?: string;
    /**
     * 
     * @type {string}
     * @memberof ChapterInfo
     */
    ImageTag?: string | null;
}
/**
 * 
 * @export
 * @interface ClientCapabilities
 */
export interface ClientCapabilities {
    /**
     * 
     * @type {Array<string>}
     * @memberof ClientCapabilities
     */
    PlayableMediaTypes?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClientCapabilities
     */
    SupportedCommands?: Array<string> | null;
    /**
     * 
     * @type {boolean}
     * @memberof ClientCapabilities
     */
    SupportsMediaControl?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ClientCapabilities
     */
    SupportsContentUploading?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ClientCapabilities
     */
    MessageCallbackUrl?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ClientCapabilities
     */
    SupportsPersistentIdentifier?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ClientCapabilities
     */
    SupportsSync?: boolean;
    /**
     * 
     * @type {DeviceProfile}
     * @memberof ClientCapabilities
     */
    DeviceProfile?: DeviceProfile;
    /**
     * 
     * @type {string}
     * @memberof ClientCapabilities
     */
    AppStoreUrl?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ClientCapabilities
     */
    IconUrl?: string | null;
}
/**
 * 
 * @export
 * @interface CodecProfile
 */
export interface CodecProfile {
    /**
     * 
     * @type {CodecType}
     * @memberof CodecProfile
     */
    Type?: CodecType;
    /**
     * 
     * @type {Array<ProfileCondition>}
     * @memberof CodecProfile
     */
    Conditions?: Array<ProfileCondition> | null;
    /**
     * 
     * @type {Array<ProfileCondition>}
     * @memberof CodecProfile
     */
    ApplyConditions?: Array<ProfileCondition> | null;
    /**
     * 
     * @type {string}
     * @memberof CodecProfile
     */
    Codec?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CodecProfile
     */
    Container?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum CodecType {
    Video = 'Video',
    VideoAudio = 'VideoAudio',
    Audio = 'Audio'
}

/**
 * 
 * @export
 * @interface CollectionCreationResult
 */
export interface CollectionCreationResult {
    /**
     * 
     * @type {string}
     * @memberof CollectionCreationResult
     */
    Id?: string;
}
/**
 * 
 * @export
 * @interface ConfigurationPageInfo
 */
export interface ConfigurationPageInfo {
    /**
     * 
     * @type {string}
     * @memberof ConfigurationPageInfo
     */
    Name?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigurationPageInfo
     */
    EnableInMainMenu?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ConfigurationPageInfo
     */
    MenuSection?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ConfigurationPageInfo
     */
    MenuIcon?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ConfigurationPageInfo
     */
    DisplayName?: string | null;
    /**
     * 
     * @type {ConfigurationPageType}
     * @memberof ConfigurationPageInfo
     */
    ConfigurationPageType?: ConfigurationPageType;
    /**
     * 
     * @type {string}
     * @memberof ConfigurationPageInfo
     */
    PluginId?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum ConfigurationPageType {
    PluginConfiguration = 'PluginConfiguration',
    None = 'None'
}

/**
 * 
 * @export
 * @interface ContainerProfile
 */
export interface ContainerProfile {
    /**
     * 
     * @type {DlnaProfileType}
     * @memberof ContainerProfile
     */
    Type?: DlnaProfileType;
    /**
     * 
     * @type {Array<ProfileCondition>}
     * @memberof ContainerProfile
     */
    Conditions?: Array<ProfileCondition> | null;
    /**
     * 
     * @type {string}
     * @memberof ContainerProfile
     */
    Container?: string | null;
}
/**
 * 
 * @export
 * @interface ControlResponse
 */
export interface ControlResponse {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ControlResponse
     */
    Headers?: { [key: string]: string; } | null;
    /**
     * 
     * @type {string}
     * @memberof ControlResponse
     */
    Xml?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ControlResponse
     */
    IsSuccessful?: boolean;
}
/**
 * 
 * @export
 * @interface CountryInfo
 */
export interface CountryInfo {
    /**
     * 
     * @type {string}
     * @memberof CountryInfo
     */
    Name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CountryInfo
     */
    DisplayName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CountryInfo
     */
    TwoLetterISORegionName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CountryInfo
     */
    ThreeLetterISORegionName?: string | null;
}
/**
 * 
 * @export
 * @interface CreatePlaylistDto
 */
export interface CreatePlaylistDto {
    /**
     * 
     * @type {string}
     * @memberof CreatePlaylistDto
     */
    Name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreatePlaylistDto
     */
    Ids?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreatePlaylistDto
     */
    UserId?: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePlaylistDto
     */
    MediaType?: string | null;
}
/**
 * 
 * @export
 * @interface CreateUserByName
 */
export interface CreateUserByName {
    /**
     * 
     * @type {string}
     * @memberof CreateUserByName
     */
    Name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateUserByName
     */
    Password?: string | null;
}
/**
 * 
 * @export
 * @interface CultureDto
 */
export interface CultureDto {
    /**
     * 
     * @type {string}
     * @memberof CultureDto
     */
    Name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CultureDto
     */
    DisplayName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CultureDto
     */
    TwoLetterISOLanguageName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CultureDto
     */
    ThreeLetterISOLanguageName?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof CultureDto
     */
    ThreeLetterISOLanguageNames?: Array<string> | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum DayOfWeek {
    Sunday = 'Sunday',
    Monday = 'Monday',
    Tuesday = 'Tuesday',
    Wednesday = 'Wednesday',
    Thursday = 'Thursday',
    Friday = 'Friday',
    Saturday = 'Saturday'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum DayPattern {
    Daily = 'Daily',
    Weekdays = 'Weekdays',
    Weekends = 'Weekends'
}

/**
 * 
 * @export
 * @interface DefaultDirectoryBrowserInfoDto
 */
export interface DefaultDirectoryBrowserInfoDto {
    /**
     * 
     * @type {string}
     * @memberof DefaultDirectoryBrowserInfoDto
     */
    Path?: string | null;
}
/**
 * 
 * @export
 * @interface DeviceIdentification
 */
export interface DeviceIdentification {
    /**
     * 
     * @type {string}
     * @memberof DeviceIdentification
     */
    FriendlyName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeviceIdentification
     */
    ModelNumber?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeviceIdentification
     */
    SerialNumber?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeviceIdentification
     */
    ModelName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeviceIdentification
     */
    ModelDescription?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeviceIdentification
     */
    DeviceDescription?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeviceIdentification
     */
    ModelUrl?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeviceIdentification
     */
    Manufacturer?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeviceIdentification
     */
    ManufacturerUrl?: string | null;
    /**
     * 
     * @type {Array<HttpHeaderInfo>}
     * @memberof DeviceIdentification
     */
    Headers?: Array<HttpHeaderInfo> | null;
}
/**
 * 
 * @export
 * @interface DeviceInfo
 */
export interface DeviceInfo {
    /**
     * 
     * @type {string}
     * @memberof DeviceInfo
     */
    Name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeviceInfo
     */
    Id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeviceInfo
     */
    LastUserName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeviceInfo
     */
    AppName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeviceInfo
     */
    AppVersion?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeviceInfo
     */
    LastUserId?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceInfo
     */
    DateLastActivity?: string;
    /**
     * 
     * @type {ClientCapabilities}
     * @memberof DeviceInfo
     */
    Capabilities?: ClientCapabilities;
    /**
     * 
     * @type {string}
     * @memberof DeviceInfo
     */
    IconUrl?: string | null;
}
/**
 * 
 * @export
 * @interface DeviceInfoQueryResult
 */
export interface DeviceInfoQueryResult {
    /**
     * 
     * @type {Array<DeviceInfo>}
     * @memberof DeviceInfoQueryResult
     */
    Items?: Array<DeviceInfo> | null;
    /**
     * 
     * @type {number}
     * @memberof DeviceInfoQueryResult
     */
    TotalRecordCount?: number;
    /**
     * 
     * @type {number}
     * @memberof DeviceInfoQueryResult
     */
    StartIndex?: number;
}
/**
 * 
 * @export
 * @interface DeviceOptions
 */
export interface DeviceOptions {
    /**
     * 
     * @type {string}
     * @memberof DeviceOptions
     */
    CustomName?: string | null;
}
/**
 * 
 * @export
 * @interface DeviceProfile
 */
export interface DeviceProfile {
    /**
     * 
     * @type {string}
     * @memberof DeviceProfile
     */
    Name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeviceProfile
     */
    Id?: string | null;
    /**
     * 
     * @type {DeviceIdentification}
     * @memberof DeviceProfile
     */
    Identification?: DeviceIdentification;
    /**
     * 
     * @type {string}
     * @memberof DeviceProfile
     */
    FriendlyName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeviceProfile
     */
    Manufacturer?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeviceProfile
     */
    ManufacturerUrl?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeviceProfile
     */
    ModelName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeviceProfile
     */
    ModelDescription?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeviceProfile
     */
    ModelNumber?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeviceProfile
     */
    ModelUrl?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeviceProfile
     */
    SerialNumber?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof DeviceProfile
     */
    EnableAlbumArtInDidl?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DeviceProfile
     */
    EnableSingleAlbumArtLimit?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DeviceProfile
     */
    EnableSingleSubtitleLimit?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DeviceProfile
     */
    SupportedMediaTypes?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeviceProfile
     */
    UserId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeviceProfile
     */
    AlbumArtPn?: string | null;
    /**
     * 
     * @type {number}
     * @memberof DeviceProfile
     */
    MaxAlbumArtWidth?: number;
    /**
     * 
     * @type {number}
     * @memberof DeviceProfile
     */
    MaxAlbumArtHeight?: number;
    /**
     * 
     * @type {number}
     * @memberof DeviceProfile
     */
    MaxIconWidth?: number | null;
    /**
     * 
     * @type {number}
     * @memberof DeviceProfile
     */
    MaxIconHeight?: number | null;
    /**
     * 
     * @type {number}
     * @memberof DeviceProfile
     */
    MaxStreamingBitrate?: number | null;
    /**
     * 
     * @type {number}
     * @memberof DeviceProfile
     */
    MaxStaticBitrate?: number | null;
    /**
     * 
     * @type {number}
     * @memberof DeviceProfile
     */
    MusicStreamingTranscodingBitrate?: number | null;
    /**
     * 
     * @type {number}
     * @memberof DeviceProfile
     */
    MaxStaticMusicBitrate?: number | null;
    /**
     * 
     * @type {string}
     * @memberof DeviceProfile
     */
    SonyAggregationFlags?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeviceProfile
     */
    ProtocolInfo?: string | null;
    /**
     * 
     * @type {number}
     * @memberof DeviceProfile
     */
    TimelineOffsetSeconds?: number;
    /**
     * 
     * @type {boolean}
     * @memberof DeviceProfile
     */
    RequiresPlainVideoItems?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DeviceProfile
     */
    RequiresPlainFolders?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DeviceProfile
     */
    EnableMSMediaReceiverRegistrar?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DeviceProfile
     */
    IgnoreTranscodeByteRangeRequests?: boolean;
    /**
     * 
     * @type {Array<XmlAttribute>}
     * @memberof DeviceProfile
     */
    XmlRootAttributes?: Array<XmlAttribute> | null;
    /**
     * 
     * @type {Array<DirectPlayProfile>}
     * @memberof DeviceProfile
     */
    DirectPlayProfiles?: Array<DirectPlayProfile> | null;
    /**
     * 
     * @type {Array<TranscodingProfile>}
     * @memberof DeviceProfile
     */
    TranscodingProfiles?: Array<TranscodingProfile> | null;
    /**
     * 
     * @type {Array<ContainerProfile>}
     * @memberof DeviceProfile
     */
    ContainerProfiles?: Array<ContainerProfile> | null;
    /**
     * 
     * @type {Array<CodecProfile>}
     * @memberof DeviceProfile
     */
    CodecProfiles?: Array<CodecProfile> | null;
    /**
     * 
     * @type {Array<ResponseProfile>}
     * @memberof DeviceProfile
     */
    ResponseProfiles?: Array<ResponseProfile> | null;
    /**
     * 
     * @type {Array<SubtitleProfile>}
     * @memberof DeviceProfile
     */
    SubtitleProfiles?: Array<SubtitleProfile> | null;
}
/**
 * 
 * @export
 * @interface DeviceProfileDto
 */
export interface DeviceProfileDto {
    /**
     * 
     * @type {DeviceProfile}
     * @memberof DeviceProfileDto
     */
    DeviceProfile?: DeviceProfile;
}
/**
 * 
 * @export
 * @interface DeviceProfileInfo
 */
export interface DeviceProfileInfo {
    /**
     * 
     * @type {string}
     * @memberof DeviceProfileInfo
     */
    Id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeviceProfileInfo
     */
    Name?: string | null;
    /**
     * 
     * @type {DeviceProfileType}
     * @memberof DeviceProfileInfo
     */
    Type?: DeviceProfileType;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum DeviceProfileType {
    System = 'System',
    User = 'User'
}

/**
 * 
 * @export
 * @interface DirectPlayProfile
 */
export interface DirectPlayProfile {
    /**
     * 
     * @type {string}
     * @memberof DirectPlayProfile
     */
    Container?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DirectPlayProfile
     */
    AudioCodec?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DirectPlayProfile
     */
    VideoCodec?: string | null;
    /**
     * 
     * @type {DlnaProfileType}
     * @memberof DirectPlayProfile
     */
    Type?: DlnaProfileType;
}
/**
 * 
 * @export
 * @interface DisplayPreferencesDto
 */
export interface DisplayPreferencesDto {
    /**
     * 
     * @type {string}
     * @memberof DisplayPreferencesDto
     */
    Id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DisplayPreferencesDto
     */
    ViewType?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DisplayPreferencesDto
     */
    SortBy?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DisplayPreferencesDto
     */
    IndexBy?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof DisplayPreferencesDto
     */
    RememberIndexing?: boolean;
    /**
     * 
     * @type {number}
     * @memberof DisplayPreferencesDto
     */
    PrimaryImageHeight?: number;
    /**
     * 
     * @type {number}
     * @memberof DisplayPreferencesDto
     */
    PrimaryImageWidth?: number;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof DisplayPreferencesDto
     */
    CustomPrefs?: { [key: string]: string; } | null;
    /**
     * 
     * @type {ScrollDirection}
     * @memberof DisplayPreferencesDto
     */
    ScrollDirection?: ScrollDirection;
    /**
     * 
     * @type {boolean}
     * @memberof DisplayPreferencesDto
     */
    ShowBackdrop?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DisplayPreferencesDto
     */
    RememberSorting?: boolean;
    /**
     * 
     * @type {SortOrder}
     * @memberof DisplayPreferencesDto
     */
    SortOrder?: SortOrder;
    /**
     * 
     * @type {boolean}
     * @memberof DisplayPreferencesDto
     */
    ShowSidebar?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DisplayPreferencesDto
     */
    Client?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum DlnaProfileType {
    Audio = 'Audio',
    Video = 'Video',
    Photo = 'Photo'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum DynamicDayOfWeek {
    Sunday = 'Sunday',
    Monday = 'Monday',
    Tuesday = 'Tuesday',
    Wednesday = 'Wednesday',
    Thursday = 'Thursday',
    Friday = 'Friday',
    Saturday = 'Saturday',
    Everyday = 'Everyday',
    Weekday = 'Weekday',
    Weekend = 'Weekend'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum EncodingContext {
    Streaming = 'Streaming',
    Static = 'Static'
}

/**
 * 
 * @export
 * @interface EndPointInfo
 */
export interface EndPointInfo {
    /**
     * 
     * @type {boolean}
     * @memberof EndPointInfo
     */
    IsLocal?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EndPointInfo
     */
    IsInNetwork?: boolean;
}
/**
 * 
 * @export
 * @interface ExternalIdInfo
 */
export interface ExternalIdInfo {
    /**
     * 
     * @type {string}
     * @memberof ExternalIdInfo
     */
    Name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExternalIdInfo
     */
    Key?: string | null;
    /**
     * 
     * @type {ExternalIdMediaType}
     * @memberof ExternalIdInfo
     */
    Type?: ExternalIdMediaType;
    /**
     * 
     * @type {string}
     * @memberof ExternalIdInfo
     */
    UrlFormatString?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum ExternalIdMediaType {
    Album = 'Album',
    AlbumArtist = 'AlbumArtist',
    Artist = 'Artist',
    BoxSet = 'BoxSet',
    Episode = 'Episode',
    Movie = 'Movie',
    OtherArtist = 'OtherArtist',
    Person = 'Person',
    ReleaseGroup = 'ReleaseGroup',
    Season = 'Season',
    Series = 'Series',
    Track = 'Track'
}

/**
 * 
 * @export
 * @interface ExternalUrl
 */
export interface ExternalUrl {
    /**
     * 
     * @type {string}
     * @memberof ExternalUrl
     */
    Name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExternalUrl
     */
    Url?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum FFmpegLocation {
    NotFound = 'NotFound',
    SetByArgument = 'SetByArgument',
    Custom = 'Custom',
    System = 'System'
}

/**
 * 
 * @export
 * @interface FileSystemEntryInfo
 */
export interface FileSystemEntryInfo {
    /**
     * 
     * @type {string}
     * @memberof FileSystemEntryInfo
     */
    Name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FileSystemEntryInfo
     */
    Path?: string | null;
    /**
     * 
     * @type {FileSystemEntryType}
     * @memberof FileSystemEntryInfo
     */
    Type?: FileSystemEntryType;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum FileSystemEntryType {
    File = 'File',
    Directory = 'Directory',
    NetworkComputer = 'NetworkComputer',
    NetworkShare = 'NetworkShare'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum ForgotPasswordAction {
    ContactAdmin = 'ContactAdmin',
    PinCode = 'PinCode',
    InNetworkRequired = 'InNetworkRequired'
}

/**
 * 
 * @export
 * @interface ForgotPasswordResult
 */
export interface ForgotPasswordResult {
    /**
     * 
     * @type {ForgotPasswordAction}
     * @memberof ForgotPasswordResult
     */
    Action?: ForgotPasswordAction;
    /**
     * 
     * @type {string}
     * @memberof ForgotPasswordResult
     */
    PinFile?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ForgotPasswordResult
     */
    PinExpirationDate?: string | null;
}
/**
 * 
 * @export
 * @interface GeneralCommand
 */
export interface GeneralCommand {
    /**
     * 
     * @type {string}
     * @memberof GeneralCommand
     */
    Name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GeneralCommand
     */
    ControllingUserId?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof GeneralCommand
     */
    Arguments?: { [key: string]: string; } | null;
}
/**
 * 
 * @export
 * @interface GetProgramsDto
 */
export interface GetProgramsDto {
    /**
     * 
     * @type {string}
     * @memberof GetProgramsDto
     */
    ChannelIds?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetProgramsDto
     */
    UserId?: string;
    /**
     * 
     * @type {string}
     * @memberof GetProgramsDto
     */
    MinStartDate?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof GetProgramsDto
     */
    HasAired?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof GetProgramsDto
     */
    IsAiring?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof GetProgramsDto
     */
    MaxStartDate?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetProgramsDto
     */
    MinEndDate?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetProgramsDto
     */
    MaxEndDate?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof GetProgramsDto
     */
    IsMovie?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof GetProgramsDto
     */
    IsSeries?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof GetProgramsDto
     */
    IsNews?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof GetProgramsDto
     */
    IsKids?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof GetProgramsDto
     */
    IsSports?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof GetProgramsDto
     */
    StartIndex?: number | null;
    /**
     * 
     * @type {number}
     * @memberof GetProgramsDto
     */
    Limit?: number | null;
    /**
     * 
     * @type {string}
     * @memberof GetProgramsDto
     */
    SortBy?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetProgramsDto
     */
    SortOrder?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetProgramsDto
     */
    Genres?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetProgramsDto
     */
    GenreIds?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof GetProgramsDto
     */
    EnableImages?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof GetProgramsDto
     */
    EnableTotalRecordCount?: boolean;
    /**
     * 
     * @type {number}
     * @memberof GetProgramsDto
     */
    ImageTypeLimit?: number | null;
    /**
     * 
     * @type {string}
     * @memberof GetProgramsDto
     */
    EnableImageTypes?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof GetProgramsDto
     */
    EnableUserData?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof GetProgramsDto
     */
    SeriesTimerId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetProgramsDto
     */
    LibrarySeriesId?: string;
    /**
     * 
     * @type {string}
     * @memberof GetProgramsDto
     */
    Fields?: string | null;
}
/**
 * 
 * @export
 * @interface GroupInfoView
 */
export interface GroupInfoView {
    /**
     * 
     * @type {string}
     * @memberof GroupInfoView
     */
    GroupId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GroupInfoView
     */
    PlayingItemId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GroupInfoView
     */
    PlayingItemName?: string | null;
    /**
     * 
     * @type {number}
     * @memberof GroupInfoView
     */
    PositionTicks?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof GroupInfoView
     */
    Participants?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface GuideInfo
 */
export interface GuideInfo {
    /**
     * 
     * @type {string}
     * @memberof GuideInfo
     */
    StartDate?: string;
    /**
     * 
     * @type {string}
     * @memberof GuideInfo
     */
    EndDate?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum HeaderMatchType {
    Equals = 'Equals',
    Regex = 'Regex',
    Substring = 'Substring'
}

/**
 * 
 * @export
 * @interface HttpHeaderInfo
 */
export interface HttpHeaderInfo {
    /**
     * 
     * @type {string}
     * @memberof HttpHeaderInfo
     */
    Name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof HttpHeaderInfo
     */
    Value?: string | null;
    /**
     * 
     * @type {HeaderMatchType}
     * @memberof HttpHeaderInfo
     */
    Match?: HeaderMatchType;
}
/**
 * 
 * @export
 * @interface IScheduledTask
 */
export interface IScheduledTask {
    /**
     * 
     * @type {string}
     * @memberof IScheduledTask
     */
    Name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IScheduledTask
     */
    Key?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IScheduledTask
     */
    Description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IScheduledTask
     */
    Category?: string | null;
}
/**
 * 
 * @export
 * @interface IScheduledTaskWorker
 */
export interface IScheduledTaskWorker {
    /**
     * 
     * @type {IScheduledTask}
     * @memberof IScheduledTaskWorker
     */
    ScheduledTask?: IScheduledTask;
    /**
     * 
     * @type {TaskResult}
     * @memberof IScheduledTaskWorker
     */
    LastExecutionResult?: TaskResult;
    /**
     * 
     * @type {string}
     * @memberof IScheduledTaskWorker
     */
    Name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IScheduledTaskWorker
     */
    Description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IScheduledTaskWorker
     */
    Category?: string | null;
    /**
     * 
     * @type {TaskState}
     * @memberof IScheduledTaskWorker
     */
    State?: TaskState;
    /**
     * 
     * @type {number}
     * @memberof IScheduledTaskWorker
     */
    CurrentProgress?: number | null;
    /**
     * 
     * @type {Array<TaskTriggerInfo>}
     * @memberof IScheduledTaskWorker
     */
    Triggers?: Array<TaskTriggerInfo> | null;
    /**
     * 
     * @type {string}
     * @memberof IScheduledTaskWorker
     */
    Id?: string | null;
}
/**
 * 
 * @export
 * @interface ImageByNameInfo
 */
export interface ImageByNameInfo {
    /**
     * 
     * @type {string}
     * @memberof ImageByNameInfo
     */
    Name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ImageByNameInfo
     */
    Theme?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ImageByNameInfo
     */
    Context?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ImageByNameInfo
     */
    FileLength?: number;
    /**
     * 
     * @type {string}
     * @memberof ImageByNameInfo
     */
    Format?: string | null;
}
/**
 * 
 * @export
 * @interface ImageInfo
 */
export interface ImageInfo {
    /**
     * 
     * @type {ImageType}
     * @memberof ImageInfo
     */
    ImageType?: ImageType;
    /**
     * 
     * @type {number}
     * @memberof ImageInfo
     */
    ImageIndex?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ImageInfo
     */
    ImageTag?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ImageInfo
     */
    Path?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ImageInfo
     */
    BlurHash?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ImageInfo
     */
    Height?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ImageInfo
     */
    Width?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ImageInfo
     */
    Size?: number;
}
/**
 * 
 * @export
 * @interface ImageOption
 */
export interface ImageOption {
    /**
     * 
     * @type {ImageType}
     * @memberof ImageOption
     */
    Type?: ImageType;
    /**
     * 
     * @type {number}
     * @memberof ImageOption
     */
    Limit?: number;
    /**
     * 
     * @type {number}
     * @memberof ImageOption
     */
    MinWidth?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum ImageOrientation {
    TopLeft = 'TopLeft',
    TopRight = 'TopRight',
    BottomRight = 'BottomRight',
    BottomLeft = 'BottomLeft',
    LeftTop = 'LeftTop',
    RightTop = 'RightTop',
    RightBottom = 'RightBottom',
    LeftBottom = 'LeftBottom'
}

/**
 * 
 * @export
 * @interface ImageProviderInfo
 */
export interface ImageProviderInfo {
    /**
     * 
     * @type {string}
     * @memberof ImageProviderInfo
     */
    Name?: string | null;
    /**
     * 
     * @type {Array<ImageType>}
     * @memberof ImageProviderInfo
     */
    SupportedImages?: Array<ImageType> | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum ImageSavingConvention {
    Legacy = 'Legacy',
    Compatible = 'Compatible'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum ImageType {
    Primary = 'Primary',
    Art = 'Art',
    Backdrop = 'Backdrop',
    Banner = 'Banner',
    Logo = 'Logo',
    Thumb = 'Thumb',
    Disc = 'Disc',
    Box = 'Box',
    Screenshot = 'Screenshot',
    Menu = 'Menu',
    Chapter = 'Chapter',
    BoxRear = 'BoxRear',
    Profile = 'Profile'
}

/**
 * 
 * @export
 * @interface InstallationInfo
 */
export interface InstallationInfo {
    /**
     * 
     * @type {string}
     * @memberof InstallationInfo
     */
    Guid?: string;
    /**
     * 
     * @type {string}
     * @memberof InstallationInfo
     */
    Name?: string | null;
    /**
     * 
     * @type {Version}
     * @memberof InstallationInfo
     */
    Version?: Version;
    /**
     * 
     * @type {string}
     * @memberof InstallationInfo
     */
    Changelog?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InstallationInfo
     */
    SourceUrl?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InstallationInfo
     */
    Checksum?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum IsoType {
    Dvd = 'Dvd',
    BluRay = 'BluRay'
}

/**
 * 
 * @export
 * @interface ItemCounts
 */
export interface ItemCounts {
    /**
     * 
     * @type {number}
     * @memberof ItemCounts
     */
    MovieCount?: number;
    /**
     * 
     * @type {number}
     * @memberof ItemCounts
     */
    SeriesCount?: number;
    /**
     * 
     * @type {number}
     * @memberof ItemCounts
     */
    EpisodeCount?: number;
    /**
     * 
     * @type {number}
     * @memberof ItemCounts
     */
    ArtistCount?: number;
    /**
     * 
     * @type {number}
     * @memberof ItemCounts
     */
    ProgramCount?: number;
    /**
     * 
     * @type {number}
     * @memberof ItemCounts
     */
    TrailerCount?: number;
    /**
     * 
     * @type {number}
     * @memberof ItemCounts
     */
    SongCount?: number;
    /**
     * 
     * @type {number}
     * @memberof ItemCounts
     */
    AlbumCount?: number;
    /**
     * 
     * @type {number}
     * @memberof ItemCounts
     */
    MusicVideoCount?: number;
    /**
     * 
     * @type {number}
     * @memberof ItemCounts
     */
    BoxSetCount?: number;
    /**
     * 
     * @type {number}
     * @memberof ItemCounts
     */
    BookCount?: number;
    /**
     * 
     * @type {number}
     * @memberof ItemCounts
     */
    ItemCount?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum KeepUntil {
    UntilDeleted = 'UntilDeleted',
    UntilSpaceNeeded = 'UntilSpaceNeeded',
    UntilWatched = 'UntilWatched',
    UntilDate = 'UntilDate'
}

/**
 * 
 * @export
 * @interface LibraryOptionInfoDto
 */
export interface LibraryOptionInfoDto {
    /**
     * 
     * @type {string}
     * @memberof LibraryOptionInfoDto
     */
    Name?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof LibraryOptionInfoDto
     */
    DefaultEnabled?: boolean;
}
/**
 * 
 * @export
 * @interface LibraryOptions
 */
export interface LibraryOptions {
    /**
     * 
     * @type {boolean}
     * @memberof LibraryOptions
     */
    EnablePhotos?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LibraryOptions
     */
    EnableRealtimeMonitor?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LibraryOptions
     */
    EnableChapterImageExtraction?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LibraryOptions
     */
    ExtractChapterImagesDuringLibraryScan?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LibraryOptions
     */
    DownloadImagesInAdvance?: boolean;
    /**
     * 
     * @type {Array<MediaPathInfo>}
     * @memberof LibraryOptions
     */
    PathInfos?: Array<MediaPathInfo> | null;
    /**
     * 
     * @type {boolean}
     * @memberof LibraryOptions
     */
    SaveLocalMetadata?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LibraryOptions
     */
    EnableInternetProviders?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LibraryOptions
     */
    ImportMissingEpisodes?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LibraryOptions
     */
    EnableAutomaticSeriesGrouping?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LibraryOptions
     */
    EnableEmbeddedTitles?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LibraryOptions
     */
    EnableEmbeddedEpisodeInfos?: boolean;
    /**
     * 
     * @type {number}
     * @memberof LibraryOptions
     */
    AutomaticRefreshIntervalDays?: number;
    /**
     * 
     * @type {string}
     * @memberof LibraryOptions
     */
    PreferredMetadataLanguage?: string | null;
    /**
     * 
     * @type {string}
     * @memberof LibraryOptions
     */
    MetadataCountryCode?: string | null;
    /**
     * 
     * @type {string}
     * @memberof LibraryOptions
     */
    SeasonZeroDisplayName?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof LibraryOptions
     */
    MetadataSavers?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof LibraryOptions
     */
    DisabledLocalMetadataReaders?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof LibraryOptions
     */
    LocalMetadataReaderOrder?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof LibraryOptions
     */
    DisabledSubtitleFetchers?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof LibraryOptions
     */
    SubtitleFetcherOrder?: Array<string> | null;
    /**
     * 
     * @type {boolean}
     * @memberof LibraryOptions
     */
    SkipSubtitlesIfEmbeddedSubtitlesPresent?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LibraryOptions
     */
    SkipSubtitlesIfAudioTrackMatches?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof LibraryOptions
     */
    SubtitleDownloadLanguages?: Array<string> | null;
    /**
     * 
     * @type {boolean}
     * @memberof LibraryOptions
     */
    RequirePerfectSubtitleMatch?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LibraryOptions
     */
    SaveSubtitlesWithMedia?: boolean;
    /**
     * 
     * @type {Array<TypeOptions>}
     * @memberof LibraryOptions
     */
    TypeOptions?: Array<TypeOptions> | null;
}
/**
 * 
 * @export
 * @interface LibraryOptionsResultDto
 */
export interface LibraryOptionsResultDto {
    /**
     * 
     * @type {Array<LibraryOptionInfoDto>}
     * @memberof LibraryOptionsResultDto
     */
    MetadataSavers?: Array<LibraryOptionInfoDto> | null;
    /**
     * 
     * @type {Array<LibraryOptionInfoDto>}
     * @memberof LibraryOptionsResultDto
     */
    MetadataReaders?: Array<LibraryOptionInfoDto> | null;
    /**
     * 
     * @type {Array<LibraryOptionInfoDto>}
     * @memberof LibraryOptionsResultDto
     */
    SubtitleFetchers?: Array<LibraryOptionInfoDto> | null;
    /**
     * 
     * @type {Array<LibraryTypeOptionsDto>}
     * @memberof LibraryOptionsResultDto
     */
    TypeOptions?: Array<LibraryTypeOptionsDto> | null;
}
/**
 * 
 * @export
 * @interface LibraryTypeOptionsDto
 */
export interface LibraryTypeOptionsDto {
    /**
     * 
     * @type {string}
     * @memberof LibraryTypeOptionsDto
     */
    Type?: string | null;
    /**
     * 
     * @type {Array<LibraryOptionInfoDto>}
     * @memberof LibraryTypeOptionsDto
     */
    MetadataFetchers?: Array<LibraryOptionInfoDto> | null;
    /**
     * 
     * @type {Array<LibraryOptionInfoDto>}
     * @memberof LibraryTypeOptionsDto
     */
    ImageFetchers?: Array<LibraryOptionInfoDto> | null;
    /**
     * 
     * @type {Array<ImageType>}
     * @memberof LibraryTypeOptionsDto
     */
    SupportedImageTypes?: Array<ImageType> | null;
    /**
     * 
     * @type {Array<ImageOption>}
     * @memberof LibraryTypeOptionsDto
     */
    DefaultImageOptions?: Array<ImageOption> | null;
}
/**
 * 
 * @export
 * @interface ListingsProviderInfo
 */
export interface ListingsProviderInfo {
    /**
     * 
     * @type {string}
     * @memberof ListingsProviderInfo
     */
    Id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ListingsProviderInfo
     */
    Type?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ListingsProviderInfo
     */
    Username?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ListingsProviderInfo
     */
    Password?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ListingsProviderInfo
     */
    ListingsId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ListingsProviderInfo
     */
    ZipCode?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ListingsProviderInfo
     */
    Country?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ListingsProviderInfo
     */
    Path?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ListingsProviderInfo
     */
    EnabledTuners?: Array<string> | null;
    /**
     * 
     * @type {boolean}
     * @memberof ListingsProviderInfo
     */
    EnableAllTuners?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof ListingsProviderInfo
     */
    NewsCategories?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ListingsProviderInfo
     */
    SportsCategories?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ListingsProviderInfo
     */
    KidsCategories?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ListingsProviderInfo
     */
    MovieCategories?: Array<string> | null;
    /**
     * 
     * @type {Array<NameValuePair>}
     * @memberof ListingsProviderInfo
     */
    ChannelMappings?: Array<NameValuePair> | null;
    /**
     * 
     * @type {string}
     * @memberof ListingsProviderInfo
     */
    MoviePrefix?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ListingsProviderInfo
     */
    PreferredLanguage?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ListingsProviderInfo
     */
    UserAgent?: string | null;
}
/**
 * 
 * @export
 * @interface LiveStreamResponse
 */
export interface LiveStreamResponse {
    /**
     * 
     * @type {MediaSourceInfo}
     * @memberof LiveStreamResponse
     */
    MediaSource?: MediaSourceInfo;
}
/**
 * 
 * @export
 * @interface LiveTvInfo
 */
export interface LiveTvInfo {
    /**
     * 
     * @type {Array<LiveTvServiceInfo>}
     * @memberof LiveTvInfo
     */
    Services?: Array<LiveTvServiceInfo> | null;
    /**
     * 
     * @type {boolean}
     * @memberof LiveTvInfo
     */
    IsEnabled?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof LiveTvInfo
     */
    EnabledUsers?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface LiveTvServiceInfo
 */
export interface LiveTvServiceInfo {
    /**
     * 
     * @type {string}
     * @memberof LiveTvServiceInfo
     */
    Name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof LiveTvServiceInfo
     */
    HomePageUrl?: string | null;
    /**
     * 
     * @type {LiveTvServiceStatus}
     * @memberof LiveTvServiceInfo
     */
    Status?: LiveTvServiceStatus;
    /**
     * 
     * @type {string}
     * @memberof LiveTvServiceInfo
     */
    StatusMessage?: string | null;
    /**
     * 
     * @type {string}
     * @memberof LiveTvServiceInfo
     */
    Version?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof LiveTvServiceInfo
     */
    HasUpdateAvailable?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LiveTvServiceInfo
     */
    IsVisible?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof LiveTvServiceInfo
     */
    Tuners?: Array<string> | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum LiveTvServiceStatus {
    Ok = 'Ok',
    Unavailable = 'Unavailable'
}

/**
 * 
 * @export
 * @interface LocalizationOption
 */
export interface LocalizationOption {
    /**
     * 
     * @type {string}
     * @memberof LocalizationOption
     */
    Name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof LocalizationOption
     */
    Value?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum LocationType {
    FileSystem = 'FileSystem',
    Remote = 'Remote',
    Virtual = 'Virtual',
    Offline = 'Offline'
}

/**
 * 
 * @export
 * @interface LogFile
 */
export interface LogFile {
    /**
     * 
     * @type {string}
     * @memberof LogFile
     */
    DateCreated?: string;
    /**
     * 
     * @type {string}
     * @memberof LogFile
     */
    DateModified?: string;
    /**
     * 
     * @type {number}
     * @memberof LogFile
     */
    Size?: number;
    /**
     * 
     * @type {string}
     * @memberof LogFile
     */
    Name?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum LogLevel {
    Trace = 'Trace',
    Debug = 'Debug',
    Information = 'Information',
    Warning = 'Warning',
    Error = 'Error',
    Critical = 'Critical',
    None = 'None'
}

/**
 * 
 * @export
 * @interface MBRegistrationRecord
 */
export interface MBRegistrationRecord {
    /**
     * 
     * @type {string}
     * @memberof MBRegistrationRecord
     */
    ExpirationDate?: string;
    /**
     * 
     * @type {boolean}
     * @memberof MBRegistrationRecord
     */
    IsRegistered?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MBRegistrationRecord
     */
    RegChecked?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MBRegistrationRecord
     */
    RegError?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MBRegistrationRecord
     */
    TrialVersion?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MBRegistrationRecord
     */
    IsValid?: boolean;
}
/**
 * 
 * @export
 * @interface MediaAttachment
 */
export interface MediaAttachment {
    /**
     * 
     * @type {string}
     * @memberof MediaAttachment
     */
    Codec?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MediaAttachment
     */
    CodecTag?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MediaAttachment
     */
    Comment?: string | null;
    /**
     * 
     * @type {number}
     * @memberof MediaAttachment
     */
    Index?: number;
    /**
     * 
     * @type {string}
     * @memberof MediaAttachment
     */
    FileName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MediaAttachment
     */
    MimeType?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MediaAttachment
     */
    DeliveryUrl?: string | null;
}
/**
 * 
 * @export
 * @interface MediaEncoderPathDto
 */
export interface MediaEncoderPathDto {
    /**
     * 
     * @type {string}
     * @memberof MediaEncoderPathDto
     */
    Path?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MediaEncoderPathDto
     */
    PathType?: string | null;
}
/**
 * 
 * @export
 * @interface MediaPathDto
 */
export interface MediaPathDto {
    /**
     * 
     * @type {string}
     * @memberof MediaPathDto
     */
    Name: string;
    /**
     * 
     * @type {string}
     * @memberof MediaPathDto
     */
    Path?: string | null;
    /**
     * 
     * @type {MediaPathInfo}
     * @memberof MediaPathDto
     */
    PathInfo?: MediaPathInfo;
}
/**
 * 
 * @export
 * @interface MediaPathInfo
 */
export interface MediaPathInfo {
    /**
     * 
     * @type {string}
     * @memberof MediaPathInfo
     */
    Path?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MediaPathInfo
     */
    NetworkPath?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum MediaProtocol {
    File = 'File',
    Http = 'Http',
    Rtmp = 'Rtmp',
    Rtsp = 'Rtsp',
    Udp = 'Udp',
    Rtp = 'Rtp',
    Ftp = 'Ftp'
}

/**
 * 
 * @export
 * @interface MediaSourceInfo
 */
export interface MediaSourceInfo {
    /**
     * 
     * @type {MediaProtocol}
     * @memberof MediaSourceInfo
     */
    Protocol?: MediaProtocol;
    /**
     * 
     * @type {string}
     * @memberof MediaSourceInfo
     */
    Id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MediaSourceInfo
     */
    Path?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MediaSourceInfo
     */
    EncoderPath?: string | null;
    /**
     * 
     * @type {MediaProtocol}
     * @memberof MediaSourceInfo
     */
    EncoderProtocol?: MediaProtocol;
    /**
     * 
     * @type {MediaSourceType}
     * @memberof MediaSourceInfo
     */
    Type?: MediaSourceType;
    /**
     * 
     * @type {string}
     * @memberof MediaSourceInfo
     */
    Container?: string | null;
    /**
     * 
     * @type {number}
     * @memberof MediaSourceInfo
     */
    Size?: number | null;
    /**
     * 
     * @type {string}
     * @memberof MediaSourceInfo
     */
    Name?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof MediaSourceInfo
     */
    IsRemote?: boolean;
    /**
     * 
     * @type {string}
     * @memberof MediaSourceInfo
     */
    ETag?: string | null;
    /**
     * 
     * @type {number}
     * @memberof MediaSourceInfo
     */
    RunTimeTicks?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof MediaSourceInfo
     */
    ReadAtNativeFramerate?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MediaSourceInfo
     */
    IgnoreDts?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MediaSourceInfo
     */
    IgnoreIndex?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MediaSourceInfo
     */
    GenPtsInput?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MediaSourceInfo
     */
    SupportsTranscoding?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MediaSourceInfo
     */
    SupportsDirectStream?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MediaSourceInfo
     */
    SupportsDirectPlay?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MediaSourceInfo
     */
    IsInfiniteStream?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MediaSourceInfo
     */
    RequiresOpening?: boolean;
    /**
     * 
     * @type {string}
     * @memberof MediaSourceInfo
     */
    OpenToken?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof MediaSourceInfo
     */
    RequiresClosing?: boolean;
    /**
     * 
     * @type {string}
     * @memberof MediaSourceInfo
     */
    LiveStreamId?: string | null;
    /**
     * 
     * @type {number}
     * @memberof MediaSourceInfo
     */
    BufferMs?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof MediaSourceInfo
     */
    RequiresLooping?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MediaSourceInfo
     */
    SupportsProbing?: boolean;
    /**
     * 
     * @type {VideoType}
     * @memberof MediaSourceInfo
     */
    VideoType?: VideoType;
    /**
     * 
     * @type {IsoType}
     * @memberof MediaSourceInfo
     */
    IsoType?: IsoType;
    /**
     * 
     * @type {Video3DFormat}
     * @memberof MediaSourceInfo
     */
    Video3DFormat?: Video3DFormat;
    /**
     * 
     * @type {Array<MediaStream>}
     * @memberof MediaSourceInfo
     */
    MediaStreams?: Array<MediaStream> | null;
    /**
     * 
     * @type {Array<MediaAttachment>}
     * @memberof MediaSourceInfo
     */
    MediaAttachments?: Array<MediaAttachment> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof MediaSourceInfo
     */
    Formats?: Array<string> | null;
    /**
     * 
     * @type {number}
     * @memberof MediaSourceInfo
     */
    Bitrate?: number | null;
    /**
     * 
     * @type {TransportStreamTimestamp}
     * @memberof MediaSourceInfo
     */
    Timestamp?: TransportStreamTimestamp;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof MediaSourceInfo
     */
    RequiredHttpHeaders?: { [key: string]: string; } | null;
    /**
     * 
     * @type {string}
     * @memberof MediaSourceInfo
     */
    TranscodingUrl?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MediaSourceInfo
     */
    TranscodingSubProtocol?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MediaSourceInfo
     */
    TranscodingContainer?: string | null;
    /**
     * 
     * @type {number}
     * @memberof MediaSourceInfo
     */
    AnalyzeDurationMs?: number | null;
    /**
     * 
     * @type {number}
     * @memberof MediaSourceInfo
     */
    DefaultAudioStreamIndex?: number | null;
    /**
     * 
     * @type {number}
     * @memberof MediaSourceInfo
     */
    DefaultSubtitleStreamIndex?: number | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum MediaSourceType {
    Default = 'Default',
    Grouping = 'Grouping',
    Placeholder = 'Placeholder'
}

/**
 * 
 * @export
 * @interface MediaStream
 */
export interface MediaStream {
    /**
     * 
     * @type {string}
     * @memberof MediaStream
     */
    Codec?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MediaStream
     */
    CodecTag?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MediaStream
     */
    Language?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MediaStream
     */
    ColorTransfer?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MediaStream
     */
    ColorPrimaries?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MediaStream
     */
    ColorSpace?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MediaStream
     */
    Comment?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MediaStream
     */
    TimeBase?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MediaStream
     */
    CodecTimeBase?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MediaStream
     */
    Title?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MediaStream
     */
    VideoRange?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MediaStream
     */
    localizedUndefined?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MediaStream
     */
    localizedDefault?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MediaStream
     */
    localizedForced?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MediaStream
     */
    DisplayTitle?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MediaStream
     */
    NalLengthSize?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof MediaStream
     */
    IsInterlaced?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MediaStream
     */
    IsAVC?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof MediaStream
     */
    ChannelLayout?: string | null;
    /**
     * 
     * @type {number}
     * @memberof MediaStream
     */
    BitRate?: number | null;
    /**
     * 
     * @type {number}
     * @memberof MediaStream
     */
    BitDepth?: number | null;
    /**
     * 
     * @type {number}
     * @memberof MediaStream
     */
    RefFrames?: number | null;
    /**
     * 
     * @type {number}
     * @memberof MediaStream
     */
    PacketLength?: number | null;
    /**
     * 
     * @type {number}
     * @memberof MediaStream
     */
    Channels?: number | null;
    /**
     * 
     * @type {number}
     * @memberof MediaStream
     */
    SampleRate?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof MediaStream
     */
    IsDefault?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MediaStream
     */
    IsForced?: boolean;
    /**
     * 
     * @type {number}
     * @memberof MediaStream
     */
    Height?: number | null;
    /**
     * 
     * @type {number}
     * @memberof MediaStream
     */
    Width?: number | null;
    /**
     * 
     * @type {number}
     * @memberof MediaStream
     */
    AverageFrameRate?: number | null;
    /**
     * 
     * @type {number}
     * @memberof MediaStream
     */
    RealFrameRate?: number | null;
    /**
     * 
     * @type {string}
     * @memberof MediaStream
     */
    Profile?: string | null;
    /**
     * 
     * @type {MediaStreamType}
     * @memberof MediaStream
     */
    Type?: MediaStreamType;
    /**
     * 
     * @type {string}
     * @memberof MediaStream
     */
    AspectRatio?: string | null;
    /**
     * 
     * @type {number}
     * @memberof MediaStream
     */
    Index?: number;
    /**
     * 
     * @type {number}
     * @memberof MediaStream
     */
    Score?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof MediaStream
     */
    IsExternal?: boolean;
    /**
     * 
     * @type {SubtitleDeliveryMethod}
     * @memberof MediaStream
     */
    DeliveryMethod?: SubtitleDeliveryMethod;
    /**
     * 
     * @type {string}
     * @memberof MediaStream
     */
    DeliveryUrl?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof MediaStream
     */
    IsExternalUrl?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof MediaStream
     */
    IsTextSubtitleStream?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MediaStream
     */
    SupportsExternalStream?: boolean;
    /**
     * 
     * @type {string}
     * @memberof MediaStream
     */
    Path?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MediaStream
     */
    PixelFormat?: string | null;
    /**
     * 
     * @type {number}
     * @memberof MediaStream
     */
    Level?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof MediaStream
     */
    IsAnamorphic?: boolean | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum MediaStreamType {
    Audio = 'Audio',
    Video = 'Video',
    Subtitle = 'Subtitle',
    EmbeddedImage = 'EmbeddedImage'
}

/**
 * 
 * @export
 * @interface MediaUpdateInfoDto
 */
export interface MediaUpdateInfoDto {
    /**
     * 
     * @type {string}
     * @memberof MediaUpdateInfoDto
     */
    Path?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MediaUpdateInfoDto
     */
    UpdateType?: string | null;
}
/**
 * 
 * @export
 * @interface MediaUrl
 */
export interface MediaUrl {
    /**
     * 
     * @type {string}
     * @memberof MediaUrl
     */
    Url?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MediaUrl
     */
    Name?: string | null;
}
/**
 * 
 * @export
 * @interface MetadataEditorInfo
 */
export interface MetadataEditorInfo {
    /**
     * 
     * @type {Array<ParentalRating>}
     * @memberof MetadataEditorInfo
     */
    ParentalRatingOptions?: Array<ParentalRating> | null;
    /**
     * 
     * @type {Array<CountryInfo>}
     * @memberof MetadataEditorInfo
     */
    Countries?: Array<CountryInfo> | null;
    /**
     * 
     * @type {Array<CultureDto>}
     * @memberof MetadataEditorInfo
     */
    Cultures?: Array<CultureDto> | null;
    /**
     * 
     * @type {Array<ExternalIdInfo>}
     * @memberof MetadataEditorInfo
     */
    ExternalIdInfos?: Array<ExternalIdInfo> | null;
    /**
     * 
     * @type {string}
     * @memberof MetadataEditorInfo
     */
    ContentType?: string | null;
    /**
     * 
     * @type {Array<NameValuePair>}
     * @memberof MetadataEditorInfo
     */
    ContentTypeOptions?: Array<NameValuePair> | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum MetadataField {
    Cast = 'Cast',
    Genres = 'Genres',
    ProductionLocations = 'ProductionLocations',
    Studios = 'Studios',
    Tags = 'Tags',
    Name = 'Name',
    Overview = 'Overview',
    Runtime = 'Runtime',
    OfficialRating = 'OfficialRating'
}

/**
 * 
 * @export
 * @interface MetadataOptions
 */
export interface MetadataOptions {
    /**
     * 
     * @type {string}
     * @memberof MetadataOptions
     */
    ItemType?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof MetadataOptions
     */
    DisabledMetadataSavers?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof MetadataOptions
     */
    LocalMetadataReaderOrder?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof MetadataOptions
     */
    DisabledMetadataFetchers?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof MetadataOptions
     */
    MetadataFetcherOrder?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof MetadataOptions
     */
    DisabledImageFetchers?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof MetadataOptions
     */
    ImageFetcherOrder?: Array<string> | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum MetadataRefreshMode {
    None = 'None',
    ValidationOnly = 'ValidationOnly',
    Default = 'Default',
    FullRefresh = 'FullRefresh'
}

/**
 * 
 * @export
 * @interface MovieInfo
 */
export interface MovieInfo {
    /**
     * 
     * @type {string}
     * @memberof MovieInfo
     */
    Name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MovieInfo
     */
    Path?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MovieInfo
     */
    MetadataLanguage?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MovieInfo
     */
    MetadataCountryCode?: string | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof MovieInfo
     */
    ProviderIds?: { [key: string]: string; } | null;
    /**
     * 
     * @type {number}
     * @memberof MovieInfo
     */
    Year?: number | null;
    /**
     * 
     * @type {number}
     * @memberof MovieInfo
     */
    IndexNumber?: number | null;
    /**
     * 
     * @type {number}
     * @memberof MovieInfo
     */
    ParentIndexNumber?: number | null;
    /**
     * 
     * @type {string}
     * @memberof MovieInfo
     */
    PremiereDate?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof MovieInfo
     */
    IsAutomated?: boolean;
}
/**
 * 
 * @export
 * @interface MovieInfoRemoteSearchQuery
 */
export interface MovieInfoRemoteSearchQuery {
    /**
     * 
     * @type {MovieInfo}
     * @memberof MovieInfoRemoteSearchQuery
     */
    SearchInfo?: MovieInfo;
    /**
     * 
     * @type {string}
     * @memberof MovieInfoRemoteSearchQuery
     */
    ItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof MovieInfoRemoteSearchQuery
     */
    SearchProviderName?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof MovieInfoRemoteSearchQuery
     */
    IncludeDisabledProviders?: boolean;
}
/**
 * 
 * @export
 * @interface MusicVideoInfo
 */
export interface MusicVideoInfo {
    /**
     * 
     * @type {Array<string>}
     * @memberof MusicVideoInfo
     */
    Artists?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof MusicVideoInfo
     */
    Name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MusicVideoInfo
     */
    Path?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MusicVideoInfo
     */
    MetadataLanguage?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MusicVideoInfo
     */
    MetadataCountryCode?: string | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof MusicVideoInfo
     */
    ProviderIds?: { [key: string]: string; } | null;
    /**
     * 
     * @type {number}
     * @memberof MusicVideoInfo
     */
    Year?: number | null;
    /**
     * 
     * @type {number}
     * @memberof MusicVideoInfo
     */
    IndexNumber?: number | null;
    /**
     * 
     * @type {number}
     * @memberof MusicVideoInfo
     */
    ParentIndexNumber?: number | null;
    /**
     * 
     * @type {string}
     * @memberof MusicVideoInfo
     */
    PremiereDate?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof MusicVideoInfo
     */
    IsAutomated?: boolean;
}
/**
 * 
 * @export
 * @interface MusicVideoInfoRemoteSearchQuery
 */
export interface MusicVideoInfoRemoteSearchQuery {
    /**
     * 
     * @type {MusicVideoInfo}
     * @memberof MusicVideoInfoRemoteSearchQuery
     */
    SearchInfo?: MusicVideoInfo;
    /**
     * 
     * @type {string}
     * @memberof MusicVideoInfoRemoteSearchQuery
     */
    ItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof MusicVideoInfoRemoteSearchQuery
     */
    SearchProviderName?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof MusicVideoInfoRemoteSearchQuery
     */
    IncludeDisabledProviders?: boolean;
}
/**
 * 
 * @export
 * @interface NameGuidPair
 */
export interface NameGuidPair {
    /**
     * 
     * @type {string}
     * @memberof NameGuidPair
     */
    Name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof NameGuidPair
     */
    Id?: string;
}
/**
 * 
 * @export
 * @interface NameIdPair
 */
export interface NameIdPair {
    /**
     * 
     * @type {string}
     * @memberof NameIdPair
     */
    Name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof NameIdPair
     */
    Id?: string | null;
}
/**
 * 
 * @export
 * @interface NameValuePair
 */
export interface NameValuePair {
    /**
     * 
     * @type {string}
     * @memberof NameValuePair
     */
    Name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof NameValuePair
     */
    Value?: string | null;
}
/**
 * 
 * @export
 * @interface NotificationDto
 */
export interface NotificationDto {
    /**
     * 
     * @type {string}
     * @memberof NotificationDto
     */
    Id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof NotificationDto
     */
    UserId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof NotificationDto
     */
    Date?: string;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationDto
     */
    IsRead?: boolean;
    /**
     * 
     * @type {string}
     * @memberof NotificationDto
     */
    Name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof NotificationDto
     */
    Description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof NotificationDto
     */
    Url?: string | null;
    /**
     * 
     * @type {NotificationLevel}
     * @memberof NotificationDto
     */
    Level?: NotificationLevel;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum NotificationLevel {
    Normal = 'Normal',
    Warning = 'Warning',
    Error = 'Error'
}

/**
 * 
 * @export
 * @interface NotificationResultDto
 */
export interface NotificationResultDto {
    /**
     * 
     * @type {Array<NotificationDto>}
     * @memberof NotificationResultDto
     */
    Notifications?: Array<NotificationDto> | null;
    /**
     * 
     * @type {number}
     * @memberof NotificationResultDto
     */
    TotalRecordCount?: number;
}
/**
 * 
 * @export
 * @interface NotificationTypeInfo
 */
export interface NotificationTypeInfo {
    /**
     * 
     * @type {string}
     * @memberof NotificationTypeInfo
     */
    Type?: string | null;
    /**
     * 
     * @type {string}
     * @memberof NotificationTypeInfo
     */
    Name?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationTypeInfo
     */
    Enabled?: boolean;
    /**
     * 
     * @type {string}
     * @memberof NotificationTypeInfo
     */
    Category?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationTypeInfo
     */
    IsBasedOnUserEvent?: boolean;
}
/**
 * 
 * @export
 * @interface NotificationsSummaryDto
 */
export interface NotificationsSummaryDto {
    /**
     * 
     * @type {number}
     * @memberof NotificationsSummaryDto
     */
    UnreadCount?: number;
    /**
     * 
     * @type {NotificationLevel}
     * @memberof NotificationsSummaryDto
     */
    MaxUnreadNotificationLevel?: NotificationLevel;
}
/**
 * 
 * @export
 * @interface OpenLiveStreamDto
 */
export interface OpenLiveStreamDto {
    /**
     * 
     * @type {DeviceProfile}
     * @memberof OpenLiveStreamDto
     */
    DeviceProfile?: DeviceProfile;
    /**
     * 
     * @type {Array<MediaProtocol>}
     * @memberof OpenLiveStreamDto
     */
    DirectPlayProtocols?: Array<MediaProtocol> | null;
}
/**
 * 
 * @export
 * @interface PackageInfo
 */
export interface PackageInfo {
    /**
     * 
     * @type {string}
     * @memberof PackageInfo
     */
    name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PackageInfo
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PackageInfo
     */
    overview?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PackageInfo
     */
    owner?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PackageInfo
     */
    category?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PackageInfo
     */
    guid?: string | null;
    /**
     * 
     * @type {Array<VersionInfo>}
     * @memberof PackageInfo
     */
    versions?: Array<VersionInfo> | null;
}
/**
 * 
 * @export
 * @interface ParentalRating
 */
export interface ParentalRating {
    /**
     * 
     * @type {string}
     * @memberof ParentalRating
     */
    Name?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ParentalRating
     */
    Value?: number;
}
/**
 * 
 * @export
 * @interface PathSubstitution
 */
export interface PathSubstitution {
    /**
     * 
     * @type {string}
     * @memberof PathSubstitution
     */
    From?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PathSubstitution
     */
    To?: string | null;
}
/**
 * 
 * @export
 * @interface PersonLookupInfo
 */
export interface PersonLookupInfo {
    /**
     * 
     * @type {string}
     * @memberof PersonLookupInfo
     */
    Name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonLookupInfo
     */
    Path?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonLookupInfo
     */
    MetadataLanguage?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PersonLookupInfo
     */
    MetadataCountryCode?: string | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof PersonLookupInfo
     */
    ProviderIds?: { [key: string]: string; } | null;
    /**
     * 
     * @type {number}
     * @memberof PersonLookupInfo
     */
    Year?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PersonLookupInfo
     */
    IndexNumber?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PersonLookupInfo
     */
    ParentIndexNumber?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PersonLookupInfo
     */
    PremiereDate?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PersonLookupInfo
     */
    IsAutomated?: boolean;
}
/**
 * 
 * @export
 * @interface PersonLookupInfoRemoteSearchQuery
 */
export interface PersonLookupInfoRemoteSearchQuery {
    /**
     * 
     * @type {PersonLookupInfo}
     * @memberof PersonLookupInfoRemoteSearchQuery
     */
    SearchInfo?: PersonLookupInfo;
    /**
     * 
     * @type {string}
     * @memberof PersonLookupInfoRemoteSearchQuery
     */
    ItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof PersonLookupInfoRemoteSearchQuery
     */
    SearchProviderName?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PersonLookupInfoRemoteSearchQuery
     */
    IncludeDisabledProviders?: boolean;
}
/**
 * 
 * @export
 * @interface PinRedeemResult
 */
export interface PinRedeemResult {
    /**
     * 
     * @type {boolean}
     * @memberof PinRedeemResult
     */
    Success?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof PinRedeemResult
     */
    UsersReset?: Array<string> | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum PlayAccess {
    Full = 'Full',
    None = 'None'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum PlayCommand {
    PlayNow = 'PlayNow',
    PlayNext = 'PlayNext',
    PlayLast = 'PlayLast',
    PlayInstantMix = 'PlayInstantMix',
    PlayShuffle = 'PlayShuffle'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum PlayMethod {
    Transcode = 'Transcode',
    DirectStream = 'DirectStream',
    DirectPlay = 'DirectPlay'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum PlaybackErrorCode {
    NotAllowed = 'NotAllowed',
    NoCompatibleStream = 'NoCompatibleStream',
    RateLimitExceeded = 'RateLimitExceeded'
}

/**
 * 
 * @export
 * @interface PlaybackInfoResponse
 */
export interface PlaybackInfoResponse {
    /**
     * 
     * @type {Array<MediaSourceInfo>}
     * @memberof PlaybackInfoResponse
     */
    MediaSources?: Array<MediaSourceInfo> | null;
    /**
     * 
     * @type {string}
     * @memberof PlaybackInfoResponse
     */
    PlaySessionId?: string | null;
    /**
     * 
     * @type {PlaybackErrorCode}
     * @memberof PlaybackInfoResponse
     */
    ErrorCode?: PlaybackErrorCode;
}
/**
 * 
 * @export
 * @interface PlaybackProgressInfo
 */
export interface PlaybackProgressInfo {
    /**
     * 
     * @type {boolean}
     * @memberof PlaybackProgressInfo
     */
    CanSeek?: boolean;
    /**
     * 
     * @type {BaseItemDto}
     * @memberof PlaybackProgressInfo
     */
    Item?: BaseItemDto;
    /**
     * 
     * @type {string}
     * @memberof PlaybackProgressInfo
     */
    ItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof PlaybackProgressInfo
     */
    SessionId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PlaybackProgressInfo
     */
    MediaSourceId?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PlaybackProgressInfo
     */
    AudioStreamIndex?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PlaybackProgressInfo
     */
    SubtitleStreamIndex?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PlaybackProgressInfo
     */
    IsPaused?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PlaybackProgressInfo
     */
    IsMuted?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PlaybackProgressInfo
     */
    PositionTicks?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PlaybackProgressInfo
     */
    PlaybackStartTimeTicks?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PlaybackProgressInfo
     */
    VolumeLevel?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PlaybackProgressInfo
     */
    Brightness?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PlaybackProgressInfo
     */
    AspectRatio?: string | null;
    /**
     * 
     * @type {PlayMethod}
     * @memberof PlaybackProgressInfo
     */
    PlayMethod?: PlayMethod;
    /**
     * 
     * @type {string}
     * @memberof PlaybackProgressInfo
     */
    LiveStreamId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PlaybackProgressInfo
     */
    PlaySessionId?: string | null;
    /**
     * 
     * @type {RepeatMode}
     * @memberof PlaybackProgressInfo
     */
    RepeatMode?: RepeatMode;
    /**
     * 
     * @type {Array<QueueItem>}
     * @memberof PlaybackProgressInfo
     */
    NowPlayingQueue?: Array<QueueItem> | null;
    /**
     * 
     * @type {string}
     * @memberof PlaybackProgressInfo
     */
    PlaylistItemId?: string | null;
}
/**
 * 
 * @export
 * @interface PlaybackStartInfo
 */
export interface PlaybackStartInfo {
    /**
     * 
     * @type {boolean}
     * @memberof PlaybackStartInfo
     */
    CanSeek?: boolean;
    /**
     * 
     * @type {BaseItemDto}
     * @memberof PlaybackStartInfo
     */
    Item?: BaseItemDto;
    /**
     * 
     * @type {string}
     * @memberof PlaybackStartInfo
     */
    ItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof PlaybackStartInfo
     */
    SessionId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PlaybackStartInfo
     */
    MediaSourceId?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PlaybackStartInfo
     */
    AudioStreamIndex?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PlaybackStartInfo
     */
    SubtitleStreamIndex?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PlaybackStartInfo
     */
    IsPaused?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PlaybackStartInfo
     */
    IsMuted?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PlaybackStartInfo
     */
    PositionTicks?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PlaybackStartInfo
     */
    PlaybackStartTimeTicks?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PlaybackStartInfo
     */
    VolumeLevel?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PlaybackStartInfo
     */
    Brightness?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PlaybackStartInfo
     */
    AspectRatio?: string | null;
    /**
     * 
     * @type {PlayMethod}
     * @memberof PlaybackStartInfo
     */
    PlayMethod?: PlayMethod;
    /**
     * 
     * @type {string}
     * @memberof PlaybackStartInfo
     */
    LiveStreamId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PlaybackStartInfo
     */
    PlaySessionId?: string | null;
    /**
     * 
     * @type {RepeatMode}
     * @memberof PlaybackStartInfo
     */
    RepeatMode?: RepeatMode;
    /**
     * 
     * @type {Array<QueueItem>}
     * @memberof PlaybackStartInfo
     */
    NowPlayingQueue?: Array<QueueItem> | null;
    /**
     * 
     * @type {string}
     * @memberof PlaybackStartInfo
     */
    PlaylistItemId?: string | null;
}
/**
 * 
 * @export
 * @interface PlaybackStopInfo
 */
export interface PlaybackStopInfo {
    /**
     * 
     * @type {BaseItemDto}
     * @memberof PlaybackStopInfo
     */
    Item?: BaseItemDto;
    /**
     * 
     * @type {string}
     * @memberof PlaybackStopInfo
     */
    ItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof PlaybackStopInfo
     */
    SessionId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PlaybackStopInfo
     */
    MediaSourceId?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PlaybackStopInfo
     */
    PositionTicks?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PlaybackStopInfo
     */
    LiveStreamId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PlaybackStopInfo
     */
    PlaySessionId?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PlaybackStopInfo
     */
    Failed?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PlaybackStopInfo
     */
    NextMediaType?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PlaybackStopInfo
     */
    PlaylistItemId?: string | null;
    /**
     * 
     * @type {Array<QueueItem>}
     * @memberof PlaybackStopInfo
     */
    NowPlayingQueue?: Array<QueueItem> | null;
}
/**
 * 
 * @export
 * @interface PlayerStateInfo
 */
export interface PlayerStateInfo {
    /**
     * 
     * @type {number}
     * @memberof PlayerStateInfo
     */
    PositionTicks?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PlayerStateInfo
     */
    CanSeek?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PlayerStateInfo
     */
    IsPaused?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PlayerStateInfo
     */
    IsMuted?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PlayerStateInfo
     */
    VolumeLevel?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PlayerStateInfo
     */
    AudioStreamIndex?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PlayerStateInfo
     */
    SubtitleStreamIndex?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PlayerStateInfo
     */
    MediaSourceId?: string | null;
    /**
     * 
     * @type {PlayMethod}
     * @memberof PlayerStateInfo
     */
    PlayMethod?: PlayMethod;
    /**
     * 
     * @type {RepeatMode}
     * @memberof PlayerStateInfo
     */
    RepeatMode?: RepeatMode;
}
/**
 * 
 * @export
 * @interface PlaylistCreationResult
 */
export interface PlaylistCreationResult {
    /**
     * 
     * @type {string}
     * @memberof PlaylistCreationResult
     */
    Id?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum PlaystateCommand {
    Stop = 'Stop',
    Pause = 'Pause',
    Unpause = 'Unpause',
    NextTrack = 'NextTrack',
    PreviousTrack = 'PreviousTrack',
    Seek = 'Seek',
    Rewind = 'Rewind',
    FastForward = 'FastForward',
    PlayPause = 'PlayPause'
}

/**
 * 
 * @export
 * @interface PlaystateRequest
 */
export interface PlaystateRequest {
    /**
     * 
     * @type {PlaystateCommand}
     * @memberof PlaystateRequest
     */
    Command?: PlaystateCommand;
    /**
     * 
     * @type {number}
     * @memberof PlaystateRequest
     */
    SeekPositionTicks?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PlaystateRequest
     */
    ControllingUserId?: string | null;
}
/**
 * 
 * @export
 * @interface PluginInfo
 */
export interface PluginInfo {
    /**
     * 
     * @type {string}
     * @memberof PluginInfo
     */
    Name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PluginInfo
     */
    Version?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PluginInfo
     */
    ConfigurationFileName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PluginInfo
     */
    Description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PluginInfo
     */
    Id?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PluginInfo
     */
    CanUninstall?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PluginInfo
     */
    ImageUrl?: string | null;
}
/**
 * 
 * @export
 * @interface PluginSecurityInfo
 */
export interface PluginSecurityInfo {
    /**
     * 
     * @type {string}
     * @memberof PluginSecurityInfo
     */
    SupporterKey?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PluginSecurityInfo
     */
    IsMbSupporter?: boolean;
}
/**
 * 
 * @export
 * @interface ProblemDetails
 */
export interface ProblemDetails {
    [key: string]: object | any;

    /**
     * 
     * @type {string}
     * @memberof ProblemDetails
     */
    type?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProblemDetails
     */
    title?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ProblemDetails
     */
    status?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ProblemDetails
     */
    detail?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProblemDetails
     */
    instance?: string | null;
}
/**
 * 
 * @export
 * @interface ProfileCondition
 */
export interface ProfileCondition {
    /**
     * 
     * @type {ProfileConditionType}
     * @memberof ProfileCondition
     */
    Condition?: ProfileConditionType;
    /**
     * 
     * @type {ProfileConditionValue}
     * @memberof ProfileCondition
     */
    Property?: ProfileConditionValue;
    /**
     * 
     * @type {string}
     * @memberof ProfileCondition
     */
    Value?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ProfileCondition
     */
    IsRequired?: boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum ProfileConditionType {
    Equals = 'Equals',
    NotEquals = 'NotEquals',
    LessThanEqual = 'LessThanEqual',
    GreaterThanEqual = 'GreaterThanEqual',
    EqualsAny = 'EqualsAny'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum ProfileConditionValue {
    AudioChannels = 'AudioChannels',
    AudioBitrate = 'AudioBitrate',
    AudioProfile = 'AudioProfile',
    Width = 'Width',
    Height = 'Height',
    Has64BitOffsets = 'Has64BitOffsets',
    PacketLength = 'PacketLength',
    VideoBitDepth = 'VideoBitDepth',
    VideoBitrate = 'VideoBitrate',
    VideoFramerate = 'VideoFramerate',
    VideoLevel = 'VideoLevel',
    VideoProfile = 'VideoProfile',
    VideoTimestamp = 'VideoTimestamp',
    IsAnamorphic = 'IsAnamorphic',
    RefFrames = 'RefFrames',
    NumAudioStreams = 'NumAudioStreams',
    NumVideoStreams = 'NumVideoStreams',
    IsSecondaryAudio = 'IsSecondaryAudio',
    VideoCodecTag = 'VideoCodecTag',
    IsAvc = 'IsAvc',
    IsInterlaced = 'IsInterlaced',
    AudioSampleRate = 'AudioSampleRate',
    AudioBitDepth = 'AudioBitDepth'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum ProgramAudio {
    Mono = 'Mono',
    Stereo = 'Stereo',
    Dolby = 'Dolby',
    DolbyDigital = 'DolbyDigital',
    Thx = 'Thx',
    Atmos = 'Atmos'
}

/**
 * 
 * @export
 * @interface PublicSystemInfo
 */
export interface PublicSystemInfo {
    /**
     * 
     * @type {string}
     * @memberof PublicSystemInfo
     */
    LocalAddress?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PublicSystemInfo
     */
    ServerName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PublicSystemInfo
     */
    Version?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PublicSystemInfo
     */
    ProductName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PublicSystemInfo
     */
    OperatingSystem?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PublicSystemInfo
     */
    Id?: string | null;
}
/**
 * 
 * @export
 * @interface QueryFilters
 */
export interface QueryFilters {
    /**
     * 
     * @type {Array<NameGuidPair>}
     * @memberof QueryFilters
     */
    Genres?: Array<NameGuidPair> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof QueryFilters
     */
    Tags?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface QueryFiltersLegacy
 */
export interface QueryFiltersLegacy {
    /**
     * 
     * @type {Array<string>}
     * @memberof QueryFiltersLegacy
     */
    Genres?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof QueryFiltersLegacy
     */
    Tags?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof QueryFiltersLegacy
     */
    OfficialRatings?: Array<string> | null;
    /**
     * 
     * @type {Array<number>}
     * @memberof QueryFiltersLegacy
     */
    Years?: Array<number> | null;
}
/**
 * 
 * @export
 * @interface QueueItem
 */
export interface QueueItem {
    /**
     * 
     * @type {string}
     * @memberof QueueItem
     */
    Id?: string;
    /**
     * 
     * @type {string}
     * @memberof QueueItem
     */
    PlaylistItemId?: string | null;
}
/**
 * 
 * @export
 * @interface QuickConnectDto
 */
export interface QuickConnectDto {
    /**
     * 
     * @type {string}
     * @memberof QuickConnectDto
     */
    Token: string;
}
/**
 * 
 * @export
 * @interface QuickConnectResult
 */
export interface QuickConnectResult {
    /**
     * 
     * @type {boolean}
     * @memberof QuickConnectResult
     */
    Authenticated?: boolean;
    /**
     * 
     * @type {string}
     * @memberof QuickConnectResult
     */
    Secret?: string | null;
    /**
     * 
     * @type {string}
     * @memberof QuickConnectResult
     */
    Code?: string | null;
    /**
     * 
     * @type {string}
     * @memberof QuickConnectResult
     */
    Authentication?: string | null;
    /**
     * 
     * @type {string}
     * @memberof QuickConnectResult
     */
    Error?: string | null;
    /**
     * 
     * @type {string}
     * @memberof QuickConnectResult
     */
    DateAdded?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum QuickConnectState {
    Unavailable = 'Unavailable',
    Available = 'Available',
    Active = 'Active'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum RatingType {
    Score = 'Score',
    Likes = 'Likes'
}

/**
 * 
 * @export
 * @interface RecommendationDto
 */
export interface RecommendationDto {
    /**
     * 
     * @type {Array<BaseItemDto>}
     * @memberof RecommendationDto
     */
    Items?: Array<BaseItemDto> | null;
    /**
     * 
     * @type {RecommendationType}
     * @memberof RecommendationDto
     */
    RecommendationType?: RecommendationType;
    /**
     * 
     * @type {string}
     * @memberof RecommendationDto
     */
    BaselineItemName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RecommendationDto
     */
    CategoryId?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum RecommendationType {
    SimilarToRecentlyPlayed = 'SimilarToRecentlyPlayed',
    SimilarToLikedItem = 'SimilarToLikedItem',
    HasDirectorFromRecentlyPlayed = 'HasDirectorFromRecentlyPlayed',
    HasActorFromRecentlyPlayed = 'HasActorFromRecentlyPlayed',
    HasLikedDirector = 'HasLikedDirector',
    HasLikedActor = 'HasLikedActor'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum RecordingStatus {
    New = 'New',
    InProgress = 'InProgress',
    Completed = 'Completed',
    Cancelled = 'Cancelled',
    ConflictedOk = 'ConflictedOk',
    ConflictedNotOk = 'ConflictedNotOk',
    Error = 'Error'
}

/**
 * 
 * @export
 * @interface RemoteImageInfo
 */
export interface RemoteImageInfo {
    /**
     * 
     * @type {string}
     * @memberof RemoteImageInfo
     */
    ProviderName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RemoteImageInfo
     */
    Url?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RemoteImageInfo
     */
    ThumbnailUrl?: string | null;
    /**
     * 
     * @type {number}
     * @memberof RemoteImageInfo
     */
    Height?: number | null;
    /**
     * 
     * @type {number}
     * @memberof RemoteImageInfo
     */
    Width?: number | null;
    /**
     * 
     * @type {number}
     * @memberof RemoteImageInfo
     */
    CommunityRating?: number | null;
    /**
     * 
     * @type {number}
     * @memberof RemoteImageInfo
     */
    VoteCount?: number | null;
    /**
     * 
     * @type {string}
     * @memberof RemoteImageInfo
     */
    Language?: string | null;
    /**
     * 
     * @type {ImageType}
     * @memberof RemoteImageInfo
     */
    Type?: ImageType;
    /**
     * 
     * @type {RatingType}
     * @memberof RemoteImageInfo
     */
    RatingType?: RatingType;
}
/**
 * 
 * @export
 * @interface RemoteImageResult
 */
export interface RemoteImageResult {
    /**
     * 
     * @type {Array<RemoteImageInfo>}
     * @memberof RemoteImageResult
     */
    Images?: Array<RemoteImageInfo> | null;
    /**
     * 
     * @type {number}
     * @memberof RemoteImageResult
     */
    TotalRecordCount?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof RemoteImageResult
     */
    Providers?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface RemoteSearchResult
 */
export interface RemoteSearchResult {
    /**
     * 
     * @type {string}
     * @memberof RemoteSearchResult
     */
    Name?: string | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof RemoteSearchResult
     */
    ProviderIds?: { [key: string]: string; } | null;
    /**
     * 
     * @type {number}
     * @memberof RemoteSearchResult
     */
    ProductionYear?: number | null;
    /**
     * 
     * @type {number}
     * @memberof RemoteSearchResult
     */
    IndexNumber?: number | null;
    /**
     * 
     * @type {number}
     * @memberof RemoteSearchResult
     */
    IndexNumberEnd?: number | null;
    /**
     * 
     * @type {number}
     * @memberof RemoteSearchResult
     */
    ParentIndexNumber?: number | null;
    /**
     * 
     * @type {string}
     * @memberof RemoteSearchResult
     */
    PremiereDate?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RemoteSearchResult
     */
    ImageUrl?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RemoteSearchResult
     */
    SearchProviderName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RemoteSearchResult
     */
    Overview?: string | null;
    /**
     * 
     * @type {RemoteSearchResult}
     * @memberof RemoteSearchResult
     */
    AlbumArtist?: RemoteSearchResult;
    /**
     * 
     * @type {Array<RemoteSearchResult>}
     * @memberof RemoteSearchResult
     */
    Artists?: Array<RemoteSearchResult> | null;
}
/**
 * 
 * @export
 * @interface RemoteSubtitleInfo
 */
export interface RemoteSubtitleInfo {
    /**
     * 
     * @type {string}
     * @memberof RemoteSubtitleInfo
     */
    ThreeLetterISOLanguageName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RemoteSubtitleInfo
     */
    Id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RemoteSubtitleInfo
     */
    ProviderName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RemoteSubtitleInfo
     */
    Name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RemoteSubtitleInfo
     */
    Format?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RemoteSubtitleInfo
     */
    Author?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RemoteSubtitleInfo
     */
    Comment?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RemoteSubtitleInfo
     */
    DateCreated?: string | null;
    /**
     * 
     * @type {number}
     * @memberof RemoteSubtitleInfo
     */
    CommunityRating?: number | null;
    /**
     * 
     * @type {number}
     * @memberof RemoteSubtitleInfo
     */
    DownloadCount?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof RemoteSubtitleInfo
     */
    IsHashMatch?: boolean | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum RepeatMode {
    RepeatNone = 'RepeatNone',
    RepeatAll = 'RepeatAll',
    RepeatOne = 'RepeatOne'
}

/**
 * 
 * @export
 * @interface RepositoryInfo
 */
export interface RepositoryInfo {
    /**
     * 
     * @type {string}
     * @memberof RepositoryInfo
     */
    Name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RepositoryInfo
     */
    Url?: string | null;
}
/**
 * 
 * @export
 * @interface ResponseProfile
 */
export interface ResponseProfile {
    /**
     * 
     * @type {string}
     * @memberof ResponseProfile
     */
    Container?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ResponseProfile
     */
    AudioCodec?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ResponseProfile
     */
    VideoCodec?: string | null;
    /**
     * 
     * @type {DlnaProfileType}
     * @memberof ResponseProfile
     */
    Type?: DlnaProfileType;
    /**
     * 
     * @type {string}
     * @memberof ResponseProfile
     */
    OrgPn?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ResponseProfile
     */
    MimeType?: string | null;
    /**
     * 
     * @type {Array<ProfileCondition>}
     * @memberof ResponseProfile
     */
    Conditions?: Array<ProfileCondition> | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum ScrollDirection {
    Horizontal = 'Horizontal',
    Vertical = 'Vertical'
}

/**
 * 
 * @export
 * @interface SearchHint
 */
export interface SearchHint {
    /**
     * 
     * @type {string}
     * @memberof SearchHint
     */
    ItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchHint
     */
    Id?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchHint
     */
    Name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SearchHint
     */
    MatchedTerm?: string | null;
    /**
     * 
     * @type {number}
     * @memberof SearchHint
     */
    IndexNumber?: number | null;
    /**
     * 
     * @type {number}
     * @memberof SearchHint
     */
    ProductionYear?: number | null;
    /**
     * 
     * @type {number}
     * @memberof SearchHint
     */
    ParentIndexNumber?: number | null;
    /**
     * 
     * @type {string}
     * @memberof SearchHint
     */
    PrimaryImageTag?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SearchHint
     */
    ThumbImageTag?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SearchHint
     */
    ThumbImageItemId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SearchHint
     */
    BackdropImageTag?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SearchHint
     */
    BackdropImageItemId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SearchHint
     */
    Type?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof SearchHint
     */
    IsFolder?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof SearchHint
     */
    RunTimeTicks?: number | null;
    /**
     * 
     * @type {string}
     * @memberof SearchHint
     */
    MediaType?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SearchHint
     */
    StartDate?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SearchHint
     */
    EndDate?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SearchHint
     */
    Series?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SearchHint
     */
    Status?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SearchHint
     */
    Album?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SearchHint
     */
    AlbumId?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchHint
     */
    AlbumArtist?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof SearchHint
     */
    Artists?: Array<string> | null;
    /**
     * 
     * @type {number}
     * @memberof SearchHint
     */
    SongCount?: number | null;
    /**
     * 
     * @type {number}
     * @memberof SearchHint
     */
    EpisodeCount?: number | null;
    /**
     * 
     * @type {string}
     * @memberof SearchHint
     */
    ChannelId?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchHint
     */
    ChannelName?: string | null;
    /**
     * 
     * @type {number}
     * @memberof SearchHint
     */
    PrimaryImageAspectRatio?: number | null;
}
/**
 * 
 * @export
 * @interface SearchHintResult
 */
export interface SearchHintResult {
    /**
     * 
     * @type {Array<SearchHint>}
     * @memberof SearchHintResult
     */
    SearchHints?: Array<SearchHint> | null;
    /**
     * 
     * @type {number}
     * @memberof SearchHintResult
     */
    TotalRecordCount?: number;
}
/**
 * 
 * @export
 * @interface SeriesInfo
 */
export interface SeriesInfo {
    /**
     * 
     * @type {string}
     * @memberof SeriesInfo
     */
    Name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SeriesInfo
     */
    Path?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SeriesInfo
     */
    MetadataLanguage?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SeriesInfo
     */
    MetadataCountryCode?: string | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof SeriesInfo
     */
    ProviderIds?: { [key: string]: string; } | null;
    /**
     * 
     * @type {number}
     * @memberof SeriesInfo
     */
    Year?: number | null;
    /**
     * 
     * @type {number}
     * @memberof SeriesInfo
     */
    IndexNumber?: number | null;
    /**
     * 
     * @type {number}
     * @memberof SeriesInfo
     */
    ParentIndexNumber?: number | null;
    /**
     * 
     * @type {string}
     * @memberof SeriesInfo
     */
    PremiereDate?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof SeriesInfo
     */
    IsAutomated?: boolean;
}
/**
 * 
 * @export
 * @interface SeriesInfoRemoteSearchQuery
 */
export interface SeriesInfoRemoteSearchQuery {
    /**
     * 
     * @type {SeriesInfo}
     * @memberof SeriesInfoRemoteSearchQuery
     */
    SearchInfo?: SeriesInfo;
    /**
     * 
     * @type {string}
     * @memberof SeriesInfoRemoteSearchQuery
     */
    ItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof SeriesInfoRemoteSearchQuery
     */
    SearchProviderName?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof SeriesInfoRemoteSearchQuery
     */
    IncludeDisabledProviders?: boolean;
}
/**
 * 
 * @export
 * @interface SeriesTimerInfoDto
 */
export interface SeriesTimerInfoDto {
    /**
     * 
     * @type {boolean}
     * @memberof SeriesTimerInfoDto
     */
    RecordAnyTime?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SeriesTimerInfoDto
     */
    SkipEpisodesInLibrary?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SeriesTimerInfoDto
     */
    RecordAnyChannel?: boolean;
    /**
     * 
     * @type {number}
     * @memberof SeriesTimerInfoDto
     */
    KeepUpTo?: number;
    /**
     * 
     * @type {boolean}
     * @memberof SeriesTimerInfoDto
     */
    RecordNewOnly?: boolean;
    /**
     * 
     * @type {Array<DayOfWeek>}
     * @memberof SeriesTimerInfoDto
     */
    Days?: Array<DayOfWeek> | null;
    /**
     * 
     * @type {DayPattern}
     * @memberof SeriesTimerInfoDto
     */
    DayPattern?: DayPattern;
    /**
     * 
     * @type {BaseItemDtoImageTags}
     * @memberof SeriesTimerInfoDto
     */
    ImageTags?: BaseItemDtoImageTags | null;
    /**
     * 
     * @type {string}
     * @memberof SeriesTimerInfoDto
     */
    ParentThumbItemId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SeriesTimerInfoDto
     */
    ParentThumbImageTag?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SeriesTimerInfoDto
     */
    ParentPrimaryImageItemId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SeriesTimerInfoDto
     */
    ParentPrimaryImageTag?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SeriesTimerInfoDto
     */
    Id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SeriesTimerInfoDto
     */
    Type?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SeriesTimerInfoDto
     */
    ServerId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SeriesTimerInfoDto
     */
    ExternalId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SeriesTimerInfoDto
     */
    ChannelId?: string;
    /**
     * 
     * @type {string}
     * @memberof SeriesTimerInfoDto
     */
    ExternalChannelId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SeriesTimerInfoDto
     */
    ChannelName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SeriesTimerInfoDto
     */
    ChannelPrimaryImageTag?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SeriesTimerInfoDto
     */
    ProgramId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SeriesTimerInfoDto
     */
    ExternalProgramId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SeriesTimerInfoDto
     */
    Name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SeriesTimerInfoDto
     */
    Overview?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SeriesTimerInfoDto
     */
    StartDate?: string;
    /**
     * 
     * @type {string}
     * @memberof SeriesTimerInfoDto
     */
    EndDate?: string;
    /**
     * 
     * @type {string}
     * @memberof SeriesTimerInfoDto
     */
    ServiceName?: string | null;
    /**
     * 
     * @type {number}
     * @memberof SeriesTimerInfoDto
     */
    Priority?: number;
    /**
     * 
     * @type {number}
     * @memberof SeriesTimerInfoDto
     */
    PrePaddingSeconds?: number;
    /**
     * 
     * @type {number}
     * @memberof SeriesTimerInfoDto
     */
    PostPaddingSeconds?: number;
    /**
     * 
     * @type {boolean}
     * @memberof SeriesTimerInfoDto
     */
    IsPrePaddingRequired?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SeriesTimerInfoDto
     */
    ParentBackdropItemId?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof SeriesTimerInfoDto
     */
    ParentBackdropImageTags?: Array<string> | null;
    /**
     * 
     * @type {boolean}
     * @memberof SeriesTimerInfoDto
     */
    IsPostPaddingRequired?: boolean;
    /**
     * 
     * @type {KeepUntil}
     * @memberof SeriesTimerInfoDto
     */
    KeepUntil?: KeepUntil;
}
/**
 * 
 * @export
 * @interface SeriesTimerInfoDtoQueryResult
 */
export interface SeriesTimerInfoDtoQueryResult {
    /**
     * 
     * @type {Array<SeriesTimerInfoDto>}
     * @memberof SeriesTimerInfoDtoQueryResult
     */
    Items?: Array<SeriesTimerInfoDto> | null;
    /**
     * 
     * @type {number}
     * @memberof SeriesTimerInfoDtoQueryResult
     */
    TotalRecordCount?: number;
    /**
     * 
     * @type {number}
     * @memberof SeriesTimerInfoDtoQueryResult
     */
    StartIndex?: number;
}
/**
 * 
 * @export
 * @interface ServerConfiguration
 */
export interface ServerConfiguration {
    /**
     * 
     * @type {boolean}
     * @memberof ServerConfiguration
     */
    EnableUPnP?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ServerConfiguration
     */
    EnableMetrics?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ServerConfiguration
     */
    PublicPort?: number;
    /**
     * 
     * @type {number}
     * @memberof ServerConfiguration
     */
    PublicHttpsPort?: number;
    /**
     * 
     * @type {number}
     * @memberof ServerConfiguration
     */
    HttpServerPortNumber?: number;
    /**
     * 
     * @type {number}
     * @memberof ServerConfiguration
     */
    HttpsPortNumber?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ServerConfiguration
     */
    EnableHttps?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ServerConfiguration
     */
    EnableNormalizedItemByNameIds?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ServerConfiguration
     */
    CertificatePath?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ServerConfiguration
     */
    CertificatePassword?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ServerConfiguration
     */
    IsPortAuthorized?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ServerConfiguration
     */
    QuickConnectAvailable?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ServerConfiguration
     */
    AutoRunWebApp?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ServerConfiguration
     */
    EnableRemoteAccess?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ServerConfiguration
     */
    EnableCaseSensitiveItemIds?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ServerConfiguration
     */
    DisableLiveTvChannelUserDataName?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ServerConfiguration
     */
    MetadataPath?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ServerConfiguration
     */
    MetadataNetworkPath?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ServerConfiguration
     */
    PreferredMetadataLanguage?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ServerConfiguration
     */
    MetadataCountryCode?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ServerConfiguration
     */
    SortReplaceCharacters?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ServerConfiguration
     */
    SortRemoveCharacters?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ServerConfiguration
     */
    SortRemoveWords?: Array<string> | null;
    /**
     * 
     * @type {number}
     * @memberof ServerConfiguration
     */
    MinResumePct?: number;
    /**
     * 
     * @type {number}
     * @memberof ServerConfiguration
     */
    MaxResumePct?: number;
    /**
     * 
     * @type {number}
     * @memberof ServerConfiguration
     */
    MinResumeDurationSeconds?: number;
    /**
     * 
     * @type {number}
     * @memberof ServerConfiguration
     */
    LibraryMonitorDelay?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ServerConfiguration
     */
    EnableDashboardResponseCaching?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ServerConfiguration
     */
    DashboardSourcePath?: string | null;
    /**
     * 
     * @type {ImageSavingConvention}
     * @memberof ServerConfiguration
     */
    ImageSavingConvention?: ImageSavingConvention;
    /**
     * 
     * @type {Array<MetadataOptions>}
     * @memberof ServerConfiguration
     */
    MetadataOptions?: Array<MetadataOptions> | null;
    /**
     * 
     * @type {boolean}
     * @memberof ServerConfiguration
     */
    SkipDeserializationForBasicTypes?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ServerConfiguration
     */
    ServerName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ServerConfiguration
     */
    BaseUrl?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ServerConfiguration
     */
    UICulture?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ServerConfiguration
     */
    SaveMetadataHidden?: boolean;
    /**
     * 
     * @type {Array<NameValuePair>}
     * @memberof ServerConfiguration
     */
    ContentTypes?: Array<NameValuePair> | null;
    /**
     * 
     * @type {number}
     * @memberof ServerConfiguration
     */
    RemoteClientBitrateLimit?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ServerConfiguration
     */
    EnableFolderView?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ServerConfiguration
     */
    EnableGroupingIntoCollections?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ServerConfiguration
     */
    DisplaySpecialsWithinSeasons?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof ServerConfiguration
     */
    LocalNetworkSubnets?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ServerConfiguration
     */
    LocalNetworkAddresses?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ServerConfiguration
     */
    CodecsUsed?: Array<string> | null;
    /**
     * 
     * @type {Array<RepositoryInfo>}
     * @memberof ServerConfiguration
     */
    PluginRepositories?: Array<RepositoryInfo> | null;
    /**
     * 
     * @type {boolean}
     * @memberof ServerConfiguration
     */
    IgnoreVirtualInterfaces?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ServerConfiguration
     */
    EnableExternalContentInSuggestions?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ServerConfiguration
     */
    RequireHttps?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ServerConfiguration
     */
    EnableNewOmdbSupport?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof ServerConfiguration
     */
    RemoteIPFilter?: Array<string> | null;
    /**
     * 
     * @type {boolean}
     * @memberof ServerConfiguration
     */
    IsRemoteIPFilterBlacklist?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ServerConfiguration
     */
    ImageExtractionTimeoutMs?: number;
    /**
     * 
     * @type {Array<PathSubstitution>}
     * @memberof ServerConfiguration
     */
    PathSubstitutions?: Array<PathSubstitution> | null;
    /**
     * 
     * @type {boolean}
     * @memberof ServerConfiguration
     */
    EnableSimpleArtistDetection?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof ServerConfiguration
     */
    UninstalledPlugins?: Array<string> | null;
    /**
     * 
     * @type {boolean}
     * @memberof ServerConfiguration
     */
    EnableSlowResponseWarning?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ServerConfiguration
     */
    SlowResponseThresholdMs?: number;
    /**
     * 
     * @type {number}
     * @memberof ServerConfiguration
     */
    LogFileRetentionDays?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ServerConfiguration
     */
    IsStartupWizardCompleted?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ServerConfiguration
     */
    CachePath?: string | null;
    /**
     * 
     * @type {Version}
     * @memberof ServerConfiguration
     */
    PreviousVersion?: Version;
    /**
     * 
     * @type {string}
     * @memberof ServerConfiguration
     */
    PreviousVersionStr?: string | null;
}
/**
 * 
 * @export
 * @interface SessionInfo
 */
export interface SessionInfo {
    /**
     * 
     * @type {PlayerStateInfo}
     * @memberof SessionInfo
     */
    PlayState?: PlayerStateInfo;
    /**
     * 
     * @type {Array<SessionUserInfo>}
     * @memberof SessionInfo
     */
    AdditionalUsers?: Array<SessionUserInfo> | null;
    /**
     * 
     * @type {ClientCapabilities}
     * @memberof SessionInfo
     */
    Capabilities?: ClientCapabilities;
    /**
     * 
     * @type {string}
     * @memberof SessionInfo
     */
    RemoteEndPoint?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof SessionInfo
     */
    PlayableMediaTypes?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof SessionInfo
     */
    Id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SessionInfo
     */
    UserId?: string;
    /**
     * 
     * @type {string}
     * @memberof SessionInfo
     */
    UserName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SessionInfo
     */
    Client?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SessionInfo
     */
    LastActivityDate?: string;
    /**
     * 
     * @type {string}
     * @memberof SessionInfo
     */
    LastPlaybackCheckIn?: string;
    /**
     * 
     * @type {string}
     * @memberof SessionInfo
     */
    DeviceName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SessionInfo
     */
    DeviceType?: string | null;
    /**
     * 
     * @type {BaseItemDto}
     * @memberof SessionInfo
     */
    NowPlayingItem?: BaseItemDto;
    /**
     * 
     * @type {BaseItem}
     * @memberof SessionInfo
     */
    FullNowPlayingItem?: BaseItem;
    /**
     * 
     * @type {BaseItemDto}
     * @memberof SessionInfo
     */
    NowViewingItem?: BaseItemDto;
    /**
     * 
     * @type {string}
     * @memberof SessionInfo
     */
    DeviceId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SessionInfo
     */
    ApplicationVersion?: string | null;
    /**
     * 
     * @type {TranscodingInfo}
     * @memberof SessionInfo
     */
    TranscodingInfo?: TranscodingInfo;
    /**
     * 
     * @type {boolean}
     * @memberof SessionInfo
     */
    IsActive?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SessionInfo
     */
    SupportsMediaControl?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SessionInfo
     */
    SupportsRemoteControl?: boolean;
    /**
     * 
     * @type {Array<QueueItem>}
     * @memberof SessionInfo
     */
    NowPlayingQueue?: Array<QueueItem> | null;
    /**
     * 
     * @type {boolean}
     * @memberof SessionInfo
     */
    HasCustomDeviceName?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SessionInfo
     */
    PlaylistItemId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SessionInfo
     */
    ServerId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SessionInfo
     */
    UserPrimaryImageTag?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof SessionInfo
     */
    SupportedCommands?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface SessionUserInfo
 */
export interface SessionUserInfo {
    /**
     * 
     * @type {string}
     * @memberof SessionUserInfo
     */
    UserId?: string;
    /**
     * 
     * @type {string}
     * @memberof SessionUserInfo
     */
    UserName?: string | null;
}
/**
 * 
 * @export
 * @interface SongInfo
 */
export interface SongInfo {
    /**
     * 
     * @type {Array<string>}
     * @memberof SongInfo
     */
    AlbumArtists?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof SongInfo
     */
    Album?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof SongInfo
     */
    Artists?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof SongInfo
     */
    Name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SongInfo
     */
    Path?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SongInfo
     */
    MetadataLanguage?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SongInfo
     */
    MetadataCountryCode?: string | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof SongInfo
     */
    ProviderIds?: { [key: string]: string; } | null;
    /**
     * 
     * @type {number}
     * @memberof SongInfo
     */
    Year?: number | null;
    /**
     * 
     * @type {number}
     * @memberof SongInfo
     */
    IndexNumber?: number | null;
    /**
     * 
     * @type {number}
     * @memberof SongInfo
     */
    ParentIndexNumber?: number | null;
    /**
     * 
     * @type {string}
     * @memberof SongInfo
     */
    PremiereDate?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof SongInfo
     */
    IsAutomated?: boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum SortOrder {
    Ascending = 'Ascending',
    Descending = 'Descending'
}

/**
 * 
 * @export
 * @interface SpecialViewOptionDto
 */
export interface SpecialViewOptionDto {
    /**
     * 
     * @type {string}
     * @memberof SpecialViewOptionDto
     */
    Name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SpecialViewOptionDto
     */
    Id?: string | null;
}
/**
 * 
 * @export
 * @interface StartupConfigurationDto
 */
export interface StartupConfigurationDto {
    /**
     * 
     * @type {string}
     * @memberof StartupConfigurationDto
     */
    UICulture?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StartupConfigurationDto
     */
    MetadataCountryCode?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StartupConfigurationDto
     */
    PreferredMetadataLanguage?: string | null;
}
/**
 * 
 * @export
 * @interface StartupRemoteAccessDto
 */
export interface StartupRemoteAccessDto {
    /**
     * 
     * @type {boolean}
     * @memberof StartupRemoteAccessDto
     */
    EnableRemoteAccess: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StartupRemoteAccessDto
     */
    EnableAutomaticPortMapping: boolean;
}
/**
 * 
 * @export
 * @interface StartupUserDto
 */
export interface StartupUserDto {
    /**
     * 
     * @type {string}
     * @memberof StartupUserDto
     */
    Name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StartupUserDto
     */
    Password?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum SubtitleDeliveryMethod {
    Encode = 'Encode',
    Embed = 'Embed',
    External = 'External',
    Hls = 'Hls'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum SubtitlePlaybackMode {
    Default = 'Default',
    Always = 'Always',
    OnlyForced = 'OnlyForced',
    None = 'None',
    Smart = 'Smart'
}

/**
 * 
 * @export
 * @interface SubtitleProfile
 */
export interface SubtitleProfile {
    /**
     * 
     * @type {string}
     * @memberof SubtitleProfile
     */
    Format?: string | null;
    /**
     * 
     * @type {SubtitleDeliveryMethod}
     * @memberof SubtitleProfile
     */
    Method?: SubtitleDeliveryMethod;
    /**
     * 
     * @type {string}
     * @memberof SubtitleProfile
     */
    DidlMode?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SubtitleProfile
     */
    Language?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SubtitleProfile
     */
    Container?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum SyncPlayAccess {
    CreateAndJoinGroups = 'CreateAndJoinGroups',
    JoinGroups = 'JoinGroups',
    None = 'None'
}

/**
 * 
 * @export
 * @interface SystemInfo
 */
export interface SystemInfo {
    /**
     * 
     * @type {string}
     * @memberof SystemInfo
     */
    OperatingSystemDisplayName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SystemInfo
     */
    PackageName?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof SystemInfo
     */
    HasPendingRestart?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SystemInfo
     */
    IsShuttingDown?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SystemInfo
     */
    SupportsLibraryMonitor?: boolean;
    /**
     * 
     * @type {number}
     * @memberof SystemInfo
     */
    WebSocketPortNumber?: number;
    /**
     * 
     * @type {Array<InstallationInfo>}
     * @memberof SystemInfo
     */
    CompletedInstallations?: Array<InstallationInfo> | null;
    /**
     * 
     * @type {boolean}
     * @memberof SystemInfo
     */
    CanSelfRestart?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SystemInfo
     */
    CanLaunchWebBrowser?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SystemInfo
     */
    ProgramDataPath?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SystemInfo
     */
    WebPath?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SystemInfo
     */
    ItemsByNamePath?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SystemInfo
     */
    CachePath?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SystemInfo
     */
    LogPath?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SystemInfo
     */
    InternalMetadataPath?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SystemInfo
     */
    TranscodingTempPath?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof SystemInfo
     */
    HasUpdateAvailable?: boolean;
    /**
     * 
     * @type {FFmpegLocation}
     * @memberof SystemInfo
     */
    EncoderLocation?: FFmpegLocation;
    /**
     * 
     * @type {Architecture}
     * @memberof SystemInfo
     */
    SystemArchitecture?: Architecture;
    /**
     * 
     * @type {string}
     * @memberof SystemInfo
     */
    LocalAddress?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SystemInfo
     */
    ServerName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SystemInfo
     */
    Version?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SystemInfo
     */
    ProductName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SystemInfo
     */
    OperatingSystem?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SystemInfo
     */
    Id?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum TaskCompletionStatus {
    Completed = 'Completed',
    Failed = 'Failed',
    Cancelled = 'Cancelled',
    Aborted = 'Aborted'
}

/**
 * 
 * @export
 * @interface TaskInfo
 */
export interface TaskInfo {
    /**
     * 
     * @type {string}
     * @memberof TaskInfo
     */
    Name?: string | null;
    /**
     * 
     * @type {TaskState}
     * @memberof TaskInfo
     */
    State?: TaskState;
    /**
     * 
     * @type {number}
     * @memberof TaskInfo
     */
    CurrentProgressPercentage?: number | null;
    /**
     * 
     * @type {string}
     * @memberof TaskInfo
     */
    Id?: string | null;
    /**
     * 
     * @type {TaskResult}
     * @memberof TaskInfo
     */
    LastExecutionResult?: TaskResult;
    /**
     * 
     * @type {Array<TaskTriggerInfo>}
     * @memberof TaskInfo
     */
    Triggers?: Array<TaskTriggerInfo> | null;
    /**
     * 
     * @type {string}
     * @memberof TaskInfo
     */
    Description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TaskInfo
     */
    Category?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof TaskInfo
     */
    IsHidden?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TaskInfo
     */
    Key?: string | null;
}
/**
 * 
 * @export
 * @interface TaskResult
 */
export interface TaskResult {
    /**
     * 
     * @type {string}
     * @memberof TaskResult
     */
    StartTimeUtc?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskResult
     */
    EndTimeUtc?: string;
    /**
     * 
     * @type {TaskCompletionStatus}
     * @memberof TaskResult
     */
    Status?: TaskCompletionStatus;
    /**
     * 
     * @type {string}
     * @memberof TaskResult
     */
    Name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TaskResult
     */
    Key?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TaskResult
     */
    Id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TaskResult
     */
    ErrorMessage?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TaskResult
     */
    LongErrorMessage?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum TaskState {
    Idle = 'Idle',
    Cancelling = 'Cancelling',
    Running = 'Running'
}

/**
 * 
 * @export
 * @interface TaskTriggerInfo
 */
export interface TaskTriggerInfo {
    /**
     * 
     * @type {string}
     * @memberof TaskTriggerInfo
     */
    Type?: string | null;
    /**
     * 
     * @type {number}
     * @memberof TaskTriggerInfo
     */
    TimeOfDayTicks?: number | null;
    /**
     * 
     * @type {number}
     * @memberof TaskTriggerInfo
     */
    IntervalTicks?: number | null;
    /**
     * 
     * @type {DayOfWeek}
     * @memberof TaskTriggerInfo
     */
    DayOfWeek?: DayOfWeek;
    /**
     * 
     * @type {number}
     * @memberof TaskTriggerInfo
     */
    MaxRuntimeTicks?: number | null;
}
/**
 * 
 * @export
 * @interface ThemeMediaResult
 */
export interface ThemeMediaResult {
    /**
     * 
     * @type {string}
     * @memberof ThemeMediaResult
     */
    OwnerId?: string;
    /**
     * 
     * @type {Array<BaseItemDto>}
     * @memberof ThemeMediaResult
     */
    Items?: Array<BaseItemDto> | null;
    /**
     * 
     * @type {number}
     * @memberof ThemeMediaResult
     */
    TotalRecordCount?: number;
    /**
     * 
     * @type {number}
     * @memberof ThemeMediaResult
     */
    StartIndex?: number;
}
/**
 * 
 * @export
 * @interface TimerInfoDto
 */
export interface TimerInfoDto {
    /**
     * 
     * @type {RecordingStatus}
     * @memberof TimerInfoDto
     */
    Status?: RecordingStatus;
    /**
     * 
     * @type {string}
     * @memberof TimerInfoDto
     */
    SeriesTimerId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TimerInfoDto
     */
    ExternalSeriesTimerId?: string | null;
    /**
     * 
     * @type {number}
     * @memberof TimerInfoDto
     */
    RunTimeTicks?: number | null;
    /**
     * 
     * @type {BaseItemDto}
     * @memberof TimerInfoDto
     */
    ProgramInfo?: BaseItemDto;
    /**
     * 
     * @type {string}
     * @memberof TimerInfoDto
     */
    Id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TimerInfoDto
     */
    Type?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TimerInfoDto
     */
    ServerId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TimerInfoDto
     */
    ExternalId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TimerInfoDto
     */
    ChannelId?: string;
    /**
     * 
     * @type {string}
     * @memberof TimerInfoDto
     */
    ExternalChannelId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TimerInfoDto
     */
    ChannelName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TimerInfoDto
     */
    ChannelPrimaryImageTag?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TimerInfoDto
     */
    ProgramId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TimerInfoDto
     */
    ExternalProgramId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TimerInfoDto
     */
    Name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TimerInfoDto
     */
    Overview?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TimerInfoDto
     */
    StartDate?: string;
    /**
     * 
     * @type {string}
     * @memberof TimerInfoDto
     */
    EndDate?: string;
    /**
     * 
     * @type {string}
     * @memberof TimerInfoDto
     */
    ServiceName?: string | null;
    /**
     * 
     * @type {number}
     * @memberof TimerInfoDto
     */
    Priority?: number;
    /**
     * 
     * @type {number}
     * @memberof TimerInfoDto
     */
    PrePaddingSeconds?: number;
    /**
     * 
     * @type {number}
     * @memberof TimerInfoDto
     */
    PostPaddingSeconds?: number;
    /**
     * 
     * @type {boolean}
     * @memberof TimerInfoDto
     */
    IsPrePaddingRequired?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TimerInfoDto
     */
    ParentBackdropItemId?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof TimerInfoDto
     */
    ParentBackdropImageTags?: Array<string> | null;
    /**
     * 
     * @type {boolean}
     * @memberof TimerInfoDto
     */
    IsPostPaddingRequired?: boolean;
    /**
     * 
     * @type {KeepUntil}
     * @memberof TimerInfoDto
     */
    KeepUntil?: KeepUntil;
}
/**
 * 
 * @export
 * @interface TimerInfoDtoQueryResult
 */
export interface TimerInfoDtoQueryResult {
    /**
     * 
     * @type {Array<TimerInfoDto>}
     * @memberof TimerInfoDtoQueryResult
     */
    Items?: Array<TimerInfoDto> | null;
    /**
     * 
     * @type {number}
     * @memberof TimerInfoDtoQueryResult
     */
    TotalRecordCount?: number;
    /**
     * 
     * @type {number}
     * @memberof TimerInfoDtoQueryResult
     */
    StartIndex?: number;
}
/**
 * 
 * @export
 * @interface TrailerInfo
 */
export interface TrailerInfo {
    /**
     * 
     * @type {string}
     * @memberof TrailerInfo
     */
    Name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrailerInfo
     */
    Path?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrailerInfo
     */
    MetadataLanguage?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrailerInfo
     */
    MetadataCountryCode?: string | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof TrailerInfo
     */
    ProviderIds?: { [key: string]: string; } | null;
    /**
     * 
     * @type {number}
     * @memberof TrailerInfo
     */
    Year?: number | null;
    /**
     * 
     * @type {number}
     * @memberof TrailerInfo
     */
    IndexNumber?: number | null;
    /**
     * 
     * @type {number}
     * @memberof TrailerInfo
     */
    ParentIndexNumber?: number | null;
    /**
     * 
     * @type {string}
     * @memberof TrailerInfo
     */
    PremiereDate?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof TrailerInfo
     */
    IsAutomated?: boolean;
}
/**
 * 
 * @export
 * @interface TrailerInfoRemoteSearchQuery
 */
export interface TrailerInfoRemoteSearchQuery {
    /**
     * 
     * @type {TrailerInfo}
     * @memberof TrailerInfoRemoteSearchQuery
     */
    SearchInfo?: TrailerInfo;
    /**
     * 
     * @type {string}
     * @memberof TrailerInfoRemoteSearchQuery
     */
    ItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof TrailerInfoRemoteSearchQuery
     */
    SearchProviderName?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof TrailerInfoRemoteSearchQuery
     */
    IncludeDisabledProviders?: boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum TranscodeReason {
    ContainerNotSupported = 'ContainerNotSupported',
    VideoCodecNotSupported = 'VideoCodecNotSupported',
    AudioCodecNotSupported = 'AudioCodecNotSupported',
    ContainerBitrateExceedsLimit = 'ContainerBitrateExceedsLimit',
    AudioBitrateNotSupported = 'AudioBitrateNotSupported',
    AudioChannelsNotSupported = 'AudioChannelsNotSupported',
    VideoResolutionNotSupported = 'VideoResolutionNotSupported',
    UnknownVideoStreamInfo = 'UnknownVideoStreamInfo',
    UnknownAudioStreamInfo = 'UnknownAudioStreamInfo',
    AudioProfileNotSupported = 'AudioProfileNotSupported',
    AudioSampleRateNotSupported = 'AudioSampleRateNotSupported',
    AnamorphicVideoNotSupported = 'AnamorphicVideoNotSupported',
    InterlacedVideoNotSupported = 'InterlacedVideoNotSupported',
    SecondaryAudioNotSupported = 'SecondaryAudioNotSupported',
    RefFramesNotSupported = 'RefFramesNotSupported',
    VideoBitDepthNotSupported = 'VideoBitDepthNotSupported',
    VideoBitrateNotSupported = 'VideoBitrateNotSupported',
    VideoFramerateNotSupported = 'VideoFramerateNotSupported',
    VideoLevelNotSupported = 'VideoLevelNotSupported',
    VideoProfileNotSupported = 'VideoProfileNotSupported',
    AudioBitDepthNotSupported = 'AudioBitDepthNotSupported',
    SubtitleCodecNotSupported = 'SubtitleCodecNotSupported',
    DirectPlayError = 'DirectPlayError'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum TranscodeSeekInfo {
    Auto = 'Auto',
    Bytes = 'Bytes'
}

/**
 * 
 * @export
 * @interface TranscodingInfo
 */
export interface TranscodingInfo {
    /**
     * 
     * @type {string}
     * @memberof TranscodingInfo
     */
    AudioCodec?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TranscodingInfo
     */
    VideoCodec?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TranscodingInfo
     */
    Container?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof TranscodingInfo
     */
    IsVideoDirect?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TranscodingInfo
     */
    IsAudioDirect?: boolean;
    /**
     * 
     * @type {number}
     * @memberof TranscodingInfo
     */
    Bitrate?: number | null;
    /**
     * 
     * @type {number}
     * @memberof TranscodingInfo
     */
    Framerate?: number | null;
    /**
     * 
     * @type {number}
     * @memberof TranscodingInfo
     */
    CompletionPercentage?: number | null;
    /**
     * 
     * @type {number}
     * @memberof TranscodingInfo
     */
    Width?: number | null;
    /**
     * 
     * @type {number}
     * @memberof TranscodingInfo
     */
    Height?: number | null;
    /**
     * 
     * @type {number}
     * @memberof TranscodingInfo
     */
    AudioChannels?: number | null;
    /**
     * 
     * @type {Array<TranscodeReason>}
     * @memberof TranscodingInfo
     */
    TranscodeReasons?: Array<TranscodeReason> | null;
}
/**
 * 
 * @export
 * @interface TranscodingProfile
 */
export interface TranscodingProfile {
    /**
     * 
     * @type {string}
     * @memberof TranscodingProfile
     */
    Container?: string | null;
    /**
     * 
     * @type {DlnaProfileType}
     * @memberof TranscodingProfile
     */
    Type?: DlnaProfileType;
    /**
     * 
     * @type {string}
     * @memberof TranscodingProfile
     */
    VideoCodec?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TranscodingProfile
     */
    AudioCodec?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TranscodingProfile
     */
    Protocol?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof TranscodingProfile
     */
    EstimateContentLength?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TranscodingProfile
     */
    EnableMpegtsM2TsMode?: boolean;
    /**
     * 
     * @type {TranscodeSeekInfo}
     * @memberof TranscodingProfile
     */
    TranscodeSeekInfo?: TranscodeSeekInfo;
    /**
     * 
     * @type {boolean}
     * @memberof TranscodingProfile
     */
    CopyTimestamps?: boolean;
    /**
     * 
     * @type {EncodingContext}
     * @memberof TranscodingProfile
     */
    Context?: EncodingContext;
    /**
     * 
     * @type {boolean}
     * @memberof TranscodingProfile
     */
    EnableSubtitlesInManifest?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TranscodingProfile
     */
    MaxAudioChannels?: string | null;
    /**
     * 
     * @type {number}
     * @memberof TranscodingProfile
     */
    MinSegments?: number;
    /**
     * 
     * @type {number}
     * @memberof TranscodingProfile
     */
    SegmentLength?: number;
    /**
     * 
     * @type {boolean}
     * @memberof TranscodingProfile
     */
    BreakOnNonKeyFrames?: boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum TransportStreamTimestamp {
    None = 'None',
    Zero = 'Zero',
    Valid = 'Valid'
}

/**
 * 
 * @export
 * @interface TunerChannelMapping
 */
export interface TunerChannelMapping {
    /**
     * 
     * @type {string}
     * @memberof TunerChannelMapping
     */
    Name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TunerChannelMapping
     */
    ProviderChannelName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TunerChannelMapping
     */
    ProviderChannelId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TunerChannelMapping
     */
    Id?: string | null;
}
/**
 * 
 * @export
 * @interface TunerHostInfo
 */
export interface TunerHostInfo {
    /**
     * 
     * @type {string}
     * @memberof TunerHostInfo
     */
    Id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TunerHostInfo
     */
    Url?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TunerHostInfo
     */
    Type?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TunerHostInfo
     */
    DeviceId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TunerHostInfo
     */
    FriendlyName?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof TunerHostInfo
     */
    ImportFavoritesOnly?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TunerHostInfo
     */
    AllowHWTranscoding?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TunerHostInfo
     */
    EnableStreamLooping?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TunerHostInfo
     */
    Source?: string | null;
    /**
     * 
     * @type {number}
     * @memberof TunerHostInfo
     */
    TunerCount?: number;
    /**
     * 
     * @type {string}
     * @memberof TunerHostInfo
     */
    UserAgent?: string | null;
}
/**
 * 
 * @export
 * @interface TypeOptions
 */
export interface TypeOptions {
    /**
     * 
     * @type {string}
     * @memberof TypeOptions
     */
    Type?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof TypeOptions
     */
    MetadataFetchers?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof TypeOptions
     */
    MetadataFetcherOrder?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof TypeOptions
     */
    ImageFetchers?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof TypeOptions
     */
    ImageFetcherOrder?: Array<string> | null;
    /**
     * 
     * @type {Array<ImageOption>}
     * @memberof TypeOptions
     */
    ImageOptions?: Array<ImageOption> | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum UnratedItem {
    Movie = 'Movie',
    Trailer = 'Trailer',
    Series = 'Series',
    Music = 'Music',
    Book = 'Book',
    LiveTvChannel = 'LiveTvChannel',
    LiveTvProgram = 'LiveTvProgram',
    ChannelContent = 'ChannelContent',
    Other = 'Other'
}

/**
 * 
 * @export
 * @interface UpdateLibraryOptionsDto
 */
export interface UpdateLibraryOptionsDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateLibraryOptionsDto
     */
    Id?: string;
    /**
     * 
     * @type {LibraryOptions}
     * @memberof UpdateLibraryOptionsDto
     */
    LibraryOptions?: LibraryOptions;
}
/**
 * 
 * @export
 * @interface UpdateUserEasyPassword
 */
export interface UpdateUserEasyPassword {
    /**
     * 
     * @type {string}
     * @memberof UpdateUserEasyPassword
     */
    NewPassword?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserEasyPassword
     */
    NewPw?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateUserEasyPassword
     */
    ResetPassword?: boolean;
}
/**
 * 
 * @export
 * @interface UpdateUserPassword
 */
export interface UpdateUserPassword {
    /**
     * 
     * @type {string}
     * @memberof UpdateUserPassword
     */
    CurrentPassword?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserPassword
     */
    CurrentPw?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserPassword
     */
    NewPw?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateUserPassword
     */
    ResetPassword?: boolean;
}
/**
 * 
 * @export
 * @interface UserConfiguration
 */
export interface UserConfiguration {
    /**
     * 
     * @type {string}
     * @memberof UserConfiguration
     */
    AudioLanguagePreference?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserConfiguration
     */
    PlayDefaultAudioTrack?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserConfiguration
     */
    SubtitleLanguagePreference?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserConfiguration
     */
    DisplayMissingEpisodes?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserConfiguration
     */
    GroupedFolders?: Array<string> | null;
    /**
     * 
     * @type {SubtitlePlaybackMode}
     * @memberof UserConfiguration
     */
    SubtitleMode?: SubtitlePlaybackMode;
    /**
     * 
     * @type {boolean}
     * @memberof UserConfiguration
     */
    DisplayCollectionsView?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserConfiguration
     */
    EnableLocalPassword?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserConfiguration
     */
    OrderedViews?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserConfiguration
     */
    LatestItemsExcludes?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserConfiguration
     */
    MyMediaExcludes?: Array<string> | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserConfiguration
     */
    HidePlayedInLatest?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserConfiguration
     */
    RememberAudioSelections?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserConfiguration
     */
    RememberSubtitleSelections?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserConfiguration
     */
    EnableNextEpisodeAutoPlay?: boolean;
}
/**
 * 
 * @export
 * @interface UserDto
 */
export interface UserDto {
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    Name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    ServerId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    ServerName?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    Id?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    PrimaryImageTag?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserDto
     */
    HasPassword?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserDto
     */
    HasConfiguredPassword?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserDto
     */
    HasConfiguredEasyPassword?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserDto
     */
    EnableAutoLogin?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    LastLoginDate?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    LastActivityDate?: string | null;
    /**
     * 
     * @type {UserConfiguration}
     * @memberof UserDto
     */
    Configuration?: UserConfiguration;
    /**
     * 
     * @type {UserPolicy}
     * @memberof UserDto
     */
    Policy?: UserPolicy;
    /**
     * 
     * @type {number}
     * @memberof UserDto
     */
    PrimaryImageAspectRatio?: number | null;
}
/**
 * 
 * @export
 * @interface UserItemDataDto
 */
export interface UserItemDataDto {
    /**
     * 
     * @type {number}
     * @memberof UserItemDataDto
     */
    Rating?: number | null;
    /**
     * 
     * @type {number}
     * @memberof UserItemDataDto
     */
    PlayedPercentage?: number | null;
    /**
     * 
     * @type {number}
     * @memberof UserItemDataDto
     */
    UnplayedItemCount?: number | null;
    /**
     * 
     * @type {number}
     * @memberof UserItemDataDto
     */
    PlaybackPositionTicks?: number;
    /**
     * 
     * @type {number}
     * @memberof UserItemDataDto
     */
    PlayCount?: number;
    /**
     * 
     * @type {boolean}
     * @memberof UserItemDataDto
     */
    IsFavorite?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserItemDataDto
     */
    Likes?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof UserItemDataDto
     */
    LastPlayedDate?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserItemDataDto
     */
    Played?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserItemDataDto
     */
    Key?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserItemDataDto
     */
    ItemId?: string | null;
}
/**
 * 
 * @export
 * @interface UserPolicy
 */
export interface UserPolicy {
    /**
     * 
     * @type {boolean}
     * @memberof UserPolicy
     */
    IsAdministrator?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserPolicy
     */
    IsHidden?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserPolicy
     */
    IsDisabled?: boolean;
    /**
     * 
     * @type {number}
     * @memberof UserPolicy
     */
    MaxParentalRating?: number | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserPolicy
     */
    BlockedTags?: Array<string> | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserPolicy
     */
    EnableUserPreferenceAccess?: boolean;
    /**
     * 
     * @type {Array<AccessSchedule>}
     * @memberof UserPolicy
     */
    AccessSchedules?: Array<AccessSchedule> | null;
    /**
     * 
     * @type {Array<UnratedItem>}
     * @memberof UserPolicy
     */
    BlockUnratedItems?: Array<UnratedItem> | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserPolicy
     */
    EnableRemoteControlOfOtherUsers?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserPolicy
     */
    EnableSharedDeviceControl?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserPolicy
     */
    EnableRemoteAccess?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserPolicy
     */
    EnableLiveTvManagement?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserPolicy
     */
    EnableLiveTvAccess?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserPolicy
     */
    EnableMediaPlayback?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserPolicy
     */
    EnableAudioPlaybackTranscoding?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserPolicy
     */
    EnableVideoPlaybackTranscoding?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserPolicy
     */
    EnablePlaybackRemuxing?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserPolicy
     */
    ForceRemoteSourceTranscoding?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserPolicy
     */
    EnableContentDeletion?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserPolicy
     */
    EnableContentDeletionFromFolders?: Array<string> | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserPolicy
     */
    EnableContentDownloading?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserPolicy
     */
    EnableSyncTranscoding?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserPolicy
     */
    EnableMediaConversion?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserPolicy
     */
    EnabledDevices?: Array<string> | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserPolicy
     */
    EnableAllDevices?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserPolicy
     */
    EnabledChannels?: Array<string> | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserPolicy
     */
    EnableAllChannels?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserPolicy
     */
    EnabledFolders?: Array<string> | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserPolicy
     */
    EnableAllFolders?: boolean;
    /**
     * 
     * @type {number}
     * @memberof UserPolicy
     */
    InvalidLoginAttemptCount?: number;
    /**
     * 
     * @type {number}
     * @memberof UserPolicy
     */
    LoginAttemptsBeforeLockout?: number;
    /**
     * 
     * @type {boolean}
     * @memberof UserPolicy
     */
    EnablePublicSharing?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserPolicy
     */
    BlockedMediaFolders?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserPolicy
     */
    BlockedChannels?: Array<string> | null;
    /**
     * 
     * @type {number}
     * @memberof UserPolicy
     */
    RemoteClientBitrateLimit?: number;
    /**
     * 
     * @type {string}
     * @memberof UserPolicy
     */
    AuthenticationProviderId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserPolicy
     */
    PasswordResetProviderId?: string | null;
    /**
     * 
     * @type {SyncPlayAccess}
     * @memberof UserPolicy
     */
    SyncPlayAccess?: SyncPlayAccess;
}
/**
 * 
 * @export
 * @interface UtcTimeResponse
 */
export interface UtcTimeResponse {
    /**
     * 
     * @type {string}
     * @memberof UtcTimeResponse
     */
    RequestReceptionTime?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UtcTimeResponse
     */
    ResponseTransmissionTime?: string | null;
}
/**
 * 
 * @export
 * @interface ValidatePathDto
 */
export interface ValidatePathDto {
    /**
     * 
     * @type {boolean}
     * @memberof ValidatePathDto
     */
    ValidateWritable?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ValidatePathDto
     */
    Path?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ValidatePathDto
     */
    IsFile?: boolean | null;
}
/**
 * 
 * @export
 * @interface Version
 */
export interface Version {
    /**
     * 
     * @type {number}
     * @memberof Version
     */
    Major?: number;
    /**
     * 
     * @type {number}
     * @memberof Version
     */
    Minor?: number;
    /**
     * 
     * @type {number}
     * @memberof Version
     */
    Build?: number;
    /**
     * 
     * @type {number}
     * @memberof Version
     */
    Revision?: number;
    /**
     * 
     * @type {number}
     * @memberof Version
     */
    MajorRevision?: number;
    /**
     * 
     * @type {number}
     * @memberof Version
     */
    MinorRevision?: number;
}
/**
 * 
 * @export
 * @interface VersionInfo
 */
export interface VersionInfo {
    /**
     * 
     * @type {string}
     * @memberof VersionInfo
     */
    version?: string | null;
    /**
     * 
     * @type {string}
     * @memberof VersionInfo
     */
    changelog?: string | null;
    /**
     * 
     * @type {string}
     * @memberof VersionInfo
     */
    targetAbi?: string | null;
    /**
     * 
     * @type {string}
     * @memberof VersionInfo
     */
    sourceUrl?: string | null;
    /**
     * 
     * @type {string}
     * @memberof VersionInfo
     */
    checksum?: string | null;
    /**
     * 
     * @type {string}
     * @memberof VersionInfo
     */
    timestamp?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum Video3DFormat {
    HalfSideBySide = 'HalfSideBySide',
    FullSideBySide = 'FullSideBySide',
    FullTopAndBottom = 'FullTopAndBottom',
    HalfTopAndBottom = 'HalfTopAndBottom',
    MVC = 'MVC'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum VideoType {
    VideoFile = 'VideoFile',
    Iso = 'Iso',
    Dvd = 'Dvd',
    BluRay = 'BluRay'
}

/**
 * 
 * @export
 * @interface VirtualFolderInfo
 */
export interface VirtualFolderInfo {
    /**
     * 
     * @type {string}
     * @memberof VirtualFolderInfo
     */
    Name?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof VirtualFolderInfo
     */
    Locations?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof VirtualFolderInfo
     */
    CollectionType?: string | null;
    /**
     * 
     * @type {LibraryOptions}
     * @memberof VirtualFolderInfo
     */
    LibraryOptions?: LibraryOptions;
    /**
     * 
     * @type {string}
     * @memberof VirtualFolderInfo
     */
    ItemId?: string | null;
    /**
     * 
     * @type {string}
     * @memberof VirtualFolderInfo
     */
    PrimaryImageItemId?: string | null;
    /**
     * 
     * @type {number}
     * @memberof VirtualFolderInfo
     */
    RefreshProgress?: number | null;
    /**
     * 
     * @type {string}
     * @memberof VirtualFolderInfo
     */
    RefreshStatus?: string | null;
}
/**
 * 
 * @export
 * @interface WakeOnLanInfo
 */
export interface WakeOnLanInfo {
    /**
     * 
     * @type {string}
     * @memberof WakeOnLanInfo
     */
    MacAddress?: string | null;
    /**
     * 
     * @type {number}
     * @memberof WakeOnLanInfo
     */
    Port?: number;
}
/**
 * 
 * @export
 * @interface XmlAttribute
 */
export interface XmlAttribute {
    /**
     * 
     * @type {string}
     * @memberof XmlAttribute
     */
    Name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof XmlAttribute
     */
    Value?: string | null;
}

/**
 * ActivityLogApi - axios parameter creator
 * @export
 */
export const ActivityLogApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [startIndex] 
         * @param {number} [limit] 
         * @param {string} [minDate] 
         * @param {boolean} [hasUserId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogEntries: async (startIndex?: number, limit?: number, minDate?: string, hasUserId?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/System/ActivityLog/Entries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (minDate !== undefined) {
                localVarQueryParameter['minDate'] = (minDate as any instanceof Date) ?
                    (minDate as any).toISOString() :
                    minDate;
            }

            if (hasUserId !== undefined) {
                localVarQueryParameter['hasUserId'] = hasUserId;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActivityLogApi - functional programming interface
 * @export
 */
export const ActivityLogApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [startIndex] 
         * @param {number} [limit] 
         * @param {string} [minDate] 
         * @param {boolean} [hasUserId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLogEntries(startIndex?: number, limit?: number, minDate?: string, hasUserId?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActivityLogEntryQueryResult>> {
            const localVarAxiosArgs = await ActivityLogApiAxiosParamCreator(configuration).getLogEntries(startIndex, limit, minDate, hasUserId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ActivityLogApi - factory interface
 * @export
 */
export const ActivityLogApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {number} [startIndex] 
         * @param {number} [limit] 
         * @param {string} [minDate] 
         * @param {boolean} [hasUserId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogEntries(startIndex?: number, limit?: number, minDate?: string, hasUserId?: boolean, options?: any): AxiosPromise<ActivityLogEntryQueryResult> {
            return ActivityLogApiFp(configuration).getLogEntries(startIndex, limit, minDate, hasUserId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getLogEntries operation in ActivityLogApi.
 * @export
 * @interface ActivityLogApiGetLogEntriesRequest
 */
export interface ActivityLogApiGetLogEntriesRequest {
    /**
     * 
     * @type {number}
     * @memberof ActivityLogApiGetLogEntries
     */
    readonly startIndex?: number

    /**
     * 
     * @type {number}
     * @memberof ActivityLogApiGetLogEntries
     */
    readonly limit?: number

    /**
     * 
     * @type {string}
     * @memberof ActivityLogApiGetLogEntries
     */
    readonly minDate?: string

    /**
     * 
     * @type {boolean}
     * @memberof ActivityLogApiGetLogEntries
     */
    readonly hasUserId?: boolean
}

/**
 * ActivityLogApi - object-oriented interface
 * @export
 * @class ActivityLogApi
 * @extends {BaseAPI}
 */
export class ActivityLogApi extends BaseAPI {
    /**
     * 
     * @param {ActivityLogApiGetLogEntriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityLogApi
     */
    public getLogEntries(requestParameters: ActivityLogApiGetLogEntriesRequest = {}, options?: any) {
        return ActivityLogApiFp(this.configuration).getLogEntries(requestParameters.startIndex, requestParameters.limit, requestParameters.minDate, requestParameters.hasUserId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AlbumsApi - axios parameter creator
 * @export
 */
export const AlbumsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} albumId 
         * @param {string} [userId] 
         * @param {string} [excludeArtistIds] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimilarAlbums: async (albumId: string, userId?: string, excludeArtistIds?: string, limit?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'albumId' is not null or undefined
            if (albumId === null || albumId === undefined) {
                throw new RequiredError('albumId','Required parameter albumId was null or undefined when calling getSimilarAlbums.');
            }
            const localVarPath = `/Albums/{albumId}/Similar`
                .replace(`{${"albumId"}}`, encodeURIComponent(String(albumId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (excludeArtistIds !== undefined) {
                localVarQueryParameter['excludeArtistIds'] = excludeArtistIds;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} artistId 
         * @param {string} [userId] 
         * @param {string} [excludeArtistIds] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimilarArtists: async (artistId: string, userId?: string, excludeArtistIds?: string, limit?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artistId' is not null or undefined
            if (artistId === null || artistId === undefined) {
                throw new RequiredError('artistId','Required parameter artistId was null or undefined when calling getSimilarArtists.');
            }
            const localVarPath = `/Artists/{artistId}/Similar`
                .replace(`{${"artistId"}}`, encodeURIComponent(String(artistId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (excludeArtistIds !== undefined) {
                localVarQueryParameter['excludeArtistIds'] = excludeArtistIds;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AlbumsApi - functional programming interface
 * @export
 */
export const AlbumsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} albumId 
         * @param {string} [userId] 
         * @param {string} [excludeArtistIds] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSimilarAlbums(albumId: string, userId?: string, excludeArtistIds?: string, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await AlbumsApiAxiosParamCreator(configuration).getSimilarAlbums(albumId, userId, excludeArtistIds, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} artistId 
         * @param {string} [userId] 
         * @param {string} [excludeArtistIds] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSimilarArtists(artistId: string, userId?: string, excludeArtistIds?: string, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await AlbumsApiAxiosParamCreator(configuration).getSimilarArtists(artistId, userId, excludeArtistIds, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AlbumsApi - factory interface
 * @export
 */
export const AlbumsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} albumId 
         * @param {string} [userId] 
         * @param {string} [excludeArtistIds] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimilarAlbums(albumId: string, userId?: string, excludeArtistIds?: string, limit?: number, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return AlbumsApiFp(configuration).getSimilarAlbums(albumId, userId, excludeArtistIds, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} artistId 
         * @param {string} [userId] 
         * @param {string} [excludeArtistIds] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimilarArtists(artistId: string, userId?: string, excludeArtistIds?: string, limit?: number, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return AlbumsApiFp(configuration).getSimilarArtists(artistId, userId, excludeArtistIds, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getSimilarAlbums operation in AlbumsApi.
 * @export
 * @interface AlbumsApiGetSimilarAlbumsRequest
 */
export interface AlbumsApiGetSimilarAlbumsRequest {
    /**
     * 
     * @type {string}
     * @memberof AlbumsApiGetSimilarAlbums
     */
    readonly albumId: string

    /**
     * 
     * @type {string}
     * @memberof AlbumsApiGetSimilarAlbums
     */
    readonly userId?: string

    /**
     * 
     * @type {string}
     * @memberof AlbumsApiGetSimilarAlbums
     */
    readonly excludeArtistIds?: string

    /**
     * 
     * @type {number}
     * @memberof AlbumsApiGetSimilarAlbums
     */
    readonly limit?: number
}

/**
 * Request parameters for getSimilarArtists operation in AlbumsApi.
 * @export
 * @interface AlbumsApiGetSimilarArtistsRequest
 */
export interface AlbumsApiGetSimilarArtistsRequest {
    /**
     * 
     * @type {string}
     * @memberof AlbumsApiGetSimilarArtists
     */
    readonly artistId: string

    /**
     * 
     * @type {string}
     * @memberof AlbumsApiGetSimilarArtists
     */
    readonly userId?: string

    /**
     * 
     * @type {string}
     * @memberof AlbumsApiGetSimilarArtists
     */
    readonly excludeArtistIds?: string

    /**
     * 
     * @type {number}
     * @memberof AlbumsApiGetSimilarArtists
     */
    readonly limit?: number
}

/**
 * AlbumsApi - object-oriented interface
 * @export
 * @class AlbumsApi
 * @extends {BaseAPI}
 */
export class AlbumsApi extends BaseAPI {
    /**
     * 
     * @param {AlbumsApiGetSimilarAlbumsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumsApi
     */
    public getSimilarAlbums(requestParameters: AlbumsApiGetSimilarAlbumsRequest, options?: any) {
        return AlbumsApiFp(this.configuration).getSimilarAlbums(requestParameters.albumId, requestParameters.userId, requestParameters.excludeArtistIds, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AlbumsApiGetSimilarArtistsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlbumsApi
     */
    public getSimilarArtists(requestParameters: AlbumsApiGetSimilarArtistsRequest, options?: any) {
        return AlbumsApiFp(this.configuration).getSimilarArtists(requestParameters.artistId, requestParameters.userId, requestParameters.excludeArtistIds, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ApiKeyApi - axios parameter creator
 * @export
 */
export const ApiKeyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} app 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKey: async (app: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'app' is not null or undefined
            if (app === null || app === undefined) {
                throw new RequiredError('app','Required parameter app was null or undefined when calling createKey.');
            }
            const localVarPath = `/Auth/Keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (app !== undefined) {
                localVarQueryParameter['app'] = app;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKeys: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Auth/Keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeKey: async (key: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling revokeKey.');
            }
            const localVarPath = `/Auth/Keys/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApiKeyApi - functional programming interface
 * @export
 */
export const ApiKeyApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} app 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createKey(app: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ApiKeyApiAxiosParamCreator(configuration).createKey(app, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKeys(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationInfoQueryResult>> {
            const localVarAxiosArgs = await ApiKeyApiAxiosParamCreator(configuration).getKeys(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async revokeKey(key: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ApiKeyApiAxiosParamCreator(configuration).revokeKey(key, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ApiKeyApi - factory interface
 * @export
 */
export const ApiKeyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} app 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKey(app: string, options?: any): AxiosPromise<void> {
            return ApiKeyApiFp(configuration).createKey(app, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKeys(options?: any): AxiosPromise<AuthenticationInfoQueryResult> {
            return ApiKeyApiFp(configuration).getKeys(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeKey(key: string, options?: any): AxiosPromise<void> {
            return ApiKeyApiFp(configuration).revokeKey(key, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createKey operation in ApiKeyApi.
 * @export
 * @interface ApiKeyApiCreateKeyRequest
 */
export interface ApiKeyApiCreateKeyRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiKeyApiCreateKey
     */
    readonly app: string
}

/**
 * Request parameters for revokeKey operation in ApiKeyApi.
 * @export
 * @interface ApiKeyApiRevokeKeyRequest
 */
export interface ApiKeyApiRevokeKeyRequest {
    /**
     * 
     * @type {string}
     * @memberof ApiKeyApiRevokeKey
     */
    readonly key: string
}

/**
 * ApiKeyApi - object-oriented interface
 * @export
 * @class ApiKeyApi
 * @extends {BaseAPI}
 */
export class ApiKeyApi extends BaseAPI {
    /**
     * 
     * @param {ApiKeyApiCreateKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeyApi
     */
    public createKey(requestParameters: ApiKeyApiCreateKeyRequest, options?: any) {
        return ApiKeyApiFp(this.configuration).createKey(requestParameters.app, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeyApi
     */
    public getKeys(options?: any) {
        return ApiKeyApiFp(this.configuration).getKeys(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ApiKeyApiRevokeKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeyApi
     */
    public revokeKey(requestParameters: ApiKeyApiRevokeKeyRequest, options?: any) {
        return ApiKeyApiFp(this.configuration).revokeKey(requestParameters.key, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ArtistsApi - axios parameter creator
 * @export
 */
export const ArtistsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [minCommunityRating] 
         * @param {number} [startIndex] 
         * @param {number} [limit] 
         * @param {string} [searchTerm] 
         * @param {string} [parentId] 
         * @param {string} [fields] 
         * @param {string} [excludeItemTypes] 
         * @param {string} [includeItemTypes] 
         * @param {string} [filters] 
         * @param {boolean} [isFavorite] 
         * @param {string} [mediaTypes] 
         * @param {string} [genres] 
         * @param {string} [genreIds] 
         * @param {string} [officialRatings] 
         * @param {string} [tags] 
         * @param {string} [years] 
         * @param {boolean} [enableUserData] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {string} [person] 
         * @param {string} [personIds] 
         * @param {string} [personTypes] 
         * @param {string} [studios] 
         * @param {string} [studioIds] 
         * @param {string} [userId] 
         * @param {string} [nameStartsWithOrGreater] 
         * @param {string} [nameStartsWith] 
         * @param {string} [nameLessThan] 
         * @param {boolean} [enableImages] 
         * @param {boolean} [enableTotalRecordCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlbumArtists: async (minCommunityRating?: number, startIndex?: number, limit?: number, searchTerm?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, filters?: string, isFavorite?: boolean, mediaTypes?: string, genres?: string, genreIds?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, studioIds?: string, userId?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, enableImages?: boolean, enableTotalRecordCount?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Artists/AlbumArtists`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (minCommunityRating !== undefined) {
                localVarQueryParameter['minCommunityRating'] = minCommunityRating;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (searchTerm !== undefined) {
                localVarQueryParameter['searchTerm'] = searchTerm;
            }

            if (parentId !== undefined) {
                localVarQueryParameter['parentId'] = parentId;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeItemTypes !== undefined) {
                localVarQueryParameter['excludeItemTypes'] = excludeItemTypes;
            }

            if (includeItemTypes !== undefined) {
                localVarQueryParameter['includeItemTypes'] = includeItemTypes;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (isFavorite !== undefined) {
                localVarQueryParameter['isFavorite'] = isFavorite;
            }

            if (mediaTypes !== undefined) {
                localVarQueryParameter['mediaTypes'] = mediaTypes;
            }

            if (genres !== undefined) {
                localVarQueryParameter['genres'] = genres;
            }

            if (genreIds !== undefined) {
                localVarQueryParameter['genreIds'] = genreIds;
            }

            if (officialRatings !== undefined) {
                localVarQueryParameter['officialRatings'] = officialRatings;
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }

            if (years !== undefined) {
                localVarQueryParameter['years'] = years;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes !== undefined) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }

            if (person !== undefined) {
                localVarQueryParameter['person'] = person;
            }

            if (personIds !== undefined) {
                localVarQueryParameter['personIds'] = personIds;
            }

            if (personTypes !== undefined) {
                localVarQueryParameter['personTypes'] = personTypes;
            }

            if (studios !== undefined) {
                localVarQueryParameter['studios'] = studios;
            }

            if (studioIds !== undefined) {
                localVarQueryParameter['studioIds'] = studioIds;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (nameStartsWithOrGreater !== undefined) {
                localVarQueryParameter['nameStartsWithOrGreater'] = nameStartsWithOrGreater;
            }

            if (nameStartsWith !== undefined) {
                localVarQueryParameter['nameStartsWith'] = nameStartsWith;
            }

            if (nameLessThan !== undefined) {
                localVarQueryParameter['nameLessThan'] = nameLessThan;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }

            if (enableTotalRecordCount !== undefined) {
                localVarQueryParameter['enableTotalRecordCount'] = enableTotalRecordCount;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtistByName: async (name: string, userId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getArtistByName.');
            }
            const localVarPath = `/Artists/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [minCommunityRating] 
         * @param {number} [startIndex] 
         * @param {number} [limit] 
         * @param {string} [searchTerm] 
         * @param {string} [parentId] 
         * @param {string} [fields] 
         * @param {string} [excludeItemTypes] 
         * @param {string} [includeItemTypes] 
         * @param {string} [filters] 
         * @param {boolean} [isFavorite] 
         * @param {string} [mediaTypes] 
         * @param {string} [genres] 
         * @param {string} [genreIds] 
         * @param {string} [officialRatings] 
         * @param {string} [tags] 
         * @param {string} [years] 
         * @param {boolean} [enableUserData] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {string} [person] 
         * @param {string} [personIds] 
         * @param {string} [personTypes] 
         * @param {string} [studios] 
         * @param {string} [studioIds] 
         * @param {string} [userId] 
         * @param {string} [nameStartsWithOrGreater] 
         * @param {string} [nameStartsWith] 
         * @param {string} [nameLessThan] 
         * @param {boolean} [enableImages] 
         * @param {boolean} [enableTotalRecordCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtists: async (minCommunityRating?: number, startIndex?: number, limit?: number, searchTerm?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, filters?: string, isFavorite?: boolean, mediaTypes?: string, genres?: string, genreIds?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, studioIds?: string, userId?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, enableImages?: boolean, enableTotalRecordCount?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Artists`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (minCommunityRating !== undefined) {
                localVarQueryParameter['minCommunityRating'] = minCommunityRating;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (searchTerm !== undefined) {
                localVarQueryParameter['searchTerm'] = searchTerm;
            }

            if (parentId !== undefined) {
                localVarQueryParameter['parentId'] = parentId;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeItemTypes !== undefined) {
                localVarQueryParameter['excludeItemTypes'] = excludeItemTypes;
            }

            if (includeItemTypes !== undefined) {
                localVarQueryParameter['includeItemTypes'] = includeItemTypes;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (isFavorite !== undefined) {
                localVarQueryParameter['isFavorite'] = isFavorite;
            }

            if (mediaTypes !== undefined) {
                localVarQueryParameter['mediaTypes'] = mediaTypes;
            }

            if (genres !== undefined) {
                localVarQueryParameter['genres'] = genres;
            }

            if (genreIds !== undefined) {
                localVarQueryParameter['genreIds'] = genreIds;
            }

            if (officialRatings !== undefined) {
                localVarQueryParameter['officialRatings'] = officialRatings;
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }

            if (years !== undefined) {
                localVarQueryParameter['years'] = years;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes !== undefined) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }

            if (person !== undefined) {
                localVarQueryParameter['person'] = person;
            }

            if (personIds !== undefined) {
                localVarQueryParameter['personIds'] = personIds;
            }

            if (personTypes !== undefined) {
                localVarQueryParameter['personTypes'] = personTypes;
            }

            if (studios !== undefined) {
                localVarQueryParameter['studios'] = studios;
            }

            if (studioIds !== undefined) {
                localVarQueryParameter['studioIds'] = studioIds;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (nameStartsWithOrGreater !== undefined) {
                localVarQueryParameter['nameStartsWithOrGreater'] = nameStartsWithOrGreater;
            }

            if (nameStartsWith !== undefined) {
                localVarQueryParameter['nameStartsWith'] = nameStartsWith;
            }

            if (nameLessThan !== undefined) {
                localVarQueryParameter['nameLessThan'] = nameLessThan;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }

            if (enableTotalRecordCount !== undefined) {
                localVarQueryParameter['enableTotalRecordCount'] = enableTotalRecordCount;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ArtistsApi - functional programming interface
 * @export
 */
export const ArtistsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [minCommunityRating] 
         * @param {number} [startIndex] 
         * @param {number} [limit] 
         * @param {string} [searchTerm] 
         * @param {string} [parentId] 
         * @param {string} [fields] 
         * @param {string} [excludeItemTypes] 
         * @param {string} [includeItemTypes] 
         * @param {string} [filters] 
         * @param {boolean} [isFavorite] 
         * @param {string} [mediaTypes] 
         * @param {string} [genres] 
         * @param {string} [genreIds] 
         * @param {string} [officialRatings] 
         * @param {string} [tags] 
         * @param {string} [years] 
         * @param {boolean} [enableUserData] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {string} [person] 
         * @param {string} [personIds] 
         * @param {string} [personTypes] 
         * @param {string} [studios] 
         * @param {string} [studioIds] 
         * @param {string} [userId] 
         * @param {string} [nameStartsWithOrGreater] 
         * @param {string} [nameStartsWith] 
         * @param {string} [nameLessThan] 
         * @param {boolean} [enableImages] 
         * @param {boolean} [enableTotalRecordCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAlbumArtists(minCommunityRating?: number, startIndex?: number, limit?: number, searchTerm?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, filters?: string, isFavorite?: boolean, mediaTypes?: string, genres?: string, genreIds?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, studioIds?: string, userId?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, enableImages?: boolean, enableTotalRecordCount?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await ArtistsApiAxiosParamCreator(configuration).getAlbumArtists(minCommunityRating, startIndex, limit, searchTerm, parentId, fields, excludeItemTypes, includeItemTypes, filters, isFavorite, mediaTypes, genres, genreIds, officialRatings, tags, years, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, studioIds, userId, nameStartsWithOrGreater, nameStartsWith, nameLessThan, enableImages, enableTotalRecordCount, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArtistByName(name: string, userId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDto>> {
            const localVarAxiosArgs = await ArtistsApiAxiosParamCreator(configuration).getArtistByName(name, userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} [minCommunityRating] 
         * @param {number} [startIndex] 
         * @param {number} [limit] 
         * @param {string} [searchTerm] 
         * @param {string} [parentId] 
         * @param {string} [fields] 
         * @param {string} [excludeItemTypes] 
         * @param {string} [includeItemTypes] 
         * @param {string} [filters] 
         * @param {boolean} [isFavorite] 
         * @param {string} [mediaTypes] 
         * @param {string} [genres] 
         * @param {string} [genreIds] 
         * @param {string} [officialRatings] 
         * @param {string} [tags] 
         * @param {string} [years] 
         * @param {boolean} [enableUserData] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {string} [person] 
         * @param {string} [personIds] 
         * @param {string} [personTypes] 
         * @param {string} [studios] 
         * @param {string} [studioIds] 
         * @param {string} [userId] 
         * @param {string} [nameStartsWithOrGreater] 
         * @param {string} [nameStartsWith] 
         * @param {string} [nameLessThan] 
         * @param {boolean} [enableImages] 
         * @param {boolean} [enableTotalRecordCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArtists(minCommunityRating?: number, startIndex?: number, limit?: number, searchTerm?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, filters?: string, isFavorite?: boolean, mediaTypes?: string, genres?: string, genreIds?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, studioIds?: string, userId?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, enableImages?: boolean, enableTotalRecordCount?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await ArtistsApiAxiosParamCreator(configuration).getArtists(minCommunityRating, startIndex, limit, searchTerm, parentId, fields, excludeItemTypes, includeItemTypes, filters, isFavorite, mediaTypes, genres, genreIds, officialRatings, tags, years, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, studioIds, userId, nameStartsWithOrGreater, nameStartsWith, nameLessThan, enableImages, enableTotalRecordCount, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ArtistsApi - factory interface
 * @export
 */
export const ArtistsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {number} [minCommunityRating] 
         * @param {number} [startIndex] 
         * @param {number} [limit] 
         * @param {string} [searchTerm] 
         * @param {string} [parentId] 
         * @param {string} [fields] 
         * @param {string} [excludeItemTypes] 
         * @param {string} [includeItemTypes] 
         * @param {string} [filters] 
         * @param {boolean} [isFavorite] 
         * @param {string} [mediaTypes] 
         * @param {string} [genres] 
         * @param {string} [genreIds] 
         * @param {string} [officialRatings] 
         * @param {string} [tags] 
         * @param {string} [years] 
         * @param {boolean} [enableUserData] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {string} [person] 
         * @param {string} [personIds] 
         * @param {string} [personTypes] 
         * @param {string} [studios] 
         * @param {string} [studioIds] 
         * @param {string} [userId] 
         * @param {string} [nameStartsWithOrGreater] 
         * @param {string} [nameStartsWith] 
         * @param {string} [nameLessThan] 
         * @param {boolean} [enableImages] 
         * @param {boolean} [enableTotalRecordCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlbumArtists(minCommunityRating?: number, startIndex?: number, limit?: number, searchTerm?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, filters?: string, isFavorite?: boolean, mediaTypes?: string, genres?: string, genreIds?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, studioIds?: string, userId?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, enableImages?: boolean, enableTotalRecordCount?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return ArtistsApiFp(configuration).getAlbumArtists(minCommunityRating, startIndex, limit, searchTerm, parentId, fields, excludeItemTypes, includeItemTypes, filters, isFavorite, mediaTypes, genres, genreIds, officialRatings, tags, years, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, studioIds, userId, nameStartsWithOrGreater, nameStartsWith, nameLessThan, enableImages, enableTotalRecordCount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} name 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtistByName(name: string, userId?: string, options?: any): AxiosPromise<BaseItemDto> {
            return ArtistsApiFp(configuration).getArtistByName(name, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [minCommunityRating] 
         * @param {number} [startIndex] 
         * @param {number} [limit] 
         * @param {string} [searchTerm] 
         * @param {string} [parentId] 
         * @param {string} [fields] 
         * @param {string} [excludeItemTypes] 
         * @param {string} [includeItemTypes] 
         * @param {string} [filters] 
         * @param {boolean} [isFavorite] 
         * @param {string} [mediaTypes] 
         * @param {string} [genres] 
         * @param {string} [genreIds] 
         * @param {string} [officialRatings] 
         * @param {string} [tags] 
         * @param {string} [years] 
         * @param {boolean} [enableUserData] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {string} [person] 
         * @param {string} [personIds] 
         * @param {string} [personTypes] 
         * @param {string} [studios] 
         * @param {string} [studioIds] 
         * @param {string} [userId] 
         * @param {string} [nameStartsWithOrGreater] 
         * @param {string} [nameStartsWith] 
         * @param {string} [nameLessThan] 
         * @param {boolean} [enableImages] 
         * @param {boolean} [enableTotalRecordCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtists(minCommunityRating?: number, startIndex?: number, limit?: number, searchTerm?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, filters?: string, isFavorite?: boolean, mediaTypes?: string, genres?: string, genreIds?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, studioIds?: string, userId?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, enableImages?: boolean, enableTotalRecordCount?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return ArtistsApiFp(configuration).getArtists(minCommunityRating, startIndex, limit, searchTerm, parentId, fields, excludeItemTypes, includeItemTypes, filters, isFavorite, mediaTypes, genres, genreIds, officialRatings, tags, years, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, studioIds, userId, nameStartsWithOrGreater, nameStartsWith, nameLessThan, enableImages, enableTotalRecordCount, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getAlbumArtists operation in ArtistsApi.
 * @export
 * @interface ArtistsApiGetAlbumArtistsRequest
 */
export interface ArtistsApiGetAlbumArtistsRequest {
    /**
     * 
     * @type {number}
     * @memberof ArtistsApiGetAlbumArtists
     */
    readonly minCommunityRating?: number

    /**
     * 
     * @type {number}
     * @memberof ArtistsApiGetAlbumArtists
     */
    readonly startIndex?: number

    /**
     * 
     * @type {number}
     * @memberof ArtistsApiGetAlbumArtists
     */
    readonly limit?: number

    /**
     * 
     * @type {string}
     * @memberof ArtistsApiGetAlbumArtists
     */
    readonly searchTerm?: string

    /**
     * 
     * @type {string}
     * @memberof ArtistsApiGetAlbumArtists
     */
    readonly parentId?: string

    /**
     * 
     * @type {string}
     * @memberof ArtistsApiGetAlbumArtists
     */
    readonly fields?: string

    /**
     * 
     * @type {string}
     * @memberof ArtistsApiGetAlbumArtists
     */
    readonly excludeItemTypes?: string

    /**
     * 
     * @type {string}
     * @memberof ArtistsApiGetAlbumArtists
     */
    readonly includeItemTypes?: string

    /**
     * 
     * @type {string}
     * @memberof ArtistsApiGetAlbumArtists
     */
    readonly filters?: string

    /**
     * 
     * @type {boolean}
     * @memberof ArtistsApiGetAlbumArtists
     */
    readonly isFavorite?: boolean

    /**
     * 
     * @type {string}
     * @memberof ArtistsApiGetAlbumArtists
     */
    readonly mediaTypes?: string

    /**
     * 
     * @type {string}
     * @memberof ArtistsApiGetAlbumArtists
     */
    readonly genres?: string

    /**
     * 
     * @type {string}
     * @memberof ArtistsApiGetAlbumArtists
     */
    readonly genreIds?: string

    /**
     * 
     * @type {string}
     * @memberof ArtistsApiGetAlbumArtists
     */
    readonly officialRatings?: string

    /**
     * 
     * @type {string}
     * @memberof ArtistsApiGetAlbumArtists
     */
    readonly tags?: string

    /**
     * 
     * @type {string}
     * @memberof ArtistsApiGetAlbumArtists
     */
    readonly years?: string

    /**
     * 
     * @type {boolean}
     * @memberof ArtistsApiGetAlbumArtists
     */
    readonly enableUserData?: boolean

    /**
     * 
     * @type {number}
     * @memberof ArtistsApiGetAlbumArtists
     */
    readonly imageTypeLimit?: number

    /**
     * 
     * @type {string}
     * @memberof ArtistsApiGetAlbumArtists
     */
    readonly enableImageTypes?: string

    /**
     * 
     * @type {string}
     * @memberof ArtistsApiGetAlbumArtists
     */
    readonly person?: string

    /**
     * 
     * @type {string}
     * @memberof ArtistsApiGetAlbumArtists
     */
    readonly personIds?: string

    /**
     * 
     * @type {string}
     * @memberof ArtistsApiGetAlbumArtists
     */
    readonly personTypes?: string

    /**
     * 
     * @type {string}
     * @memberof ArtistsApiGetAlbumArtists
     */
    readonly studios?: string

    /**
     * 
     * @type {string}
     * @memberof ArtistsApiGetAlbumArtists
     */
    readonly studioIds?: string

    /**
     * 
     * @type {string}
     * @memberof ArtistsApiGetAlbumArtists
     */
    readonly userId?: string

    /**
     * 
     * @type {string}
     * @memberof ArtistsApiGetAlbumArtists
     */
    readonly nameStartsWithOrGreater?: string

    /**
     * 
     * @type {string}
     * @memberof ArtistsApiGetAlbumArtists
     */
    readonly nameStartsWith?: string

    /**
     * 
     * @type {string}
     * @memberof ArtistsApiGetAlbumArtists
     */
    readonly nameLessThan?: string

    /**
     * 
     * @type {boolean}
     * @memberof ArtistsApiGetAlbumArtists
     */
    readonly enableImages?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ArtistsApiGetAlbumArtists
     */
    readonly enableTotalRecordCount?: boolean
}

/**
 * Request parameters for getArtistByName operation in ArtistsApi.
 * @export
 * @interface ArtistsApiGetArtistByNameRequest
 */
export interface ArtistsApiGetArtistByNameRequest {
    /**
     * 
     * @type {string}
     * @memberof ArtistsApiGetArtistByName
     */
    readonly name: string

    /**
     * 
     * @type {string}
     * @memberof ArtistsApiGetArtistByName
     */
    readonly userId?: string
}

/**
 * Request parameters for getArtists operation in ArtistsApi.
 * @export
 * @interface ArtistsApiGetArtistsRequest
 */
export interface ArtistsApiGetArtistsRequest {
    /**
     * 
     * @type {number}
     * @memberof ArtistsApiGetArtists
     */
    readonly minCommunityRating?: number

    /**
     * 
     * @type {number}
     * @memberof ArtistsApiGetArtists
     */
    readonly startIndex?: number

    /**
     * 
     * @type {number}
     * @memberof ArtistsApiGetArtists
     */
    readonly limit?: number

    /**
     * 
     * @type {string}
     * @memberof ArtistsApiGetArtists
     */
    readonly searchTerm?: string

    /**
     * 
     * @type {string}
     * @memberof ArtistsApiGetArtists
     */
    readonly parentId?: string

    /**
     * 
     * @type {string}
     * @memberof ArtistsApiGetArtists
     */
    readonly fields?: string

    /**
     * 
     * @type {string}
     * @memberof ArtistsApiGetArtists
     */
    readonly excludeItemTypes?: string

    /**
     * 
     * @type {string}
     * @memberof ArtistsApiGetArtists
     */
    readonly includeItemTypes?: string

    /**
     * 
     * @type {string}
     * @memberof ArtistsApiGetArtists
     */
    readonly filters?: string

    /**
     * 
     * @type {boolean}
     * @memberof ArtistsApiGetArtists
     */
    readonly isFavorite?: boolean

    /**
     * 
     * @type {string}
     * @memberof ArtistsApiGetArtists
     */
    readonly mediaTypes?: string

    /**
     * 
     * @type {string}
     * @memberof ArtistsApiGetArtists
     */
    readonly genres?: string

    /**
     * 
     * @type {string}
     * @memberof ArtistsApiGetArtists
     */
    readonly genreIds?: string

    /**
     * 
     * @type {string}
     * @memberof ArtistsApiGetArtists
     */
    readonly officialRatings?: string

    /**
     * 
     * @type {string}
     * @memberof ArtistsApiGetArtists
     */
    readonly tags?: string

    /**
     * 
     * @type {string}
     * @memberof ArtistsApiGetArtists
     */
    readonly years?: string

    /**
     * 
     * @type {boolean}
     * @memberof ArtistsApiGetArtists
     */
    readonly enableUserData?: boolean

    /**
     * 
     * @type {number}
     * @memberof ArtistsApiGetArtists
     */
    readonly imageTypeLimit?: number

    /**
     * 
     * @type {string}
     * @memberof ArtistsApiGetArtists
     */
    readonly enableImageTypes?: string

    /**
     * 
     * @type {string}
     * @memberof ArtistsApiGetArtists
     */
    readonly person?: string

    /**
     * 
     * @type {string}
     * @memberof ArtistsApiGetArtists
     */
    readonly personIds?: string

    /**
     * 
     * @type {string}
     * @memberof ArtistsApiGetArtists
     */
    readonly personTypes?: string

    /**
     * 
     * @type {string}
     * @memberof ArtistsApiGetArtists
     */
    readonly studios?: string

    /**
     * 
     * @type {string}
     * @memberof ArtistsApiGetArtists
     */
    readonly studioIds?: string

    /**
     * 
     * @type {string}
     * @memberof ArtistsApiGetArtists
     */
    readonly userId?: string

    /**
     * 
     * @type {string}
     * @memberof ArtistsApiGetArtists
     */
    readonly nameStartsWithOrGreater?: string

    /**
     * 
     * @type {string}
     * @memberof ArtistsApiGetArtists
     */
    readonly nameStartsWith?: string

    /**
     * 
     * @type {string}
     * @memberof ArtistsApiGetArtists
     */
    readonly nameLessThan?: string

    /**
     * 
     * @type {boolean}
     * @memberof ArtistsApiGetArtists
     */
    readonly enableImages?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ArtistsApiGetArtists
     */
    readonly enableTotalRecordCount?: boolean
}

/**
 * ArtistsApi - object-oriented interface
 * @export
 * @class ArtistsApi
 * @extends {BaseAPI}
 */
export class ArtistsApi extends BaseAPI {
    /**
     * 
     * @param {ArtistsApiGetAlbumArtistsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtistsApi
     */
    public getAlbumArtists(requestParameters: ArtistsApiGetAlbumArtistsRequest = {}, options?: any) {
        return ArtistsApiFp(this.configuration).getAlbumArtists(requestParameters.minCommunityRating, requestParameters.startIndex, requestParameters.limit, requestParameters.searchTerm, requestParameters.parentId, requestParameters.fields, requestParameters.excludeItemTypes, requestParameters.includeItemTypes, requestParameters.filters, requestParameters.isFavorite, requestParameters.mediaTypes, requestParameters.genres, requestParameters.genreIds, requestParameters.officialRatings, requestParameters.tags, requestParameters.years, requestParameters.enableUserData, requestParameters.imageTypeLimit, requestParameters.enableImageTypes, requestParameters.person, requestParameters.personIds, requestParameters.personTypes, requestParameters.studios, requestParameters.studioIds, requestParameters.userId, requestParameters.nameStartsWithOrGreater, requestParameters.nameStartsWith, requestParameters.nameLessThan, requestParameters.enableImages, requestParameters.enableTotalRecordCount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ArtistsApiGetArtistByNameRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtistsApi
     */
    public getArtistByName(requestParameters: ArtistsApiGetArtistByNameRequest, options?: any) {
        return ArtistsApiFp(this.configuration).getArtistByName(requestParameters.name, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ArtistsApiGetArtistsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtistsApi
     */
    public getArtists(requestParameters: ArtistsApiGetArtistsRequest = {}, options?: any) {
        return ArtistsApiFp(this.configuration).getArtists(requestParameters.minCommunityRating, requestParameters.startIndex, requestParameters.limit, requestParameters.searchTerm, requestParameters.parentId, requestParameters.fields, requestParameters.excludeItemTypes, requestParameters.includeItemTypes, requestParameters.filters, requestParameters.isFavorite, requestParameters.mediaTypes, requestParameters.genres, requestParameters.genreIds, requestParameters.officialRatings, requestParameters.tags, requestParameters.years, requestParameters.enableUserData, requestParameters.imageTypeLimit, requestParameters.enableImageTypes, requestParameters.person, requestParameters.personIds, requestParameters.personTypes, requestParameters.studios, requestParameters.studioIds, requestParameters.userId, requestParameters.nameStartsWithOrGreater, requestParameters.nameStartsWith, requestParameters.nameLessThan, requestParameters.enableImages, requestParameters.enableTotalRecordCount, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AudioApi - axios parameter creator
 * @export
 */
export const AudioApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} itemId 
         * @param {string} container 
         * @param {boolean} [_static] 
         * @param {string} [params] 
         * @param {string} [tag] 
         * @param {string} [deviceProfileId] 
         * @param {string} [playSessionId] 
         * @param {string} [segmentContainer] 
         * @param {number} [segmentLength] 
         * @param {number} [minSegments] 
         * @param {string} [mediaSourceId] 
         * @param {string} [deviceId] 
         * @param {string} [audioCodec] 
         * @param {boolean} [enableAutoStreamCopy] 
         * @param {boolean} [allowVideoStreamCopy] 
         * @param {boolean} [allowAudioStreamCopy] 
         * @param {boolean} [breakOnNonKeyFrames] 
         * @param {number} [audioSampleRate] 
         * @param {number} [maxAudioBitDepth] 
         * @param {number} [audioBitRate] 
         * @param {number} [audioChannels] 
         * @param {number} [maxAudioChannels] 
         * @param {string} [profile] 
         * @param {string} [level] 
         * @param {number} [framerate] 
         * @param {number} [maxFramerate] 
         * @param {boolean} [copyTimestamps] 
         * @param {number} [startTimeTicks] 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [videoBitRate] 
         * @param {number} [subtitleStreamIndex] 
         * @param {SubtitleDeliveryMethod} [subtitleMethod] 
         * @param {number} [maxRefFrames] 
         * @param {number} [maxVideoBitDepth] 
         * @param {boolean} [requireAvc] 
         * @param {boolean} [deInterlace] 
         * @param {boolean} [requireNonAnamorphic] 
         * @param {number} [transcodingMaxAudioChannels] 
         * @param {number} [cpuCoreLimit] 
         * @param {string} [liveStreamId] 
         * @param {boolean} [enableMpegtsM2TsMode] 
         * @param {string} [videoCodec] 
         * @param {string} [subtitleCodec] 
         * @param {string} [transcodingReasons] 
         * @param {number} [audioStreamIndex] 
         * @param {number} [videoStreamIndex] 
         * @param {EncodingContext} [context] 
         * @param {{ [key: string]: string; }} [streamOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAudioStream: async (itemId: string, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getAudioStream.');
            }
            // verify required parameter 'container' is not null or undefined
            if (container === null || container === undefined) {
                throw new RequiredError('container','Required parameter container was null or undefined when calling getAudioStream.');
            }
            const localVarPath = `/Audio/{itemId}/stream`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"container"}}`, encodeURIComponent(String(container)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (_static !== undefined) {
                localVarQueryParameter['static'] = _static;
            }

            if (params !== undefined) {
                localVarQueryParameter['params'] = params;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (deviceProfileId !== undefined) {
                localVarQueryParameter['deviceProfileId'] = deviceProfileId;
            }

            if (playSessionId !== undefined) {
                localVarQueryParameter['playSessionId'] = playSessionId;
            }

            if (segmentContainer !== undefined) {
                localVarQueryParameter['segmentContainer'] = segmentContainer;
            }

            if (segmentLength !== undefined) {
                localVarQueryParameter['segmentLength'] = segmentLength;
            }

            if (minSegments !== undefined) {
                localVarQueryParameter['minSegments'] = minSegments;
            }

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['mediaSourceId'] = mediaSourceId;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (audioCodec !== undefined) {
                localVarQueryParameter['audioCodec'] = audioCodec;
            }

            if (enableAutoStreamCopy !== undefined) {
                localVarQueryParameter['enableAutoStreamCopy'] = enableAutoStreamCopy;
            }

            if (allowVideoStreamCopy !== undefined) {
                localVarQueryParameter['allowVideoStreamCopy'] = allowVideoStreamCopy;
            }

            if (allowAudioStreamCopy !== undefined) {
                localVarQueryParameter['allowAudioStreamCopy'] = allowAudioStreamCopy;
            }

            if (breakOnNonKeyFrames !== undefined) {
                localVarQueryParameter['breakOnNonKeyFrames'] = breakOnNonKeyFrames;
            }

            if (audioSampleRate !== undefined) {
                localVarQueryParameter['audioSampleRate'] = audioSampleRate;
            }

            if (maxAudioBitDepth !== undefined) {
                localVarQueryParameter['maxAudioBitDepth'] = maxAudioBitDepth;
            }

            if (audioBitRate !== undefined) {
                localVarQueryParameter['audioBitRate'] = audioBitRate;
            }

            if (audioChannels !== undefined) {
                localVarQueryParameter['audioChannels'] = audioChannels;
            }

            if (maxAudioChannels !== undefined) {
                localVarQueryParameter['maxAudioChannels'] = maxAudioChannels;
            }

            if (profile !== undefined) {
                localVarQueryParameter['profile'] = profile;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (framerate !== undefined) {
                localVarQueryParameter['framerate'] = framerate;
            }

            if (maxFramerate !== undefined) {
                localVarQueryParameter['maxFramerate'] = maxFramerate;
            }

            if (copyTimestamps !== undefined) {
                localVarQueryParameter['copyTimestamps'] = copyTimestamps;
            }

            if (startTimeTicks !== undefined) {
                localVarQueryParameter['startTimeTicks'] = startTimeTicks;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (videoBitRate !== undefined) {
                localVarQueryParameter['videoBitRate'] = videoBitRate;
            }

            if (subtitleStreamIndex !== undefined) {
                localVarQueryParameter['subtitleStreamIndex'] = subtitleStreamIndex;
            }

            if (subtitleMethod !== undefined) {
                localVarQueryParameter['subtitleMethod'] = subtitleMethod;
            }

            if (maxRefFrames !== undefined) {
                localVarQueryParameter['maxRefFrames'] = maxRefFrames;
            }

            if (maxVideoBitDepth !== undefined) {
                localVarQueryParameter['maxVideoBitDepth'] = maxVideoBitDepth;
            }

            if (requireAvc !== undefined) {
                localVarQueryParameter['requireAvc'] = requireAvc;
            }

            if (deInterlace !== undefined) {
                localVarQueryParameter['deInterlace'] = deInterlace;
            }

            if (requireNonAnamorphic !== undefined) {
                localVarQueryParameter['requireNonAnamorphic'] = requireNonAnamorphic;
            }

            if (transcodingMaxAudioChannels !== undefined) {
                localVarQueryParameter['transcodingMaxAudioChannels'] = transcodingMaxAudioChannels;
            }

            if (cpuCoreLimit !== undefined) {
                localVarQueryParameter['cpuCoreLimit'] = cpuCoreLimit;
            }

            if (liveStreamId !== undefined) {
                localVarQueryParameter['liveStreamId'] = liveStreamId;
            }

            if (enableMpegtsM2TsMode !== undefined) {
                localVarQueryParameter['enableMpegtsM2TsMode'] = enableMpegtsM2TsMode;
            }

            if (videoCodec !== undefined) {
                localVarQueryParameter['videoCodec'] = videoCodec;
            }

            if (subtitleCodec !== undefined) {
                localVarQueryParameter['subtitleCodec'] = subtitleCodec;
            }

            if (transcodingReasons !== undefined) {
                localVarQueryParameter['transcodingReasons'] = transcodingReasons;
            }

            if (audioStreamIndex !== undefined) {
                localVarQueryParameter['audioStreamIndex'] = audioStreamIndex;
            }

            if (videoStreamIndex !== undefined) {
                localVarQueryParameter['videoStreamIndex'] = videoStreamIndex;
            }

            if (context !== undefined) {
                localVarQueryParameter['context'] = context;
            }

            if (streamOptions !== undefined) {
                localVarQueryParameter['streamOptions'] = streamOptions;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} container 
         * @param {boolean} [_static] 
         * @param {string} [params] 
         * @param {string} [tag] 
         * @param {string} [deviceProfileId] 
         * @param {string} [playSessionId] 
         * @param {string} [segmentContainer] 
         * @param {number} [segmentLength] 
         * @param {number} [minSegments] 
         * @param {string} [mediaSourceId] 
         * @param {string} [deviceId] 
         * @param {string} [audioCodec] 
         * @param {boolean} [enableAutoStreamCopy] 
         * @param {boolean} [allowVideoStreamCopy] 
         * @param {boolean} [allowAudioStreamCopy] 
         * @param {boolean} [breakOnNonKeyFrames] 
         * @param {number} [audioSampleRate] 
         * @param {number} [maxAudioBitDepth] 
         * @param {number} [audioBitRate] 
         * @param {number} [audioChannels] 
         * @param {number} [maxAudioChannels] 
         * @param {string} [profile] 
         * @param {string} [level] 
         * @param {number} [framerate] 
         * @param {number} [maxFramerate] 
         * @param {boolean} [copyTimestamps] 
         * @param {number} [startTimeTicks] 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [videoBitRate] 
         * @param {number} [subtitleStreamIndex] 
         * @param {SubtitleDeliveryMethod} [subtitleMethod] 
         * @param {number} [maxRefFrames] 
         * @param {number} [maxVideoBitDepth] 
         * @param {boolean} [requireAvc] 
         * @param {boolean} [deInterlace] 
         * @param {boolean} [requireNonAnamorphic] 
         * @param {number} [transcodingMaxAudioChannels] 
         * @param {number} [cpuCoreLimit] 
         * @param {string} [liveStreamId] 
         * @param {boolean} [enableMpegtsM2TsMode] 
         * @param {string} [videoCodec] 
         * @param {string} [subtitleCodec] 
         * @param {string} [transcodingReasons] 
         * @param {number} [audioStreamIndex] 
         * @param {number} [videoStreamIndex] 
         * @param {EncodingContext} [context] 
         * @param {{ [key: string]: string; }} [streamOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAudioStreamByContainer: async (itemId: string, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getAudioStreamByContainer.');
            }
            // verify required parameter 'container' is not null or undefined
            if (container === null || container === undefined) {
                throw new RequiredError('container','Required parameter container was null or undefined when calling getAudioStreamByContainer.');
            }
            const localVarPath = `/Audio/{itemId}/stream.{container}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"container"}}`, encodeURIComponent(String(container)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (_static !== undefined) {
                localVarQueryParameter['static'] = _static;
            }

            if (params !== undefined) {
                localVarQueryParameter['params'] = params;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (deviceProfileId !== undefined) {
                localVarQueryParameter['deviceProfileId'] = deviceProfileId;
            }

            if (playSessionId !== undefined) {
                localVarQueryParameter['playSessionId'] = playSessionId;
            }

            if (segmentContainer !== undefined) {
                localVarQueryParameter['segmentContainer'] = segmentContainer;
            }

            if (segmentLength !== undefined) {
                localVarQueryParameter['segmentLength'] = segmentLength;
            }

            if (minSegments !== undefined) {
                localVarQueryParameter['minSegments'] = minSegments;
            }

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['mediaSourceId'] = mediaSourceId;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (audioCodec !== undefined) {
                localVarQueryParameter['audioCodec'] = audioCodec;
            }

            if (enableAutoStreamCopy !== undefined) {
                localVarQueryParameter['enableAutoStreamCopy'] = enableAutoStreamCopy;
            }

            if (allowVideoStreamCopy !== undefined) {
                localVarQueryParameter['allowVideoStreamCopy'] = allowVideoStreamCopy;
            }

            if (allowAudioStreamCopy !== undefined) {
                localVarQueryParameter['allowAudioStreamCopy'] = allowAudioStreamCopy;
            }

            if (breakOnNonKeyFrames !== undefined) {
                localVarQueryParameter['breakOnNonKeyFrames'] = breakOnNonKeyFrames;
            }

            if (audioSampleRate !== undefined) {
                localVarQueryParameter['audioSampleRate'] = audioSampleRate;
            }

            if (maxAudioBitDepth !== undefined) {
                localVarQueryParameter['maxAudioBitDepth'] = maxAudioBitDepth;
            }

            if (audioBitRate !== undefined) {
                localVarQueryParameter['audioBitRate'] = audioBitRate;
            }

            if (audioChannels !== undefined) {
                localVarQueryParameter['audioChannels'] = audioChannels;
            }

            if (maxAudioChannels !== undefined) {
                localVarQueryParameter['maxAudioChannels'] = maxAudioChannels;
            }

            if (profile !== undefined) {
                localVarQueryParameter['profile'] = profile;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (framerate !== undefined) {
                localVarQueryParameter['framerate'] = framerate;
            }

            if (maxFramerate !== undefined) {
                localVarQueryParameter['maxFramerate'] = maxFramerate;
            }

            if (copyTimestamps !== undefined) {
                localVarQueryParameter['copyTimestamps'] = copyTimestamps;
            }

            if (startTimeTicks !== undefined) {
                localVarQueryParameter['startTimeTicks'] = startTimeTicks;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (videoBitRate !== undefined) {
                localVarQueryParameter['videoBitRate'] = videoBitRate;
            }

            if (subtitleStreamIndex !== undefined) {
                localVarQueryParameter['subtitleStreamIndex'] = subtitleStreamIndex;
            }

            if (subtitleMethod !== undefined) {
                localVarQueryParameter['subtitleMethod'] = subtitleMethod;
            }

            if (maxRefFrames !== undefined) {
                localVarQueryParameter['maxRefFrames'] = maxRefFrames;
            }

            if (maxVideoBitDepth !== undefined) {
                localVarQueryParameter['maxVideoBitDepth'] = maxVideoBitDepth;
            }

            if (requireAvc !== undefined) {
                localVarQueryParameter['requireAvc'] = requireAvc;
            }

            if (deInterlace !== undefined) {
                localVarQueryParameter['deInterlace'] = deInterlace;
            }

            if (requireNonAnamorphic !== undefined) {
                localVarQueryParameter['requireNonAnamorphic'] = requireNonAnamorphic;
            }

            if (transcodingMaxAudioChannels !== undefined) {
                localVarQueryParameter['transcodingMaxAudioChannels'] = transcodingMaxAudioChannels;
            }

            if (cpuCoreLimit !== undefined) {
                localVarQueryParameter['cpuCoreLimit'] = cpuCoreLimit;
            }

            if (liveStreamId !== undefined) {
                localVarQueryParameter['liveStreamId'] = liveStreamId;
            }

            if (enableMpegtsM2TsMode !== undefined) {
                localVarQueryParameter['enableMpegtsM2TsMode'] = enableMpegtsM2TsMode;
            }

            if (videoCodec !== undefined) {
                localVarQueryParameter['videoCodec'] = videoCodec;
            }

            if (subtitleCodec !== undefined) {
                localVarQueryParameter['subtitleCodec'] = subtitleCodec;
            }

            if (transcodingReasons !== undefined) {
                localVarQueryParameter['transcodingReasons'] = transcodingReasons;
            }

            if (audioStreamIndex !== undefined) {
                localVarQueryParameter['audioStreamIndex'] = audioStreamIndex;
            }

            if (videoStreamIndex !== undefined) {
                localVarQueryParameter['videoStreamIndex'] = videoStreamIndex;
            }

            if (context !== undefined) {
                localVarQueryParameter['context'] = context;
            }

            if (streamOptions !== undefined) {
                localVarQueryParameter['streamOptions'] = streamOptions;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} container 
         * @param {boolean} [_static] 
         * @param {string} [params] 
         * @param {string} [tag] 
         * @param {string} [deviceProfileId] 
         * @param {string} [playSessionId] 
         * @param {string} [segmentContainer] 
         * @param {number} [segmentLength] 
         * @param {number} [minSegments] 
         * @param {string} [mediaSourceId] 
         * @param {string} [deviceId] 
         * @param {string} [audioCodec] 
         * @param {boolean} [enableAutoStreamCopy] 
         * @param {boolean} [allowVideoStreamCopy] 
         * @param {boolean} [allowAudioStreamCopy] 
         * @param {boolean} [breakOnNonKeyFrames] 
         * @param {number} [audioSampleRate] 
         * @param {number} [maxAudioBitDepth] 
         * @param {number} [audioBitRate] 
         * @param {number} [audioChannels] 
         * @param {number} [maxAudioChannels] 
         * @param {string} [profile] 
         * @param {string} [level] 
         * @param {number} [framerate] 
         * @param {number} [maxFramerate] 
         * @param {boolean} [copyTimestamps] 
         * @param {number} [startTimeTicks] 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [videoBitRate] 
         * @param {number} [subtitleStreamIndex] 
         * @param {SubtitleDeliveryMethod} [subtitleMethod] 
         * @param {number} [maxRefFrames] 
         * @param {number} [maxVideoBitDepth] 
         * @param {boolean} [requireAvc] 
         * @param {boolean} [deInterlace] 
         * @param {boolean} [requireNonAnamorphic] 
         * @param {number} [transcodingMaxAudioChannels] 
         * @param {number} [cpuCoreLimit] 
         * @param {string} [liveStreamId] 
         * @param {boolean} [enableMpegtsM2TsMode] 
         * @param {string} [videoCodec] 
         * @param {string} [subtitleCodec] 
         * @param {string} [transcodingReasons] 
         * @param {number} [audioStreamIndex] 
         * @param {number} [videoStreamIndex] 
         * @param {EncodingContext} [context] 
         * @param {{ [key: string]: string; }} [streamOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headAudioStream: async (itemId: string, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling headAudioStream.');
            }
            // verify required parameter 'container' is not null or undefined
            if (container === null || container === undefined) {
                throw new RequiredError('container','Required parameter container was null or undefined when calling headAudioStream.');
            }
            const localVarPath = `/Audio/{itemId}/stream`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"container"}}`, encodeURIComponent(String(container)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (_static !== undefined) {
                localVarQueryParameter['static'] = _static;
            }

            if (params !== undefined) {
                localVarQueryParameter['params'] = params;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (deviceProfileId !== undefined) {
                localVarQueryParameter['deviceProfileId'] = deviceProfileId;
            }

            if (playSessionId !== undefined) {
                localVarQueryParameter['playSessionId'] = playSessionId;
            }

            if (segmentContainer !== undefined) {
                localVarQueryParameter['segmentContainer'] = segmentContainer;
            }

            if (segmentLength !== undefined) {
                localVarQueryParameter['segmentLength'] = segmentLength;
            }

            if (minSegments !== undefined) {
                localVarQueryParameter['minSegments'] = minSegments;
            }

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['mediaSourceId'] = mediaSourceId;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (audioCodec !== undefined) {
                localVarQueryParameter['audioCodec'] = audioCodec;
            }

            if (enableAutoStreamCopy !== undefined) {
                localVarQueryParameter['enableAutoStreamCopy'] = enableAutoStreamCopy;
            }

            if (allowVideoStreamCopy !== undefined) {
                localVarQueryParameter['allowVideoStreamCopy'] = allowVideoStreamCopy;
            }

            if (allowAudioStreamCopy !== undefined) {
                localVarQueryParameter['allowAudioStreamCopy'] = allowAudioStreamCopy;
            }

            if (breakOnNonKeyFrames !== undefined) {
                localVarQueryParameter['breakOnNonKeyFrames'] = breakOnNonKeyFrames;
            }

            if (audioSampleRate !== undefined) {
                localVarQueryParameter['audioSampleRate'] = audioSampleRate;
            }

            if (maxAudioBitDepth !== undefined) {
                localVarQueryParameter['maxAudioBitDepth'] = maxAudioBitDepth;
            }

            if (audioBitRate !== undefined) {
                localVarQueryParameter['audioBitRate'] = audioBitRate;
            }

            if (audioChannels !== undefined) {
                localVarQueryParameter['audioChannels'] = audioChannels;
            }

            if (maxAudioChannels !== undefined) {
                localVarQueryParameter['maxAudioChannels'] = maxAudioChannels;
            }

            if (profile !== undefined) {
                localVarQueryParameter['profile'] = profile;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (framerate !== undefined) {
                localVarQueryParameter['framerate'] = framerate;
            }

            if (maxFramerate !== undefined) {
                localVarQueryParameter['maxFramerate'] = maxFramerate;
            }

            if (copyTimestamps !== undefined) {
                localVarQueryParameter['copyTimestamps'] = copyTimestamps;
            }

            if (startTimeTicks !== undefined) {
                localVarQueryParameter['startTimeTicks'] = startTimeTicks;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (videoBitRate !== undefined) {
                localVarQueryParameter['videoBitRate'] = videoBitRate;
            }

            if (subtitleStreamIndex !== undefined) {
                localVarQueryParameter['subtitleStreamIndex'] = subtitleStreamIndex;
            }

            if (subtitleMethod !== undefined) {
                localVarQueryParameter['subtitleMethod'] = subtitleMethod;
            }

            if (maxRefFrames !== undefined) {
                localVarQueryParameter['maxRefFrames'] = maxRefFrames;
            }

            if (maxVideoBitDepth !== undefined) {
                localVarQueryParameter['maxVideoBitDepth'] = maxVideoBitDepth;
            }

            if (requireAvc !== undefined) {
                localVarQueryParameter['requireAvc'] = requireAvc;
            }

            if (deInterlace !== undefined) {
                localVarQueryParameter['deInterlace'] = deInterlace;
            }

            if (requireNonAnamorphic !== undefined) {
                localVarQueryParameter['requireNonAnamorphic'] = requireNonAnamorphic;
            }

            if (transcodingMaxAudioChannels !== undefined) {
                localVarQueryParameter['transcodingMaxAudioChannels'] = transcodingMaxAudioChannels;
            }

            if (cpuCoreLimit !== undefined) {
                localVarQueryParameter['cpuCoreLimit'] = cpuCoreLimit;
            }

            if (liveStreamId !== undefined) {
                localVarQueryParameter['liveStreamId'] = liveStreamId;
            }

            if (enableMpegtsM2TsMode !== undefined) {
                localVarQueryParameter['enableMpegtsM2TsMode'] = enableMpegtsM2TsMode;
            }

            if (videoCodec !== undefined) {
                localVarQueryParameter['videoCodec'] = videoCodec;
            }

            if (subtitleCodec !== undefined) {
                localVarQueryParameter['subtitleCodec'] = subtitleCodec;
            }

            if (transcodingReasons !== undefined) {
                localVarQueryParameter['transcodingReasons'] = transcodingReasons;
            }

            if (audioStreamIndex !== undefined) {
                localVarQueryParameter['audioStreamIndex'] = audioStreamIndex;
            }

            if (videoStreamIndex !== undefined) {
                localVarQueryParameter['videoStreamIndex'] = videoStreamIndex;
            }

            if (context !== undefined) {
                localVarQueryParameter['context'] = context;
            }

            if (streamOptions !== undefined) {
                localVarQueryParameter['streamOptions'] = streamOptions;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} container 
         * @param {boolean} [_static] 
         * @param {string} [params] 
         * @param {string} [tag] 
         * @param {string} [deviceProfileId] 
         * @param {string} [playSessionId] 
         * @param {string} [segmentContainer] 
         * @param {number} [segmentLength] 
         * @param {number} [minSegments] 
         * @param {string} [mediaSourceId] 
         * @param {string} [deviceId] 
         * @param {string} [audioCodec] 
         * @param {boolean} [enableAutoStreamCopy] 
         * @param {boolean} [allowVideoStreamCopy] 
         * @param {boolean} [allowAudioStreamCopy] 
         * @param {boolean} [breakOnNonKeyFrames] 
         * @param {number} [audioSampleRate] 
         * @param {number} [maxAudioBitDepth] 
         * @param {number} [audioBitRate] 
         * @param {number} [audioChannels] 
         * @param {number} [maxAudioChannels] 
         * @param {string} [profile] 
         * @param {string} [level] 
         * @param {number} [framerate] 
         * @param {number} [maxFramerate] 
         * @param {boolean} [copyTimestamps] 
         * @param {number} [startTimeTicks] 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [videoBitRate] 
         * @param {number} [subtitleStreamIndex] 
         * @param {SubtitleDeliveryMethod} [subtitleMethod] 
         * @param {number} [maxRefFrames] 
         * @param {number} [maxVideoBitDepth] 
         * @param {boolean} [requireAvc] 
         * @param {boolean} [deInterlace] 
         * @param {boolean} [requireNonAnamorphic] 
         * @param {number} [transcodingMaxAudioChannels] 
         * @param {number} [cpuCoreLimit] 
         * @param {string} [liveStreamId] 
         * @param {boolean} [enableMpegtsM2TsMode] 
         * @param {string} [videoCodec] 
         * @param {string} [subtitleCodec] 
         * @param {string} [transcodingReasons] 
         * @param {number} [audioStreamIndex] 
         * @param {number} [videoStreamIndex] 
         * @param {EncodingContext} [context] 
         * @param {{ [key: string]: string; }} [streamOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headAudioStreamByContainer: async (itemId: string, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling headAudioStreamByContainer.');
            }
            // verify required parameter 'container' is not null or undefined
            if (container === null || container === undefined) {
                throw new RequiredError('container','Required parameter container was null or undefined when calling headAudioStreamByContainer.');
            }
            const localVarPath = `/Audio/{itemId}/stream.{container}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"container"}}`, encodeURIComponent(String(container)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (_static !== undefined) {
                localVarQueryParameter['static'] = _static;
            }

            if (params !== undefined) {
                localVarQueryParameter['params'] = params;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (deviceProfileId !== undefined) {
                localVarQueryParameter['deviceProfileId'] = deviceProfileId;
            }

            if (playSessionId !== undefined) {
                localVarQueryParameter['playSessionId'] = playSessionId;
            }

            if (segmentContainer !== undefined) {
                localVarQueryParameter['segmentContainer'] = segmentContainer;
            }

            if (segmentLength !== undefined) {
                localVarQueryParameter['segmentLength'] = segmentLength;
            }

            if (minSegments !== undefined) {
                localVarQueryParameter['minSegments'] = minSegments;
            }

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['mediaSourceId'] = mediaSourceId;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (audioCodec !== undefined) {
                localVarQueryParameter['audioCodec'] = audioCodec;
            }

            if (enableAutoStreamCopy !== undefined) {
                localVarQueryParameter['enableAutoStreamCopy'] = enableAutoStreamCopy;
            }

            if (allowVideoStreamCopy !== undefined) {
                localVarQueryParameter['allowVideoStreamCopy'] = allowVideoStreamCopy;
            }

            if (allowAudioStreamCopy !== undefined) {
                localVarQueryParameter['allowAudioStreamCopy'] = allowAudioStreamCopy;
            }

            if (breakOnNonKeyFrames !== undefined) {
                localVarQueryParameter['breakOnNonKeyFrames'] = breakOnNonKeyFrames;
            }

            if (audioSampleRate !== undefined) {
                localVarQueryParameter['audioSampleRate'] = audioSampleRate;
            }

            if (maxAudioBitDepth !== undefined) {
                localVarQueryParameter['maxAudioBitDepth'] = maxAudioBitDepth;
            }

            if (audioBitRate !== undefined) {
                localVarQueryParameter['audioBitRate'] = audioBitRate;
            }

            if (audioChannels !== undefined) {
                localVarQueryParameter['audioChannels'] = audioChannels;
            }

            if (maxAudioChannels !== undefined) {
                localVarQueryParameter['maxAudioChannels'] = maxAudioChannels;
            }

            if (profile !== undefined) {
                localVarQueryParameter['profile'] = profile;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (framerate !== undefined) {
                localVarQueryParameter['framerate'] = framerate;
            }

            if (maxFramerate !== undefined) {
                localVarQueryParameter['maxFramerate'] = maxFramerate;
            }

            if (copyTimestamps !== undefined) {
                localVarQueryParameter['copyTimestamps'] = copyTimestamps;
            }

            if (startTimeTicks !== undefined) {
                localVarQueryParameter['startTimeTicks'] = startTimeTicks;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (videoBitRate !== undefined) {
                localVarQueryParameter['videoBitRate'] = videoBitRate;
            }

            if (subtitleStreamIndex !== undefined) {
                localVarQueryParameter['subtitleStreamIndex'] = subtitleStreamIndex;
            }

            if (subtitleMethod !== undefined) {
                localVarQueryParameter['subtitleMethod'] = subtitleMethod;
            }

            if (maxRefFrames !== undefined) {
                localVarQueryParameter['maxRefFrames'] = maxRefFrames;
            }

            if (maxVideoBitDepth !== undefined) {
                localVarQueryParameter['maxVideoBitDepth'] = maxVideoBitDepth;
            }

            if (requireAvc !== undefined) {
                localVarQueryParameter['requireAvc'] = requireAvc;
            }

            if (deInterlace !== undefined) {
                localVarQueryParameter['deInterlace'] = deInterlace;
            }

            if (requireNonAnamorphic !== undefined) {
                localVarQueryParameter['requireNonAnamorphic'] = requireNonAnamorphic;
            }

            if (transcodingMaxAudioChannels !== undefined) {
                localVarQueryParameter['transcodingMaxAudioChannels'] = transcodingMaxAudioChannels;
            }

            if (cpuCoreLimit !== undefined) {
                localVarQueryParameter['cpuCoreLimit'] = cpuCoreLimit;
            }

            if (liveStreamId !== undefined) {
                localVarQueryParameter['liveStreamId'] = liveStreamId;
            }

            if (enableMpegtsM2TsMode !== undefined) {
                localVarQueryParameter['enableMpegtsM2TsMode'] = enableMpegtsM2TsMode;
            }

            if (videoCodec !== undefined) {
                localVarQueryParameter['videoCodec'] = videoCodec;
            }

            if (subtitleCodec !== undefined) {
                localVarQueryParameter['subtitleCodec'] = subtitleCodec;
            }

            if (transcodingReasons !== undefined) {
                localVarQueryParameter['transcodingReasons'] = transcodingReasons;
            }

            if (audioStreamIndex !== undefined) {
                localVarQueryParameter['audioStreamIndex'] = audioStreamIndex;
            }

            if (videoStreamIndex !== undefined) {
                localVarQueryParameter['videoStreamIndex'] = videoStreamIndex;
            }

            if (context !== undefined) {
                localVarQueryParameter['context'] = context;
            }

            if (streamOptions !== undefined) {
                localVarQueryParameter['streamOptions'] = streamOptions;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AudioApi - functional programming interface
 * @export
 */
export const AudioApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} itemId 
         * @param {string} container 
         * @param {boolean} [_static] 
         * @param {string} [params] 
         * @param {string} [tag] 
         * @param {string} [deviceProfileId] 
         * @param {string} [playSessionId] 
         * @param {string} [segmentContainer] 
         * @param {number} [segmentLength] 
         * @param {number} [minSegments] 
         * @param {string} [mediaSourceId] 
         * @param {string} [deviceId] 
         * @param {string} [audioCodec] 
         * @param {boolean} [enableAutoStreamCopy] 
         * @param {boolean} [allowVideoStreamCopy] 
         * @param {boolean} [allowAudioStreamCopy] 
         * @param {boolean} [breakOnNonKeyFrames] 
         * @param {number} [audioSampleRate] 
         * @param {number} [maxAudioBitDepth] 
         * @param {number} [audioBitRate] 
         * @param {number} [audioChannels] 
         * @param {number} [maxAudioChannels] 
         * @param {string} [profile] 
         * @param {string} [level] 
         * @param {number} [framerate] 
         * @param {number} [maxFramerate] 
         * @param {boolean} [copyTimestamps] 
         * @param {number} [startTimeTicks] 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [videoBitRate] 
         * @param {number} [subtitleStreamIndex] 
         * @param {SubtitleDeliveryMethod} [subtitleMethod] 
         * @param {number} [maxRefFrames] 
         * @param {number} [maxVideoBitDepth] 
         * @param {boolean} [requireAvc] 
         * @param {boolean} [deInterlace] 
         * @param {boolean} [requireNonAnamorphic] 
         * @param {number} [transcodingMaxAudioChannels] 
         * @param {number} [cpuCoreLimit] 
         * @param {string} [liveStreamId] 
         * @param {boolean} [enableMpegtsM2TsMode] 
         * @param {string} [videoCodec] 
         * @param {string} [subtitleCodec] 
         * @param {string} [transcodingReasons] 
         * @param {number} [audioStreamIndex] 
         * @param {number} [videoStreamIndex] 
         * @param {EncodingContext} [context] 
         * @param {{ [key: string]: string; }} [streamOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAudioStream(itemId: string, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AudioApiAxiosParamCreator(configuration).getAudioStream(itemId, container, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} container 
         * @param {boolean} [_static] 
         * @param {string} [params] 
         * @param {string} [tag] 
         * @param {string} [deviceProfileId] 
         * @param {string} [playSessionId] 
         * @param {string} [segmentContainer] 
         * @param {number} [segmentLength] 
         * @param {number} [minSegments] 
         * @param {string} [mediaSourceId] 
         * @param {string} [deviceId] 
         * @param {string} [audioCodec] 
         * @param {boolean} [enableAutoStreamCopy] 
         * @param {boolean} [allowVideoStreamCopy] 
         * @param {boolean} [allowAudioStreamCopy] 
         * @param {boolean} [breakOnNonKeyFrames] 
         * @param {number} [audioSampleRate] 
         * @param {number} [maxAudioBitDepth] 
         * @param {number} [audioBitRate] 
         * @param {number} [audioChannels] 
         * @param {number} [maxAudioChannels] 
         * @param {string} [profile] 
         * @param {string} [level] 
         * @param {number} [framerate] 
         * @param {number} [maxFramerate] 
         * @param {boolean} [copyTimestamps] 
         * @param {number} [startTimeTicks] 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [videoBitRate] 
         * @param {number} [subtitleStreamIndex] 
         * @param {SubtitleDeliveryMethod} [subtitleMethod] 
         * @param {number} [maxRefFrames] 
         * @param {number} [maxVideoBitDepth] 
         * @param {boolean} [requireAvc] 
         * @param {boolean} [deInterlace] 
         * @param {boolean} [requireNonAnamorphic] 
         * @param {number} [transcodingMaxAudioChannels] 
         * @param {number} [cpuCoreLimit] 
         * @param {string} [liveStreamId] 
         * @param {boolean} [enableMpegtsM2TsMode] 
         * @param {string} [videoCodec] 
         * @param {string} [subtitleCodec] 
         * @param {string} [transcodingReasons] 
         * @param {number} [audioStreamIndex] 
         * @param {number} [videoStreamIndex] 
         * @param {EncodingContext} [context] 
         * @param {{ [key: string]: string; }} [streamOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAudioStreamByContainer(itemId: string, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AudioApiAxiosParamCreator(configuration).getAudioStreamByContainer(itemId, container, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} container 
         * @param {boolean} [_static] 
         * @param {string} [params] 
         * @param {string} [tag] 
         * @param {string} [deviceProfileId] 
         * @param {string} [playSessionId] 
         * @param {string} [segmentContainer] 
         * @param {number} [segmentLength] 
         * @param {number} [minSegments] 
         * @param {string} [mediaSourceId] 
         * @param {string} [deviceId] 
         * @param {string} [audioCodec] 
         * @param {boolean} [enableAutoStreamCopy] 
         * @param {boolean} [allowVideoStreamCopy] 
         * @param {boolean} [allowAudioStreamCopy] 
         * @param {boolean} [breakOnNonKeyFrames] 
         * @param {number} [audioSampleRate] 
         * @param {number} [maxAudioBitDepth] 
         * @param {number} [audioBitRate] 
         * @param {number} [audioChannels] 
         * @param {number} [maxAudioChannels] 
         * @param {string} [profile] 
         * @param {string} [level] 
         * @param {number} [framerate] 
         * @param {number} [maxFramerate] 
         * @param {boolean} [copyTimestamps] 
         * @param {number} [startTimeTicks] 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [videoBitRate] 
         * @param {number} [subtitleStreamIndex] 
         * @param {SubtitleDeliveryMethod} [subtitleMethod] 
         * @param {number} [maxRefFrames] 
         * @param {number} [maxVideoBitDepth] 
         * @param {boolean} [requireAvc] 
         * @param {boolean} [deInterlace] 
         * @param {boolean} [requireNonAnamorphic] 
         * @param {number} [transcodingMaxAudioChannels] 
         * @param {number} [cpuCoreLimit] 
         * @param {string} [liveStreamId] 
         * @param {boolean} [enableMpegtsM2TsMode] 
         * @param {string} [videoCodec] 
         * @param {string} [subtitleCodec] 
         * @param {string} [transcodingReasons] 
         * @param {number} [audioStreamIndex] 
         * @param {number} [videoStreamIndex] 
         * @param {EncodingContext} [context] 
         * @param {{ [key: string]: string; }} [streamOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headAudioStream(itemId: string, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AudioApiAxiosParamCreator(configuration).headAudioStream(itemId, container, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} container 
         * @param {boolean} [_static] 
         * @param {string} [params] 
         * @param {string} [tag] 
         * @param {string} [deviceProfileId] 
         * @param {string} [playSessionId] 
         * @param {string} [segmentContainer] 
         * @param {number} [segmentLength] 
         * @param {number} [minSegments] 
         * @param {string} [mediaSourceId] 
         * @param {string} [deviceId] 
         * @param {string} [audioCodec] 
         * @param {boolean} [enableAutoStreamCopy] 
         * @param {boolean} [allowVideoStreamCopy] 
         * @param {boolean} [allowAudioStreamCopy] 
         * @param {boolean} [breakOnNonKeyFrames] 
         * @param {number} [audioSampleRate] 
         * @param {number} [maxAudioBitDepth] 
         * @param {number} [audioBitRate] 
         * @param {number} [audioChannels] 
         * @param {number} [maxAudioChannels] 
         * @param {string} [profile] 
         * @param {string} [level] 
         * @param {number} [framerate] 
         * @param {number} [maxFramerate] 
         * @param {boolean} [copyTimestamps] 
         * @param {number} [startTimeTicks] 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [videoBitRate] 
         * @param {number} [subtitleStreamIndex] 
         * @param {SubtitleDeliveryMethod} [subtitleMethod] 
         * @param {number} [maxRefFrames] 
         * @param {number} [maxVideoBitDepth] 
         * @param {boolean} [requireAvc] 
         * @param {boolean} [deInterlace] 
         * @param {boolean} [requireNonAnamorphic] 
         * @param {number} [transcodingMaxAudioChannels] 
         * @param {number} [cpuCoreLimit] 
         * @param {string} [liveStreamId] 
         * @param {boolean} [enableMpegtsM2TsMode] 
         * @param {string} [videoCodec] 
         * @param {string} [subtitleCodec] 
         * @param {string} [transcodingReasons] 
         * @param {number} [audioStreamIndex] 
         * @param {number} [videoStreamIndex] 
         * @param {EncodingContext} [context] 
         * @param {{ [key: string]: string; }} [streamOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headAudioStreamByContainer(itemId: string, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AudioApiAxiosParamCreator(configuration).headAudioStreamByContainer(itemId, container, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AudioApi - factory interface
 * @export
 */
export const AudioApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} itemId 
         * @param {string} container 
         * @param {boolean} [_static] 
         * @param {string} [params] 
         * @param {string} [tag] 
         * @param {string} [deviceProfileId] 
         * @param {string} [playSessionId] 
         * @param {string} [segmentContainer] 
         * @param {number} [segmentLength] 
         * @param {number} [minSegments] 
         * @param {string} [mediaSourceId] 
         * @param {string} [deviceId] 
         * @param {string} [audioCodec] 
         * @param {boolean} [enableAutoStreamCopy] 
         * @param {boolean} [allowVideoStreamCopy] 
         * @param {boolean} [allowAudioStreamCopy] 
         * @param {boolean} [breakOnNonKeyFrames] 
         * @param {number} [audioSampleRate] 
         * @param {number} [maxAudioBitDepth] 
         * @param {number} [audioBitRate] 
         * @param {number} [audioChannels] 
         * @param {number} [maxAudioChannels] 
         * @param {string} [profile] 
         * @param {string} [level] 
         * @param {number} [framerate] 
         * @param {number} [maxFramerate] 
         * @param {boolean} [copyTimestamps] 
         * @param {number} [startTimeTicks] 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [videoBitRate] 
         * @param {number} [subtitleStreamIndex] 
         * @param {SubtitleDeliveryMethod} [subtitleMethod] 
         * @param {number} [maxRefFrames] 
         * @param {number} [maxVideoBitDepth] 
         * @param {boolean} [requireAvc] 
         * @param {boolean} [deInterlace] 
         * @param {boolean} [requireNonAnamorphic] 
         * @param {number} [transcodingMaxAudioChannels] 
         * @param {number} [cpuCoreLimit] 
         * @param {string} [liveStreamId] 
         * @param {boolean} [enableMpegtsM2TsMode] 
         * @param {string} [videoCodec] 
         * @param {string} [subtitleCodec] 
         * @param {string} [transcodingReasons] 
         * @param {number} [audioStreamIndex] 
         * @param {number} [videoStreamIndex] 
         * @param {EncodingContext} [context] 
         * @param {{ [key: string]: string; }} [streamOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAudioStream(itemId: string, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any): AxiosPromise<void> {
            return AudioApiFp(configuration).getAudioStream(itemId, container, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} container 
         * @param {boolean} [_static] 
         * @param {string} [params] 
         * @param {string} [tag] 
         * @param {string} [deviceProfileId] 
         * @param {string} [playSessionId] 
         * @param {string} [segmentContainer] 
         * @param {number} [segmentLength] 
         * @param {number} [minSegments] 
         * @param {string} [mediaSourceId] 
         * @param {string} [deviceId] 
         * @param {string} [audioCodec] 
         * @param {boolean} [enableAutoStreamCopy] 
         * @param {boolean} [allowVideoStreamCopy] 
         * @param {boolean} [allowAudioStreamCopy] 
         * @param {boolean} [breakOnNonKeyFrames] 
         * @param {number} [audioSampleRate] 
         * @param {number} [maxAudioBitDepth] 
         * @param {number} [audioBitRate] 
         * @param {number} [audioChannels] 
         * @param {number} [maxAudioChannels] 
         * @param {string} [profile] 
         * @param {string} [level] 
         * @param {number} [framerate] 
         * @param {number} [maxFramerate] 
         * @param {boolean} [copyTimestamps] 
         * @param {number} [startTimeTicks] 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [videoBitRate] 
         * @param {number} [subtitleStreamIndex] 
         * @param {SubtitleDeliveryMethod} [subtitleMethod] 
         * @param {number} [maxRefFrames] 
         * @param {number} [maxVideoBitDepth] 
         * @param {boolean} [requireAvc] 
         * @param {boolean} [deInterlace] 
         * @param {boolean} [requireNonAnamorphic] 
         * @param {number} [transcodingMaxAudioChannels] 
         * @param {number} [cpuCoreLimit] 
         * @param {string} [liveStreamId] 
         * @param {boolean} [enableMpegtsM2TsMode] 
         * @param {string} [videoCodec] 
         * @param {string} [subtitleCodec] 
         * @param {string} [transcodingReasons] 
         * @param {number} [audioStreamIndex] 
         * @param {number} [videoStreamIndex] 
         * @param {EncodingContext} [context] 
         * @param {{ [key: string]: string; }} [streamOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAudioStreamByContainer(itemId: string, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any): AxiosPromise<void> {
            return AudioApiFp(configuration).getAudioStreamByContainer(itemId, container, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} container 
         * @param {boolean} [_static] 
         * @param {string} [params] 
         * @param {string} [tag] 
         * @param {string} [deviceProfileId] 
         * @param {string} [playSessionId] 
         * @param {string} [segmentContainer] 
         * @param {number} [segmentLength] 
         * @param {number} [minSegments] 
         * @param {string} [mediaSourceId] 
         * @param {string} [deviceId] 
         * @param {string} [audioCodec] 
         * @param {boolean} [enableAutoStreamCopy] 
         * @param {boolean} [allowVideoStreamCopy] 
         * @param {boolean} [allowAudioStreamCopy] 
         * @param {boolean} [breakOnNonKeyFrames] 
         * @param {number} [audioSampleRate] 
         * @param {number} [maxAudioBitDepth] 
         * @param {number} [audioBitRate] 
         * @param {number} [audioChannels] 
         * @param {number} [maxAudioChannels] 
         * @param {string} [profile] 
         * @param {string} [level] 
         * @param {number} [framerate] 
         * @param {number} [maxFramerate] 
         * @param {boolean} [copyTimestamps] 
         * @param {number} [startTimeTicks] 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [videoBitRate] 
         * @param {number} [subtitleStreamIndex] 
         * @param {SubtitleDeliveryMethod} [subtitleMethod] 
         * @param {number} [maxRefFrames] 
         * @param {number} [maxVideoBitDepth] 
         * @param {boolean} [requireAvc] 
         * @param {boolean} [deInterlace] 
         * @param {boolean} [requireNonAnamorphic] 
         * @param {number} [transcodingMaxAudioChannels] 
         * @param {number} [cpuCoreLimit] 
         * @param {string} [liveStreamId] 
         * @param {boolean} [enableMpegtsM2TsMode] 
         * @param {string} [videoCodec] 
         * @param {string} [subtitleCodec] 
         * @param {string} [transcodingReasons] 
         * @param {number} [audioStreamIndex] 
         * @param {number} [videoStreamIndex] 
         * @param {EncodingContext} [context] 
         * @param {{ [key: string]: string; }} [streamOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headAudioStream(itemId: string, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any): AxiosPromise<void> {
            return AudioApiFp(configuration).headAudioStream(itemId, container, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} container 
         * @param {boolean} [_static] 
         * @param {string} [params] 
         * @param {string} [tag] 
         * @param {string} [deviceProfileId] 
         * @param {string} [playSessionId] 
         * @param {string} [segmentContainer] 
         * @param {number} [segmentLength] 
         * @param {number} [minSegments] 
         * @param {string} [mediaSourceId] 
         * @param {string} [deviceId] 
         * @param {string} [audioCodec] 
         * @param {boolean} [enableAutoStreamCopy] 
         * @param {boolean} [allowVideoStreamCopy] 
         * @param {boolean} [allowAudioStreamCopy] 
         * @param {boolean} [breakOnNonKeyFrames] 
         * @param {number} [audioSampleRate] 
         * @param {number} [maxAudioBitDepth] 
         * @param {number} [audioBitRate] 
         * @param {number} [audioChannels] 
         * @param {number} [maxAudioChannels] 
         * @param {string} [profile] 
         * @param {string} [level] 
         * @param {number} [framerate] 
         * @param {number} [maxFramerate] 
         * @param {boolean} [copyTimestamps] 
         * @param {number} [startTimeTicks] 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [videoBitRate] 
         * @param {number} [subtitleStreamIndex] 
         * @param {SubtitleDeliveryMethod} [subtitleMethod] 
         * @param {number} [maxRefFrames] 
         * @param {number} [maxVideoBitDepth] 
         * @param {boolean} [requireAvc] 
         * @param {boolean} [deInterlace] 
         * @param {boolean} [requireNonAnamorphic] 
         * @param {number} [transcodingMaxAudioChannels] 
         * @param {number} [cpuCoreLimit] 
         * @param {string} [liveStreamId] 
         * @param {boolean} [enableMpegtsM2TsMode] 
         * @param {string} [videoCodec] 
         * @param {string} [subtitleCodec] 
         * @param {string} [transcodingReasons] 
         * @param {number} [audioStreamIndex] 
         * @param {number} [videoStreamIndex] 
         * @param {EncodingContext} [context] 
         * @param {{ [key: string]: string; }} [streamOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headAudioStreamByContainer(itemId: string, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any): AxiosPromise<void> {
            return AudioApiFp(configuration).headAudioStreamByContainer(itemId, container, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getAudioStream operation in AudioApi.
 * @export
 * @interface AudioApiGetAudioStreamRequest
 */
export interface AudioApiGetAudioStreamRequest {
    /**
     * 
     * @type {string}
     * @memberof AudioApiGetAudioStream
     */
    readonly itemId: string

    /**
     * 
     * @type {string}
     * @memberof AudioApiGetAudioStream
     */
    readonly container: string

    /**
     * 
     * @type {boolean}
     * @memberof AudioApiGetAudioStream
     */
    readonly _static?: boolean

    /**
     * 
     * @type {string}
     * @memberof AudioApiGetAudioStream
     */
    readonly params?: string

    /**
     * 
     * @type {string}
     * @memberof AudioApiGetAudioStream
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof AudioApiGetAudioStream
     */
    readonly deviceProfileId?: string

    /**
     * 
     * @type {string}
     * @memberof AudioApiGetAudioStream
     */
    readonly playSessionId?: string

    /**
     * 
     * @type {string}
     * @memberof AudioApiGetAudioStream
     */
    readonly segmentContainer?: string

    /**
     * 
     * @type {number}
     * @memberof AudioApiGetAudioStream
     */
    readonly segmentLength?: number

    /**
     * 
     * @type {number}
     * @memberof AudioApiGetAudioStream
     */
    readonly minSegments?: number

    /**
     * 
     * @type {string}
     * @memberof AudioApiGetAudioStream
     */
    readonly mediaSourceId?: string

    /**
     * 
     * @type {string}
     * @memberof AudioApiGetAudioStream
     */
    readonly deviceId?: string

    /**
     * 
     * @type {string}
     * @memberof AudioApiGetAudioStream
     */
    readonly audioCodec?: string

    /**
     * 
     * @type {boolean}
     * @memberof AudioApiGetAudioStream
     */
    readonly enableAutoStreamCopy?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof AudioApiGetAudioStream
     */
    readonly allowVideoStreamCopy?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof AudioApiGetAudioStream
     */
    readonly allowAudioStreamCopy?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof AudioApiGetAudioStream
     */
    readonly breakOnNonKeyFrames?: boolean

    /**
     * 
     * @type {number}
     * @memberof AudioApiGetAudioStream
     */
    readonly audioSampleRate?: number

    /**
     * 
     * @type {number}
     * @memberof AudioApiGetAudioStream
     */
    readonly maxAudioBitDepth?: number

    /**
     * 
     * @type {number}
     * @memberof AudioApiGetAudioStream
     */
    readonly audioBitRate?: number

    /**
     * 
     * @type {number}
     * @memberof AudioApiGetAudioStream
     */
    readonly audioChannels?: number

    /**
     * 
     * @type {number}
     * @memberof AudioApiGetAudioStream
     */
    readonly maxAudioChannels?: number

    /**
     * 
     * @type {string}
     * @memberof AudioApiGetAudioStream
     */
    readonly profile?: string

    /**
     * 
     * @type {string}
     * @memberof AudioApiGetAudioStream
     */
    readonly level?: string

    /**
     * 
     * @type {number}
     * @memberof AudioApiGetAudioStream
     */
    readonly framerate?: number

    /**
     * 
     * @type {number}
     * @memberof AudioApiGetAudioStream
     */
    readonly maxFramerate?: number

    /**
     * 
     * @type {boolean}
     * @memberof AudioApiGetAudioStream
     */
    readonly copyTimestamps?: boolean

    /**
     * 
     * @type {number}
     * @memberof AudioApiGetAudioStream
     */
    readonly startTimeTicks?: number

    /**
     * 
     * @type {number}
     * @memberof AudioApiGetAudioStream
     */
    readonly width?: number

    /**
     * 
     * @type {number}
     * @memberof AudioApiGetAudioStream
     */
    readonly height?: number

    /**
     * 
     * @type {number}
     * @memberof AudioApiGetAudioStream
     */
    readonly videoBitRate?: number

    /**
     * 
     * @type {number}
     * @memberof AudioApiGetAudioStream
     */
    readonly subtitleStreamIndex?: number

    /**
     * 
     * @type {SubtitleDeliveryMethod}
     * @memberof AudioApiGetAudioStream
     */
    readonly subtitleMethod?: SubtitleDeliveryMethod

    /**
     * 
     * @type {number}
     * @memberof AudioApiGetAudioStream
     */
    readonly maxRefFrames?: number

    /**
     * 
     * @type {number}
     * @memberof AudioApiGetAudioStream
     */
    readonly maxVideoBitDepth?: number

    /**
     * 
     * @type {boolean}
     * @memberof AudioApiGetAudioStream
     */
    readonly requireAvc?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof AudioApiGetAudioStream
     */
    readonly deInterlace?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof AudioApiGetAudioStream
     */
    readonly requireNonAnamorphic?: boolean

    /**
     * 
     * @type {number}
     * @memberof AudioApiGetAudioStream
     */
    readonly transcodingMaxAudioChannels?: number

    /**
     * 
     * @type {number}
     * @memberof AudioApiGetAudioStream
     */
    readonly cpuCoreLimit?: number

    /**
     * 
     * @type {string}
     * @memberof AudioApiGetAudioStream
     */
    readonly liveStreamId?: string

    /**
     * 
     * @type {boolean}
     * @memberof AudioApiGetAudioStream
     */
    readonly enableMpegtsM2TsMode?: boolean

    /**
     * 
     * @type {string}
     * @memberof AudioApiGetAudioStream
     */
    readonly videoCodec?: string

    /**
     * 
     * @type {string}
     * @memberof AudioApiGetAudioStream
     */
    readonly subtitleCodec?: string

    /**
     * 
     * @type {string}
     * @memberof AudioApiGetAudioStream
     */
    readonly transcodingReasons?: string

    /**
     * 
     * @type {number}
     * @memberof AudioApiGetAudioStream
     */
    readonly audioStreamIndex?: number

    /**
     * 
     * @type {number}
     * @memberof AudioApiGetAudioStream
     */
    readonly videoStreamIndex?: number

    /**
     * 
     * @type {EncodingContext}
     * @memberof AudioApiGetAudioStream
     */
    readonly context?: EncodingContext

    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof AudioApiGetAudioStream
     */
    readonly streamOptions?: { [key: string]: string; }
}

/**
 * Request parameters for getAudioStreamByContainer operation in AudioApi.
 * @export
 * @interface AudioApiGetAudioStreamByContainerRequest
 */
export interface AudioApiGetAudioStreamByContainerRequest {
    /**
     * 
     * @type {string}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly itemId: string

    /**
     * 
     * @type {string}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly container: string

    /**
     * 
     * @type {boolean}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly _static?: boolean

    /**
     * 
     * @type {string}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly params?: string

    /**
     * 
     * @type {string}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly deviceProfileId?: string

    /**
     * 
     * @type {string}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly playSessionId?: string

    /**
     * 
     * @type {string}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly segmentContainer?: string

    /**
     * 
     * @type {number}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly segmentLength?: number

    /**
     * 
     * @type {number}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly minSegments?: number

    /**
     * 
     * @type {string}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly mediaSourceId?: string

    /**
     * 
     * @type {string}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly deviceId?: string

    /**
     * 
     * @type {string}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly audioCodec?: string

    /**
     * 
     * @type {boolean}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly enableAutoStreamCopy?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly allowVideoStreamCopy?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly allowAudioStreamCopy?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly breakOnNonKeyFrames?: boolean

    /**
     * 
     * @type {number}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly audioSampleRate?: number

    /**
     * 
     * @type {number}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly maxAudioBitDepth?: number

    /**
     * 
     * @type {number}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly audioBitRate?: number

    /**
     * 
     * @type {number}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly audioChannels?: number

    /**
     * 
     * @type {number}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly maxAudioChannels?: number

    /**
     * 
     * @type {string}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly profile?: string

    /**
     * 
     * @type {string}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly level?: string

    /**
     * 
     * @type {number}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly framerate?: number

    /**
     * 
     * @type {number}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly maxFramerate?: number

    /**
     * 
     * @type {boolean}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly copyTimestamps?: boolean

    /**
     * 
     * @type {number}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly startTimeTicks?: number

    /**
     * 
     * @type {number}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly width?: number

    /**
     * 
     * @type {number}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly height?: number

    /**
     * 
     * @type {number}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly videoBitRate?: number

    /**
     * 
     * @type {number}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly subtitleStreamIndex?: number

    /**
     * 
     * @type {SubtitleDeliveryMethod}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly subtitleMethod?: SubtitleDeliveryMethod

    /**
     * 
     * @type {number}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly maxRefFrames?: number

    /**
     * 
     * @type {number}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly maxVideoBitDepth?: number

    /**
     * 
     * @type {boolean}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly requireAvc?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly deInterlace?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly requireNonAnamorphic?: boolean

    /**
     * 
     * @type {number}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly transcodingMaxAudioChannels?: number

    /**
     * 
     * @type {number}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly cpuCoreLimit?: number

    /**
     * 
     * @type {string}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly liveStreamId?: string

    /**
     * 
     * @type {boolean}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly enableMpegtsM2TsMode?: boolean

    /**
     * 
     * @type {string}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly videoCodec?: string

    /**
     * 
     * @type {string}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly subtitleCodec?: string

    /**
     * 
     * @type {string}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly transcodingReasons?: string

    /**
     * 
     * @type {number}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly audioStreamIndex?: number

    /**
     * 
     * @type {number}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly videoStreamIndex?: number

    /**
     * 
     * @type {EncodingContext}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly context?: EncodingContext

    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof AudioApiGetAudioStreamByContainer
     */
    readonly streamOptions?: { [key: string]: string; }
}

/**
 * Request parameters for headAudioStream operation in AudioApi.
 * @export
 * @interface AudioApiHeadAudioStreamRequest
 */
export interface AudioApiHeadAudioStreamRequest {
    /**
     * 
     * @type {string}
     * @memberof AudioApiHeadAudioStream
     */
    readonly itemId: string

    /**
     * 
     * @type {string}
     * @memberof AudioApiHeadAudioStream
     */
    readonly container: string

    /**
     * 
     * @type {boolean}
     * @memberof AudioApiHeadAudioStream
     */
    readonly _static?: boolean

    /**
     * 
     * @type {string}
     * @memberof AudioApiHeadAudioStream
     */
    readonly params?: string

    /**
     * 
     * @type {string}
     * @memberof AudioApiHeadAudioStream
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof AudioApiHeadAudioStream
     */
    readonly deviceProfileId?: string

    /**
     * 
     * @type {string}
     * @memberof AudioApiHeadAudioStream
     */
    readonly playSessionId?: string

    /**
     * 
     * @type {string}
     * @memberof AudioApiHeadAudioStream
     */
    readonly segmentContainer?: string

    /**
     * 
     * @type {number}
     * @memberof AudioApiHeadAudioStream
     */
    readonly segmentLength?: number

    /**
     * 
     * @type {number}
     * @memberof AudioApiHeadAudioStream
     */
    readonly minSegments?: number

    /**
     * 
     * @type {string}
     * @memberof AudioApiHeadAudioStream
     */
    readonly mediaSourceId?: string

    /**
     * 
     * @type {string}
     * @memberof AudioApiHeadAudioStream
     */
    readonly deviceId?: string

    /**
     * 
     * @type {string}
     * @memberof AudioApiHeadAudioStream
     */
    readonly audioCodec?: string

    /**
     * 
     * @type {boolean}
     * @memberof AudioApiHeadAudioStream
     */
    readonly enableAutoStreamCopy?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof AudioApiHeadAudioStream
     */
    readonly allowVideoStreamCopy?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof AudioApiHeadAudioStream
     */
    readonly allowAudioStreamCopy?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof AudioApiHeadAudioStream
     */
    readonly breakOnNonKeyFrames?: boolean

    /**
     * 
     * @type {number}
     * @memberof AudioApiHeadAudioStream
     */
    readonly audioSampleRate?: number

    /**
     * 
     * @type {number}
     * @memberof AudioApiHeadAudioStream
     */
    readonly maxAudioBitDepth?: number

    /**
     * 
     * @type {number}
     * @memberof AudioApiHeadAudioStream
     */
    readonly audioBitRate?: number

    /**
     * 
     * @type {number}
     * @memberof AudioApiHeadAudioStream
     */
    readonly audioChannels?: number

    /**
     * 
     * @type {number}
     * @memberof AudioApiHeadAudioStream
     */
    readonly maxAudioChannels?: number

    /**
     * 
     * @type {string}
     * @memberof AudioApiHeadAudioStream
     */
    readonly profile?: string

    /**
     * 
     * @type {string}
     * @memberof AudioApiHeadAudioStream
     */
    readonly level?: string

    /**
     * 
     * @type {number}
     * @memberof AudioApiHeadAudioStream
     */
    readonly framerate?: number

    /**
     * 
     * @type {number}
     * @memberof AudioApiHeadAudioStream
     */
    readonly maxFramerate?: number

    /**
     * 
     * @type {boolean}
     * @memberof AudioApiHeadAudioStream
     */
    readonly copyTimestamps?: boolean

    /**
     * 
     * @type {number}
     * @memberof AudioApiHeadAudioStream
     */
    readonly startTimeTicks?: number

    /**
     * 
     * @type {number}
     * @memberof AudioApiHeadAudioStream
     */
    readonly width?: number

    /**
     * 
     * @type {number}
     * @memberof AudioApiHeadAudioStream
     */
    readonly height?: number

    /**
     * 
     * @type {number}
     * @memberof AudioApiHeadAudioStream
     */
    readonly videoBitRate?: number

    /**
     * 
     * @type {number}
     * @memberof AudioApiHeadAudioStream
     */
    readonly subtitleStreamIndex?: number

    /**
     * 
     * @type {SubtitleDeliveryMethod}
     * @memberof AudioApiHeadAudioStream
     */
    readonly subtitleMethod?: SubtitleDeliveryMethod

    /**
     * 
     * @type {number}
     * @memberof AudioApiHeadAudioStream
     */
    readonly maxRefFrames?: number

    /**
     * 
     * @type {number}
     * @memberof AudioApiHeadAudioStream
     */
    readonly maxVideoBitDepth?: number

    /**
     * 
     * @type {boolean}
     * @memberof AudioApiHeadAudioStream
     */
    readonly requireAvc?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof AudioApiHeadAudioStream
     */
    readonly deInterlace?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof AudioApiHeadAudioStream
     */
    readonly requireNonAnamorphic?: boolean

    /**
     * 
     * @type {number}
     * @memberof AudioApiHeadAudioStream
     */
    readonly transcodingMaxAudioChannels?: number

    /**
     * 
     * @type {number}
     * @memberof AudioApiHeadAudioStream
     */
    readonly cpuCoreLimit?: number

    /**
     * 
     * @type {string}
     * @memberof AudioApiHeadAudioStream
     */
    readonly liveStreamId?: string

    /**
     * 
     * @type {boolean}
     * @memberof AudioApiHeadAudioStream
     */
    readonly enableMpegtsM2TsMode?: boolean

    /**
     * 
     * @type {string}
     * @memberof AudioApiHeadAudioStream
     */
    readonly videoCodec?: string

    /**
     * 
     * @type {string}
     * @memberof AudioApiHeadAudioStream
     */
    readonly subtitleCodec?: string

    /**
     * 
     * @type {string}
     * @memberof AudioApiHeadAudioStream
     */
    readonly transcodingReasons?: string

    /**
     * 
     * @type {number}
     * @memberof AudioApiHeadAudioStream
     */
    readonly audioStreamIndex?: number

    /**
     * 
     * @type {number}
     * @memberof AudioApiHeadAudioStream
     */
    readonly videoStreamIndex?: number

    /**
     * 
     * @type {EncodingContext}
     * @memberof AudioApiHeadAudioStream
     */
    readonly context?: EncodingContext

    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof AudioApiHeadAudioStream
     */
    readonly streamOptions?: { [key: string]: string; }
}

/**
 * Request parameters for headAudioStreamByContainer operation in AudioApi.
 * @export
 * @interface AudioApiHeadAudioStreamByContainerRequest
 */
export interface AudioApiHeadAudioStreamByContainerRequest {
    /**
     * 
     * @type {string}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly itemId: string

    /**
     * 
     * @type {string}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly container: string

    /**
     * 
     * @type {boolean}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly _static?: boolean

    /**
     * 
     * @type {string}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly params?: string

    /**
     * 
     * @type {string}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly deviceProfileId?: string

    /**
     * 
     * @type {string}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly playSessionId?: string

    /**
     * 
     * @type {string}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly segmentContainer?: string

    /**
     * 
     * @type {number}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly segmentLength?: number

    /**
     * 
     * @type {number}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly minSegments?: number

    /**
     * 
     * @type {string}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly mediaSourceId?: string

    /**
     * 
     * @type {string}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly deviceId?: string

    /**
     * 
     * @type {string}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly audioCodec?: string

    /**
     * 
     * @type {boolean}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly enableAutoStreamCopy?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly allowVideoStreamCopy?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly allowAudioStreamCopy?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly breakOnNonKeyFrames?: boolean

    /**
     * 
     * @type {number}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly audioSampleRate?: number

    /**
     * 
     * @type {number}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly maxAudioBitDepth?: number

    /**
     * 
     * @type {number}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly audioBitRate?: number

    /**
     * 
     * @type {number}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly audioChannels?: number

    /**
     * 
     * @type {number}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly maxAudioChannels?: number

    /**
     * 
     * @type {string}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly profile?: string

    /**
     * 
     * @type {string}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly level?: string

    /**
     * 
     * @type {number}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly framerate?: number

    /**
     * 
     * @type {number}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly maxFramerate?: number

    /**
     * 
     * @type {boolean}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly copyTimestamps?: boolean

    /**
     * 
     * @type {number}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly startTimeTicks?: number

    /**
     * 
     * @type {number}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly width?: number

    /**
     * 
     * @type {number}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly height?: number

    /**
     * 
     * @type {number}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly videoBitRate?: number

    /**
     * 
     * @type {number}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly subtitleStreamIndex?: number

    /**
     * 
     * @type {SubtitleDeliveryMethod}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly subtitleMethod?: SubtitleDeliveryMethod

    /**
     * 
     * @type {number}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly maxRefFrames?: number

    /**
     * 
     * @type {number}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly maxVideoBitDepth?: number

    /**
     * 
     * @type {boolean}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly requireAvc?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly deInterlace?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly requireNonAnamorphic?: boolean

    /**
     * 
     * @type {number}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly transcodingMaxAudioChannels?: number

    /**
     * 
     * @type {number}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly cpuCoreLimit?: number

    /**
     * 
     * @type {string}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly liveStreamId?: string

    /**
     * 
     * @type {boolean}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly enableMpegtsM2TsMode?: boolean

    /**
     * 
     * @type {string}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly videoCodec?: string

    /**
     * 
     * @type {string}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly subtitleCodec?: string

    /**
     * 
     * @type {string}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly transcodingReasons?: string

    /**
     * 
     * @type {number}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly audioStreamIndex?: number

    /**
     * 
     * @type {number}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly videoStreamIndex?: number

    /**
     * 
     * @type {EncodingContext}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly context?: EncodingContext

    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof AudioApiHeadAudioStreamByContainer
     */
    readonly streamOptions?: { [key: string]: string; }
}

/**
 * AudioApi - object-oriented interface
 * @export
 * @class AudioApi
 * @extends {BaseAPI}
 */
export class AudioApi extends BaseAPI {
    /**
     * 
     * @param {AudioApiGetAudioStreamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AudioApi
     */
    public getAudioStream(requestParameters: AudioApiGetAudioStreamRequest, options?: any) {
        return AudioApiFp(this.configuration).getAudioStream(requestParameters.itemId, requestParameters.container, requestParameters._static, requestParameters.params, requestParameters.tag, requestParameters.deviceProfileId, requestParameters.playSessionId, requestParameters.segmentContainer, requestParameters.segmentLength, requestParameters.minSegments, requestParameters.mediaSourceId, requestParameters.deviceId, requestParameters.audioCodec, requestParameters.enableAutoStreamCopy, requestParameters.allowVideoStreamCopy, requestParameters.allowAudioStreamCopy, requestParameters.breakOnNonKeyFrames, requestParameters.audioSampleRate, requestParameters.maxAudioBitDepth, requestParameters.audioBitRate, requestParameters.audioChannels, requestParameters.maxAudioChannels, requestParameters.profile, requestParameters.level, requestParameters.framerate, requestParameters.maxFramerate, requestParameters.copyTimestamps, requestParameters.startTimeTicks, requestParameters.width, requestParameters.height, requestParameters.videoBitRate, requestParameters.subtitleStreamIndex, requestParameters.subtitleMethod, requestParameters.maxRefFrames, requestParameters.maxVideoBitDepth, requestParameters.requireAvc, requestParameters.deInterlace, requestParameters.requireNonAnamorphic, requestParameters.transcodingMaxAudioChannels, requestParameters.cpuCoreLimit, requestParameters.liveStreamId, requestParameters.enableMpegtsM2TsMode, requestParameters.videoCodec, requestParameters.subtitleCodec, requestParameters.transcodingReasons, requestParameters.audioStreamIndex, requestParameters.videoStreamIndex, requestParameters.context, requestParameters.streamOptions, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AudioApiGetAudioStreamByContainerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AudioApi
     */
    public getAudioStreamByContainer(requestParameters: AudioApiGetAudioStreamByContainerRequest, options?: any) {
        return AudioApiFp(this.configuration).getAudioStreamByContainer(requestParameters.itemId, requestParameters.container, requestParameters._static, requestParameters.params, requestParameters.tag, requestParameters.deviceProfileId, requestParameters.playSessionId, requestParameters.segmentContainer, requestParameters.segmentLength, requestParameters.minSegments, requestParameters.mediaSourceId, requestParameters.deviceId, requestParameters.audioCodec, requestParameters.enableAutoStreamCopy, requestParameters.allowVideoStreamCopy, requestParameters.allowAudioStreamCopy, requestParameters.breakOnNonKeyFrames, requestParameters.audioSampleRate, requestParameters.maxAudioBitDepth, requestParameters.audioBitRate, requestParameters.audioChannels, requestParameters.maxAudioChannels, requestParameters.profile, requestParameters.level, requestParameters.framerate, requestParameters.maxFramerate, requestParameters.copyTimestamps, requestParameters.startTimeTicks, requestParameters.width, requestParameters.height, requestParameters.videoBitRate, requestParameters.subtitleStreamIndex, requestParameters.subtitleMethod, requestParameters.maxRefFrames, requestParameters.maxVideoBitDepth, requestParameters.requireAvc, requestParameters.deInterlace, requestParameters.requireNonAnamorphic, requestParameters.transcodingMaxAudioChannels, requestParameters.cpuCoreLimit, requestParameters.liveStreamId, requestParameters.enableMpegtsM2TsMode, requestParameters.videoCodec, requestParameters.subtitleCodec, requestParameters.transcodingReasons, requestParameters.audioStreamIndex, requestParameters.videoStreamIndex, requestParameters.context, requestParameters.streamOptions, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AudioApiHeadAudioStreamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AudioApi
     */
    public headAudioStream(requestParameters: AudioApiHeadAudioStreamRequest, options?: any) {
        return AudioApiFp(this.configuration).headAudioStream(requestParameters.itemId, requestParameters.container, requestParameters._static, requestParameters.params, requestParameters.tag, requestParameters.deviceProfileId, requestParameters.playSessionId, requestParameters.segmentContainer, requestParameters.segmentLength, requestParameters.minSegments, requestParameters.mediaSourceId, requestParameters.deviceId, requestParameters.audioCodec, requestParameters.enableAutoStreamCopy, requestParameters.allowVideoStreamCopy, requestParameters.allowAudioStreamCopy, requestParameters.breakOnNonKeyFrames, requestParameters.audioSampleRate, requestParameters.maxAudioBitDepth, requestParameters.audioBitRate, requestParameters.audioChannels, requestParameters.maxAudioChannels, requestParameters.profile, requestParameters.level, requestParameters.framerate, requestParameters.maxFramerate, requestParameters.copyTimestamps, requestParameters.startTimeTicks, requestParameters.width, requestParameters.height, requestParameters.videoBitRate, requestParameters.subtitleStreamIndex, requestParameters.subtitleMethod, requestParameters.maxRefFrames, requestParameters.maxVideoBitDepth, requestParameters.requireAvc, requestParameters.deInterlace, requestParameters.requireNonAnamorphic, requestParameters.transcodingMaxAudioChannels, requestParameters.cpuCoreLimit, requestParameters.liveStreamId, requestParameters.enableMpegtsM2TsMode, requestParameters.videoCodec, requestParameters.subtitleCodec, requestParameters.transcodingReasons, requestParameters.audioStreamIndex, requestParameters.videoStreamIndex, requestParameters.context, requestParameters.streamOptions, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AudioApiHeadAudioStreamByContainerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AudioApi
     */
    public headAudioStreamByContainer(requestParameters: AudioApiHeadAudioStreamByContainerRequest, options?: any) {
        return AudioApiFp(this.configuration).headAudioStreamByContainer(requestParameters.itemId, requestParameters.container, requestParameters._static, requestParameters.params, requestParameters.tag, requestParameters.deviceProfileId, requestParameters.playSessionId, requestParameters.segmentContainer, requestParameters.segmentLength, requestParameters.minSegments, requestParameters.mediaSourceId, requestParameters.deviceId, requestParameters.audioCodec, requestParameters.enableAutoStreamCopy, requestParameters.allowVideoStreamCopy, requestParameters.allowAudioStreamCopy, requestParameters.breakOnNonKeyFrames, requestParameters.audioSampleRate, requestParameters.maxAudioBitDepth, requestParameters.audioBitRate, requestParameters.audioChannels, requestParameters.maxAudioChannels, requestParameters.profile, requestParameters.level, requestParameters.framerate, requestParameters.maxFramerate, requestParameters.copyTimestamps, requestParameters.startTimeTicks, requestParameters.width, requestParameters.height, requestParameters.videoBitRate, requestParameters.subtitleStreamIndex, requestParameters.subtitleMethod, requestParameters.maxRefFrames, requestParameters.maxVideoBitDepth, requestParameters.requireAvc, requestParameters.deInterlace, requestParameters.requireNonAnamorphic, requestParameters.transcodingMaxAudioChannels, requestParameters.cpuCoreLimit, requestParameters.liveStreamId, requestParameters.enableMpegtsM2TsMode, requestParameters.videoCodec, requestParameters.subtitleCodec, requestParameters.transcodingReasons, requestParameters.audioStreamIndex, requestParameters.videoStreamIndex, requestParameters.context, requestParameters.streamOptions, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BrandingApi - axios parameter creator
 * @export
 */
export const BrandingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBrandingCss: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Branding/Css`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBrandingCss2: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Branding/Css.css`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBrandingOptions: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Branding/Configuration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BrandingApi - functional programming interface
 * @export
 */
export const BrandingApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBrandingCss(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await BrandingApiAxiosParamCreator(configuration).getBrandingCss(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBrandingCss2(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await BrandingApiAxiosParamCreator(configuration).getBrandingCss2(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBrandingOptions(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BrandingOptions>> {
            const localVarAxiosArgs = await BrandingApiAxiosParamCreator(configuration).getBrandingOptions(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * BrandingApi - factory interface
 * @export
 */
export const BrandingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBrandingCss(options?: any): AxiosPromise<string> {
            return BrandingApiFp(configuration).getBrandingCss(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBrandingCss2(options?: any): AxiosPromise<string> {
            return BrandingApiFp(configuration).getBrandingCss2(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBrandingOptions(options?: any): AxiosPromise<BrandingOptions> {
            return BrandingApiFp(configuration).getBrandingOptions(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BrandingApi - object-oriented interface
 * @export
 * @class BrandingApi
 * @extends {BaseAPI}
 */
export class BrandingApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrandingApi
     */
    public getBrandingCss(options?: any) {
        return BrandingApiFp(this.configuration).getBrandingCss(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrandingApi
     */
    public getBrandingCss2(options?: any) {
        return BrandingApiFp(this.configuration).getBrandingCss2(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrandingApi
     */
    public getBrandingOptions(options?: any) {
        return BrandingApiFp(this.configuration).getBrandingOptions(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ChannelsApi - axios parameter creator
 * @export
 */
export const ChannelsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllChannelFeatures: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Channels/Features`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} channelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelFeatures: async (channelId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            if (channelId === null || channelId === undefined) {
                throw new RequiredError('channelId','Required parameter channelId was null or undefined when calling getChannelFeatures.');
            }
            const localVarPath = `/Channels/{channelId}/Features`
                .replace(`{${"channelId"}}`, encodeURIComponent(String(channelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} [folderId] 
         * @param {string} [userId] 
         * @param {number} [startIndex] 
         * @param {number} [limit] 
         * @param {string} [sortOrder] 
         * @param {string} [filters] 
         * @param {string} [sortBy] 
         * @param {string} [fields] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelItems: async (channelId: string, folderId?: string, userId?: string, startIndex?: number, limit?: number, sortOrder?: string, filters?: string, sortBy?: string, fields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            if (channelId === null || channelId === undefined) {
                throw new RequiredError('channelId','Required parameter channelId was null or undefined when calling getChannelItems.');
            }
            const localVarPath = `/Channels/{channelId}/Items`
                .replace(`{${"channelId"}}`, encodeURIComponent(String(channelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (folderId !== undefined) {
                localVarQueryParameter['folderId'] = folderId;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [userId] 
         * @param {number} [startIndex] 
         * @param {number} [limit] 
         * @param {boolean} [supportsLatestItems] 
         * @param {boolean} [supportsMediaDeletion] 
         * @param {boolean} [isFavorite] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannels: async (userId?: string, startIndex?: number, limit?: number, supportsLatestItems?: boolean, supportsMediaDeletion?: boolean, isFavorite?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Channels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (supportsLatestItems !== undefined) {
                localVarQueryParameter['supportsLatestItems'] = supportsLatestItems;
            }

            if (supportsMediaDeletion !== undefined) {
                localVarQueryParameter['supportsMediaDeletion'] = supportsMediaDeletion;
            }

            if (isFavorite !== undefined) {
                localVarQueryParameter['isFavorite'] = isFavorite;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [userId] 
         * @param {number} [startIndex] 
         * @param {number} [limit] 
         * @param {string} [filters] 
         * @param {string} [fields] 
         * @param {string} [channelIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestChannelItems: async (userId?: string, startIndex?: number, limit?: number, filters?: string, fields?: string, channelIds?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Channels/Items/Latest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (channelIds !== undefined) {
                localVarQueryParameter['channelIds'] = channelIds;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChannelsApi - functional programming interface
 * @export
 */
export const ChannelsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllChannelFeatures(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ChannelFeatures>>> {
            const localVarAxiosArgs = await ChannelsApiAxiosParamCreator(configuration).getAllChannelFeatures(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} channelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChannelFeatures(channelId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChannelFeatures>> {
            const localVarAxiosArgs = await ChannelsApiAxiosParamCreator(configuration).getChannelFeatures(channelId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} [folderId] 
         * @param {string} [userId] 
         * @param {number} [startIndex] 
         * @param {number} [limit] 
         * @param {string} [sortOrder] 
         * @param {string} [filters] 
         * @param {string} [sortBy] 
         * @param {string} [fields] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChannelItems(channelId: string, folderId?: string, userId?: string, startIndex?: number, limit?: number, sortOrder?: string, filters?: string, sortBy?: string, fields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await ChannelsApiAxiosParamCreator(configuration).getChannelItems(channelId, folderId, userId, startIndex, limit, sortOrder, filters, sortBy, fields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [userId] 
         * @param {number} [startIndex] 
         * @param {number} [limit] 
         * @param {boolean} [supportsLatestItems] 
         * @param {boolean} [supportsMediaDeletion] 
         * @param {boolean} [isFavorite] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChannels(userId?: string, startIndex?: number, limit?: number, supportsLatestItems?: boolean, supportsMediaDeletion?: boolean, isFavorite?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await ChannelsApiAxiosParamCreator(configuration).getChannels(userId, startIndex, limit, supportsLatestItems, supportsMediaDeletion, isFavorite, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [userId] 
         * @param {number} [startIndex] 
         * @param {number} [limit] 
         * @param {string} [filters] 
         * @param {string} [fields] 
         * @param {string} [channelIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLatestChannelItems(userId?: string, startIndex?: number, limit?: number, filters?: string, fields?: string, channelIds?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await ChannelsApiAxiosParamCreator(configuration).getLatestChannelItems(userId, startIndex, limit, filters, fields, channelIds, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ChannelsApi - factory interface
 * @export
 */
export const ChannelsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllChannelFeatures(options?: any): AxiosPromise<Array<ChannelFeatures>> {
            return ChannelsApiFp(configuration).getAllChannelFeatures(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} channelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelFeatures(channelId: string, options?: any): AxiosPromise<ChannelFeatures> {
            return ChannelsApiFp(configuration).getChannelFeatures(channelId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} [folderId] 
         * @param {string} [userId] 
         * @param {number} [startIndex] 
         * @param {number} [limit] 
         * @param {string} [sortOrder] 
         * @param {string} [filters] 
         * @param {string} [sortBy] 
         * @param {string} [fields] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelItems(channelId: string, folderId?: string, userId?: string, startIndex?: number, limit?: number, sortOrder?: string, filters?: string, sortBy?: string, fields?: string, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return ChannelsApiFp(configuration).getChannelItems(channelId, folderId, userId, startIndex, limit, sortOrder, filters, sortBy, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [userId] 
         * @param {number} [startIndex] 
         * @param {number} [limit] 
         * @param {boolean} [supportsLatestItems] 
         * @param {boolean} [supportsMediaDeletion] 
         * @param {boolean} [isFavorite] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannels(userId?: string, startIndex?: number, limit?: number, supportsLatestItems?: boolean, supportsMediaDeletion?: boolean, isFavorite?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return ChannelsApiFp(configuration).getChannels(userId, startIndex, limit, supportsLatestItems, supportsMediaDeletion, isFavorite, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [userId] 
         * @param {number} [startIndex] 
         * @param {number} [limit] 
         * @param {string} [filters] 
         * @param {string} [fields] 
         * @param {string} [channelIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestChannelItems(userId?: string, startIndex?: number, limit?: number, filters?: string, fields?: string, channelIds?: string, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return ChannelsApiFp(configuration).getLatestChannelItems(userId, startIndex, limit, filters, fields, channelIds, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getChannelFeatures operation in ChannelsApi.
 * @export
 * @interface ChannelsApiGetChannelFeaturesRequest
 */
export interface ChannelsApiGetChannelFeaturesRequest {
    /**
     * 
     * @type {string}
     * @memberof ChannelsApiGetChannelFeatures
     */
    readonly channelId: string
}

/**
 * Request parameters for getChannelItems operation in ChannelsApi.
 * @export
 * @interface ChannelsApiGetChannelItemsRequest
 */
export interface ChannelsApiGetChannelItemsRequest {
    /**
     * 
     * @type {string}
     * @memberof ChannelsApiGetChannelItems
     */
    readonly channelId: string

    /**
     * 
     * @type {string}
     * @memberof ChannelsApiGetChannelItems
     */
    readonly folderId?: string

    /**
     * 
     * @type {string}
     * @memberof ChannelsApiGetChannelItems
     */
    readonly userId?: string

    /**
     * 
     * @type {number}
     * @memberof ChannelsApiGetChannelItems
     */
    readonly startIndex?: number

    /**
     * 
     * @type {number}
     * @memberof ChannelsApiGetChannelItems
     */
    readonly limit?: number

    /**
     * 
     * @type {string}
     * @memberof ChannelsApiGetChannelItems
     */
    readonly sortOrder?: string

    /**
     * 
     * @type {string}
     * @memberof ChannelsApiGetChannelItems
     */
    readonly filters?: string

    /**
     * 
     * @type {string}
     * @memberof ChannelsApiGetChannelItems
     */
    readonly sortBy?: string

    /**
     * 
     * @type {string}
     * @memberof ChannelsApiGetChannelItems
     */
    readonly fields?: string
}

/**
 * Request parameters for getChannels operation in ChannelsApi.
 * @export
 * @interface ChannelsApiGetChannelsRequest
 */
export interface ChannelsApiGetChannelsRequest {
    /**
     * 
     * @type {string}
     * @memberof ChannelsApiGetChannels
     */
    readonly userId?: string

    /**
     * 
     * @type {number}
     * @memberof ChannelsApiGetChannels
     */
    readonly startIndex?: number

    /**
     * 
     * @type {number}
     * @memberof ChannelsApiGetChannels
     */
    readonly limit?: number

    /**
     * 
     * @type {boolean}
     * @memberof ChannelsApiGetChannels
     */
    readonly supportsLatestItems?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ChannelsApiGetChannels
     */
    readonly supportsMediaDeletion?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ChannelsApiGetChannels
     */
    readonly isFavorite?: boolean
}

/**
 * Request parameters for getLatestChannelItems operation in ChannelsApi.
 * @export
 * @interface ChannelsApiGetLatestChannelItemsRequest
 */
export interface ChannelsApiGetLatestChannelItemsRequest {
    /**
     * 
     * @type {string}
     * @memberof ChannelsApiGetLatestChannelItems
     */
    readonly userId?: string

    /**
     * 
     * @type {number}
     * @memberof ChannelsApiGetLatestChannelItems
     */
    readonly startIndex?: number

    /**
     * 
     * @type {number}
     * @memberof ChannelsApiGetLatestChannelItems
     */
    readonly limit?: number

    /**
     * 
     * @type {string}
     * @memberof ChannelsApiGetLatestChannelItems
     */
    readonly filters?: string

    /**
     * 
     * @type {string}
     * @memberof ChannelsApiGetLatestChannelItems
     */
    readonly fields?: string

    /**
     * 
     * @type {string}
     * @memberof ChannelsApiGetLatestChannelItems
     */
    readonly channelIds?: string
}

/**
 * ChannelsApi - object-oriented interface
 * @export
 * @class ChannelsApi
 * @extends {BaseAPI}
 */
export class ChannelsApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelsApi
     */
    public getAllChannelFeatures(options?: any) {
        return ChannelsApiFp(this.configuration).getAllChannelFeatures(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ChannelsApiGetChannelFeaturesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelsApi
     */
    public getChannelFeatures(requestParameters: ChannelsApiGetChannelFeaturesRequest, options?: any) {
        return ChannelsApiFp(this.configuration).getChannelFeatures(requestParameters.channelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ChannelsApiGetChannelItemsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelsApi
     */
    public getChannelItems(requestParameters: ChannelsApiGetChannelItemsRequest, options?: any) {
        return ChannelsApiFp(this.configuration).getChannelItems(requestParameters.channelId, requestParameters.folderId, requestParameters.userId, requestParameters.startIndex, requestParameters.limit, requestParameters.sortOrder, requestParameters.filters, requestParameters.sortBy, requestParameters.fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ChannelsApiGetChannelsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelsApi
     */
    public getChannels(requestParameters: ChannelsApiGetChannelsRequest = {}, options?: any) {
        return ChannelsApiFp(this.configuration).getChannels(requestParameters.userId, requestParameters.startIndex, requestParameters.limit, requestParameters.supportsLatestItems, requestParameters.supportsMediaDeletion, requestParameters.isFavorite, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ChannelsApiGetLatestChannelItemsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelsApi
     */
    public getLatestChannelItems(requestParameters: ChannelsApiGetLatestChannelItemsRequest = {}, options?: any) {
        return ChannelsApiFp(this.configuration).getLatestChannelItems(requestParameters.userId, requestParameters.startIndex, requestParameters.limit, requestParameters.filters, requestParameters.fields, requestParameters.channelIds, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CollectionApi - axios parameter creator
 * @export
 */
export const CollectionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} collectionId 
         * @param {string} itemIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addToCollection: async (collectionId: string, itemIds: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionId' is not null or undefined
            if (collectionId === null || collectionId === undefined) {
                throw new RequiredError('collectionId','Required parameter collectionId was null or undefined when calling addToCollection.');
            }
            // verify required parameter 'itemIds' is not null or undefined
            if (itemIds === null || itemIds === undefined) {
                throw new RequiredError('itemIds','Required parameter itemIds was null or undefined when calling addToCollection.');
            }
            const localVarPath = `/Collections/{collectionId}/Items`
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (itemIds !== undefined) {
                localVarQueryParameter['itemIds'] = itemIds;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [name] 
         * @param {string} [ids] 
         * @param {string} [parentId] 
         * @param {boolean} [isLocked] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollection: async (name?: string, ids?: string, parentId?: string, isLocked?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Collections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }

            if (parentId !== undefined) {
                localVarQueryParameter['parentId'] = parentId;
            }

            if (isLocked !== undefined) {
                localVarQueryParameter['isLocked'] = isLocked;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} collectionId 
         * @param {string} itemIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeFromCollection: async (collectionId: string, itemIds: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionId' is not null or undefined
            if (collectionId === null || collectionId === undefined) {
                throw new RequiredError('collectionId','Required parameter collectionId was null or undefined when calling removeFromCollection.');
            }
            // verify required parameter 'itemIds' is not null or undefined
            if (itemIds === null || itemIds === undefined) {
                throw new RequiredError('itemIds','Required parameter itemIds was null or undefined when calling removeFromCollection.');
            }
            const localVarPath = `/Collections/{collectionId}/Items`
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (itemIds !== undefined) {
                localVarQueryParameter['itemIds'] = itemIds;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CollectionApi - functional programming interface
 * @export
 */
export const CollectionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} collectionId 
         * @param {string} itemIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addToCollection(collectionId: string, itemIds: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await CollectionApiAxiosParamCreator(configuration).addToCollection(collectionId, itemIds, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [name] 
         * @param {string} [ids] 
         * @param {string} [parentId] 
         * @param {boolean} [isLocked] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCollection(name?: string, ids?: string, parentId?: string, isLocked?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionCreationResult>> {
            const localVarAxiosArgs = await CollectionApiAxiosParamCreator(configuration).createCollection(name, ids, parentId, isLocked, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} collectionId 
         * @param {string} itemIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeFromCollection(collectionId: string, itemIds: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await CollectionApiAxiosParamCreator(configuration).removeFromCollection(collectionId, itemIds, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * CollectionApi - factory interface
 * @export
 */
export const CollectionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} collectionId 
         * @param {string} itemIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addToCollection(collectionId: string, itemIds: string, options?: any): AxiosPromise<void> {
            return CollectionApiFp(configuration).addToCollection(collectionId, itemIds, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [name] 
         * @param {string} [ids] 
         * @param {string} [parentId] 
         * @param {boolean} [isLocked] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCollection(name?: string, ids?: string, parentId?: string, isLocked?: boolean, options?: any): AxiosPromise<CollectionCreationResult> {
            return CollectionApiFp(configuration).createCollection(name, ids, parentId, isLocked, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} collectionId 
         * @param {string} itemIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeFromCollection(collectionId: string, itemIds: string, options?: any): AxiosPromise<void> {
            return CollectionApiFp(configuration).removeFromCollection(collectionId, itemIds, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addToCollection operation in CollectionApi.
 * @export
 * @interface CollectionApiAddToCollectionRequest
 */
export interface CollectionApiAddToCollectionRequest {
    /**
     * 
     * @type {string}
     * @memberof CollectionApiAddToCollection
     */
    readonly collectionId: string

    /**
     * 
     * @type {string}
     * @memberof CollectionApiAddToCollection
     */
    readonly itemIds: string
}

/**
 * Request parameters for createCollection operation in CollectionApi.
 * @export
 * @interface CollectionApiCreateCollectionRequest
 */
export interface CollectionApiCreateCollectionRequest {
    /**
     * 
     * @type {string}
     * @memberof CollectionApiCreateCollection
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof CollectionApiCreateCollection
     */
    readonly ids?: string

    /**
     * 
     * @type {string}
     * @memberof CollectionApiCreateCollection
     */
    readonly parentId?: string

    /**
     * 
     * @type {boolean}
     * @memberof CollectionApiCreateCollection
     */
    readonly isLocked?: boolean
}

/**
 * Request parameters for removeFromCollection operation in CollectionApi.
 * @export
 * @interface CollectionApiRemoveFromCollectionRequest
 */
export interface CollectionApiRemoveFromCollectionRequest {
    /**
     * 
     * @type {string}
     * @memberof CollectionApiRemoveFromCollection
     */
    readonly collectionId: string

    /**
     * 
     * @type {string}
     * @memberof CollectionApiRemoveFromCollection
     */
    readonly itemIds: string
}

/**
 * CollectionApi - object-oriented interface
 * @export
 * @class CollectionApi
 * @extends {BaseAPI}
 */
export class CollectionApi extends BaseAPI {
    /**
     * 
     * @param {CollectionApiAddToCollectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public addToCollection(requestParameters: CollectionApiAddToCollectionRequest, options?: any) {
        return CollectionApiFp(this.configuration).addToCollection(requestParameters.collectionId, requestParameters.itemIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CollectionApiCreateCollectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public createCollection(requestParameters: CollectionApiCreateCollectionRequest = {}, options?: any) {
        return CollectionApiFp(this.configuration).createCollection(requestParameters.name, requestParameters.ids, requestParameters.parentId, requestParameters.isLocked, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CollectionApiRemoveFromCollectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionApi
     */
    public removeFromCollection(requestParameters: CollectionApiRemoveFromCollectionRequest, options?: any) {
        return CollectionApiFp(this.configuration).removeFromCollection(requestParameters.collectionId, requestParameters.itemIds, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ConfigurationApi - axios parameter creator
 * @export
 */
export const ConfigurationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfiguration: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/System/Configuration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultMetadataOptions: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/System/Configuration/MetadataOptions/Default`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamedConfiguration: async (key: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling getNamedConfiguration.');
            }
            const localVarPath = `/System/Configuration/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ServerConfiguration} serverConfiguration 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConfiguration: async (serverConfiguration: ServerConfiguration, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverConfiguration' is not null or undefined
            if (serverConfiguration === null || serverConfiguration === undefined) {
                throw new RequiredError('serverConfiguration','Required parameter serverConfiguration was null or undefined when calling updateConfiguration.');
            }
            const localVarPath = `/System/Configuration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof serverConfiguration !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(serverConfiguration !== undefined ? serverConfiguration : {}) : (serverConfiguration || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {MediaEncoderPathDto} mediaEncoderPathDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMediaEncoderPath: async (mediaEncoderPathDto: MediaEncoderPathDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'mediaEncoderPathDto' is not null or undefined
            if (mediaEncoderPathDto === null || mediaEncoderPathDto === undefined) {
                throw new RequiredError('mediaEncoderPathDto','Required parameter mediaEncoderPathDto was null or undefined when calling updateMediaEncoderPath.');
            }
            const localVarPath = `/System/MediaEncoder/Path`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof mediaEncoderPathDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(mediaEncoderPathDto !== undefined ? mediaEncoderPathDto : {}) : (mediaEncoderPathDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNamedConfiguration: async (key: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling updateNamedConfiguration.');
            }
            const localVarPath = `/System/Configuration/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConfigurationApi - functional programming interface
 * @export
 */
export const ConfigurationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConfiguration(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerConfiguration>> {
            const localVarAxiosArgs = await ConfigurationApiAxiosParamCreator(configuration).getConfiguration(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDefaultMetadataOptions(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetadataOptions>> {
            const localVarAxiosArgs = await ConfigurationApiAxiosParamCreator(configuration).getDefaultMetadataOptions(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNamedConfiguration(key: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ConfigurationApiAxiosParamCreator(configuration).getNamedConfiguration(key, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {ServerConfiguration} serverConfiguration 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateConfiguration(serverConfiguration: ServerConfiguration, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ConfigurationApiAxiosParamCreator(configuration).updateConfiguration(serverConfiguration, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {MediaEncoderPathDto} mediaEncoderPathDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMediaEncoderPath(mediaEncoderPathDto: MediaEncoderPathDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ConfigurationApiAxiosParamCreator(configuration).updateMediaEncoderPath(mediaEncoderPathDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateNamedConfiguration(key: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ConfigurationApiAxiosParamCreator(configuration).updateNamedConfiguration(key, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ConfigurationApi - factory interface
 * @export
 */
export const ConfigurationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfiguration(options?: any): AxiosPromise<ServerConfiguration> {
            return ConfigurationApiFp(configuration).getConfiguration(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultMetadataOptions(options?: any): AxiosPromise<MetadataOptions> {
            return ConfigurationApiFp(configuration).getDefaultMetadataOptions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamedConfiguration(key: string, options?: any): AxiosPromise<void> {
            return ConfigurationApiFp(configuration).getNamedConfiguration(key, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ServerConfiguration} serverConfiguration 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConfiguration(serverConfiguration: ServerConfiguration, options?: any): AxiosPromise<void> {
            return ConfigurationApiFp(configuration).updateConfiguration(serverConfiguration, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {MediaEncoderPathDto} mediaEncoderPathDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMediaEncoderPath(mediaEncoderPathDto: MediaEncoderPathDto, options?: any): AxiosPromise<void> {
            return ConfigurationApiFp(configuration).updateMediaEncoderPath(mediaEncoderPathDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNamedConfiguration(key: string, options?: any): AxiosPromise<void> {
            return ConfigurationApiFp(configuration).updateNamedConfiguration(key, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getNamedConfiguration operation in ConfigurationApi.
 * @export
 * @interface ConfigurationApiGetNamedConfigurationRequest
 */
export interface ConfigurationApiGetNamedConfigurationRequest {
    /**
     * 
     * @type {string}
     * @memberof ConfigurationApiGetNamedConfiguration
     */
    readonly key: string
}

/**
 * Request parameters for updateConfiguration operation in ConfigurationApi.
 * @export
 * @interface ConfigurationApiUpdateConfigurationRequest
 */
export interface ConfigurationApiUpdateConfigurationRequest {
    /**
     * 
     * @type {ServerConfiguration}
     * @memberof ConfigurationApiUpdateConfiguration
     */
    readonly serverConfiguration: ServerConfiguration
}

/**
 * Request parameters for updateMediaEncoderPath operation in ConfigurationApi.
 * @export
 * @interface ConfigurationApiUpdateMediaEncoderPathRequest
 */
export interface ConfigurationApiUpdateMediaEncoderPathRequest {
    /**
     * 
     * @type {MediaEncoderPathDto}
     * @memberof ConfigurationApiUpdateMediaEncoderPath
     */
    readonly mediaEncoderPathDto: MediaEncoderPathDto
}

/**
 * Request parameters for updateNamedConfiguration operation in ConfigurationApi.
 * @export
 * @interface ConfigurationApiUpdateNamedConfigurationRequest
 */
export interface ConfigurationApiUpdateNamedConfigurationRequest {
    /**
     * 
     * @type {string}
     * @memberof ConfigurationApiUpdateNamedConfiguration
     */
    readonly key: string
}

/**
 * ConfigurationApi - object-oriented interface
 * @export
 * @class ConfigurationApi
 * @extends {BaseAPI}
 */
export class ConfigurationApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApi
     */
    public getConfiguration(options?: any) {
        return ConfigurationApiFp(this.configuration).getConfiguration(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApi
     */
    public getDefaultMetadataOptions(options?: any) {
        return ConfigurationApiFp(this.configuration).getDefaultMetadataOptions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ConfigurationApiGetNamedConfigurationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApi
     */
    public getNamedConfiguration(requestParameters: ConfigurationApiGetNamedConfigurationRequest, options?: any) {
        return ConfigurationApiFp(this.configuration).getNamedConfiguration(requestParameters.key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ConfigurationApiUpdateConfigurationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApi
     */
    public updateConfiguration(requestParameters: ConfigurationApiUpdateConfigurationRequest, options?: any) {
        return ConfigurationApiFp(this.configuration).updateConfiguration(requestParameters.serverConfiguration, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ConfigurationApiUpdateMediaEncoderPathRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApi
     */
    public updateMediaEncoderPath(requestParameters: ConfigurationApiUpdateMediaEncoderPathRequest, options?: any) {
        return ConfigurationApiFp(this.configuration).updateMediaEncoderPath(requestParameters.mediaEncoderPathDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ConfigurationApiUpdateNamedConfigurationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigurationApi
     */
    public updateNamedConfiguration(requestParameters: ConfigurationApiUpdateNamedConfigurationRequest, options?: any) {
        return ConfigurationApiFp(this.configuration).updateNamedConfiguration(requestParameters.key, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DashboardApi - axios parameter creator
 * @export
 */
export const DashboardApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {boolean} [enableInMainMenu] 
         * @param {ConfigurationPageType} [pageType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfigurationPages: async (enableInMainMenu?: boolean, pageType?: ConfigurationPageType, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/web/ConfigurationPages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (enableInMainMenu !== undefined) {
                localVarQueryParameter['enableInMainMenu'] = enableInMainMenu;
            }

            if (pageType !== undefined) {
                localVarQueryParameter['pageType'] = pageType;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardConfigurationPage: async (name?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/web/ConfigurationPage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DashboardApi - functional programming interface
 * @export
 */
export const DashboardApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {boolean} [enableInMainMenu] 
         * @param {ConfigurationPageType} [pageType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConfigurationPages(enableInMainMenu?: boolean, pageType?: ConfigurationPageType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ConfigurationPageInfo>>> {
            const localVarAxiosArgs = await DashboardApiAxiosParamCreator(configuration).getConfigurationPages(enableInMainMenu, pageType, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDashboardConfigurationPage(name?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DashboardApiAxiosParamCreator(configuration).getDashboardConfigurationPage(name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DashboardApi - factory interface
 * @export
 */
export const DashboardApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {boolean} [enableInMainMenu] 
         * @param {ConfigurationPageType} [pageType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfigurationPages(enableInMainMenu?: boolean, pageType?: ConfigurationPageType, options?: any): AxiosPromise<Array<ConfigurationPageInfo>> {
            return DashboardApiFp(configuration).getConfigurationPages(enableInMainMenu, pageType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardConfigurationPage(name?: string, options?: any): AxiosPromise<void> {
            return DashboardApiFp(configuration).getDashboardConfigurationPage(name, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getConfigurationPages operation in DashboardApi.
 * @export
 * @interface DashboardApiGetConfigurationPagesRequest
 */
export interface DashboardApiGetConfigurationPagesRequest {
    /**
     * 
     * @type {boolean}
     * @memberof DashboardApiGetConfigurationPages
     */
    readonly enableInMainMenu?: boolean

    /**
     * 
     * @type {ConfigurationPageType}
     * @memberof DashboardApiGetConfigurationPages
     */
    readonly pageType?: ConfigurationPageType
}

/**
 * Request parameters for getDashboardConfigurationPage operation in DashboardApi.
 * @export
 * @interface DashboardApiGetDashboardConfigurationPageRequest
 */
export interface DashboardApiGetDashboardConfigurationPageRequest {
    /**
     * 
     * @type {string}
     * @memberof DashboardApiGetDashboardConfigurationPage
     */
    readonly name?: string
}

/**
 * DashboardApi - object-oriented interface
 * @export
 * @class DashboardApi
 * @extends {BaseAPI}
 */
export class DashboardApi extends BaseAPI {
    /**
     * 
     * @param {DashboardApiGetConfigurationPagesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApi
     */
    public getConfigurationPages(requestParameters: DashboardApiGetConfigurationPagesRequest = {}, options?: any) {
        return DashboardApiFp(this.configuration).getConfigurationPages(requestParameters.enableInMainMenu, requestParameters.pageType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DashboardApiGetDashboardConfigurationPageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApi
     */
    public getDashboardConfigurationPage(requestParameters: DashboardApiGetDashboardConfigurationPageRequest = {}, options?: any) {
        return DashboardApiFp(this.configuration).getDashboardConfigurationPage(requestParameters.name, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DevicesApi - axios parameter creator
 * @export
 */
export const DevicesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDevice: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteDevice.');
            }
            const localVarPath = `/Devices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceInfo: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getDeviceInfo.');
            }
            const localVarPath = `/Devices/Info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceOptions: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getDeviceOptions.');
            }
            const localVarPath = `/Devices/Options`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {boolean} [supportsSync] 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevices: async (supportsSync?: boolean, userId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Devices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (supportsSync !== undefined) {
                localVarQueryParameter['supportsSync'] = supportsSync;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {DeviceOptions} deviceOptions 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceOptions: async (id: string, deviceOptions: DeviceOptions, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateDeviceOptions.');
            }
            // verify required parameter 'deviceOptions' is not null or undefined
            if (deviceOptions === null || deviceOptions === undefined) {
                throw new RequiredError('deviceOptions','Required parameter deviceOptions was null or undefined when calling updateDeviceOptions.');
            }
            const localVarPath = `/Devices/Options`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof deviceOptions !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(deviceOptions !== undefined ? deviceOptions : {}) : (deviceOptions || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DevicesApi - functional programming interface
 * @export
 */
export const DevicesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDevice(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DevicesApiAxiosParamCreator(configuration).deleteDevice(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeviceInfo(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceInfo>> {
            const localVarAxiosArgs = await DevicesApiAxiosParamCreator(configuration).getDeviceInfo(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeviceOptions(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceOptions>> {
            const localVarAxiosArgs = await DevicesApiAxiosParamCreator(configuration).getDeviceOptions(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {boolean} [supportsSync] 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDevices(supportsSync?: boolean, userId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceInfoQueryResult>> {
            const localVarAxiosArgs = await DevicesApiAxiosParamCreator(configuration).getDevices(supportsSync, userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {DeviceOptions} deviceOptions 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDeviceOptions(id: string, deviceOptions: DeviceOptions, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DevicesApiAxiosParamCreator(configuration).updateDeviceOptions(id, deviceOptions, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DevicesApi - factory interface
 * @export
 */
export const DevicesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDevice(id: string, options?: any): AxiosPromise<void> {
            return DevicesApiFp(configuration).deleteDevice(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceInfo(id: string, options?: any): AxiosPromise<DeviceInfo> {
            return DevicesApiFp(configuration).getDeviceInfo(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceOptions(id: string, options?: any): AxiosPromise<DeviceOptions> {
            return DevicesApiFp(configuration).getDeviceOptions(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {boolean} [supportsSync] 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevices(supportsSync?: boolean, userId?: string, options?: any): AxiosPromise<DeviceInfoQueryResult> {
            return DevicesApiFp(configuration).getDevices(supportsSync, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {DeviceOptions} deviceOptions 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceOptions(id: string, deviceOptions: DeviceOptions, options?: any): AxiosPromise<void> {
            return DevicesApiFp(configuration).updateDeviceOptions(id, deviceOptions, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deleteDevice operation in DevicesApi.
 * @export
 * @interface DevicesApiDeleteDeviceRequest
 */
export interface DevicesApiDeleteDeviceRequest {
    /**
     * 
     * @type {string}
     * @memberof DevicesApiDeleteDevice
     */
    readonly id: string
}

/**
 * Request parameters for getDeviceInfo operation in DevicesApi.
 * @export
 * @interface DevicesApiGetDeviceInfoRequest
 */
export interface DevicesApiGetDeviceInfoRequest {
    /**
     * 
     * @type {string}
     * @memberof DevicesApiGetDeviceInfo
     */
    readonly id: string
}

/**
 * Request parameters for getDeviceOptions operation in DevicesApi.
 * @export
 * @interface DevicesApiGetDeviceOptionsRequest
 */
export interface DevicesApiGetDeviceOptionsRequest {
    /**
     * 
     * @type {string}
     * @memberof DevicesApiGetDeviceOptions
     */
    readonly id: string
}

/**
 * Request parameters for getDevices operation in DevicesApi.
 * @export
 * @interface DevicesApiGetDevicesRequest
 */
export interface DevicesApiGetDevicesRequest {
    /**
     * 
     * @type {boolean}
     * @memberof DevicesApiGetDevices
     */
    readonly supportsSync?: boolean

    /**
     * 
     * @type {string}
     * @memberof DevicesApiGetDevices
     */
    readonly userId?: string
}

/**
 * Request parameters for updateDeviceOptions operation in DevicesApi.
 * @export
 * @interface DevicesApiUpdateDeviceOptionsRequest
 */
export interface DevicesApiUpdateDeviceOptionsRequest {
    /**
     * 
     * @type {string}
     * @memberof DevicesApiUpdateDeviceOptions
     */
    readonly id: string

    /**
     * 
     * @type {DeviceOptions}
     * @memberof DevicesApiUpdateDeviceOptions
     */
    readonly deviceOptions: DeviceOptions
}

/**
 * DevicesApi - object-oriented interface
 * @export
 * @class DevicesApi
 * @extends {BaseAPI}
 */
export class DevicesApi extends BaseAPI {
    /**
     * 
     * @param {DevicesApiDeleteDeviceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public deleteDevice(requestParameters: DevicesApiDeleteDeviceRequest, options?: any) {
        return DevicesApiFp(this.configuration).deleteDevice(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DevicesApiGetDeviceInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public getDeviceInfo(requestParameters: DevicesApiGetDeviceInfoRequest, options?: any) {
        return DevicesApiFp(this.configuration).getDeviceInfo(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DevicesApiGetDeviceOptionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public getDeviceOptions(requestParameters: DevicesApiGetDeviceOptionsRequest, options?: any) {
        return DevicesApiFp(this.configuration).getDeviceOptions(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DevicesApiGetDevicesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public getDevices(requestParameters: DevicesApiGetDevicesRequest = {}, options?: any) {
        return DevicesApiFp(this.configuration).getDevices(requestParameters.supportsSync, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DevicesApiUpdateDeviceOptionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public updateDeviceOptions(requestParameters: DevicesApiUpdateDeviceOptionsRequest, options?: any) {
        return DevicesApiFp(this.configuration).updateDeviceOptions(requestParameters.id, requestParameters.deviceOptions, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DisplayPreferencesApi - axios parameter creator
 * @export
 */
export const DisplayPreferencesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} displayPreferencesId 
         * @param {string} userId 
         * @param {string} client 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDisplayPreferences: async (displayPreferencesId: string, userId: string, client: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'displayPreferencesId' is not null or undefined
            if (displayPreferencesId === null || displayPreferencesId === undefined) {
                throw new RequiredError('displayPreferencesId','Required parameter displayPreferencesId was null or undefined when calling getDisplayPreferences.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getDisplayPreferences.');
            }
            // verify required parameter 'client' is not null or undefined
            if (client === null || client === undefined) {
                throw new RequiredError('client','Required parameter client was null or undefined when calling getDisplayPreferences.');
            }
            const localVarPath = `/DisplayPreferences/{displayPreferencesId}`
                .replace(`{${"displayPreferencesId"}}`, encodeURIComponent(String(displayPreferencesId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (client !== undefined) {
                localVarQueryParameter['client'] = client;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} displayPreferencesId 
         * @param {string} userId 
         * @param {string} client 
         * @param {DisplayPreferencesDto} displayPreferencesDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDisplayPreferences: async (displayPreferencesId: string, userId: string, client: string, displayPreferencesDto: DisplayPreferencesDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'displayPreferencesId' is not null or undefined
            if (displayPreferencesId === null || displayPreferencesId === undefined) {
                throw new RequiredError('displayPreferencesId','Required parameter displayPreferencesId was null or undefined when calling updateDisplayPreferences.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling updateDisplayPreferences.');
            }
            // verify required parameter 'client' is not null or undefined
            if (client === null || client === undefined) {
                throw new RequiredError('client','Required parameter client was null or undefined when calling updateDisplayPreferences.');
            }
            // verify required parameter 'displayPreferencesDto' is not null or undefined
            if (displayPreferencesDto === null || displayPreferencesDto === undefined) {
                throw new RequiredError('displayPreferencesDto','Required parameter displayPreferencesDto was null or undefined when calling updateDisplayPreferences.');
            }
            const localVarPath = `/DisplayPreferences/{displayPreferencesId}`
                .replace(`{${"displayPreferencesId"}}`, encodeURIComponent(String(displayPreferencesId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (client !== undefined) {
                localVarQueryParameter['client'] = client;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof displayPreferencesDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(displayPreferencesDto !== undefined ? displayPreferencesDto : {}) : (displayPreferencesDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DisplayPreferencesApi - functional programming interface
 * @export
 */
export const DisplayPreferencesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} displayPreferencesId 
         * @param {string} userId 
         * @param {string} client 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDisplayPreferences(displayPreferencesId: string, userId: string, client: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DisplayPreferencesDto>> {
            const localVarAxiosArgs = await DisplayPreferencesApiAxiosParamCreator(configuration).getDisplayPreferences(displayPreferencesId, userId, client, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} displayPreferencesId 
         * @param {string} userId 
         * @param {string} client 
         * @param {DisplayPreferencesDto} displayPreferencesDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDisplayPreferences(displayPreferencesId: string, userId: string, client: string, displayPreferencesDto: DisplayPreferencesDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DisplayPreferencesApiAxiosParamCreator(configuration).updateDisplayPreferences(displayPreferencesId, userId, client, displayPreferencesDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DisplayPreferencesApi - factory interface
 * @export
 */
export const DisplayPreferencesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} displayPreferencesId 
         * @param {string} userId 
         * @param {string} client 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDisplayPreferences(displayPreferencesId: string, userId: string, client: string, options?: any): AxiosPromise<DisplayPreferencesDto> {
            return DisplayPreferencesApiFp(configuration).getDisplayPreferences(displayPreferencesId, userId, client, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} displayPreferencesId 
         * @param {string} userId 
         * @param {string} client 
         * @param {DisplayPreferencesDto} displayPreferencesDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDisplayPreferences(displayPreferencesId: string, userId: string, client: string, displayPreferencesDto: DisplayPreferencesDto, options?: any): AxiosPromise<void> {
            return DisplayPreferencesApiFp(configuration).updateDisplayPreferences(displayPreferencesId, userId, client, displayPreferencesDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getDisplayPreferences operation in DisplayPreferencesApi.
 * @export
 * @interface DisplayPreferencesApiGetDisplayPreferencesRequest
 */
export interface DisplayPreferencesApiGetDisplayPreferencesRequest {
    /**
     * 
     * @type {string}
     * @memberof DisplayPreferencesApiGetDisplayPreferences
     */
    readonly displayPreferencesId: string

    /**
     * 
     * @type {string}
     * @memberof DisplayPreferencesApiGetDisplayPreferences
     */
    readonly userId: string

    /**
     * 
     * @type {string}
     * @memberof DisplayPreferencesApiGetDisplayPreferences
     */
    readonly client: string
}

/**
 * Request parameters for updateDisplayPreferences operation in DisplayPreferencesApi.
 * @export
 * @interface DisplayPreferencesApiUpdateDisplayPreferencesRequest
 */
export interface DisplayPreferencesApiUpdateDisplayPreferencesRequest {
    /**
     * 
     * @type {string}
     * @memberof DisplayPreferencesApiUpdateDisplayPreferences
     */
    readonly displayPreferencesId: string

    /**
     * 
     * @type {string}
     * @memberof DisplayPreferencesApiUpdateDisplayPreferences
     */
    readonly userId: string

    /**
     * 
     * @type {string}
     * @memberof DisplayPreferencesApiUpdateDisplayPreferences
     */
    readonly client: string

    /**
     * 
     * @type {DisplayPreferencesDto}
     * @memberof DisplayPreferencesApiUpdateDisplayPreferences
     */
    readonly displayPreferencesDto: DisplayPreferencesDto
}

/**
 * DisplayPreferencesApi - object-oriented interface
 * @export
 * @class DisplayPreferencesApi
 * @extends {BaseAPI}
 */
export class DisplayPreferencesApi extends BaseAPI {
    /**
     * 
     * @param {DisplayPreferencesApiGetDisplayPreferencesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisplayPreferencesApi
     */
    public getDisplayPreferences(requestParameters: DisplayPreferencesApiGetDisplayPreferencesRequest, options?: any) {
        return DisplayPreferencesApiFp(this.configuration).getDisplayPreferences(requestParameters.displayPreferencesId, requestParameters.userId, requestParameters.client, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DisplayPreferencesApiUpdateDisplayPreferencesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisplayPreferencesApi
     */
    public updateDisplayPreferences(requestParameters: DisplayPreferencesApiUpdateDisplayPreferencesRequest, options?: any) {
        return DisplayPreferencesApiFp(this.configuration).updateDisplayPreferences(requestParameters.displayPreferencesId, requestParameters.userId, requestParameters.client, requestParameters.displayPreferencesDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DlnaApi - axios parameter creator
 * @export
 */
export const DlnaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {DeviceProfile} [deviceProfile] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProfile: async (deviceProfile?: DeviceProfile, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Dlna/Profiles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof deviceProfile !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(deviceProfile !== undefined ? deviceProfile : {}) : (deviceProfile || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} profileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProfile: async (profileId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'profileId' is not null or undefined
            if (profileId === null || profileId === undefined) {
                throw new RequiredError('profileId','Required parameter profileId was null or undefined when calling deleteProfile.');
            }
            const localVarPath = `/Dlna/Profiles/{profileId}`
                .replace(`{${"profileId"}}`, encodeURIComponent(String(profileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultProfile: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Dlna/Profiles/Default`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} profileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfile: async (profileId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'profileId' is not null or undefined
            if (profileId === null || profileId === undefined) {
                throw new RequiredError('profileId','Required parameter profileId was null or undefined when calling getProfile.');
            }
            const localVarPath = `/Dlna/Profiles/{profileId}`
                .replace(`{${"profileId"}}`, encodeURIComponent(String(profileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfileInfos: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Dlna/ProfileInfos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} profileId 
         * @param {DeviceProfile} [deviceProfile] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProfile: async (profileId: string, deviceProfile?: DeviceProfile, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'profileId' is not null or undefined
            if (profileId === null || profileId === undefined) {
                throw new RequiredError('profileId','Required parameter profileId was null or undefined when calling updateProfile.');
            }
            const localVarPath = `/Dlna/Profiles/{profileId}`
                .replace(`{${"profileId"}}`, encodeURIComponent(String(profileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof deviceProfile !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(deviceProfile !== undefined ? deviceProfile : {}) : (deviceProfile || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DlnaApi - functional programming interface
 * @export
 */
export const DlnaApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {DeviceProfile} [deviceProfile] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProfile(deviceProfile?: DeviceProfile, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DlnaApiAxiosParamCreator(configuration).createProfile(deviceProfile, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} profileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProfile(profileId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DlnaApiAxiosParamCreator(configuration).deleteProfile(profileId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDefaultProfile(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceProfile>> {
            const localVarAxiosArgs = await DlnaApiAxiosParamCreator(configuration).getDefaultProfile(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} profileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProfile(profileId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceProfile>> {
            const localVarAxiosArgs = await DlnaApiAxiosParamCreator(configuration).getProfile(profileId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProfileInfos(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DeviceProfileInfo>>> {
            const localVarAxiosArgs = await DlnaApiAxiosParamCreator(configuration).getProfileInfos(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} profileId 
         * @param {DeviceProfile} [deviceProfile] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProfile(profileId: string, deviceProfile?: DeviceProfile, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DlnaApiAxiosParamCreator(configuration).updateProfile(profileId, deviceProfile, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DlnaApi - factory interface
 * @export
 */
export const DlnaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {DeviceProfile} [deviceProfile] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProfile(deviceProfile?: DeviceProfile, options?: any): AxiosPromise<void> {
            return DlnaApiFp(configuration).createProfile(deviceProfile, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} profileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProfile(profileId: string, options?: any): AxiosPromise<void> {
            return DlnaApiFp(configuration).deleteProfile(profileId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultProfile(options?: any): AxiosPromise<DeviceProfile> {
            return DlnaApiFp(configuration).getDefaultProfile(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} profileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfile(profileId: string, options?: any): AxiosPromise<DeviceProfile> {
            return DlnaApiFp(configuration).getProfile(profileId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfileInfos(options?: any): AxiosPromise<Array<DeviceProfileInfo>> {
            return DlnaApiFp(configuration).getProfileInfos(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} profileId 
         * @param {DeviceProfile} [deviceProfile] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProfile(profileId: string, deviceProfile?: DeviceProfile, options?: any): AxiosPromise<void> {
            return DlnaApiFp(configuration).updateProfile(profileId, deviceProfile, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createProfile operation in DlnaApi.
 * @export
 * @interface DlnaApiCreateProfileRequest
 */
export interface DlnaApiCreateProfileRequest {
    /**
     * 
     * @type {DeviceProfile}
     * @memberof DlnaApiCreateProfile
     */
    readonly deviceProfile?: DeviceProfile
}

/**
 * Request parameters for deleteProfile operation in DlnaApi.
 * @export
 * @interface DlnaApiDeleteProfileRequest
 */
export interface DlnaApiDeleteProfileRequest {
    /**
     * 
     * @type {string}
     * @memberof DlnaApiDeleteProfile
     */
    readonly profileId: string
}

/**
 * Request parameters for getProfile operation in DlnaApi.
 * @export
 * @interface DlnaApiGetProfileRequest
 */
export interface DlnaApiGetProfileRequest {
    /**
     * 
     * @type {string}
     * @memberof DlnaApiGetProfile
     */
    readonly profileId: string
}

/**
 * Request parameters for updateProfile operation in DlnaApi.
 * @export
 * @interface DlnaApiUpdateProfileRequest
 */
export interface DlnaApiUpdateProfileRequest {
    /**
     * 
     * @type {string}
     * @memberof DlnaApiUpdateProfile
     */
    readonly profileId: string

    /**
     * 
     * @type {DeviceProfile}
     * @memberof DlnaApiUpdateProfile
     */
    readonly deviceProfile?: DeviceProfile
}

/**
 * DlnaApi - object-oriented interface
 * @export
 * @class DlnaApi
 * @extends {BaseAPI}
 */
export class DlnaApi extends BaseAPI {
    /**
     * 
     * @param {DlnaApiCreateProfileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DlnaApi
     */
    public createProfile(requestParameters: DlnaApiCreateProfileRequest = {}, options?: any) {
        return DlnaApiFp(this.configuration).createProfile(requestParameters.deviceProfile, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DlnaApiDeleteProfileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DlnaApi
     */
    public deleteProfile(requestParameters: DlnaApiDeleteProfileRequest, options?: any) {
        return DlnaApiFp(this.configuration).deleteProfile(requestParameters.profileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DlnaApi
     */
    public getDefaultProfile(options?: any) {
        return DlnaApiFp(this.configuration).getDefaultProfile(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DlnaApiGetProfileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DlnaApi
     */
    public getProfile(requestParameters: DlnaApiGetProfileRequest, options?: any) {
        return DlnaApiFp(this.configuration).getProfile(requestParameters.profileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DlnaApi
     */
    public getProfileInfos(options?: any) {
        return DlnaApiFp(this.configuration).getProfileInfos(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DlnaApiUpdateProfileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DlnaApi
     */
    public updateProfile(requestParameters: DlnaApiUpdateProfileRequest, options?: any) {
        return DlnaApiFp(this.configuration).updateProfile(requestParameters.profileId, requestParameters.deviceProfile, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DlnaServerApi - axios parameter creator
 * @export
 */
export const DlnaServerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} serverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectionManager: async (serverId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling getConnectionManager.');
            }
            const localVarPath = `/Dlna/{serverId}/ConnectionManager`
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} serverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectionManager2: async (serverId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling getConnectionManager2.');
            }
            const localVarPath = `/Dlna/{serverId}/ConnectionManager.xml`
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} serverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentDirectory: async (serverId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling getContentDirectory.');
            }
            const localVarPath = `/Dlna/{serverId}/ContentDirectory`
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} serverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentDirectory2: async (serverId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling getContentDirectory2.');
            }
            const localVarPath = `/Dlna/{serverId}/ContentDirectory.xml`
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} serverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDescriptionXml: async (serverId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling getDescriptionXml.');
            }
            const localVarPath = `/Dlna/{serverId}/description`
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} serverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDescriptionXml2: async (serverId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling getDescriptionXml2.');
            }
            const localVarPath = `/Dlna/{serverId}/description.xml`
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} fileName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIcon: async (fileName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileName' is not null or undefined
            if (fileName === null || fileName === undefined) {
                throw new RequiredError('fileName','Required parameter fileName was null or undefined when calling getIcon.');
            }
            const localVarPath = `/Dlna/icons/{fileName}`
                .replace(`{${"fileName"}}`, encodeURIComponent(String(fileName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} serverId 
         * @param {string} fileName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIconId: async (serverId: string, fileName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling getIconId.');
            }
            // verify required parameter 'fileName' is not null or undefined
            if (fileName === null || fileName === undefined) {
                throw new RequiredError('fileName','Required parameter fileName was null or undefined when calling getIconId.');
            }
            const localVarPath = `/Dlna/{serverId}/icons/{fileName}`
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)))
                .replace(`{${"fileName"}}`, encodeURIComponent(String(fileName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} serverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediaReceiverRegistrar: async (serverId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling getMediaReceiverRegistrar.');
            }
            const localVarPath = `/Dlna/{serverId}/MediaReceiverRegistrar`
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} serverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediaReceiverRegistrar2: async (serverId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling getMediaReceiverRegistrar2.');
            }
            const localVarPath = `/Dlna/{serverId}/MediaReceiverRegistrar.xml`
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} serverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processConnectionManagerControlRequest: async (serverId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling processConnectionManagerControlRequest.');
            }
            const localVarPath = `/Dlna/{serverId}/ConnectionManager/Control`
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} serverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processContentDirectoryControlRequest: async (serverId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling processContentDirectoryControlRequest.');
            }
            const localVarPath = `/Dlna/{serverId}/ContentDirectory/Control`
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} serverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processMediaReceiverRegistrarControlRequest: async (serverId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling processMediaReceiverRegistrarControlRequest.');
            }
            const localVarPath = `/Dlna/{serverId}/MediaReceiverRegistrar/Control`
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DlnaServerApi - functional programming interface
 * @export
 */
export const DlnaServerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} serverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConnectionManager(serverId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DlnaServerApiAxiosParamCreator(configuration).getConnectionManager(serverId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} serverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConnectionManager2(serverId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DlnaServerApiAxiosParamCreator(configuration).getConnectionManager2(serverId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} serverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContentDirectory(serverId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DlnaServerApiAxiosParamCreator(configuration).getContentDirectory(serverId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} serverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContentDirectory2(serverId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DlnaServerApiAxiosParamCreator(configuration).getContentDirectory2(serverId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} serverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDescriptionXml(serverId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DlnaServerApiAxiosParamCreator(configuration).getDescriptionXml(serverId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} serverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDescriptionXml2(serverId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DlnaServerApiAxiosParamCreator(configuration).getDescriptionXml2(serverId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} fileName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIcon(fileName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DlnaServerApiAxiosParamCreator(configuration).getIcon(fileName, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} serverId 
         * @param {string} fileName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIconId(serverId: string, fileName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DlnaServerApiAxiosParamCreator(configuration).getIconId(serverId, fileName, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} serverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMediaReceiverRegistrar(serverId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DlnaServerApiAxiosParamCreator(configuration).getMediaReceiverRegistrar(serverId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} serverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMediaReceiverRegistrar2(serverId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DlnaServerApiAxiosParamCreator(configuration).getMediaReceiverRegistrar2(serverId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} serverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async processConnectionManagerControlRequest(serverId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ControlResponse>> {
            const localVarAxiosArgs = await DlnaServerApiAxiosParamCreator(configuration).processConnectionManagerControlRequest(serverId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} serverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async processContentDirectoryControlRequest(serverId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ControlResponse>> {
            const localVarAxiosArgs = await DlnaServerApiAxiosParamCreator(configuration).processContentDirectoryControlRequest(serverId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} serverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async processMediaReceiverRegistrarControlRequest(serverId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ControlResponse>> {
            const localVarAxiosArgs = await DlnaServerApiAxiosParamCreator(configuration).processMediaReceiverRegistrarControlRequest(serverId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DlnaServerApi - factory interface
 * @export
 */
export const DlnaServerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} serverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectionManager(serverId: string, options?: any): AxiosPromise<void> {
            return DlnaServerApiFp(configuration).getConnectionManager(serverId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} serverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectionManager2(serverId: string, options?: any): AxiosPromise<void> {
            return DlnaServerApiFp(configuration).getConnectionManager2(serverId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} serverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentDirectory(serverId: string, options?: any): AxiosPromise<void> {
            return DlnaServerApiFp(configuration).getContentDirectory(serverId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} serverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentDirectory2(serverId: string, options?: any): AxiosPromise<void> {
            return DlnaServerApiFp(configuration).getContentDirectory2(serverId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} serverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDescriptionXml(serverId: string, options?: any): AxiosPromise<void> {
            return DlnaServerApiFp(configuration).getDescriptionXml(serverId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} serverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDescriptionXml2(serverId: string, options?: any): AxiosPromise<void> {
            return DlnaServerApiFp(configuration).getDescriptionXml2(serverId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} fileName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIcon(fileName: string, options?: any): AxiosPromise<void> {
            return DlnaServerApiFp(configuration).getIcon(fileName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} serverId 
         * @param {string} fileName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIconId(serverId: string, fileName: string, options?: any): AxiosPromise<void> {
            return DlnaServerApiFp(configuration).getIconId(serverId, fileName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} serverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediaReceiverRegistrar(serverId: string, options?: any): AxiosPromise<void> {
            return DlnaServerApiFp(configuration).getMediaReceiverRegistrar(serverId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} serverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediaReceiverRegistrar2(serverId: string, options?: any): AxiosPromise<void> {
            return DlnaServerApiFp(configuration).getMediaReceiverRegistrar2(serverId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} serverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processConnectionManagerControlRequest(serverId: string, options?: any): AxiosPromise<ControlResponse> {
            return DlnaServerApiFp(configuration).processConnectionManagerControlRequest(serverId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} serverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processContentDirectoryControlRequest(serverId: string, options?: any): AxiosPromise<ControlResponse> {
            return DlnaServerApiFp(configuration).processContentDirectoryControlRequest(serverId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} serverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processMediaReceiverRegistrarControlRequest(serverId: string, options?: any): AxiosPromise<ControlResponse> {
            return DlnaServerApiFp(configuration).processMediaReceiverRegistrarControlRequest(serverId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getConnectionManager operation in DlnaServerApi.
 * @export
 * @interface DlnaServerApiGetConnectionManagerRequest
 */
export interface DlnaServerApiGetConnectionManagerRequest {
    /**
     * 
     * @type {string}
     * @memberof DlnaServerApiGetConnectionManager
     */
    readonly serverId: string
}

/**
 * Request parameters for getConnectionManager2 operation in DlnaServerApi.
 * @export
 * @interface DlnaServerApiGetConnectionManager2Request
 */
export interface DlnaServerApiGetConnectionManager2Request {
    /**
     * 
     * @type {string}
     * @memberof DlnaServerApiGetConnectionManager2
     */
    readonly serverId: string
}

/**
 * Request parameters for getContentDirectory operation in DlnaServerApi.
 * @export
 * @interface DlnaServerApiGetContentDirectoryRequest
 */
export interface DlnaServerApiGetContentDirectoryRequest {
    /**
     * 
     * @type {string}
     * @memberof DlnaServerApiGetContentDirectory
     */
    readonly serverId: string
}

/**
 * Request parameters for getContentDirectory2 operation in DlnaServerApi.
 * @export
 * @interface DlnaServerApiGetContentDirectory2Request
 */
export interface DlnaServerApiGetContentDirectory2Request {
    /**
     * 
     * @type {string}
     * @memberof DlnaServerApiGetContentDirectory2
     */
    readonly serverId: string
}

/**
 * Request parameters for getDescriptionXml operation in DlnaServerApi.
 * @export
 * @interface DlnaServerApiGetDescriptionXmlRequest
 */
export interface DlnaServerApiGetDescriptionXmlRequest {
    /**
     * 
     * @type {string}
     * @memberof DlnaServerApiGetDescriptionXml
     */
    readonly serverId: string
}

/**
 * Request parameters for getDescriptionXml2 operation in DlnaServerApi.
 * @export
 * @interface DlnaServerApiGetDescriptionXml2Request
 */
export interface DlnaServerApiGetDescriptionXml2Request {
    /**
     * 
     * @type {string}
     * @memberof DlnaServerApiGetDescriptionXml2
     */
    readonly serverId: string
}

/**
 * Request parameters for getIcon operation in DlnaServerApi.
 * @export
 * @interface DlnaServerApiGetIconRequest
 */
export interface DlnaServerApiGetIconRequest {
    /**
     * 
     * @type {string}
     * @memberof DlnaServerApiGetIcon
     */
    readonly fileName: string
}

/**
 * Request parameters for getIconId operation in DlnaServerApi.
 * @export
 * @interface DlnaServerApiGetIconIdRequest
 */
export interface DlnaServerApiGetIconIdRequest {
    /**
     * 
     * @type {string}
     * @memberof DlnaServerApiGetIconId
     */
    readonly serverId: string

    /**
     * 
     * @type {string}
     * @memberof DlnaServerApiGetIconId
     */
    readonly fileName: string
}

/**
 * Request parameters for getMediaReceiverRegistrar operation in DlnaServerApi.
 * @export
 * @interface DlnaServerApiGetMediaReceiverRegistrarRequest
 */
export interface DlnaServerApiGetMediaReceiverRegistrarRequest {
    /**
     * 
     * @type {string}
     * @memberof DlnaServerApiGetMediaReceiverRegistrar
     */
    readonly serverId: string
}

/**
 * Request parameters for getMediaReceiverRegistrar2 operation in DlnaServerApi.
 * @export
 * @interface DlnaServerApiGetMediaReceiverRegistrar2Request
 */
export interface DlnaServerApiGetMediaReceiverRegistrar2Request {
    /**
     * 
     * @type {string}
     * @memberof DlnaServerApiGetMediaReceiverRegistrar2
     */
    readonly serverId: string
}

/**
 * Request parameters for processConnectionManagerControlRequest operation in DlnaServerApi.
 * @export
 * @interface DlnaServerApiProcessConnectionManagerControlRequestRequest
 */
export interface DlnaServerApiProcessConnectionManagerControlRequestRequest {
    /**
     * 
     * @type {string}
     * @memberof DlnaServerApiProcessConnectionManagerControlRequest
     */
    readonly serverId: string
}

/**
 * Request parameters for processContentDirectoryControlRequest operation in DlnaServerApi.
 * @export
 * @interface DlnaServerApiProcessContentDirectoryControlRequestRequest
 */
export interface DlnaServerApiProcessContentDirectoryControlRequestRequest {
    /**
     * 
     * @type {string}
     * @memberof DlnaServerApiProcessContentDirectoryControlRequest
     */
    readonly serverId: string
}

/**
 * Request parameters for processMediaReceiverRegistrarControlRequest operation in DlnaServerApi.
 * @export
 * @interface DlnaServerApiProcessMediaReceiverRegistrarControlRequestRequest
 */
export interface DlnaServerApiProcessMediaReceiverRegistrarControlRequestRequest {
    /**
     * 
     * @type {string}
     * @memberof DlnaServerApiProcessMediaReceiverRegistrarControlRequest
     */
    readonly serverId: string
}

/**
 * DlnaServerApi - object-oriented interface
 * @export
 * @class DlnaServerApi
 * @extends {BaseAPI}
 */
export class DlnaServerApi extends BaseAPI {
    /**
     * 
     * @param {DlnaServerApiGetConnectionManagerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DlnaServerApi
     */
    public getConnectionManager(requestParameters: DlnaServerApiGetConnectionManagerRequest, options?: any) {
        return DlnaServerApiFp(this.configuration).getConnectionManager(requestParameters.serverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DlnaServerApiGetConnectionManager2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DlnaServerApi
     */
    public getConnectionManager2(requestParameters: DlnaServerApiGetConnectionManager2Request, options?: any) {
        return DlnaServerApiFp(this.configuration).getConnectionManager2(requestParameters.serverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DlnaServerApiGetContentDirectoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DlnaServerApi
     */
    public getContentDirectory(requestParameters: DlnaServerApiGetContentDirectoryRequest, options?: any) {
        return DlnaServerApiFp(this.configuration).getContentDirectory(requestParameters.serverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DlnaServerApiGetContentDirectory2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DlnaServerApi
     */
    public getContentDirectory2(requestParameters: DlnaServerApiGetContentDirectory2Request, options?: any) {
        return DlnaServerApiFp(this.configuration).getContentDirectory2(requestParameters.serverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DlnaServerApiGetDescriptionXmlRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DlnaServerApi
     */
    public getDescriptionXml(requestParameters: DlnaServerApiGetDescriptionXmlRequest, options?: any) {
        return DlnaServerApiFp(this.configuration).getDescriptionXml(requestParameters.serverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DlnaServerApiGetDescriptionXml2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DlnaServerApi
     */
    public getDescriptionXml2(requestParameters: DlnaServerApiGetDescriptionXml2Request, options?: any) {
        return DlnaServerApiFp(this.configuration).getDescriptionXml2(requestParameters.serverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DlnaServerApiGetIconRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DlnaServerApi
     */
    public getIcon(requestParameters: DlnaServerApiGetIconRequest, options?: any) {
        return DlnaServerApiFp(this.configuration).getIcon(requestParameters.fileName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DlnaServerApiGetIconIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DlnaServerApi
     */
    public getIconId(requestParameters: DlnaServerApiGetIconIdRequest, options?: any) {
        return DlnaServerApiFp(this.configuration).getIconId(requestParameters.serverId, requestParameters.fileName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DlnaServerApiGetMediaReceiverRegistrarRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DlnaServerApi
     */
    public getMediaReceiverRegistrar(requestParameters: DlnaServerApiGetMediaReceiverRegistrarRequest, options?: any) {
        return DlnaServerApiFp(this.configuration).getMediaReceiverRegistrar(requestParameters.serverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DlnaServerApiGetMediaReceiverRegistrar2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DlnaServerApi
     */
    public getMediaReceiverRegistrar2(requestParameters: DlnaServerApiGetMediaReceiverRegistrar2Request, options?: any) {
        return DlnaServerApiFp(this.configuration).getMediaReceiverRegistrar2(requestParameters.serverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DlnaServerApiProcessConnectionManagerControlRequestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DlnaServerApi
     */
    public processConnectionManagerControlRequest(requestParameters: DlnaServerApiProcessConnectionManagerControlRequestRequest, options?: any) {
        return DlnaServerApiFp(this.configuration).processConnectionManagerControlRequest(requestParameters.serverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DlnaServerApiProcessContentDirectoryControlRequestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DlnaServerApi
     */
    public processContentDirectoryControlRequest(requestParameters: DlnaServerApiProcessContentDirectoryControlRequestRequest, options?: any) {
        return DlnaServerApiFp(this.configuration).processContentDirectoryControlRequest(requestParameters.serverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DlnaServerApiProcessMediaReceiverRegistrarControlRequestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DlnaServerApi
     */
    public processMediaReceiverRegistrarControlRequest(requestParameters: DlnaServerApiProcessMediaReceiverRegistrarControlRequestRequest, options?: any) {
        return DlnaServerApiFp(this.configuration).processMediaReceiverRegistrarControlRequest(requestParameters.serverId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DynamicHlsApi - axios parameter creator
 * @export
 */
export const DynamicHlsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} itemId 
         * @param {string} playlistId 
         * @param {number} segmentId 
         * @param {string} container 
         * @param {boolean} [_static] 
         * @param {string} [params] 
         * @param {string} [tag] 
         * @param {string} [deviceProfileId] 
         * @param {string} [playSessionId] 
         * @param {string} [segmentContainer] 
         * @param {number} [segmentLength] 
         * @param {number} [minSegments] 
         * @param {string} [mediaSourceId] 
         * @param {string} [deviceId] 
         * @param {string} [audioCodec] 
         * @param {boolean} [enableAutoStreamCopy] 
         * @param {boolean} [allowVideoStreamCopy] 
         * @param {boolean} [allowAudioStreamCopy] 
         * @param {boolean} [breakOnNonKeyFrames] 
         * @param {number} [audioSampleRate] 
         * @param {number} [maxAudioBitDepth] 
         * @param {number} [audioBitRate] 
         * @param {number} [audioChannels] 
         * @param {number} [maxAudioChannels] 
         * @param {string} [profile] 
         * @param {string} [level] 
         * @param {number} [framerate] 
         * @param {number} [maxFramerate] 
         * @param {boolean} [copyTimestamps] 
         * @param {number} [startTimeTicks] 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [videoBitRate] 
         * @param {number} [subtitleStreamIndex] 
         * @param {SubtitleDeliveryMethod} [subtitleMethod] 
         * @param {number} [maxRefFrames] 
         * @param {number} [maxVideoBitDepth] 
         * @param {boolean} [requireAvc] 
         * @param {boolean} [deInterlace] 
         * @param {boolean} [requireNonAnamorphic] 
         * @param {number} [transcodingMaxAudioChannels] 
         * @param {number} [cpuCoreLimit] 
         * @param {string} [liveStreamId] 
         * @param {boolean} [enableMpegtsM2TsMode] 
         * @param {string} [videoCodec] 
         * @param {string} [subtitleCodec] 
         * @param {string} [transcodingReasons] 
         * @param {number} [audioStreamIndex] 
         * @param {number} [videoStreamIndex] 
         * @param {EncodingContext} [context] 
         * @param {{ [key: string]: string; }} [streamOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHlsAudioSegment: async (itemId: string, playlistId: string, segmentId: number, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getHlsAudioSegment.');
            }
            // verify required parameter 'playlistId' is not null or undefined
            if (playlistId === null || playlistId === undefined) {
                throw new RequiredError('playlistId','Required parameter playlistId was null or undefined when calling getHlsAudioSegment.');
            }
            // verify required parameter 'segmentId' is not null or undefined
            if (segmentId === null || segmentId === undefined) {
                throw new RequiredError('segmentId','Required parameter segmentId was null or undefined when calling getHlsAudioSegment.');
            }
            // verify required parameter 'container' is not null or undefined
            if (container === null || container === undefined) {
                throw new RequiredError('container','Required parameter container was null or undefined when calling getHlsAudioSegment.');
            }
            const localVarPath = `/Audio/{itemId}/hls1/{playlistId}/{segmentId}.{container}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"playlistId"}}`, encodeURIComponent(String(playlistId)))
                .replace(`{${"segmentId"}}`, encodeURIComponent(String(segmentId)))
                .replace(`{${"container"}}`, encodeURIComponent(String(container)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (_static !== undefined) {
                localVarQueryParameter['static'] = _static;
            }

            if (params !== undefined) {
                localVarQueryParameter['params'] = params;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (deviceProfileId !== undefined) {
                localVarQueryParameter['deviceProfileId'] = deviceProfileId;
            }

            if (playSessionId !== undefined) {
                localVarQueryParameter['playSessionId'] = playSessionId;
            }

            if (segmentContainer !== undefined) {
                localVarQueryParameter['segmentContainer'] = segmentContainer;
            }

            if (segmentLength !== undefined) {
                localVarQueryParameter['segmentLength'] = segmentLength;
            }

            if (minSegments !== undefined) {
                localVarQueryParameter['minSegments'] = minSegments;
            }

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['mediaSourceId'] = mediaSourceId;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (audioCodec !== undefined) {
                localVarQueryParameter['audioCodec'] = audioCodec;
            }

            if (enableAutoStreamCopy !== undefined) {
                localVarQueryParameter['enableAutoStreamCopy'] = enableAutoStreamCopy;
            }

            if (allowVideoStreamCopy !== undefined) {
                localVarQueryParameter['allowVideoStreamCopy'] = allowVideoStreamCopy;
            }

            if (allowAudioStreamCopy !== undefined) {
                localVarQueryParameter['allowAudioStreamCopy'] = allowAudioStreamCopy;
            }

            if (breakOnNonKeyFrames !== undefined) {
                localVarQueryParameter['breakOnNonKeyFrames'] = breakOnNonKeyFrames;
            }

            if (audioSampleRate !== undefined) {
                localVarQueryParameter['audioSampleRate'] = audioSampleRate;
            }

            if (maxAudioBitDepth !== undefined) {
                localVarQueryParameter['maxAudioBitDepth'] = maxAudioBitDepth;
            }

            if (audioBitRate !== undefined) {
                localVarQueryParameter['audioBitRate'] = audioBitRate;
            }

            if (audioChannels !== undefined) {
                localVarQueryParameter['audioChannels'] = audioChannels;
            }

            if (maxAudioChannels !== undefined) {
                localVarQueryParameter['maxAudioChannels'] = maxAudioChannels;
            }

            if (profile !== undefined) {
                localVarQueryParameter['profile'] = profile;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (framerate !== undefined) {
                localVarQueryParameter['framerate'] = framerate;
            }

            if (maxFramerate !== undefined) {
                localVarQueryParameter['maxFramerate'] = maxFramerate;
            }

            if (copyTimestamps !== undefined) {
                localVarQueryParameter['copyTimestamps'] = copyTimestamps;
            }

            if (startTimeTicks !== undefined) {
                localVarQueryParameter['startTimeTicks'] = startTimeTicks;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (videoBitRate !== undefined) {
                localVarQueryParameter['videoBitRate'] = videoBitRate;
            }

            if (subtitleStreamIndex !== undefined) {
                localVarQueryParameter['subtitleStreamIndex'] = subtitleStreamIndex;
            }

            if (subtitleMethod !== undefined) {
                localVarQueryParameter['subtitleMethod'] = subtitleMethod;
            }

            if (maxRefFrames !== undefined) {
                localVarQueryParameter['maxRefFrames'] = maxRefFrames;
            }

            if (maxVideoBitDepth !== undefined) {
                localVarQueryParameter['maxVideoBitDepth'] = maxVideoBitDepth;
            }

            if (requireAvc !== undefined) {
                localVarQueryParameter['requireAvc'] = requireAvc;
            }

            if (deInterlace !== undefined) {
                localVarQueryParameter['deInterlace'] = deInterlace;
            }

            if (requireNonAnamorphic !== undefined) {
                localVarQueryParameter['requireNonAnamorphic'] = requireNonAnamorphic;
            }

            if (transcodingMaxAudioChannels !== undefined) {
                localVarQueryParameter['transcodingMaxAudioChannels'] = transcodingMaxAudioChannels;
            }

            if (cpuCoreLimit !== undefined) {
                localVarQueryParameter['cpuCoreLimit'] = cpuCoreLimit;
            }

            if (liveStreamId !== undefined) {
                localVarQueryParameter['liveStreamId'] = liveStreamId;
            }

            if (enableMpegtsM2TsMode !== undefined) {
                localVarQueryParameter['enableMpegtsM2TsMode'] = enableMpegtsM2TsMode;
            }

            if (videoCodec !== undefined) {
                localVarQueryParameter['videoCodec'] = videoCodec;
            }

            if (subtitleCodec !== undefined) {
                localVarQueryParameter['subtitleCodec'] = subtitleCodec;
            }

            if (transcodingReasons !== undefined) {
                localVarQueryParameter['transcodingReasons'] = transcodingReasons;
            }

            if (audioStreamIndex !== undefined) {
                localVarQueryParameter['audioStreamIndex'] = audioStreamIndex;
            }

            if (videoStreamIndex !== undefined) {
                localVarQueryParameter['videoStreamIndex'] = videoStreamIndex;
            }

            if (context !== undefined) {
                localVarQueryParameter['context'] = context;
            }

            if (streamOptions !== undefined) {
                localVarQueryParameter['streamOptions'] = streamOptions;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} playlistId 
         * @param {number} segmentId 
         * @param {string} container 
         * @param {boolean} [_static] 
         * @param {string} [params] 
         * @param {string} [tag] 
         * @param {string} [deviceProfileId] 
         * @param {string} [playSessionId] 
         * @param {string} [segmentContainer] 
         * @param {number} [segmentLength] 
         * @param {number} [minSegments] 
         * @param {string} [mediaSourceId] 
         * @param {string} [deviceId] 
         * @param {string} [audioCodec] 
         * @param {boolean} [enableAutoStreamCopy] 
         * @param {boolean} [allowVideoStreamCopy] 
         * @param {boolean} [allowAudioStreamCopy] 
         * @param {boolean} [breakOnNonKeyFrames] 
         * @param {number} [audioSampleRate] 
         * @param {number} [maxAudioBitDepth] 
         * @param {number} [audioBitRate] 
         * @param {number} [audioChannels] 
         * @param {number} [maxAudioChannels] 
         * @param {string} [profile] 
         * @param {string} [level] 
         * @param {number} [framerate] 
         * @param {number} [maxFramerate] 
         * @param {boolean} [copyTimestamps] 
         * @param {number} [startTimeTicks] 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [videoBitRate] 
         * @param {number} [subtitleStreamIndex] 
         * @param {SubtitleDeliveryMethod} [subtitleMethod] 
         * @param {number} [maxRefFrames] 
         * @param {number} [maxVideoBitDepth] 
         * @param {boolean} [requireAvc] 
         * @param {boolean} [deInterlace] 
         * @param {boolean} [requireNonAnamorphic] 
         * @param {number} [transcodingMaxAudioChannels] 
         * @param {number} [cpuCoreLimit] 
         * @param {string} [liveStreamId] 
         * @param {boolean} [enableMpegtsM2TsMode] 
         * @param {string} [videoCodec] 
         * @param {string} [subtitleCodec] 
         * @param {string} [transcodingReasons] 
         * @param {number} [audioStreamIndex] 
         * @param {number} [videoStreamIndex] 
         * @param {EncodingContext} [context] 
         * @param {{ [key: string]: string; }} [streamOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHlsVideoSegment: async (itemId: string, playlistId: string, segmentId: number, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getHlsVideoSegment.');
            }
            // verify required parameter 'playlistId' is not null or undefined
            if (playlistId === null || playlistId === undefined) {
                throw new RequiredError('playlistId','Required parameter playlistId was null or undefined when calling getHlsVideoSegment.');
            }
            // verify required parameter 'segmentId' is not null or undefined
            if (segmentId === null || segmentId === undefined) {
                throw new RequiredError('segmentId','Required parameter segmentId was null or undefined when calling getHlsVideoSegment.');
            }
            // verify required parameter 'container' is not null or undefined
            if (container === null || container === undefined) {
                throw new RequiredError('container','Required parameter container was null or undefined when calling getHlsVideoSegment.');
            }
            const localVarPath = `/Videos/{itemId}/hls1/{playlistId}/{segmentId}.{container}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"playlistId"}}`, encodeURIComponent(String(playlistId)))
                .replace(`{${"segmentId"}}`, encodeURIComponent(String(segmentId)))
                .replace(`{${"container"}}`, encodeURIComponent(String(container)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (_static !== undefined) {
                localVarQueryParameter['static'] = _static;
            }

            if (params !== undefined) {
                localVarQueryParameter['params'] = params;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (deviceProfileId !== undefined) {
                localVarQueryParameter['deviceProfileId'] = deviceProfileId;
            }

            if (playSessionId !== undefined) {
                localVarQueryParameter['playSessionId'] = playSessionId;
            }

            if (segmentContainer !== undefined) {
                localVarQueryParameter['segmentContainer'] = segmentContainer;
            }

            if (segmentLength !== undefined) {
                localVarQueryParameter['segmentLength'] = segmentLength;
            }

            if (minSegments !== undefined) {
                localVarQueryParameter['minSegments'] = minSegments;
            }

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['mediaSourceId'] = mediaSourceId;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (audioCodec !== undefined) {
                localVarQueryParameter['audioCodec'] = audioCodec;
            }

            if (enableAutoStreamCopy !== undefined) {
                localVarQueryParameter['enableAutoStreamCopy'] = enableAutoStreamCopy;
            }

            if (allowVideoStreamCopy !== undefined) {
                localVarQueryParameter['allowVideoStreamCopy'] = allowVideoStreamCopy;
            }

            if (allowAudioStreamCopy !== undefined) {
                localVarQueryParameter['allowAudioStreamCopy'] = allowAudioStreamCopy;
            }

            if (breakOnNonKeyFrames !== undefined) {
                localVarQueryParameter['breakOnNonKeyFrames'] = breakOnNonKeyFrames;
            }

            if (audioSampleRate !== undefined) {
                localVarQueryParameter['audioSampleRate'] = audioSampleRate;
            }

            if (maxAudioBitDepth !== undefined) {
                localVarQueryParameter['maxAudioBitDepth'] = maxAudioBitDepth;
            }

            if (audioBitRate !== undefined) {
                localVarQueryParameter['audioBitRate'] = audioBitRate;
            }

            if (audioChannels !== undefined) {
                localVarQueryParameter['audioChannels'] = audioChannels;
            }

            if (maxAudioChannels !== undefined) {
                localVarQueryParameter['maxAudioChannels'] = maxAudioChannels;
            }

            if (profile !== undefined) {
                localVarQueryParameter['profile'] = profile;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (framerate !== undefined) {
                localVarQueryParameter['framerate'] = framerate;
            }

            if (maxFramerate !== undefined) {
                localVarQueryParameter['maxFramerate'] = maxFramerate;
            }

            if (copyTimestamps !== undefined) {
                localVarQueryParameter['copyTimestamps'] = copyTimestamps;
            }

            if (startTimeTicks !== undefined) {
                localVarQueryParameter['startTimeTicks'] = startTimeTicks;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (videoBitRate !== undefined) {
                localVarQueryParameter['videoBitRate'] = videoBitRate;
            }

            if (subtitleStreamIndex !== undefined) {
                localVarQueryParameter['subtitleStreamIndex'] = subtitleStreamIndex;
            }

            if (subtitleMethod !== undefined) {
                localVarQueryParameter['subtitleMethod'] = subtitleMethod;
            }

            if (maxRefFrames !== undefined) {
                localVarQueryParameter['maxRefFrames'] = maxRefFrames;
            }

            if (maxVideoBitDepth !== undefined) {
                localVarQueryParameter['maxVideoBitDepth'] = maxVideoBitDepth;
            }

            if (requireAvc !== undefined) {
                localVarQueryParameter['requireAvc'] = requireAvc;
            }

            if (deInterlace !== undefined) {
                localVarQueryParameter['deInterlace'] = deInterlace;
            }

            if (requireNonAnamorphic !== undefined) {
                localVarQueryParameter['requireNonAnamorphic'] = requireNonAnamorphic;
            }

            if (transcodingMaxAudioChannels !== undefined) {
                localVarQueryParameter['transcodingMaxAudioChannels'] = transcodingMaxAudioChannels;
            }

            if (cpuCoreLimit !== undefined) {
                localVarQueryParameter['cpuCoreLimit'] = cpuCoreLimit;
            }

            if (liveStreamId !== undefined) {
                localVarQueryParameter['liveStreamId'] = liveStreamId;
            }

            if (enableMpegtsM2TsMode !== undefined) {
                localVarQueryParameter['enableMpegtsM2TsMode'] = enableMpegtsM2TsMode;
            }

            if (videoCodec !== undefined) {
                localVarQueryParameter['videoCodec'] = videoCodec;
            }

            if (subtitleCodec !== undefined) {
                localVarQueryParameter['subtitleCodec'] = subtitleCodec;
            }

            if (transcodingReasons !== undefined) {
                localVarQueryParameter['transcodingReasons'] = transcodingReasons;
            }

            if (audioStreamIndex !== undefined) {
                localVarQueryParameter['audioStreamIndex'] = audioStreamIndex;
            }

            if (videoStreamIndex !== undefined) {
                localVarQueryParameter['videoStreamIndex'] = videoStreamIndex;
            }

            if (context !== undefined) {
                localVarQueryParameter['context'] = context;
            }

            if (streamOptions !== undefined) {
                localVarQueryParameter['streamOptions'] = streamOptions;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} container 
         * @param {string} mediaSourceId 
         * @param {boolean} [_static] 
         * @param {string} [params] 
         * @param {string} [tag] 
         * @param {string} [deviceProfileId] 
         * @param {string} [playSessionId] 
         * @param {string} [segmentContainer] 
         * @param {number} [segmentLength] 
         * @param {number} [minSegments] 
         * @param {string} [deviceId] 
         * @param {string} [audioCodec] 
         * @param {boolean} [enableAutoStreamCopy] 
         * @param {boolean} [allowVideoStreamCopy] 
         * @param {boolean} [allowAudioStreamCopy] 
         * @param {boolean} [breakOnNonKeyFrames] 
         * @param {number} [audioSampleRate] 
         * @param {number} [maxAudioBitDepth] 
         * @param {number} [audioBitRate] 
         * @param {number} [audioChannels] 
         * @param {number} [maxAudioChannels] 
         * @param {string} [profile] 
         * @param {string} [level] 
         * @param {number} [framerate] 
         * @param {number} [maxFramerate] 
         * @param {boolean} [copyTimestamps] 
         * @param {number} [startTimeTicks] 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [videoBitRate] 
         * @param {number} [subtitleStreamIndex] 
         * @param {SubtitleDeliveryMethod} [subtitleMethod] 
         * @param {number} [maxRefFrames] 
         * @param {number} [maxVideoBitDepth] 
         * @param {boolean} [requireAvc] 
         * @param {boolean} [deInterlace] 
         * @param {boolean} [requireNonAnamorphic] 
         * @param {number} [transcodingMaxAudioChannels] 
         * @param {number} [cpuCoreLimit] 
         * @param {string} [liveStreamId] 
         * @param {boolean} [enableMpegtsM2TsMode] 
         * @param {string} [videoCodec] 
         * @param {string} [subtitleCodec] 
         * @param {string} [transcodingReasons] 
         * @param {number} [audioStreamIndex] 
         * @param {number} [videoStreamIndex] 
         * @param {EncodingContext} [context] 
         * @param {{ [key: string]: string; }} [streamOptions] 
         * @param {boolean} [enableAdaptiveBitrateStreaming] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterHlsAudioPlaylist: async (itemId: string, container: string, mediaSourceId: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, enableAdaptiveBitrateStreaming?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getMasterHlsAudioPlaylist.');
            }
            // verify required parameter 'container' is not null or undefined
            if (container === null || container === undefined) {
                throw new RequiredError('container','Required parameter container was null or undefined when calling getMasterHlsAudioPlaylist.');
            }
            // verify required parameter 'mediaSourceId' is not null or undefined
            if (mediaSourceId === null || mediaSourceId === undefined) {
                throw new RequiredError('mediaSourceId','Required parameter mediaSourceId was null or undefined when calling getMasterHlsAudioPlaylist.');
            }
            const localVarPath = `/Audio/{itemId}/master.m3u8`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"container"}}`, encodeURIComponent(String(container)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (_static !== undefined) {
                localVarQueryParameter['static'] = _static;
            }

            if (params !== undefined) {
                localVarQueryParameter['params'] = params;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (deviceProfileId !== undefined) {
                localVarQueryParameter['deviceProfileId'] = deviceProfileId;
            }

            if (playSessionId !== undefined) {
                localVarQueryParameter['playSessionId'] = playSessionId;
            }

            if (segmentContainer !== undefined) {
                localVarQueryParameter['segmentContainer'] = segmentContainer;
            }

            if (segmentLength !== undefined) {
                localVarQueryParameter['segmentLength'] = segmentLength;
            }

            if (minSegments !== undefined) {
                localVarQueryParameter['minSegments'] = minSegments;
            }

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['mediaSourceId'] = mediaSourceId;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (audioCodec !== undefined) {
                localVarQueryParameter['audioCodec'] = audioCodec;
            }

            if (enableAutoStreamCopy !== undefined) {
                localVarQueryParameter['enableAutoStreamCopy'] = enableAutoStreamCopy;
            }

            if (allowVideoStreamCopy !== undefined) {
                localVarQueryParameter['allowVideoStreamCopy'] = allowVideoStreamCopy;
            }

            if (allowAudioStreamCopy !== undefined) {
                localVarQueryParameter['allowAudioStreamCopy'] = allowAudioStreamCopy;
            }

            if (breakOnNonKeyFrames !== undefined) {
                localVarQueryParameter['breakOnNonKeyFrames'] = breakOnNonKeyFrames;
            }

            if (audioSampleRate !== undefined) {
                localVarQueryParameter['audioSampleRate'] = audioSampleRate;
            }

            if (maxAudioBitDepth !== undefined) {
                localVarQueryParameter['maxAudioBitDepth'] = maxAudioBitDepth;
            }

            if (audioBitRate !== undefined) {
                localVarQueryParameter['audioBitRate'] = audioBitRate;
            }

            if (audioChannels !== undefined) {
                localVarQueryParameter['audioChannels'] = audioChannels;
            }

            if (maxAudioChannels !== undefined) {
                localVarQueryParameter['maxAudioChannels'] = maxAudioChannels;
            }

            if (profile !== undefined) {
                localVarQueryParameter['profile'] = profile;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (framerate !== undefined) {
                localVarQueryParameter['framerate'] = framerate;
            }

            if (maxFramerate !== undefined) {
                localVarQueryParameter['maxFramerate'] = maxFramerate;
            }

            if (copyTimestamps !== undefined) {
                localVarQueryParameter['copyTimestamps'] = copyTimestamps;
            }

            if (startTimeTicks !== undefined) {
                localVarQueryParameter['startTimeTicks'] = startTimeTicks;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (videoBitRate !== undefined) {
                localVarQueryParameter['videoBitRate'] = videoBitRate;
            }

            if (subtitleStreamIndex !== undefined) {
                localVarQueryParameter['subtitleStreamIndex'] = subtitleStreamIndex;
            }

            if (subtitleMethod !== undefined) {
                localVarQueryParameter['subtitleMethod'] = subtitleMethod;
            }

            if (maxRefFrames !== undefined) {
                localVarQueryParameter['maxRefFrames'] = maxRefFrames;
            }

            if (maxVideoBitDepth !== undefined) {
                localVarQueryParameter['maxVideoBitDepth'] = maxVideoBitDepth;
            }

            if (requireAvc !== undefined) {
                localVarQueryParameter['requireAvc'] = requireAvc;
            }

            if (deInterlace !== undefined) {
                localVarQueryParameter['deInterlace'] = deInterlace;
            }

            if (requireNonAnamorphic !== undefined) {
                localVarQueryParameter['requireNonAnamorphic'] = requireNonAnamorphic;
            }

            if (transcodingMaxAudioChannels !== undefined) {
                localVarQueryParameter['transcodingMaxAudioChannels'] = transcodingMaxAudioChannels;
            }

            if (cpuCoreLimit !== undefined) {
                localVarQueryParameter['cpuCoreLimit'] = cpuCoreLimit;
            }

            if (liveStreamId !== undefined) {
                localVarQueryParameter['liveStreamId'] = liveStreamId;
            }

            if (enableMpegtsM2TsMode !== undefined) {
                localVarQueryParameter['enableMpegtsM2TsMode'] = enableMpegtsM2TsMode;
            }

            if (videoCodec !== undefined) {
                localVarQueryParameter['videoCodec'] = videoCodec;
            }

            if (subtitleCodec !== undefined) {
                localVarQueryParameter['subtitleCodec'] = subtitleCodec;
            }

            if (transcodingReasons !== undefined) {
                localVarQueryParameter['transcodingReasons'] = transcodingReasons;
            }

            if (audioStreamIndex !== undefined) {
                localVarQueryParameter['audioStreamIndex'] = audioStreamIndex;
            }

            if (videoStreamIndex !== undefined) {
                localVarQueryParameter['videoStreamIndex'] = videoStreamIndex;
            }

            if (context !== undefined) {
                localVarQueryParameter['context'] = context;
            }

            if (streamOptions !== undefined) {
                localVarQueryParameter['streamOptions'] = streamOptions;
            }

            if (enableAdaptiveBitrateStreaming !== undefined) {
                localVarQueryParameter['enableAdaptiveBitrateStreaming'] = enableAdaptiveBitrateStreaming;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} container 
         * @param {string} mediaSourceId 
         * @param {boolean} [_static] 
         * @param {string} [params] 
         * @param {string} [tag] 
         * @param {string} [deviceProfileId] 
         * @param {string} [playSessionId] 
         * @param {string} [segmentContainer] 
         * @param {number} [segmentLength] 
         * @param {number} [minSegments] 
         * @param {string} [deviceId] 
         * @param {string} [audioCodec] 
         * @param {boolean} [enableAutoStreamCopy] 
         * @param {boolean} [allowVideoStreamCopy] 
         * @param {boolean} [allowAudioStreamCopy] 
         * @param {boolean} [breakOnNonKeyFrames] 
         * @param {number} [audioSampleRate] 
         * @param {number} [maxAudioBitDepth] 
         * @param {number} [audioBitRate] 
         * @param {number} [audioChannels] 
         * @param {number} [maxAudioChannels] 
         * @param {string} [profile] 
         * @param {string} [level] 
         * @param {number} [framerate] 
         * @param {number} [maxFramerate] 
         * @param {boolean} [copyTimestamps] 
         * @param {number} [startTimeTicks] 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [videoBitRate] 
         * @param {number} [subtitleStreamIndex] 
         * @param {SubtitleDeliveryMethod} [subtitleMethod] 
         * @param {number} [maxRefFrames] 
         * @param {number} [maxVideoBitDepth] 
         * @param {boolean} [requireAvc] 
         * @param {boolean} [deInterlace] 
         * @param {boolean} [requireNonAnamorphic] 
         * @param {number} [transcodingMaxAudioChannels] 
         * @param {number} [cpuCoreLimit] 
         * @param {string} [liveStreamId] 
         * @param {boolean} [enableMpegtsM2TsMode] 
         * @param {string} [videoCodec] 
         * @param {string} [subtitleCodec] 
         * @param {string} [transcodingReasons] 
         * @param {number} [audioStreamIndex] 
         * @param {number} [videoStreamIndex] 
         * @param {EncodingContext} [context] 
         * @param {{ [key: string]: string; }} [streamOptions] 
         * @param {boolean} [enableAdaptiveBitrateStreaming] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterHlsVideoPlaylist: async (itemId: string, container: string, mediaSourceId: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, enableAdaptiveBitrateStreaming?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getMasterHlsVideoPlaylist.');
            }
            // verify required parameter 'container' is not null or undefined
            if (container === null || container === undefined) {
                throw new RequiredError('container','Required parameter container was null or undefined when calling getMasterHlsVideoPlaylist.');
            }
            // verify required parameter 'mediaSourceId' is not null or undefined
            if (mediaSourceId === null || mediaSourceId === undefined) {
                throw new RequiredError('mediaSourceId','Required parameter mediaSourceId was null or undefined when calling getMasterHlsVideoPlaylist.');
            }
            const localVarPath = `/Videos/{itemId}/master.m3u8`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"container"}}`, encodeURIComponent(String(container)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (_static !== undefined) {
                localVarQueryParameter['static'] = _static;
            }

            if (params !== undefined) {
                localVarQueryParameter['params'] = params;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (deviceProfileId !== undefined) {
                localVarQueryParameter['deviceProfileId'] = deviceProfileId;
            }

            if (playSessionId !== undefined) {
                localVarQueryParameter['playSessionId'] = playSessionId;
            }

            if (segmentContainer !== undefined) {
                localVarQueryParameter['segmentContainer'] = segmentContainer;
            }

            if (segmentLength !== undefined) {
                localVarQueryParameter['segmentLength'] = segmentLength;
            }

            if (minSegments !== undefined) {
                localVarQueryParameter['minSegments'] = minSegments;
            }

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['mediaSourceId'] = mediaSourceId;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (audioCodec !== undefined) {
                localVarQueryParameter['audioCodec'] = audioCodec;
            }

            if (enableAutoStreamCopy !== undefined) {
                localVarQueryParameter['enableAutoStreamCopy'] = enableAutoStreamCopy;
            }

            if (allowVideoStreamCopy !== undefined) {
                localVarQueryParameter['allowVideoStreamCopy'] = allowVideoStreamCopy;
            }

            if (allowAudioStreamCopy !== undefined) {
                localVarQueryParameter['allowAudioStreamCopy'] = allowAudioStreamCopy;
            }

            if (breakOnNonKeyFrames !== undefined) {
                localVarQueryParameter['breakOnNonKeyFrames'] = breakOnNonKeyFrames;
            }

            if (audioSampleRate !== undefined) {
                localVarQueryParameter['audioSampleRate'] = audioSampleRate;
            }

            if (maxAudioBitDepth !== undefined) {
                localVarQueryParameter['maxAudioBitDepth'] = maxAudioBitDepth;
            }

            if (audioBitRate !== undefined) {
                localVarQueryParameter['audioBitRate'] = audioBitRate;
            }

            if (audioChannels !== undefined) {
                localVarQueryParameter['audioChannels'] = audioChannels;
            }

            if (maxAudioChannels !== undefined) {
                localVarQueryParameter['maxAudioChannels'] = maxAudioChannels;
            }

            if (profile !== undefined) {
                localVarQueryParameter['profile'] = profile;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (framerate !== undefined) {
                localVarQueryParameter['framerate'] = framerate;
            }

            if (maxFramerate !== undefined) {
                localVarQueryParameter['maxFramerate'] = maxFramerate;
            }

            if (copyTimestamps !== undefined) {
                localVarQueryParameter['copyTimestamps'] = copyTimestamps;
            }

            if (startTimeTicks !== undefined) {
                localVarQueryParameter['startTimeTicks'] = startTimeTicks;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (videoBitRate !== undefined) {
                localVarQueryParameter['videoBitRate'] = videoBitRate;
            }

            if (subtitleStreamIndex !== undefined) {
                localVarQueryParameter['subtitleStreamIndex'] = subtitleStreamIndex;
            }

            if (subtitleMethod !== undefined) {
                localVarQueryParameter['subtitleMethod'] = subtitleMethod;
            }

            if (maxRefFrames !== undefined) {
                localVarQueryParameter['maxRefFrames'] = maxRefFrames;
            }

            if (maxVideoBitDepth !== undefined) {
                localVarQueryParameter['maxVideoBitDepth'] = maxVideoBitDepth;
            }

            if (requireAvc !== undefined) {
                localVarQueryParameter['requireAvc'] = requireAvc;
            }

            if (deInterlace !== undefined) {
                localVarQueryParameter['deInterlace'] = deInterlace;
            }

            if (requireNonAnamorphic !== undefined) {
                localVarQueryParameter['requireNonAnamorphic'] = requireNonAnamorphic;
            }

            if (transcodingMaxAudioChannels !== undefined) {
                localVarQueryParameter['transcodingMaxAudioChannels'] = transcodingMaxAudioChannels;
            }

            if (cpuCoreLimit !== undefined) {
                localVarQueryParameter['cpuCoreLimit'] = cpuCoreLimit;
            }

            if (liveStreamId !== undefined) {
                localVarQueryParameter['liveStreamId'] = liveStreamId;
            }

            if (enableMpegtsM2TsMode !== undefined) {
                localVarQueryParameter['enableMpegtsM2TsMode'] = enableMpegtsM2TsMode;
            }

            if (videoCodec !== undefined) {
                localVarQueryParameter['videoCodec'] = videoCodec;
            }

            if (subtitleCodec !== undefined) {
                localVarQueryParameter['subtitleCodec'] = subtitleCodec;
            }

            if (transcodingReasons !== undefined) {
                localVarQueryParameter['transcodingReasons'] = transcodingReasons;
            }

            if (audioStreamIndex !== undefined) {
                localVarQueryParameter['audioStreamIndex'] = audioStreamIndex;
            }

            if (videoStreamIndex !== undefined) {
                localVarQueryParameter['videoStreamIndex'] = videoStreamIndex;
            }

            if (context !== undefined) {
                localVarQueryParameter['context'] = context;
            }

            if (streamOptions !== undefined) {
                localVarQueryParameter['streamOptions'] = streamOptions;
            }

            if (enableAdaptiveBitrateStreaming !== undefined) {
                localVarQueryParameter['enableAdaptiveBitrateStreaming'] = enableAdaptiveBitrateStreaming;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} container 
         * @param {boolean} [_static] 
         * @param {string} [params] 
         * @param {string} [tag] 
         * @param {string} [deviceProfileId] 
         * @param {string} [playSessionId] 
         * @param {string} [segmentContainer] 
         * @param {number} [segmentLength] 
         * @param {number} [minSegments] 
         * @param {string} [mediaSourceId] 
         * @param {string} [deviceId] 
         * @param {string} [audioCodec] 
         * @param {boolean} [enableAutoStreamCopy] 
         * @param {boolean} [allowVideoStreamCopy] 
         * @param {boolean} [allowAudioStreamCopy] 
         * @param {boolean} [breakOnNonKeyFrames] 
         * @param {number} [audioSampleRate] 
         * @param {number} [maxAudioBitDepth] 
         * @param {number} [audioBitRate] 
         * @param {number} [audioChannels] 
         * @param {number} [maxAudioChannels] 
         * @param {string} [profile] 
         * @param {string} [level] 
         * @param {number} [framerate] 
         * @param {number} [maxFramerate] 
         * @param {boolean} [copyTimestamps] 
         * @param {number} [startTimeTicks] 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [videoBitRate] 
         * @param {number} [subtitleStreamIndex] 
         * @param {SubtitleDeliveryMethod} [subtitleMethod] 
         * @param {number} [maxRefFrames] 
         * @param {number} [maxVideoBitDepth] 
         * @param {boolean} [requireAvc] 
         * @param {boolean} [deInterlace] 
         * @param {boolean} [requireNonAnamorphic] 
         * @param {number} [transcodingMaxAudioChannels] 
         * @param {number} [cpuCoreLimit] 
         * @param {string} [liveStreamId] 
         * @param {boolean} [enableMpegtsM2TsMode] 
         * @param {string} [videoCodec] 
         * @param {string} [subtitleCodec] 
         * @param {string} [transcodingReasons] 
         * @param {number} [audioStreamIndex] 
         * @param {number} [videoStreamIndex] 
         * @param {EncodingContext} [context] 
         * @param {{ [key: string]: string; }} [streamOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariantHlsAudioPlaylist: async (itemId: string, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getVariantHlsAudioPlaylist.');
            }
            // verify required parameter 'container' is not null or undefined
            if (container === null || container === undefined) {
                throw new RequiredError('container','Required parameter container was null or undefined when calling getVariantHlsAudioPlaylist.');
            }
            const localVarPath = `/Audio/{itemId}/main.m3u8`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"container"}}`, encodeURIComponent(String(container)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (_static !== undefined) {
                localVarQueryParameter['static'] = _static;
            }

            if (params !== undefined) {
                localVarQueryParameter['params'] = params;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (deviceProfileId !== undefined) {
                localVarQueryParameter['deviceProfileId'] = deviceProfileId;
            }

            if (playSessionId !== undefined) {
                localVarQueryParameter['playSessionId'] = playSessionId;
            }

            if (segmentContainer !== undefined) {
                localVarQueryParameter['segmentContainer'] = segmentContainer;
            }

            if (segmentLength !== undefined) {
                localVarQueryParameter['segmentLength'] = segmentLength;
            }

            if (minSegments !== undefined) {
                localVarQueryParameter['minSegments'] = minSegments;
            }

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['mediaSourceId'] = mediaSourceId;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (audioCodec !== undefined) {
                localVarQueryParameter['audioCodec'] = audioCodec;
            }

            if (enableAutoStreamCopy !== undefined) {
                localVarQueryParameter['enableAutoStreamCopy'] = enableAutoStreamCopy;
            }

            if (allowVideoStreamCopy !== undefined) {
                localVarQueryParameter['allowVideoStreamCopy'] = allowVideoStreamCopy;
            }

            if (allowAudioStreamCopy !== undefined) {
                localVarQueryParameter['allowAudioStreamCopy'] = allowAudioStreamCopy;
            }

            if (breakOnNonKeyFrames !== undefined) {
                localVarQueryParameter['breakOnNonKeyFrames'] = breakOnNonKeyFrames;
            }

            if (audioSampleRate !== undefined) {
                localVarQueryParameter['audioSampleRate'] = audioSampleRate;
            }

            if (maxAudioBitDepth !== undefined) {
                localVarQueryParameter['maxAudioBitDepth'] = maxAudioBitDepth;
            }

            if (audioBitRate !== undefined) {
                localVarQueryParameter['audioBitRate'] = audioBitRate;
            }

            if (audioChannels !== undefined) {
                localVarQueryParameter['audioChannels'] = audioChannels;
            }

            if (maxAudioChannels !== undefined) {
                localVarQueryParameter['maxAudioChannels'] = maxAudioChannels;
            }

            if (profile !== undefined) {
                localVarQueryParameter['profile'] = profile;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (framerate !== undefined) {
                localVarQueryParameter['framerate'] = framerate;
            }

            if (maxFramerate !== undefined) {
                localVarQueryParameter['maxFramerate'] = maxFramerate;
            }

            if (copyTimestamps !== undefined) {
                localVarQueryParameter['copyTimestamps'] = copyTimestamps;
            }

            if (startTimeTicks !== undefined) {
                localVarQueryParameter['startTimeTicks'] = startTimeTicks;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (videoBitRate !== undefined) {
                localVarQueryParameter['videoBitRate'] = videoBitRate;
            }

            if (subtitleStreamIndex !== undefined) {
                localVarQueryParameter['subtitleStreamIndex'] = subtitleStreamIndex;
            }

            if (subtitleMethod !== undefined) {
                localVarQueryParameter['subtitleMethod'] = subtitleMethod;
            }

            if (maxRefFrames !== undefined) {
                localVarQueryParameter['maxRefFrames'] = maxRefFrames;
            }

            if (maxVideoBitDepth !== undefined) {
                localVarQueryParameter['maxVideoBitDepth'] = maxVideoBitDepth;
            }

            if (requireAvc !== undefined) {
                localVarQueryParameter['requireAvc'] = requireAvc;
            }

            if (deInterlace !== undefined) {
                localVarQueryParameter['deInterlace'] = deInterlace;
            }

            if (requireNonAnamorphic !== undefined) {
                localVarQueryParameter['requireNonAnamorphic'] = requireNonAnamorphic;
            }

            if (transcodingMaxAudioChannels !== undefined) {
                localVarQueryParameter['transcodingMaxAudioChannels'] = transcodingMaxAudioChannels;
            }

            if (cpuCoreLimit !== undefined) {
                localVarQueryParameter['cpuCoreLimit'] = cpuCoreLimit;
            }

            if (liveStreamId !== undefined) {
                localVarQueryParameter['liveStreamId'] = liveStreamId;
            }

            if (enableMpegtsM2TsMode !== undefined) {
                localVarQueryParameter['enableMpegtsM2TsMode'] = enableMpegtsM2TsMode;
            }

            if (videoCodec !== undefined) {
                localVarQueryParameter['videoCodec'] = videoCodec;
            }

            if (subtitleCodec !== undefined) {
                localVarQueryParameter['subtitleCodec'] = subtitleCodec;
            }

            if (transcodingReasons !== undefined) {
                localVarQueryParameter['transcodingReasons'] = transcodingReasons;
            }

            if (audioStreamIndex !== undefined) {
                localVarQueryParameter['audioStreamIndex'] = audioStreamIndex;
            }

            if (videoStreamIndex !== undefined) {
                localVarQueryParameter['videoStreamIndex'] = videoStreamIndex;
            }

            if (context !== undefined) {
                localVarQueryParameter['context'] = context;
            }

            if (streamOptions !== undefined) {
                localVarQueryParameter['streamOptions'] = streamOptions;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} container 
         * @param {boolean} [_static] 
         * @param {string} [params] 
         * @param {string} [tag] 
         * @param {string} [deviceProfileId] 
         * @param {string} [playSessionId] 
         * @param {string} [segmentContainer] 
         * @param {number} [segmentLength] 
         * @param {number} [minSegments] 
         * @param {string} [mediaSourceId] 
         * @param {string} [deviceId] 
         * @param {string} [audioCodec] 
         * @param {boolean} [enableAutoStreamCopy] 
         * @param {boolean} [allowVideoStreamCopy] 
         * @param {boolean} [allowAudioStreamCopy] 
         * @param {boolean} [breakOnNonKeyFrames] 
         * @param {number} [audioSampleRate] 
         * @param {number} [maxAudioBitDepth] 
         * @param {number} [audioBitRate] 
         * @param {number} [audioChannels] 
         * @param {number} [maxAudioChannels] 
         * @param {string} [profile] 
         * @param {string} [level] 
         * @param {number} [framerate] 
         * @param {number} [maxFramerate] 
         * @param {boolean} [copyTimestamps] 
         * @param {number} [startTimeTicks] 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [videoBitRate] 
         * @param {number} [subtitleStreamIndex] 
         * @param {SubtitleDeliveryMethod} [subtitleMethod] 
         * @param {number} [maxRefFrames] 
         * @param {number} [maxVideoBitDepth] 
         * @param {boolean} [requireAvc] 
         * @param {boolean} [deInterlace] 
         * @param {boolean} [requireNonAnamorphic] 
         * @param {number} [transcodingMaxAudioChannels] 
         * @param {number} [cpuCoreLimit] 
         * @param {string} [liveStreamId] 
         * @param {boolean} [enableMpegtsM2TsMode] 
         * @param {string} [videoCodec] 
         * @param {string} [subtitleCodec] 
         * @param {string} [transcodingReasons] 
         * @param {number} [audioStreamIndex] 
         * @param {number} [videoStreamIndex] 
         * @param {EncodingContext} [context] 
         * @param {{ [key: string]: string; }} [streamOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariantHlsVideoPlaylist: async (itemId: string, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getVariantHlsVideoPlaylist.');
            }
            // verify required parameter 'container' is not null or undefined
            if (container === null || container === undefined) {
                throw new RequiredError('container','Required parameter container was null or undefined when calling getVariantHlsVideoPlaylist.');
            }
            const localVarPath = `/Videos/{itemId}/main.m3u8`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"container"}}`, encodeURIComponent(String(container)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (_static !== undefined) {
                localVarQueryParameter['static'] = _static;
            }

            if (params !== undefined) {
                localVarQueryParameter['params'] = params;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (deviceProfileId !== undefined) {
                localVarQueryParameter['deviceProfileId'] = deviceProfileId;
            }

            if (playSessionId !== undefined) {
                localVarQueryParameter['playSessionId'] = playSessionId;
            }

            if (segmentContainer !== undefined) {
                localVarQueryParameter['segmentContainer'] = segmentContainer;
            }

            if (segmentLength !== undefined) {
                localVarQueryParameter['segmentLength'] = segmentLength;
            }

            if (minSegments !== undefined) {
                localVarQueryParameter['minSegments'] = minSegments;
            }

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['mediaSourceId'] = mediaSourceId;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (audioCodec !== undefined) {
                localVarQueryParameter['audioCodec'] = audioCodec;
            }

            if (enableAutoStreamCopy !== undefined) {
                localVarQueryParameter['enableAutoStreamCopy'] = enableAutoStreamCopy;
            }

            if (allowVideoStreamCopy !== undefined) {
                localVarQueryParameter['allowVideoStreamCopy'] = allowVideoStreamCopy;
            }

            if (allowAudioStreamCopy !== undefined) {
                localVarQueryParameter['allowAudioStreamCopy'] = allowAudioStreamCopy;
            }

            if (breakOnNonKeyFrames !== undefined) {
                localVarQueryParameter['breakOnNonKeyFrames'] = breakOnNonKeyFrames;
            }

            if (audioSampleRate !== undefined) {
                localVarQueryParameter['audioSampleRate'] = audioSampleRate;
            }

            if (maxAudioBitDepth !== undefined) {
                localVarQueryParameter['maxAudioBitDepth'] = maxAudioBitDepth;
            }

            if (audioBitRate !== undefined) {
                localVarQueryParameter['audioBitRate'] = audioBitRate;
            }

            if (audioChannels !== undefined) {
                localVarQueryParameter['audioChannels'] = audioChannels;
            }

            if (maxAudioChannels !== undefined) {
                localVarQueryParameter['maxAudioChannels'] = maxAudioChannels;
            }

            if (profile !== undefined) {
                localVarQueryParameter['profile'] = profile;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (framerate !== undefined) {
                localVarQueryParameter['framerate'] = framerate;
            }

            if (maxFramerate !== undefined) {
                localVarQueryParameter['maxFramerate'] = maxFramerate;
            }

            if (copyTimestamps !== undefined) {
                localVarQueryParameter['copyTimestamps'] = copyTimestamps;
            }

            if (startTimeTicks !== undefined) {
                localVarQueryParameter['startTimeTicks'] = startTimeTicks;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (videoBitRate !== undefined) {
                localVarQueryParameter['videoBitRate'] = videoBitRate;
            }

            if (subtitleStreamIndex !== undefined) {
                localVarQueryParameter['subtitleStreamIndex'] = subtitleStreamIndex;
            }

            if (subtitleMethod !== undefined) {
                localVarQueryParameter['subtitleMethod'] = subtitleMethod;
            }

            if (maxRefFrames !== undefined) {
                localVarQueryParameter['maxRefFrames'] = maxRefFrames;
            }

            if (maxVideoBitDepth !== undefined) {
                localVarQueryParameter['maxVideoBitDepth'] = maxVideoBitDepth;
            }

            if (requireAvc !== undefined) {
                localVarQueryParameter['requireAvc'] = requireAvc;
            }

            if (deInterlace !== undefined) {
                localVarQueryParameter['deInterlace'] = deInterlace;
            }

            if (requireNonAnamorphic !== undefined) {
                localVarQueryParameter['requireNonAnamorphic'] = requireNonAnamorphic;
            }

            if (transcodingMaxAudioChannels !== undefined) {
                localVarQueryParameter['transcodingMaxAudioChannels'] = transcodingMaxAudioChannels;
            }

            if (cpuCoreLimit !== undefined) {
                localVarQueryParameter['cpuCoreLimit'] = cpuCoreLimit;
            }

            if (liveStreamId !== undefined) {
                localVarQueryParameter['liveStreamId'] = liveStreamId;
            }

            if (enableMpegtsM2TsMode !== undefined) {
                localVarQueryParameter['enableMpegtsM2TsMode'] = enableMpegtsM2TsMode;
            }

            if (videoCodec !== undefined) {
                localVarQueryParameter['videoCodec'] = videoCodec;
            }

            if (subtitleCodec !== undefined) {
                localVarQueryParameter['subtitleCodec'] = subtitleCodec;
            }

            if (transcodingReasons !== undefined) {
                localVarQueryParameter['transcodingReasons'] = transcodingReasons;
            }

            if (audioStreamIndex !== undefined) {
                localVarQueryParameter['audioStreamIndex'] = audioStreamIndex;
            }

            if (videoStreamIndex !== undefined) {
                localVarQueryParameter['videoStreamIndex'] = videoStreamIndex;
            }

            if (context !== undefined) {
                localVarQueryParameter['context'] = context;
            }

            if (streamOptions !== undefined) {
                localVarQueryParameter['streamOptions'] = streamOptions;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} container 
         * @param {string} mediaSourceId 
         * @param {boolean} [_static] 
         * @param {string} [params] 
         * @param {string} [tag] 
         * @param {string} [deviceProfileId] 
         * @param {string} [playSessionId] 
         * @param {string} [segmentContainer] 
         * @param {number} [segmentLength] 
         * @param {number} [minSegments] 
         * @param {string} [deviceId] 
         * @param {string} [audioCodec] 
         * @param {boolean} [enableAutoStreamCopy] 
         * @param {boolean} [allowVideoStreamCopy] 
         * @param {boolean} [allowAudioStreamCopy] 
         * @param {boolean} [breakOnNonKeyFrames] 
         * @param {number} [audioSampleRate] 
         * @param {number} [maxAudioBitDepth] 
         * @param {number} [audioBitRate] 
         * @param {number} [audioChannels] 
         * @param {number} [maxAudioChannels] 
         * @param {string} [profile] 
         * @param {string} [level] 
         * @param {number} [framerate] 
         * @param {number} [maxFramerate] 
         * @param {boolean} [copyTimestamps] 
         * @param {number} [startTimeTicks] 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [videoBitRate] 
         * @param {number} [subtitleStreamIndex] 
         * @param {SubtitleDeliveryMethod} [subtitleMethod] 
         * @param {number} [maxRefFrames] 
         * @param {number} [maxVideoBitDepth] 
         * @param {boolean} [requireAvc] 
         * @param {boolean} [deInterlace] 
         * @param {boolean} [requireNonAnamorphic] 
         * @param {number} [transcodingMaxAudioChannels] 
         * @param {number} [cpuCoreLimit] 
         * @param {string} [liveStreamId] 
         * @param {boolean} [enableMpegtsM2TsMode] 
         * @param {string} [videoCodec] 
         * @param {string} [subtitleCodec] 
         * @param {string} [transcodingReasons] 
         * @param {number} [audioStreamIndex] 
         * @param {number} [videoStreamIndex] 
         * @param {EncodingContext} [context] 
         * @param {{ [key: string]: string; }} [streamOptions] 
         * @param {boolean} [enableAdaptiveBitrateStreaming] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headMasterHlsAudioPlaylist: async (itemId: string, container: string, mediaSourceId: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, enableAdaptiveBitrateStreaming?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling headMasterHlsAudioPlaylist.');
            }
            // verify required parameter 'container' is not null or undefined
            if (container === null || container === undefined) {
                throw new RequiredError('container','Required parameter container was null or undefined when calling headMasterHlsAudioPlaylist.');
            }
            // verify required parameter 'mediaSourceId' is not null or undefined
            if (mediaSourceId === null || mediaSourceId === undefined) {
                throw new RequiredError('mediaSourceId','Required parameter mediaSourceId was null or undefined when calling headMasterHlsAudioPlaylist.');
            }
            const localVarPath = `/Audio/{itemId}/master.m3u8`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"container"}}`, encodeURIComponent(String(container)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (_static !== undefined) {
                localVarQueryParameter['static'] = _static;
            }

            if (params !== undefined) {
                localVarQueryParameter['params'] = params;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (deviceProfileId !== undefined) {
                localVarQueryParameter['deviceProfileId'] = deviceProfileId;
            }

            if (playSessionId !== undefined) {
                localVarQueryParameter['playSessionId'] = playSessionId;
            }

            if (segmentContainer !== undefined) {
                localVarQueryParameter['segmentContainer'] = segmentContainer;
            }

            if (segmentLength !== undefined) {
                localVarQueryParameter['segmentLength'] = segmentLength;
            }

            if (minSegments !== undefined) {
                localVarQueryParameter['minSegments'] = minSegments;
            }

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['mediaSourceId'] = mediaSourceId;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (audioCodec !== undefined) {
                localVarQueryParameter['audioCodec'] = audioCodec;
            }

            if (enableAutoStreamCopy !== undefined) {
                localVarQueryParameter['enableAutoStreamCopy'] = enableAutoStreamCopy;
            }

            if (allowVideoStreamCopy !== undefined) {
                localVarQueryParameter['allowVideoStreamCopy'] = allowVideoStreamCopy;
            }

            if (allowAudioStreamCopy !== undefined) {
                localVarQueryParameter['allowAudioStreamCopy'] = allowAudioStreamCopy;
            }

            if (breakOnNonKeyFrames !== undefined) {
                localVarQueryParameter['breakOnNonKeyFrames'] = breakOnNonKeyFrames;
            }

            if (audioSampleRate !== undefined) {
                localVarQueryParameter['audioSampleRate'] = audioSampleRate;
            }

            if (maxAudioBitDepth !== undefined) {
                localVarQueryParameter['maxAudioBitDepth'] = maxAudioBitDepth;
            }

            if (audioBitRate !== undefined) {
                localVarQueryParameter['audioBitRate'] = audioBitRate;
            }

            if (audioChannels !== undefined) {
                localVarQueryParameter['audioChannels'] = audioChannels;
            }

            if (maxAudioChannels !== undefined) {
                localVarQueryParameter['maxAudioChannels'] = maxAudioChannels;
            }

            if (profile !== undefined) {
                localVarQueryParameter['profile'] = profile;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (framerate !== undefined) {
                localVarQueryParameter['framerate'] = framerate;
            }

            if (maxFramerate !== undefined) {
                localVarQueryParameter['maxFramerate'] = maxFramerate;
            }

            if (copyTimestamps !== undefined) {
                localVarQueryParameter['copyTimestamps'] = copyTimestamps;
            }

            if (startTimeTicks !== undefined) {
                localVarQueryParameter['startTimeTicks'] = startTimeTicks;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (videoBitRate !== undefined) {
                localVarQueryParameter['videoBitRate'] = videoBitRate;
            }

            if (subtitleStreamIndex !== undefined) {
                localVarQueryParameter['subtitleStreamIndex'] = subtitleStreamIndex;
            }

            if (subtitleMethod !== undefined) {
                localVarQueryParameter['subtitleMethod'] = subtitleMethod;
            }

            if (maxRefFrames !== undefined) {
                localVarQueryParameter['maxRefFrames'] = maxRefFrames;
            }

            if (maxVideoBitDepth !== undefined) {
                localVarQueryParameter['maxVideoBitDepth'] = maxVideoBitDepth;
            }

            if (requireAvc !== undefined) {
                localVarQueryParameter['requireAvc'] = requireAvc;
            }

            if (deInterlace !== undefined) {
                localVarQueryParameter['deInterlace'] = deInterlace;
            }

            if (requireNonAnamorphic !== undefined) {
                localVarQueryParameter['requireNonAnamorphic'] = requireNonAnamorphic;
            }

            if (transcodingMaxAudioChannels !== undefined) {
                localVarQueryParameter['transcodingMaxAudioChannels'] = transcodingMaxAudioChannels;
            }

            if (cpuCoreLimit !== undefined) {
                localVarQueryParameter['cpuCoreLimit'] = cpuCoreLimit;
            }

            if (liveStreamId !== undefined) {
                localVarQueryParameter['liveStreamId'] = liveStreamId;
            }

            if (enableMpegtsM2TsMode !== undefined) {
                localVarQueryParameter['enableMpegtsM2TsMode'] = enableMpegtsM2TsMode;
            }

            if (videoCodec !== undefined) {
                localVarQueryParameter['videoCodec'] = videoCodec;
            }

            if (subtitleCodec !== undefined) {
                localVarQueryParameter['subtitleCodec'] = subtitleCodec;
            }

            if (transcodingReasons !== undefined) {
                localVarQueryParameter['transcodingReasons'] = transcodingReasons;
            }

            if (audioStreamIndex !== undefined) {
                localVarQueryParameter['audioStreamIndex'] = audioStreamIndex;
            }

            if (videoStreamIndex !== undefined) {
                localVarQueryParameter['videoStreamIndex'] = videoStreamIndex;
            }

            if (context !== undefined) {
                localVarQueryParameter['context'] = context;
            }

            if (streamOptions !== undefined) {
                localVarQueryParameter['streamOptions'] = streamOptions;
            }

            if (enableAdaptiveBitrateStreaming !== undefined) {
                localVarQueryParameter['enableAdaptiveBitrateStreaming'] = enableAdaptiveBitrateStreaming;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} container 
         * @param {string} mediaSourceId 
         * @param {boolean} [_static] 
         * @param {string} [params] 
         * @param {string} [tag] 
         * @param {string} [deviceProfileId] 
         * @param {string} [playSessionId] 
         * @param {string} [segmentContainer] 
         * @param {number} [segmentLength] 
         * @param {number} [minSegments] 
         * @param {string} [deviceId] 
         * @param {string} [audioCodec] 
         * @param {boolean} [enableAutoStreamCopy] 
         * @param {boolean} [allowVideoStreamCopy] 
         * @param {boolean} [allowAudioStreamCopy] 
         * @param {boolean} [breakOnNonKeyFrames] 
         * @param {number} [audioSampleRate] 
         * @param {number} [maxAudioBitDepth] 
         * @param {number} [audioBitRate] 
         * @param {number} [audioChannels] 
         * @param {number} [maxAudioChannels] 
         * @param {string} [profile] 
         * @param {string} [level] 
         * @param {number} [framerate] 
         * @param {number} [maxFramerate] 
         * @param {boolean} [copyTimestamps] 
         * @param {number} [startTimeTicks] 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [videoBitRate] 
         * @param {number} [subtitleStreamIndex] 
         * @param {SubtitleDeliveryMethod} [subtitleMethod] 
         * @param {number} [maxRefFrames] 
         * @param {number} [maxVideoBitDepth] 
         * @param {boolean} [requireAvc] 
         * @param {boolean} [deInterlace] 
         * @param {boolean} [requireNonAnamorphic] 
         * @param {number} [transcodingMaxAudioChannels] 
         * @param {number} [cpuCoreLimit] 
         * @param {string} [liveStreamId] 
         * @param {boolean} [enableMpegtsM2TsMode] 
         * @param {string} [videoCodec] 
         * @param {string} [subtitleCodec] 
         * @param {string} [transcodingReasons] 
         * @param {number} [audioStreamIndex] 
         * @param {number} [videoStreamIndex] 
         * @param {EncodingContext} [context] 
         * @param {{ [key: string]: string; }} [streamOptions] 
         * @param {boolean} [enableAdaptiveBitrateStreaming] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headMasterHlsVideoPlaylist: async (itemId: string, container: string, mediaSourceId: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, enableAdaptiveBitrateStreaming?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling headMasterHlsVideoPlaylist.');
            }
            // verify required parameter 'container' is not null or undefined
            if (container === null || container === undefined) {
                throw new RequiredError('container','Required parameter container was null or undefined when calling headMasterHlsVideoPlaylist.');
            }
            // verify required parameter 'mediaSourceId' is not null or undefined
            if (mediaSourceId === null || mediaSourceId === undefined) {
                throw new RequiredError('mediaSourceId','Required parameter mediaSourceId was null or undefined when calling headMasterHlsVideoPlaylist.');
            }
            const localVarPath = `/Videos/{itemId}/master.m3u8`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"container"}}`, encodeURIComponent(String(container)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (_static !== undefined) {
                localVarQueryParameter['static'] = _static;
            }

            if (params !== undefined) {
                localVarQueryParameter['params'] = params;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (deviceProfileId !== undefined) {
                localVarQueryParameter['deviceProfileId'] = deviceProfileId;
            }

            if (playSessionId !== undefined) {
                localVarQueryParameter['playSessionId'] = playSessionId;
            }

            if (segmentContainer !== undefined) {
                localVarQueryParameter['segmentContainer'] = segmentContainer;
            }

            if (segmentLength !== undefined) {
                localVarQueryParameter['segmentLength'] = segmentLength;
            }

            if (minSegments !== undefined) {
                localVarQueryParameter['minSegments'] = minSegments;
            }

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['mediaSourceId'] = mediaSourceId;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (audioCodec !== undefined) {
                localVarQueryParameter['audioCodec'] = audioCodec;
            }

            if (enableAutoStreamCopy !== undefined) {
                localVarQueryParameter['enableAutoStreamCopy'] = enableAutoStreamCopy;
            }

            if (allowVideoStreamCopy !== undefined) {
                localVarQueryParameter['allowVideoStreamCopy'] = allowVideoStreamCopy;
            }

            if (allowAudioStreamCopy !== undefined) {
                localVarQueryParameter['allowAudioStreamCopy'] = allowAudioStreamCopy;
            }

            if (breakOnNonKeyFrames !== undefined) {
                localVarQueryParameter['breakOnNonKeyFrames'] = breakOnNonKeyFrames;
            }

            if (audioSampleRate !== undefined) {
                localVarQueryParameter['audioSampleRate'] = audioSampleRate;
            }

            if (maxAudioBitDepth !== undefined) {
                localVarQueryParameter['maxAudioBitDepth'] = maxAudioBitDepth;
            }

            if (audioBitRate !== undefined) {
                localVarQueryParameter['audioBitRate'] = audioBitRate;
            }

            if (audioChannels !== undefined) {
                localVarQueryParameter['audioChannels'] = audioChannels;
            }

            if (maxAudioChannels !== undefined) {
                localVarQueryParameter['maxAudioChannels'] = maxAudioChannels;
            }

            if (profile !== undefined) {
                localVarQueryParameter['profile'] = profile;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (framerate !== undefined) {
                localVarQueryParameter['framerate'] = framerate;
            }

            if (maxFramerate !== undefined) {
                localVarQueryParameter['maxFramerate'] = maxFramerate;
            }

            if (copyTimestamps !== undefined) {
                localVarQueryParameter['copyTimestamps'] = copyTimestamps;
            }

            if (startTimeTicks !== undefined) {
                localVarQueryParameter['startTimeTicks'] = startTimeTicks;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (videoBitRate !== undefined) {
                localVarQueryParameter['videoBitRate'] = videoBitRate;
            }

            if (subtitleStreamIndex !== undefined) {
                localVarQueryParameter['subtitleStreamIndex'] = subtitleStreamIndex;
            }

            if (subtitleMethod !== undefined) {
                localVarQueryParameter['subtitleMethod'] = subtitleMethod;
            }

            if (maxRefFrames !== undefined) {
                localVarQueryParameter['maxRefFrames'] = maxRefFrames;
            }

            if (maxVideoBitDepth !== undefined) {
                localVarQueryParameter['maxVideoBitDepth'] = maxVideoBitDepth;
            }

            if (requireAvc !== undefined) {
                localVarQueryParameter['requireAvc'] = requireAvc;
            }

            if (deInterlace !== undefined) {
                localVarQueryParameter['deInterlace'] = deInterlace;
            }

            if (requireNonAnamorphic !== undefined) {
                localVarQueryParameter['requireNonAnamorphic'] = requireNonAnamorphic;
            }

            if (transcodingMaxAudioChannels !== undefined) {
                localVarQueryParameter['transcodingMaxAudioChannels'] = transcodingMaxAudioChannels;
            }

            if (cpuCoreLimit !== undefined) {
                localVarQueryParameter['cpuCoreLimit'] = cpuCoreLimit;
            }

            if (liveStreamId !== undefined) {
                localVarQueryParameter['liveStreamId'] = liveStreamId;
            }

            if (enableMpegtsM2TsMode !== undefined) {
                localVarQueryParameter['enableMpegtsM2TsMode'] = enableMpegtsM2TsMode;
            }

            if (videoCodec !== undefined) {
                localVarQueryParameter['videoCodec'] = videoCodec;
            }

            if (subtitleCodec !== undefined) {
                localVarQueryParameter['subtitleCodec'] = subtitleCodec;
            }

            if (transcodingReasons !== undefined) {
                localVarQueryParameter['transcodingReasons'] = transcodingReasons;
            }

            if (audioStreamIndex !== undefined) {
                localVarQueryParameter['audioStreamIndex'] = audioStreamIndex;
            }

            if (videoStreamIndex !== undefined) {
                localVarQueryParameter['videoStreamIndex'] = videoStreamIndex;
            }

            if (context !== undefined) {
                localVarQueryParameter['context'] = context;
            }

            if (streamOptions !== undefined) {
                localVarQueryParameter['streamOptions'] = streamOptions;
            }

            if (enableAdaptiveBitrateStreaming !== undefined) {
                localVarQueryParameter['enableAdaptiveBitrateStreaming'] = enableAdaptiveBitrateStreaming;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DynamicHlsApi - functional programming interface
 * @export
 */
export const DynamicHlsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} itemId 
         * @param {string} playlistId 
         * @param {number} segmentId 
         * @param {string} container 
         * @param {boolean} [_static] 
         * @param {string} [params] 
         * @param {string} [tag] 
         * @param {string} [deviceProfileId] 
         * @param {string} [playSessionId] 
         * @param {string} [segmentContainer] 
         * @param {number} [segmentLength] 
         * @param {number} [minSegments] 
         * @param {string} [mediaSourceId] 
         * @param {string} [deviceId] 
         * @param {string} [audioCodec] 
         * @param {boolean} [enableAutoStreamCopy] 
         * @param {boolean} [allowVideoStreamCopy] 
         * @param {boolean} [allowAudioStreamCopy] 
         * @param {boolean} [breakOnNonKeyFrames] 
         * @param {number} [audioSampleRate] 
         * @param {number} [maxAudioBitDepth] 
         * @param {number} [audioBitRate] 
         * @param {number} [audioChannels] 
         * @param {number} [maxAudioChannels] 
         * @param {string} [profile] 
         * @param {string} [level] 
         * @param {number} [framerate] 
         * @param {number} [maxFramerate] 
         * @param {boolean} [copyTimestamps] 
         * @param {number} [startTimeTicks] 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [videoBitRate] 
         * @param {number} [subtitleStreamIndex] 
         * @param {SubtitleDeliveryMethod} [subtitleMethod] 
         * @param {number} [maxRefFrames] 
         * @param {number} [maxVideoBitDepth] 
         * @param {boolean} [requireAvc] 
         * @param {boolean} [deInterlace] 
         * @param {boolean} [requireNonAnamorphic] 
         * @param {number} [transcodingMaxAudioChannels] 
         * @param {number} [cpuCoreLimit] 
         * @param {string} [liveStreamId] 
         * @param {boolean} [enableMpegtsM2TsMode] 
         * @param {string} [videoCodec] 
         * @param {string} [subtitleCodec] 
         * @param {string} [transcodingReasons] 
         * @param {number} [audioStreamIndex] 
         * @param {number} [videoStreamIndex] 
         * @param {EncodingContext} [context] 
         * @param {{ [key: string]: string; }} [streamOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHlsAudioSegment(itemId: string, playlistId: string, segmentId: number, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DynamicHlsApiAxiosParamCreator(configuration).getHlsAudioSegment(itemId, playlistId, segmentId, container, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} playlistId 
         * @param {number} segmentId 
         * @param {string} container 
         * @param {boolean} [_static] 
         * @param {string} [params] 
         * @param {string} [tag] 
         * @param {string} [deviceProfileId] 
         * @param {string} [playSessionId] 
         * @param {string} [segmentContainer] 
         * @param {number} [segmentLength] 
         * @param {number} [minSegments] 
         * @param {string} [mediaSourceId] 
         * @param {string} [deviceId] 
         * @param {string} [audioCodec] 
         * @param {boolean} [enableAutoStreamCopy] 
         * @param {boolean} [allowVideoStreamCopy] 
         * @param {boolean} [allowAudioStreamCopy] 
         * @param {boolean} [breakOnNonKeyFrames] 
         * @param {number} [audioSampleRate] 
         * @param {number} [maxAudioBitDepth] 
         * @param {number} [audioBitRate] 
         * @param {number} [audioChannels] 
         * @param {number} [maxAudioChannels] 
         * @param {string} [profile] 
         * @param {string} [level] 
         * @param {number} [framerate] 
         * @param {number} [maxFramerate] 
         * @param {boolean} [copyTimestamps] 
         * @param {number} [startTimeTicks] 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [videoBitRate] 
         * @param {number} [subtitleStreamIndex] 
         * @param {SubtitleDeliveryMethod} [subtitleMethod] 
         * @param {number} [maxRefFrames] 
         * @param {number} [maxVideoBitDepth] 
         * @param {boolean} [requireAvc] 
         * @param {boolean} [deInterlace] 
         * @param {boolean} [requireNonAnamorphic] 
         * @param {number} [transcodingMaxAudioChannels] 
         * @param {number} [cpuCoreLimit] 
         * @param {string} [liveStreamId] 
         * @param {boolean} [enableMpegtsM2TsMode] 
         * @param {string} [videoCodec] 
         * @param {string} [subtitleCodec] 
         * @param {string} [transcodingReasons] 
         * @param {number} [audioStreamIndex] 
         * @param {number} [videoStreamIndex] 
         * @param {EncodingContext} [context] 
         * @param {{ [key: string]: string; }} [streamOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHlsVideoSegment(itemId: string, playlistId: string, segmentId: number, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DynamicHlsApiAxiosParamCreator(configuration).getHlsVideoSegment(itemId, playlistId, segmentId, container, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} container 
         * @param {string} mediaSourceId 
         * @param {boolean} [_static] 
         * @param {string} [params] 
         * @param {string} [tag] 
         * @param {string} [deviceProfileId] 
         * @param {string} [playSessionId] 
         * @param {string} [segmentContainer] 
         * @param {number} [segmentLength] 
         * @param {number} [minSegments] 
         * @param {string} [deviceId] 
         * @param {string} [audioCodec] 
         * @param {boolean} [enableAutoStreamCopy] 
         * @param {boolean} [allowVideoStreamCopy] 
         * @param {boolean} [allowAudioStreamCopy] 
         * @param {boolean} [breakOnNonKeyFrames] 
         * @param {number} [audioSampleRate] 
         * @param {number} [maxAudioBitDepth] 
         * @param {number} [audioBitRate] 
         * @param {number} [audioChannels] 
         * @param {number} [maxAudioChannels] 
         * @param {string} [profile] 
         * @param {string} [level] 
         * @param {number} [framerate] 
         * @param {number} [maxFramerate] 
         * @param {boolean} [copyTimestamps] 
         * @param {number} [startTimeTicks] 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [videoBitRate] 
         * @param {number} [subtitleStreamIndex] 
         * @param {SubtitleDeliveryMethod} [subtitleMethod] 
         * @param {number} [maxRefFrames] 
         * @param {number} [maxVideoBitDepth] 
         * @param {boolean} [requireAvc] 
         * @param {boolean} [deInterlace] 
         * @param {boolean} [requireNonAnamorphic] 
         * @param {number} [transcodingMaxAudioChannels] 
         * @param {number} [cpuCoreLimit] 
         * @param {string} [liveStreamId] 
         * @param {boolean} [enableMpegtsM2TsMode] 
         * @param {string} [videoCodec] 
         * @param {string} [subtitleCodec] 
         * @param {string} [transcodingReasons] 
         * @param {number} [audioStreamIndex] 
         * @param {number} [videoStreamIndex] 
         * @param {EncodingContext} [context] 
         * @param {{ [key: string]: string; }} [streamOptions] 
         * @param {boolean} [enableAdaptiveBitrateStreaming] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMasterHlsAudioPlaylist(itemId: string, container: string, mediaSourceId: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, enableAdaptiveBitrateStreaming?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DynamicHlsApiAxiosParamCreator(configuration).getMasterHlsAudioPlaylist(itemId, container, mediaSourceId, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, enableAdaptiveBitrateStreaming, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} container 
         * @param {string} mediaSourceId 
         * @param {boolean} [_static] 
         * @param {string} [params] 
         * @param {string} [tag] 
         * @param {string} [deviceProfileId] 
         * @param {string} [playSessionId] 
         * @param {string} [segmentContainer] 
         * @param {number} [segmentLength] 
         * @param {number} [minSegments] 
         * @param {string} [deviceId] 
         * @param {string} [audioCodec] 
         * @param {boolean} [enableAutoStreamCopy] 
         * @param {boolean} [allowVideoStreamCopy] 
         * @param {boolean} [allowAudioStreamCopy] 
         * @param {boolean} [breakOnNonKeyFrames] 
         * @param {number} [audioSampleRate] 
         * @param {number} [maxAudioBitDepth] 
         * @param {number} [audioBitRate] 
         * @param {number} [audioChannels] 
         * @param {number} [maxAudioChannels] 
         * @param {string} [profile] 
         * @param {string} [level] 
         * @param {number} [framerate] 
         * @param {number} [maxFramerate] 
         * @param {boolean} [copyTimestamps] 
         * @param {number} [startTimeTicks] 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [videoBitRate] 
         * @param {number} [subtitleStreamIndex] 
         * @param {SubtitleDeliveryMethod} [subtitleMethod] 
         * @param {number} [maxRefFrames] 
         * @param {number} [maxVideoBitDepth] 
         * @param {boolean} [requireAvc] 
         * @param {boolean} [deInterlace] 
         * @param {boolean} [requireNonAnamorphic] 
         * @param {number} [transcodingMaxAudioChannels] 
         * @param {number} [cpuCoreLimit] 
         * @param {string} [liveStreamId] 
         * @param {boolean} [enableMpegtsM2TsMode] 
         * @param {string} [videoCodec] 
         * @param {string} [subtitleCodec] 
         * @param {string} [transcodingReasons] 
         * @param {number} [audioStreamIndex] 
         * @param {number} [videoStreamIndex] 
         * @param {EncodingContext} [context] 
         * @param {{ [key: string]: string; }} [streamOptions] 
         * @param {boolean} [enableAdaptiveBitrateStreaming] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMasterHlsVideoPlaylist(itemId: string, container: string, mediaSourceId: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, enableAdaptiveBitrateStreaming?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DynamicHlsApiAxiosParamCreator(configuration).getMasterHlsVideoPlaylist(itemId, container, mediaSourceId, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, enableAdaptiveBitrateStreaming, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} container 
         * @param {boolean} [_static] 
         * @param {string} [params] 
         * @param {string} [tag] 
         * @param {string} [deviceProfileId] 
         * @param {string} [playSessionId] 
         * @param {string} [segmentContainer] 
         * @param {number} [segmentLength] 
         * @param {number} [minSegments] 
         * @param {string} [mediaSourceId] 
         * @param {string} [deviceId] 
         * @param {string} [audioCodec] 
         * @param {boolean} [enableAutoStreamCopy] 
         * @param {boolean} [allowVideoStreamCopy] 
         * @param {boolean} [allowAudioStreamCopy] 
         * @param {boolean} [breakOnNonKeyFrames] 
         * @param {number} [audioSampleRate] 
         * @param {number} [maxAudioBitDepth] 
         * @param {number} [audioBitRate] 
         * @param {number} [audioChannels] 
         * @param {number} [maxAudioChannels] 
         * @param {string} [profile] 
         * @param {string} [level] 
         * @param {number} [framerate] 
         * @param {number} [maxFramerate] 
         * @param {boolean} [copyTimestamps] 
         * @param {number} [startTimeTicks] 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [videoBitRate] 
         * @param {number} [subtitleStreamIndex] 
         * @param {SubtitleDeliveryMethod} [subtitleMethod] 
         * @param {number} [maxRefFrames] 
         * @param {number} [maxVideoBitDepth] 
         * @param {boolean} [requireAvc] 
         * @param {boolean} [deInterlace] 
         * @param {boolean} [requireNonAnamorphic] 
         * @param {number} [transcodingMaxAudioChannels] 
         * @param {number} [cpuCoreLimit] 
         * @param {string} [liveStreamId] 
         * @param {boolean} [enableMpegtsM2TsMode] 
         * @param {string} [videoCodec] 
         * @param {string} [subtitleCodec] 
         * @param {string} [transcodingReasons] 
         * @param {number} [audioStreamIndex] 
         * @param {number} [videoStreamIndex] 
         * @param {EncodingContext} [context] 
         * @param {{ [key: string]: string; }} [streamOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVariantHlsAudioPlaylist(itemId: string, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DynamicHlsApiAxiosParamCreator(configuration).getVariantHlsAudioPlaylist(itemId, container, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} container 
         * @param {boolean} [_static] 
         * @param {string} [params] 
         * @param {string} [tag] 
         * @param {string} [deviceProfileId] 
         * @param {string} [playSessionId] 
         * @param {string} [segmentContainer] 
         * @param {number} [segmentLength] 
         * @param {number} [minSegments] 
         * @param {string} [mediaSourceId] 
         * @param {string} [deviceId] 
         * @param {string} [audioCodec] 
         * @param {boolean} [enableAutoStreamCopy] 
         * @param {boolean} [allowVideoStreamCopy] 
         * @param {boolean} [allowAudioStreamCopy] 
         * @param {boolean} [breakOnNonKeyFrames] 
         * @param {number} [audioSampleRate] 
         * @param {number} [maxAudioBitDepth] 
         * @param {number} [audioBitRate] 
         * @param {number} [audioChannels] 
         * @param {number} [maxAudioChannels] 
         * @param {string} [profile] 
         * @param {string} [level] 
         * @param {number} [framerate] 
         * @param {number} [maxFramerate] 
         * @param {boolean} [copyTimestamps] 
         * @param {number} [startTimeTicks] 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [videoBitRate] 
         * @param {number} [subtitleStreamIndex] 
         * @param {SubtitleDeliveryMethod} [subtitleMethod] 
         * @param {number} [maxRefFrames] 
         * @param {number} [maxVideoBitDepth] 
         * @param {boolean} [requireAvc] 
         * @param {boolean} [deInterlace] 
         * @param {boolean} [requireNonAnamorphic] 
         * @param {number} [transcodingMaxAudioChannels] 
         * @param {number} [cpuCoreLimit] 
         * @param {string} [liveStreamId] 
         * @param {boolean} [enableMpegtsM2TsMode] 
         * @param {string} [videoCodec] 
         * @param {string} [subtitleCodec] 
         * @param {string} [transcodingReasons] 
         * @param {number} [audioStreamIndex] 
         * @param {number} [videoStreamIndex] 
         * @param {EncodingContext} [context] 
         * @param {{ [key: string]: string; }} [streamOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVariantHlsVideoPlaylist(itemId: string, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DynamicHlsApiAxiosParamCreator(configuration).getVariantHlsVideoPlaylist(itemId, container, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} container 
         * @param {string} mediaSourceId 
         * @param {boolean} [_static] 
         * @param {string} [params] 
         * @param {string} [tag] 
         * @param {string} [deviceProfileId] 
         * @param {string} [playSessionId] 
         * @param {string} [segmentContainer] 
         * @param {number} [segmentLength] 
         * @param {number} [minSegments] 
         * @param {string} [deviceId] 
         * @param {string} [audioCodec] 
         * @param {boolean} [enableAutoStreamCopy] 
         * @param {boolean} [allowVideoStreamCopy] 
         * @param {boolean} [allowAudioStreamCopy] 
         * @param {boolean} [breakOnNonKeyFrames] 
         * @param {number} [audioSampleRate] 
         * @param {number} [maxAudioBitDepth] 
         * @param {number} [audioBitRate] 
         * @param {number} [audioChannels] 
         * @param {number} [maxAudioChannels] 
         * @param {string} [profile] 
         * @param {string} [level] 
         * @param {number} [framerate] 
         * @param {number} [maxFramerate] 
         * @param {boolean} [copyTimestamps] 
         * @param {number} [startTimeTicks] 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [videoBitRate] 
         * @param {number} [subtitleStreamIndex] 
         * @param {SubtitleDeliveryMethod} [subtitleMethod] 
         * @param {number} [maxRefFrames] 
         * @param {number} [maxVideoBitDepth] 
         * @param {boolean} [requireAvc] 
         * @param {boolean} [deInterlace] 
         * @param {boolean} [requireNonAnamorphic] 
         * @param {number} [transcodingMaxAudioChannels] 
         * @param {number} [cpuCoreLimit] 
         * @param {string} [liveStreamId] 
         * @param {boolean} [enableMpegtsM2TsMode] 
         * @param {string} [videoCodec] 
         * @param {string} [subtitleCodec] 
         * @param {string} [transcodingReasons] 
         * @param {number} [audioStreamIndex] 
         * @param {number} [videoStreamIndex] 
         * @param {EncodingContext} [context] 
         * @param {{ [key: string]: string; }} [streamOptions] 
         * @param {boolean} [enableAdaptiveBitrateStreaming] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headMasterHlsAudioPlaylist(itemId: string, container: string, mediaSourceId: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, enableAdaptiveBitrateStreaming?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DynamicHlsApiAxiosParamCreator(configuration).headMasterHlsAudioPlaylist(itemId, container, mediaSourceId, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, enableAdaptiveBitrateStreaming, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} container 
         * @param {string} mediaSourceId 
         * @param {boolean} [_static] 
         * @param {string} [params] 
         * @param {string} [tag] 
         * @param {string} [deviceProfileId] 
         * @param {string} [playSessionId] 
         * @param {string} [segmentContainer] 
         * @param {number} [segmentLength] 
         * @param {number} [minSegments] 
         * @param {string} [deviceId] 
         * @param {string} [audioCodec] 
         * @param {boolean} [enableAutoStreamCopy] 
         * @param {boolean} [allowVideoStreamCopy] 
         * @param {boolean} [allowAudioStreamCopy] 
         * @param {boolean} [breakOnNonKeyFrames] 
         * @param {number} [audioSampleRate] 
         * @param {number} [maxAudioBitDepth] 
         * @param {number} [audioBitRate] 
         * @param {number} [audioChannels] 
         * @param {number} [maxAudioChannels] 
         * @param {string} [profile] 
         * @param {string} [level] 
         * @param {number} [framerate] 
         * @param {number} [maxFramerate] 
         * @param {boolean} [copyTimestamps] 
         * @param {number} [startTimeTicks] 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [videoBitRate] 
         * @param {number} [subtitleStreamIndex] 
         * @param {SubtitleDeliveryMethod} [subtitleMethod] 
         * @param {number} [maxRefFrames] 
         * @param {number} [maxVideoBitDepth] 
         * @param {boolean} [requireAvc] 
         * @param {boolean} [deInterlace] 
         * @param {boolean} [requireNonAnamorphic] 
         * @param {number} [transcodingMaxAudioChannels] 
         * @param {number} [cpuCoreLimit] 
         * @param {string} [liveStreamId] 
         * @param {boolean} [enableMpegtsM2TsMode] 
         * @param {string} [videoCodec] 
         * @param {string} [subtitleCodec] 
         * @param {string} [transcodingReasons] 
         * @param {number} [audioStreamIndex] 
         * @param {number} [videoStreamIndex] 
         * @param {EncodingContext} [context] 
         * @param {{ [key: string]: string; }} [streamOptions] 
         * @param {boolean} [enableAdaptiveBitrateStreaming] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headMasterHlsVideoPlaylist(itemId: string, container: string, mediaSourceId: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, enableAdaptiveBitrateStreaming?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DynamicHlsApiAxiosParamCreator(configuration).headMasterHlsVideoPlaylist(itemId, container, mediaSourceId, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, enableAdaptiveBitrateStreaming, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DynamicHlsApi - factory interface
 * @export
 */
export const DynamicHlsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} itemId 
         * @param {string} playlistId 
         * @param {number} segmentId 
         * @param {string} container 
         * @param {boolean} [_static] 
         * @param {string} [params] 
         * @param {string} [tag] 
         * @param {string} [deviceProfileId] 
         * @param {string} [playSessionId] 
         * @param {string} [segmentContainer] 
         * @param {number} [segmentLength] 
         * @param {number} [minSegments] 
         * @param {string} [mediaSourceId] 
         * @param {string} [deviceId] 
         * @param {string} [audioCodec] 
         * @param {boolean} [enableAutoStreamCopy] 
         * @param {boolean} [allowVideoStreamCopy] 
         * @param {boolean} [allowAudioStreamCopy] 
         * @param {boolean} [breakOnNonKeyFrames] 
         * @param {number} [audioSampleRate] 
         * @param {number} [maxAudioBitDepth] 
         * @param {number} [audioBitRate] 
         * @param {number} [audioChannels] 
         * @param {number} [maxAudioChannels] 
         * @param {string} [profile] 
         * @param {string} [level] 
         * @param {number} [framerate] 
         * @param {number} [maxFramerate] 
         * @param {boolean} [copyTimestamps] 
         * @param {number} [startTimeTicks] 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [videoBitRate] 
         * @param {number} [subtitleStreamIndex] 
         * @param {SubtitleDeliveryMethod} [subtitleMethod] 
         * @param {number} [maxRefFrames] 
         * @param {number} [maxVideoBitDepth] 
         * @param {boolean} [requireAvc] 
         * @param {boolean} [deInterlace] 
         * @param {boolean} [requireNonAnamorphic] 
         * @param {number} [transcodingMaxAudioChannels] 
         * @param {number} [cpuCoreLimit] 
         * @param {string} [liveStreamId] 
         * @param {boolean} [enableMpegtsM2TsMode] 
         * @param {string} [videoCodec] 
         * @param {string} [subtitleCodec] 
         * @param {string} [transcodingReasons] 
         * @param {number} [audioStreamIndex] 
         * @param {number} [videoStreamIndex] 
         * @param {EncodingContext} [context] 
         * @param {{ [key: string]: string; }} [streamOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHlsAudioSegment(itemId: string, playlistId: string, segmentId: number, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any): AxiosPromise<void> {
            return DynamicHlsApiFp(configuration).getHlsAudioSegment(itemId, playlistId, segmentId, container, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} playlistId 
         * @param {number} segmentId 
         * @param {string} container 
         * @param {boolean} [_static] 
         * @param {string} [params] 
         * @param {string} [tag] 
         * @param {string} [deviceProfileId] 
         * @param {string} [playSessionId] 
         * @param {string} [segmentContainer] 
         * @param {number} [segmentLength] 
         * @param {number} [minSegments] 
         * @param {string} [mediaSourceId] 
         * @param {string} [deviceId] 
         * @param {string} [audioCodec] 
         * @param {boolean} [enableAutoStreamCopy] 
         * @param {boolean} [allowVideoStreamCopy] 
         * @param {boolean} [allowAudioStreamCopy] 
         * @param {boolean} [breakOnNonKeyFrames] 
         * @param {number} [audioSampleRate] 
         * @param {number} [maxAudioBitDepth] 
         * @param {number} [audioBitRate] 
         * @param {number} [audioChannels] 
         * @param {number} [maxAudioChannels] 
         * @param {string} [profile] 
         * @param {string} [level] 
         * @param {number} [framerate] 
         * @param {number} [maxFramerate] 
         * @param {boolean} [copyTimestamps] 
         * @param {number} [startTimeTicks] 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [videoBitRate] 
         * @param {number} [subtitleStreamIndex] 
         * @param {SubtitleDeliveryMethod} [subtitleMethod] 
         * @param {number} [maxRefFrames] 
         * @param {number} [maxVideoBitDepth] 
         * @param {boolean} [requireAvc] 
         * @param {boolean} [deInterlace] 
         * @param {boolean} [requireNonAnamorphic] 
         * @param {number} [transcodingMaxAudioChannels] 
         * @param {number} [cpuCoreLimit] 
         * @param {string} [liveStreamId] 
         * @param {boolean} [enableMpegtsM2TsMode] 
         * @param {string} [videoCodec] 
         * @param {string} [subtitleCodec] 
         * @param {string} [transcodingReasons] 
         * @param {number} [audioStreamIndex] 
         * @param {number} [videoStreamIndex] 
         * @param {EncodingContext} [context] 
         * @param {{ [key: string]: string; }} [streamOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHlsVideoSegment(itemId: string, playlistId: string, segmentId: number, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any): AxiosPromise<void> {
            return DynamicHlsApiFp(configuration).getHlsVideoSegment(itemId, playlistId, segmentId, container, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} container 
         * @param {string} mediaSourceId 
         * @param {boolean} [_static] 
         * @param {string} [params] 
         * @param {string} [tag] 
         * @param {string} [deviceProfileId] 
         * @param {string} [playSessionId] 
         * @param {string} [segmentContainer] 
         * @param {number} [segmentLength] 
         * @param {number} [minSegments] 
         * @param {string} [deviceId] 
         * @param {string} [audioCodec] 
         * @param {boolean} [enableAutoStreamCopy] 
         * @param {boolean} [allowVideoStreamCopy] 
         * @param {boolean} [allowAudioStreamCopy] 
         * @param {boolean} [breakOnNonKeyFrames] 
         * @param {number} [audioSampleRate] 
         * @param {number} [maxAudioBitDepth] 
         * @param {number} [audioBitRate] 
         * @param {number} [audioChannels] 
         * @param {number} [maxAudioChannels] 
         * @param {string} [profile] 
         * @param {string} [level] 
         * @param {number} [framerate] 
         * @param {number} [maxFramerate] 
         * @param {boolean} [copyTimestamps] 
         * @param {number} [startTimeTicks] 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [videoBitRate] 
         * @param {number} [subtitleStreamIndex] 
         * @param {SubtitleDeliveryMethod} [subtitleMethod] 
         * @param {number} [maxRefFrames] 
         * @param {number} [maxVideoBitDepth] 
         * @param {boolean} [requireAvc] 
         * @param {boolean} [deInterlace] 
         * @param {boolean} [requireNonAnamorphic] 
         * @param {number} [transcodingMaxAudioChannels] 
         * @param {number} [cpuCoreLimit] 
         * @param {string} [liveStreamId] 
         * @param {boolean} [enableMpegtsM2TsMode] 
         * @param {string} [videoCodec] 
         * @param {string} [subtitleCodec] 
         * @param {string} [transcodingReasons] 
         * @param {number} [audioStreamIndex] 
         * @param {number} [videoStreamIndex] 
         * @param {EncodingContext} [context] 
         * @param {{ [key: string]: string; }} [streamOptions] 
         * @param {boolean} [enableAdaptiveBitrateStreaming] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterHlsAudioPlaylist(itemId: string, container: string, mediaSourceId: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, enableAdaptiveBitrateStreaming?: boolean, options?: any): AxiosPromise<void> {
            return DynamicHlsApiFp(configuration).getMasterHlsAudioPlaylist(itemId, container, mediaSourceId, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, enableAdaptiveBitrateStreaming, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} container 
         * @param {string} mediaSourceId 
         * @param {boolean} [_static] 
         * @param {string} [params] 
         * @param {string} [tag] 
         * @param {string} [deviceProfileId] 
         * @param {string} [playSessionId] 
         * @param {string} [segmentContainer] 
         * @param {number} [segmentLength] 
         * @param {number} [minSegments] 
         * @param {string} [deviceId] 
         * @param {string} [audioCodec] 
         * @param {boolean} [enableAutoStreamCopy] 
         * @param {boolean} [allowVideoStreamCopy] 
         * @param {boolean} [allowAudioStreamCopy] 
         * @param {boolean} [breakOnNonKeyFrames] 
         * @param {number} [audioSampleRate] 
         * @param {number} [maxAudioBitDepth] 
         * @param {number} [audioBitRate] 
         * @param {number} [audioChannels] 
         * @param {number} [maxAudioChannels] 
         * @param {string} [profile] 
         * @param {string} [level] 
         * @param {number} [framerate] 
         * @param {number} [maxFramerate] 
         * @param {boolean} [copyTimestamps] 
         * @param {number} [startTimeTicks] 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [videoBitRate] 
         * @param {number} [subtitleStreamIndex] 
         * @param {SubtitleDeliveryMethod} [subtitleMethod] 
         * @param {number} [maxRefFrames] 
         * @param {number} [maxVideoBitDepth] 
         * @param {boolean} [requireAvc] 
         * @param {boolean} [deInterlace] 
         * @param {boolean} [requireNonAnamorphic] 
         * @param {number} [transcodingMaxAudioChannels] 
         * @param {number} [cpuCoreLimit] 
         * @param {string} [liveStreamId] 
         * @param {boolean} [enableMpegtsM2TsMode] 
         * @param {string} [videoCodec] 
         * @param {string} [subtitleCodec] 
         * @param {string} [transcodingReasons] 
         * @param {number} [audioStreamIndex] 
         * @param {number} [videoStreamIndex] 
         * @param {EncodingContext} [context] 
         * @param {{ [key: string]: string; }} [streamOptions] 
         * @param {boolean} [enableAdaptiveBitrateStreaming] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMasterHlsVideoPlaylist(itemId: string, container: string, mediaSourceId: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, enableAdaptiveBitrateStreaming?: boolean, options?: any): AxiosPromise<void> {
            return DynamicHlsApiFp(configuration).getMasterHlsVideoPlaylist(itemId, container, mediaSourceId, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, enableAdaptiveBitrateStreaming, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} container 
         * @param {boolean} [_static] 
         * @param {string} [params] 
         * @param {string} [tag] 
         * @param {string} [deviceProfileId] 
         * @param {string} [playSessionId] 
         * @param {string} [segmentContainer] 
         * @param {number} [segmentLength] 
         * @param {number} [minSegments] 
         * @param {string} [mediaSourceId] 
         * @param {string} [deviceId] 
         * @param {string} [audioCodec] 
         * @param {boolean} [enableAutoStreamCopy] 
         * @param {boolean} [allowVideoStreamCopy] 
         * @param {boolean} [allowAudioStreamCopy] 
         * @param {boolean} [breakOnNonKeyFrames] 
         * @param {number} [audioSampleRate] 
         * @param {number} [maxAudioBitDepth] 
         * @param {number} [audioBitRate] 
         * @param {number} [audioChannels] 
         * @param {number} [maxAudioChannels] 
         * @param {string} [profile] 
         * @param {string} [level] 
         * @param {number} [framerate] 
         * @param {number} [maxFramerate] 
         * @param {boolean} [copyTimestamps] 
         * @param {number} [startTimeTicks] 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [videoBitRate] 
         * @param {number} [subtitleStreamIndex] 
         * @param {SubtitleDeliveryMethod} [subtitleMethod] 
         * @param {number} [maxRefFrames] 
         * @param {number} [maxVideoBitDepth] 
         * @param {boolean} [requireAvc] 
         * @param {boolean} [deInterlace] 
         * @param {boolean} [requireNonAnamorphic] 
         * @param {number} [transcodingMaxAudioChannels] 
         * @param {number} [cpuCoreLimit] 
         * @param {string} [liveStreamId] 
         * @param {boolean} [enableMpegtsM2TsMode] 
         * @param {string} [videoCodec] 
         * @param {string} [subtitleCodec] 
         * @param {string} [transcodingReasons] 
         * @param {number} [audioStreamIndex] 
         * @param {number} [videoStreamIndex] 
         * @param {EncodingContext} [context] 
         * @param {{ [key: string]: string; }} [streamOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariantHlsAudioPlaylist(itemId: string, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any): AxiosPromise<void> {
            return DynamicHlsApiFp(configuration).getVariantHlsAudioPlaylist(itemId, container, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} container 
         * @param {boolean} [_static] 
         * @param {string} [params] 
         * @param {string} [tag] 
         * @param {string} [deviceProfileId] 
         * @param {string} [playSessionId] 
         * @param {string} [segmentContainer] 
         * @param {number} [segmentLength] 
         * @param {number} [minSegments] 
         * @param {string} [mediaSourceId] 
         * @param {string} [deviceId] 
         * @param {string} [audioCodec] 
         * @param {boolean} [enableAutoStreamCopy] 
         * @param {boolean} [allowVideoStreamCopy] 
         * @param {boolean} [allowAudioStreamCopy] 
         * @param {boolean} [breakOnNonKeyFrames] 
         * @param {number} [audioSampleRate] 
         * @param {number} [maxAudioBitDepth] 
         * @param {number} [audioBitRate] 
         * @param {number} [audioChannels] 
         * @param {number} [maxAudioChannels] 
         * @param {string} [profile] 
         * @param {string} [level] 
         * @param {number} [framerate] 
         * @param {number} [maxFramerate] 
         * @param {boolean} [copyTimestamps] 
         * @param {number} [startTimeTicks] 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [videoBitRate] 
         * @param {number} [subtitleStreamIndex] 
         * @param {SubtitleDeliveryMethod} [subtitleMethod] 
         * @param {number} [maxRefFrames] 
         * @param {number} [maxVideoBitDepth] 
         * @param {boolean} [requireAvc] 
         * @param {boolean} [deInterlace] 
         * @param {boolean} [requireNonAnamorphic] 
         * @param {number} [transcodingMaxAudioChannels] 
         * @param {number} [cpuCoreLimit] 
         * @param {string} [liveStreamId] 
         * @param {boolean} [enableMpegtsM2TsMode] 
         * @param {string} [videoCodec] 
         * @param {string} [subtitleCodec] 
         * @param {string} [transcodingReasons] 
         * @param {number} [audioStreamIndex] 
         * @param {number} [videoStreamIndex] 
         * @param {EncodingContext} [context] 
         * @param {{ [key: string]: string; }} [streamOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariantHlsVideoPlaylist(itemId: string, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any): AxiosPromise<void> {
            return DynamicHlsApiFp(configuration).getVariantHlsVideoPlaylist(itemId, container, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} container 
         * @param {string} mediaSourceId 
         * @param {boolean} [_static] 
         * @param {string} [params] 
         * @param {string} [tag] 
         * @param {string} [deviceProfileId] 
         * @param {string} [playSessionId] 
         * @param {string} [segmentContainer] 
         * @param {number} [segmentLength] 
         * @param {number} [minSegments] 
         * @param {string} [deviceId] 
         * @param {string} [audioCodec] 
         * @param {boolean} [enableAutoStreamCopy] 
         * @param {boolean} [allowVideoStreamCopy] 
         * @param {boolean} [allowAudioStreamCopy] 
         * @param {boolean} [breakOnNonKeyFrames] 
         * @param {number} [audioSampleRate] 
         * @param {number} [maxAudioBitDepth] 
         * @param {number} [audioBitRate] 
         * @param {number} [audioChannels] 
         * @param {number} [maxAudioChannels] 
         * @param {string} [profile] 
         * @param {string} [level] 
         * @param {number} [framerate] 
         * @param {number} [maxFramerate] 
         * @param {boolean} [copyTimestamps] 
         * @param {number} [startTimeTicks] 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [videoBitRate] 
         * @param {number} [subtitleStreamIndex] 
         * @param {SubtitleDeliveryMethod} [subtitleMethod] 
         * @param {number} [maxRefFrames] 
         * @param {number} [maxVideoBitDepth] 
         * @param {boolean} [requireAvc] 
         * @param {boolean} [deInterlace] 
         * @param {boolean} [requireNonAnamorphic] 
         * @param {number} [transcodingMaxAudioChannels] 
         * @param {number} [cpuCoreLimit] 
         * @param {string} [liveStreamId] 
         * @param {boolean} [enableMpegtsM2TsMode] 
         * @param {string} [videoCodec] 
         * @param {string} [subtitleCodec] 
         * @param {string} [transcodingReasons] 
         * @param {number} [audioStreamIndex] 
         * @param {number} [videoStreamIndex] 
         * @param {EncodingContext} [context] 
         * @param {{ [key: string]: string; }} [streamOptions] 
         * @param {boolean} [enableAdaptiveBitrateStreaming] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headMasterHlsAudioPlaylist(itemId: string, container: string, mediaSourceId: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, enableAdaptiveBitrateStreaming?: boolean, options?: any): AxiosPromise<void> {
            return DynamicHlsApiFp(configuration).headMasterHlsAudioPlaylist(itemId, container, mediaSourceId, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, enableAdaptiveBitrateStreaming, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} container 
         * @param {string} mediaSourceId 
         * @param {boolean} [_static] 
         * @param {string} [params] 
         * @param {string} [tag] 
         * @param {string} [deviceProfileId] 
         * @param {string} [playSessionId] 
         * @param {string} [segmentContainer] 
         * @param {number} [segmentLength] 
         * @param {number} [minSegments] 
         * @param {string} [deviceId] 
         * @param {string} [audioCodec] 
         * @param {boolean} [enableAutoStreamCopy] 
         * @param {boolean} [allowVideoStreamCopy] 
         * @param {boolean} [allowAudioStreamCopy] 
         * @param {boolean} [breakOnNonKeyFrames] 
         * @param {number} [audioSampleRate] 
         * @param {number} [maxAudioBitDepth] 
         * @param {number} [audioBitRate] 
         * @param {number} [audioChannels] 
         * @param {number} [maxAudioChannels] 
         * @param {string} [profile] 
         * @param {string} [level] 
         * @param {number} [framerate] 
         * @param {number} [maxFramerate] 
         * @param {boolean} [copyTimestamps] 
         * @param {number} [startTimeTicks] 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [videoBitRate] 
         * @param {number} [subtitleStreamIndex] 
         * @param {SubtitleDeliveryMethod} [subtitleMethod] 
         * @param {number} [maxRefFrames] 
         * @param {number} [maxVideoBitDepth] 
         * @param {boolean} [requireAvc] 
         * @param {boolean} [deInterlace] 
         * @param {boolean} [requireNonAnamorphic] 
         * @param {number} [transcodingMaxAudioChannels] 
         * @param {number} [cpuCoreLimit] 
         * @param {string} [liveStreamId] 
         * @param {boolean} [enableMpegtsM2TsMode] 
         * @param {string} [videoCodec] 
         * @param {string} [subtitleCodec] 
         * @param {string} [transcodingReasons] 
         * @param {number} [audioStreamIndex] 
         * @param {number} [videoStreamIndex] 
         * @param {EncodingContext} [context] 
         * @param {{ [key: string]: string; }} [streamOptions] 
         * @param {boolean} [enableAdaptiveBitrateStreaming] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headMasterHlsVideoPlaylist(itemId: string, container: string, mediaSourceId: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, enableAdaptiveBitrateStreaming?: boolean, options?: any): AxiosPromise<void> {
            return DynamicHlsApiFp(configuration).headMasterHlsVideoPlaylist(itemId, container, mediaSourceId, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, enableAdaptiveBitrateStreaming, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getHlsAudioSegment operation in DynamicHlsApi.
 * @export
 * @interface DynamicHlsApiGetHlsAudioSegmentRequest
 */
export interface DynamicHlsApiGetHlsAudioSegmentRequest {
    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly itemId: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly playlistId: string

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly segmentId: number

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly container: string

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly _static?: boolean

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly params?: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly deviceProfileId?: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly playSessionId?: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly segmentContainer?: string

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly segmentLength?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly minSegments?: number

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly mediaSourceId?: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly deviceId?: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly audioCodec?: string

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly enableAutoStreamCopy?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly allowVideoStreamCopy?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly allowAudioStreamCopy?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly breakOnNonKeyFrames?: boolean

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly audioSampleRate?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly maxAudioBitDepth?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly audioBitRate?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly audioChannels?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly maxAudioChannels?: number

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly profile?: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly level?: string

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly framerate?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly maxFramerate?: number

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly copyTimestamps?: boolean

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly startTimeTicks?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly width?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly height?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly videoBitRate?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly subtitleStreamIndex?: number

    /**
     * 
     * @type {SubtitleDeliveryMethod}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly subtitleMethod?: SubtitleDeliveryMethod

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly maxRefFrames?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly maxVideoBitDepth?: number

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly requireAvc?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly deInterlace?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly requireNonAnamorphic?: boolean

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly transcodingMaxAudioChannels?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly cpuCoreLimit?: number

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly liveStreamId?: string

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly enableMpegtsM2TsMode?: boolean

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly videoCodec?: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly subtitleCodec?: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly transcodingReasons?: string

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly audioStreamIndex?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly videoStreamIndex?: number

    /**
     * 
     * @type {EncodingContext}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly context?: EncodingContext

    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof DynamicHlsApiGetHlsAudioSegment
     */
    readonly streamOptions?: { [key: string]: string; }
}

/**
 * Request parameters for getHlsVideoSegment operation in DynamicHlsApi.
 * @export
 * @interface DynamicHlsApiGetHlsVideoSegmentRequest
 */
export interface DynamicHlsApiGetHlsVideoSegmentRequest {
    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly itemId: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly playlistId: string

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly segmentId: number

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly container: string

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly _static?: boolean

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly params?: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly deviceProfileId?: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly playSessionId?: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly segmentContainer?: string

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly segmentLength?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly minSegments?: number

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly mediaSourceId?: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly deviceId?: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly audioCodec?: string

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly enableAutoStreamCopy?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly allowVideoStreamCopy?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly allowAudioStreamCopy?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly breakOnNonKeyFrames?: boolean

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly audioSampleRate?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly maxAudioBitDepth?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly audioBitRate?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly audioChannels?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly maxAudioChannels?: number

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly profile?: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly level?: string

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly framerate?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly maxFramerate?: number

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly copyTimestamps?: boolean

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly startTimeTicks?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly width?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly height?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly videoBitRate?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly subtitleStreamIndex?: number

    /**
     * 
     * @type {SubtitleDeliveryMethod}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly subtitleMethod?: SubtitleDeliveryMethod

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly maxRefFrames?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly maxVideoBitDepth?: number

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly requireAvc?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly deInterlace?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly requireNonAnamorphic?: boolean

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly transcodingMaxAudioChannels?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly cpuCoreLimit?: number

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly liveStreamId?: string

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly enableMpegtsM2TsMode?: boolean

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly videoCodec?: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly subtitleCodec?: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly transcodingReasons?: string

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly audioStreamIndex?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly videoStreamIndex?: number

    /**
     * 
     * @type {EncodingContext}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly context?: EncodingContext

    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof DynamicHlsApiGetHlsVideoSegment
     */
    readonly streamOptions?: { [key: string]: string; }
}

/**
 * Request parameters for getMasterHlsAudioPlaylist operation in DynamicHlsApi.
 * @export
 * @interface DynamicHlsApiGetMasterHlsAudioPlaylistRequest
 */
export interface DynamicHlsApiGetMasterHlsAudioPlaylistRequest {
    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly itemId: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly container: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly mediaSourceId: string

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly _static?: boolean

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly params?: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly deviceProfileId?: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly playSessionId?: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly segmentContainer?: string

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly segmentLength?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly minSegments?: number

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly deviceId?: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly audioCodec?: string

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly enableAutoStreamCopy?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly allowVideoStreamCopy?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly allowAudioStreamCopy?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly breakOnNonKeyFrames?: boolean

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly audioSampleRate?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly maxAudioBitDepth?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly audioBitRate?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly audioChannels?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly maxAudioChannels?: number

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly profile?: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly level?: string

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly framerate?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly maxFramerate?: number

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly copyTimestamps?: boolean

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly startTimeTicks?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly width?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly height?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly videoBitRate?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly subtitleStreamIndex?: number

    /**
     * 
     * @type {SubtitleDeliveryMethod}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly subtitleMethod?: SubtitleDeliveryMethod

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly maxRefFrames?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly maxVideoBitDepth?: number

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly requireAvc?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly deInterlace?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly requireNonAnamorphic?: boolean

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly transcodingMaxAudioChannels?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly cpuCoreLimit?: number

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly liveStreamId?: string

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly enableMpegtsM2TsMode?: boolean

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly videoCodec?: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly subtitleCodec?: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly transcodingReasons?: string

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly audioStreamIndex?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly videoStreamIndex?: number

    /**
     * 
     * @type {EncodingContext}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly context?: EncodingContext

    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly streamOptions?: { [key: string]: string; }

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiGetMasterHlsAudioPlaylist
     */
    readonly enableAdaptiveBitrateStreaming?: boolean
}

/**
 * Request parameters for getMasterHlsVideoPlaylist operation in DynamicHlsApi.
 * @export
 * @interface DynamicHlsApiGetMasterHlsVideoPlaylistRequest
 */
export interface DynamicHlsApiGetMasterHlsVideoPlaylistRequest {
    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly itemId: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly container: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly mediaSourceId: string

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly _static?: boolean

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly params?: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly deviceProfileId?: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly playSessionId?: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly segmentContainer?: string

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly segmentLength?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly minSegments?: number

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly deviceId?: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly audioCodec?: string

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly enableAutoStreamCopy?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly allowVideoStreamCopy?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly allowAudioStreamCopy?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly breakOnNonKeyFrames?: boolean

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly audioSampleRate?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly maxAudioBitDepth?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly audioBitRate?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly audioChannels?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly maxAudioChannels?: number

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly profile?: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly level?: string

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly framerate?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly maxFramerate?: number

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly copyTimestamps?: boolean

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly startTimeTicks?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly width?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly height?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly videoBitRate?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly subtitleStreamIndex?: number

    /**
     * 
     * @type {SubtitleDeliveryMethod}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly subtitleMethod?: SubtitleDeliveryMethod

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly maxRefFrames?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly maxVideoBitDepth?: number

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly requireAvc?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly deInterlace?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly requireNonAnamorphic?: boolean

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly transcodingMaxAudioChannels?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly cpuCoreLimit?: number

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly liveStreamId?: string

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly enableMpegtsM2TsMode?: boolean

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly videoCodec?: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly subtitleCodec?: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly transcodingReasons?: string

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly audioStreamIndex?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly videoStreamIndex?: number

    /**
     * 
     * @type {EncodingContext}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly context?: EncodingContext

    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly streamOptions?: { [key: string]: string; }

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiGetMasterHlsVideoPlaylist
     */
    readonly enableAdaptiveBitrateStreaming?: boolean
}

/**
 * Request parameters for getVariantHlsAudioPlaylist operation in DynamicHlsApi.
 * @export
 * @interface DynamicHlsApiGetVariantHlsAudioPlaylistRequest
 */
export interface DynamicHlsApiGetVariantHlsAudioPlaylistRequest {
    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly itemId: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly container: string

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly _static?: boolean

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly params?: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly deviceProfileId?: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly playSessionId?: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly segmentContainer?: string

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly segmentLength?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly minSegments?: number

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly mediaSourceId?: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly deviceId?: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly audioCodec?: string

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly enableAutoStreamCopy?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly allowVideoStreamCopy?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly allowAudioStreamCopy?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly breakOnNonKeyFrames?: boolean

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly audioSampleRate?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly maxAudioBitDepth?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly audioBitRate?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly audioChannels?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly maxAudioChannels?: number

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly profile?: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly level?: string

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly framerate?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly maxFramerate?: number

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly copyTimestamps?: boolean

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly startTimeTicks?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly width?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly height?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly videoBitRate?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly subtitleStreamIndex?: number

    /**
     * 
     * @type {SubtitleDeliveryMethod}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly subtitleMethod?: SubtitleDeliveryMethod

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly maxRefFrames?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly maxVideoBitDepth?: number

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly requireAvc?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly deInterlace?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly requireNonAnamorphic?: boolean

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly transcodingMaxAudioChannels?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly cpuCoreLimit?: number

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly liveStreamId?: string

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly enableMpegtsM2TsMode?: boolean

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly videoCodec?: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly subtitleCodec?: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly transcodingReasons?: string

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly audioStreamIndex?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly videoStreamIndex?: number

    /**
     * 
     * @type {EncodingContext}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly context?: EncodingContext

    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof DynamicHlsApiGetVariantHlsAudioPlaylist
     */
    readonly streamOptions?: { [key: string]: string; }
}

/**
 * Request parameters for getVariantHlsVideoPlaylist operation in DynamicHlsApi.
 * @export
 * @interface DynamicHlsApiGetVariantHlsVideoPlaylistRequest
 */
export interface DynamicHlsApiGetVariantHlsVideoPlaylistRequest {
    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly itemId: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly container: string

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly _static?: boolean

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly params?: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly deviceProfileId?: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly playSessionId?: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly segmentContainer?: string

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly segmentLength?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly minSegments?: number

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly mediaSourceId?: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly deviceId?: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly audioCodec?: string

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly enableAutoStreamCopy?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly allowVideoStreamCopy?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly allowAudioStreamCopy?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly breakOnNonKeyFrames?: boolean

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly audioSampleRate?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly maxAudioBitDepth?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly audioBitRate?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly audioChannels?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly maxAudioChannels?: number

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly profile?: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly level?: string

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly framerate?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly maxFramerate?: number

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly copyTimestamps?: boolean

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly startTimeTicks?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly width?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly height?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly videoBitRate?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly subtitleStreamIndex?: number

    /**
     * 
     * @type {SubtitleDeliveryMethod}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly subtitleMethod?: SubtitleDeliveryMethod

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly maxRefFrames?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly maxVideoBitDepth?: number

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly requireAvc?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly deInterlace?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly requireNonAnamorphic?: boolean

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly transcodingMaxAudioChannels?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly cpuCoreLimit?: number

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly liveStreamId?: string

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly enableMpegtsM2TsMode?: boolean

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly videoCodec?: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly subtitleCodec?: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly transcodingReasons?: string

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly audioStreamIndex?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly videoStreamIndex?: number

    /**
     * 
     * @type {EncodingContext}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly context?: EncodingContext

    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof DynamicHlsApiGetVariantHlsVideoPlaylist
     */
    readonly streamOptions?: { [key: string]: string; }
}

/**
 * Request parameters for headMasterHlsAudioPlaylist operation in DynamicHlsApi.
 * @export
 * @interface DynamicHlsApiHeadMasterHlsAudioPlaylistRequest
 */
export interface DynamicHlsApiHeadMasterHlsAudioPlaylistRequest {
    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly itemId: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly container: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly mediaSourceId: string

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly _static?: boolean

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly params?: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly deviceProfileId?: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly playSessionId?: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly segmentContainer?: string

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly segmentLength?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly minSegments?: number

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly deviceId?: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly audioCodec?: string

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly enableAutoStreamCopy?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly allowVideoStreamCopy?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly allowAudioStreamCopy?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly breakOnNonKeyFrames?: boolean

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly audioSampleRate?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly maxAudioBitDepth?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly audioBitRate?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly audioChannels?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly maxAudioChannels?: number

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly profile?: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly level?: string

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly framerate?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly maxFramerate?: number

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly copyTimestamps?: boolean

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly startTimeTicks?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly width?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly height?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly videoBitRate?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly subtitleStreamIndex?: number

    /**
     * 
     * @type {SubtitleDeliveryMethod}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly subtitleMethod?: SubtitleDeliveryMethod

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly maxRefFrames?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly maxVideoBitDepth?: number

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly requireAvc?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly deInterlace?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly requireNonAnamorphic?: boolean

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly transcodingMaxAudioChannels?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly cpuCoreLimit?: number

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly liveStreamId?: string

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly enableMpegtsM2TsMode?: boolean

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly videoCodec?: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly subtitleCodec?: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly transcodingReasons?: string

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly audioStreamIndex?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly videoStreamIndex?: number

    /**
     * 
     * @type {EncodingContext}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly context?: EncodingContext

    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly streamOptions?: { [key: string]: string; }

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiHeadMasterHlsAudioPlaylist
     */
    readonly enableAdaptiveBitrateStreaming?: boolean
}

/**
 * Request parameters for headMasterHlsVideoPlaylist operation in DynamicHlsApi.
 * @export
 * @interface DynamicHlsApiHeadMasterHlsVideoPlaylistRequest
 */
export interface DynamicHlsApiHeadMasterHlsVideoPlaylistRequest {
    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly itemId: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly container: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly mediaSourceId: string

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly _static?: boolean

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly params?: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly deviceProfileId?: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly playSessionId?: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly segmentContainer?: string

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly segmentLength?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly minSegments?: number

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly deviceId?: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly audioCodec?: string

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly enableAutoStreamCopy?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly allowVideoStreamCopy?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly allowAudioStreamCopy?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly breakOnNonKeyFrames?: boolean

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly audioSampleRate?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly maxAudioBitDepth?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly audioBitRate?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly audioChannels?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly maxAudioChannels?: number

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly profile?: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly level?: string

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly framerate?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly maxFramerate?: number

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly copyTimestamps?: boolean

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly startTimeTicks?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly width?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly height?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly videoBitRate?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly subtitleStreamIndex?: number

    /**
     * 
     * @type {SubtitleDeliveryMethod}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly subtitleMethod?: SubtitleDeliveryMethod

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly maxRefFrames?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly maxVideoBitDepth?: number

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly requireAvc?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly deInterlace?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly requireNonAnamorphic?: boolean

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly transcodingMaxAudioChannels?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly cpuCoreLimit?: number

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly liveStreamId?: string

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly enableMpegtsM2TsMode?: boolean

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly videoCodec?: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly subtitleCodec?: string

    /**
     * 
     * @type {string}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly transcodingReasons?: string

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly audioStreamIndex?: number

    /**
     * 
     * @type {number}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly videoStreamIndex?: number

    /**
     * 
     * @type {EncodingContext}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly context?: EncodingContext

    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly streamOptions?: { [key: string]: string; }

    /**
     * 
     * @type {boolean}
     * @memberof DynamicHlsApiHeadMasterHlsVideoPlaylist
     */
    readonly enableAdaptiveBitrateStreaming?: boolean
}

/**
 * DynamicHlsApi - object-oriented interface
 * @export
 * @class DynamicHlsApi
 * @extends {BaseAPI}
 */
export class DynamicHlsApi extends BaseAPI {
    /**
     * 
     * @param {DynamicHlsApiGetHlsAudioSegmentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DynamicHlsApi
     */
    public getHlsAudioSegment(requestParameters: DynamicHlsApiGetHlsAudioSegmentRequest, options?: any) {
        return DynamicHlsApiFp(this.configuration).getHlsAudioSegment(requestParameters.itemId, requestParameters.playlistId, requestParameters.segmentId, requestParameters.container, requestParameters._static, requestParameters.params, requestParameters.tag, requestParameters.deviceProfileId, requestParameters.playSessionId, requestParameters.segmentContainer, requestParameters.segmentLength, requestParameters.minSegments, requestParameters.mediaSourceId, requestParameters.deviceId, requestParameters.audioCodec, requestParameters.enableAutoStreamCopy, requestParameters.allowVideoStreamCopy, requestParameters.allowAudioStreamCopy, requestParameters.breakOnNonKeyFrames, requestParameters.audioSampleRate, requestParameters.maxAudioBitDepth, requestParameters.audioBitRate, requestParameters.audioChannels, requestParameters.maxAudioChannels, requestParameters.profile, requestParameters.level, requestParameters.framerate, requestParameters.maxFramerate, requestParameters.copyTimestamps, requestParameters.startTimeTicks, requestParameters.width, requestParameters.height, requestParameters.videoBitRate, requestParameters.subtitleStreamIndex, requestParameters.subtitleMethod, requestParameters.maxRefFrames, requestParameters.maxVideoBitDepth, requestParameters.requireAvc, requestParameters.deInterlace, requestParameters.requireNonAnamorphic, requestParameters.transcodingMaxAudioChannels, requestParameters.cpuCoreLimit, requestParameters.liveStreamId, requestParameters.enableMpegtsM2TsMode, requestParameters.videoCodec, requestParameters.subtitleCodec, requestParameters.transcodingReasons, requestParameters.audioStreamIndex, requestParameters.videoStreamIndex, requestParameters.context, requestParameters.streamOptions, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DynamicHlsApiGetHlsVideoSegmentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DynamicHlsApi
     */
    public getHlsVideoSegment(requestParameters: DynamicHlsApiGetHlsVideoSegmentRequest, options?: any) {
        return DynamicHlsApiFp(this.configuration).getHlsVideoSegment(requestParameters.itemId, requestParameters.playlistId, requestParameters.segmentId, requestParameters.container, requestParameters._static, requestParameters.params, requestParameters.tag, requestParameters.deviceProfileId, requestParameters.playSessionId, requestParameters.segmentContainer, requestParameters.segmentLength, requestParameters.minSegments, requestParameters.mediaSourceId, requestParameters.deviceId, requestParameters.audioCodec, requestParameters.enableAutoStreamCopy, requestParameters.allowVideoStreamCopy, requestParameters.allowAudioStreamCopy, requestParameters.breakOnNonKeyFrames, requestParameters.audioSampleRate, requestParameters.maxAudioBitDepth, requestParameters.audioBitRate, requestParameters.audioChannels, requestParameters.maxAudioChannels, requestParameters.profile, requestParameters.level, requestParameters.framerate, requestParameters.maxFramerate, requestParameters.copyTimestamps, requestParameters.startTimeTicks, requestParameters.width, requestParameters.height, requestParameters.videoBitRate, requestParameters.subtitleStreamIndex, requestParameters.subtitleMethod, requestParameters.maxRefFrames, requestParameters.maxVideoBitDepth, requestParameters.requireAvc, requestParameters.deInterlace, requestParameters.requireNonAnamorphic, requestParameters.transcodingMaxAudioChannels, requestParameters.cpuCoreLimit, requestParameters.liveStreamId, requestParameters.enableMpegtsM2TsMode, requestParameters.videoCodec, requestParameters.subtitleCodec, requestParameters.transcodingReasons, requestParameters.audioStreamIndex, requestParameters.videoStreamIndex, requestParameters.context, requestParameters.streamOptions, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DynamicHlsApiGetMasterHlsAudioPlaylistRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DynamicHlsApi
     */
    public getMasterHlsAudioPlaylist(requestParameters: DynamicHlsApiGetMasterHlsAudioPlaylistRequest, options?: any) {
        return DynamicHlsApiFp(this.configuration).getMasterHlsAudioPlaylist(requestParameters.itemId, requestParameters.container, requestParameters.mediaSourceId, requestParameters._static, requestParameters.params, requestParameters.tag, requestParameters.deviceProfileId, requestParameters.playSessionId, requestParameters.segmentContainer, requestParameters.segmentLength, requestParameters.minSegments, requestParameters.deviceId, requestParameters.audioCodec, requestParameters.enableAutoStreamCopy, requestParameters.allowVideoStreamCopy, requestParameters.allowAudioStreamCopy, requestParameters.breakOnNonKeyFrames, requestParameters.audioSampleRate, requestParameters.maxAudioBitDepth, requestParameters.audioBitRate, requestParameters.audioChannels, requestParameters.maxAudioChannels, requestParameters.profile, requestParameters.level, requestParameters.framerate, requestParameters.maxFramerate, requestParameters.copyTimestamps, requestParameters.startTimeTicks, requestParameters.width, requestParameters.height, requestParameters.videoBitRate, requestParameters.subtitleStreamIndex, requestParameters.subtitleMethod, requestParameters.maxRefFrames, requestParameters.maxVideoBitDepth, requestParameters.requireAvc, requestParameters.deInterlace, requestParameters.requireNonAnamorphic, requestParameters.transcodingMaxAudioChannels, requestParameters.cpuCoreLimit, requestParameters.liveStreamId, requestParameters.enableMpegtsM2TsMode, requestParameters.videoCodec, requestParameters.subtitleCodec, requestParameters.transcodingReasons, requestParameters.audioStreamIndex, requestParameters.videoStreamIndex, requestParameters.context, requestParameters.streamOptions, requestParameters.enableAdaptiveBitrateStreaming, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DynamicHlsApiGetMasterHlsVideoPlaylistRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DynamicHlsApi
     */
    public getMasterHlsVideoPlaylist(requestParameters: DynamicHlsApiGetMasterHlsVideoPlaylistRequest, options?: any) {
        return DynamicHlsApiFp(this.configuration).getMasterHlsVideoPlaylist(requestParameters.itemId, requestParameters.container, requestParameters.mediaSourceId, requestParameters._static, requestParameters.params, requestParameters.tag, requestParameters.deviceProfileId, requestParameters.playSessionId, requestParameters.segmentContainer, requestParameters.segmentLength, requestParameters.minSegments, requestParameters.deviceId, requestParameters.audioCodec, requestParameters.enableAutoStreamCopy, requestParameters.allowVideoStreamCopy, requestParameters.allowAudioStreamCopy, requestParameters.breakOnNonKeyFrames, requestParameters.audioSampleRate, requestParameters.maxAudioBitDepth, requestParameters.audioBitRate, requestParameters.audioChannels, requestParameters.maxAudioChannels, requestParameters.profile, requestParameters.level, requestParameters.framerate, requestParameters.maxFramerate, requestParameters.copyTimestamps, requestParameters.startTimeTicks, requestParameters.width, requestParameters.height, requestParameters.videoBitRate, requestParameters.subtitleStreamIndex, requestParameters.subtitleMethod, requestParameters.maxRefFrames, requestParameters.maxVideoBitDepth, requestParameters.requireAvc, requestParameters.deInterlace, requestParameters.requireNonAnamorphic, requestParameters.transcodingMaxAudioChannels, requestParameters.cpuCoreLimit, requestParameters.liveStreamId, requestParameters.enableMpegtsM2TsMode, requestParameters.videoCodec, requestParameters.subtitleCodec, requestParameters.transcodingReasons, requestParameters.audioStreamIndex, requestParameters.videoStreamIndex, requestParameters.context, requestParameters.streamOptions, requestParameters.enableAdaptiveBitrateStreaming, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DynamicHlsApiGetVariantHlsAudioPlaylistRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DynamicHlsApi
     */
    public getVariantHlsAudioPlaylist(requestParameters: DynamicHlsApiGetVariantHlsAudioPlaylistRequest, options?: any) {
        return DynamicHlsApiFp(this.configuration).getVariantHlsAudioPlaylist(requestParameters.itemId, requestParameters.container, requestParameters._static, requestParameters.params, requestParameters.tag, requestParameters.deviceProfileId, requestParameters.playSessionId, requestParameters.segmentContainer, requestParameters.segmentLength, requestParameters.minSegments, requestParameters.mediaSourceId, requestParameters.deviceId, requestParameters.audioCodec, requestParameters.enableAutoStreamCopy, requestParameters.allowVideoStreamCopy, requestParameters.allowAudioStreamCopy, requestParameters.breakOnNonKeyFrames, requestParameters.audioSampleRate, requestParameters.maxAudioBitDepth, requestParameters.audioBitRate, requestParameters.audioChannels, requestParameters.maxAudioChannels, requestParameters.profile, requestParameters.level, requestParameters.framerate, requestParameters.maxFramerate, requestParameters.copyTimestamps, requestParameters.startTimeTicks, requestParameters.width, requestParameters.height, requestParameters.videoBitRate, requestParameters.subtitleStreamIndex, requestParameters.subtitleMethod, requestParameters.maxRefFrames, requestParameters.maxVideoBitDepth, requestParameters.requireAvc, requestParameters.deInterlace, requestParameters.requireNonAnamorphic, requestParameters.transcodingMaxAudioChannels, requestParameters.cpuCoreLimit, requestParameters.liveStreamId, requestParameters.enableMpegtsM2TsMode, requestParameters.videoCodec, requestParameters.subtitleCodec, requestParameters.transcodingReasons, requestParameters.audioStreamIndex, requestParameters.videoStreamIndex, requestParameters.context, requestParameters.streamOptions, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DynamicHlsApiGetVariantHlsVideoPlaylistRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DynamicHlsApi
     */
    public getVariantHlsVideoPlaylist(requestParameters: DynamicHlsApiGetVariantHlsVideoPlaylistRequest, options?: any) {
        return DynamicHlsApiFp(this.configuration).getVariantHlsVideoPlaylist(requestParameters.itemId, requestParameters.container, requestParameters._static, requestParameters.params, requestParameters.tag, requestParameters.deviceProfileId, requestParameters.playSessionId, requestParameters.segmentContainer, requestParameters.segmentLength, requestParameters.minSegments, requestParameters.mediaSourceId, requestParameters.deviceId, requestParameters.audioCodec, requestParameters.enableAutoStreamCopy, requestParameters.allowVideoStreamCopy, requestParameters.allowAudioStreamCopy, requestParameters.breakOnNonKeyFrames, requestParameters.audioSampleRate, requestParameters.maxAudioBitDepth, requestParameters.audioBitRate, requestParameters.audioChannels, requestParameters.maxAudioChannels, requestParameters.profile, requestParameters.level, requestParameters.framerate, requestParameters.maxFramerate, requestParameters.copyTimestamps, requestParameters.startTimeTicks, requestParameters.width, requestParameters.height, requestParameters.videoBitRate, requestParameters.subtitleStreamIndex, requestParameters.subtitleMethod, requestParameters.maxRefFrames, requestParameters.maxVideoBitDepth, requestParameters.requireAvc, requestParameters.deInterlace, requestParameters.requireNonAnamorphic, requestParameters.transcodingMaxAudioChannels, requestParameters.cpuCoreLimit, requestParameters.liveStreamId, requestParameters.enableMpegtsM2TsMode, requestParameters.videoCodec, requestParameters.subtitleCodec, requestParameters.transcodingReasons, requestParameters.audioStreamIndex, requestParameters.videoStreamIndex, requestParameters.context, requestParameters.streamOptions, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DynamicHlsApiHeadMasterHlsAudioPlaylistRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DynamicHlsApi
     */
    public headMasterHlsAudioPlaylist(requestParameters: DynamicHlsApiHeadMasterHlsAudioPlaylistRequest, options?: any) {
        return DynamicHlsApiFp(this.configuration).headMasterHlsAudioPlaylist(requestParameters.itemId, requestParameters.container, requestParameters.mediaSourceId, requestParameters._static, requestParameters.params, requestParameters.tag, requestParameters.deviceProfileId, requestParameters.playSessionId, requestParameters.segmentContainer, requestParameters.segmentLength, requestParameters.minSegments, requestParameters.deviceId, requestParameters.audioCodec, requestParameters.enableAutoStreamCopy, requestParameters.allowVideoStreamCopy, requestParameters.allowAudioStreamCopy, requestParameters.breakOnNonKeyFrames, requestParameters.audioSampleRate, requestParameters.maxAudioBitDepth, requestParameters.audioBitRate, requestParameters.audioChannels, requestParameters.maxAudioChannels, requestParameters.profile, requestParameters.level, requestParameters.framerate, requestParameters.maxFramerate, requestParameters.copyTimestamps, requestParameters.startTimeTicks, requestParameters.width, requestParameters.height, requestParameters.videoBitRate, requestParameters.subtitleStreamIndex, requestParameters.subtitleMethod, requestParameters.maxRefFrames, requestParameters.maxVideoBitDepth, requestParameters.requireAvc, requestParameters.deInterlace, requestParameters.requireNonAnamorphic, requestParameters.transcodingMaxAudioChannels, requestParameters.cpuCoreLimit, requestParameters.liveStreamId, requestParameters.enableMpegtsM2TsMode, requestParameters.videoCodec, requestParameters.subtitleCodec, requestParameters.transcodingReasons, requestParameters.audioStreamIndex, requestParameters.videoStreamIndex, requestParameters.context, requestParameters.streamOptions, requestParameters.enableAdaptiveBitrateStreaming, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DynamicHlsApiHeadMasterHlsVideoPlaylistRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DynamicHlsApi
     */
    public headMasterHlsVideoPlaylist(requestParameters: DynamicHlsApiHeadMasterHlsVideoPlaylistRequest, options?: any) {
        return DynamicHlsApiFp(this.configuration).headMasterHlsVideoPlaylist(requestParameters.itemId, requestParameters.container, requestParameters.mediaSourceId, requestParameters._static, requestParameters.params, requestParameters.tag, requestParameters.deviceProfileId, requestParameters.playSessionId, requestParameters.segmentContainer, requestParameters.segmentLength, requestParameters.minSegments, requestParameters.deviceId, requestParameters.audioCodec, requestParameters.enableAutoStreamCopy, requestParameters.allowVideoStreamCopy, requestParameters.allowAudioStreamCopy, requestParameters.breakOnNonKeyFrames, requestParameters.audioSampleRate, requestParameters.maxAudioBitDepth, requestParameters.audioBitRate, requestParameters.audioChannels, requestParameters.maxAudioChannels, requestParameters.profile, requestParameters.level, requestParameters.framerate, requestParameters.maxFramerate, requestParameters.copyTimestamps, requestParameters.startTimeTicks, requestParameters.width, requestParameters.height, requestParameters.videoBitRate, requestParameters.subtitleStreamIndex, requestParameters.subtitleMethod, requestParameters.maxRefFrames, requestParameters.maxVideoBitDepth, requestParameters.requireAvc, requestParameters.deInterlace, requestParameters.requireNonAnamorphic, requestParameters.transcodingMaxAudioChannels, requestParameters.cpuCoreLimit, requestParameters.liveStreamId, requestParameters.enableMpegtsM2TsMode, requestParameters.videoCodec, requestParameters.subtitleCodec, requestParameters.transcodingReasons, requestParameters.audioStreamIndex, requestParameters.videoStreamIndex, requestParameters.context, requestParameters.streamOptions, requestParameters.enableAdaptiveBitrateStreaming, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EnvironmentApi - axios parameter creator
 * @export
 */
export const EnvironmentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultDirectoryBrowser: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Environment/DefaultDirectoryBrowser`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} path 
         * @param {boolean} [includeFiles] 
         * @param {boolean} [includeDirectories] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDirectoryContents: async (path: string, includeFiles?: boolean, includeDirectories?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'path' is not null or undefined
            if (path === null || path === undefined) {
                throw new RequiredError('path','Required parameter path was null or undefined when calling getDirectoryContents.');
            }
            const localVarPath = `/Environment/DirectoryContents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            if (includeFiles !== undefined) {
                localVarQueryParameter['includeFiles'] = includeFiles;
            }

            if (includeDirectories !== undefined) {
                localVarQueryParameter['includeDirectories'] = includeDirectories;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDrives: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Environment/Drives`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetworkShares: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Environment/NetworkShares`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParentPath: async (path: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'path' is not null or undefined
            if (path === null || path === undefined) {
                throw new RequiredError('path','Required parameter path was null or undefined when calling getParentPath.');
            }
            const localVarPath = `/Environment/ParentPath`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ValidatePathDto} validatePathDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatePath: async (validatePathDto: ValidatePathDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'validatePathDto' is not null or undefined
            if (validatePathDto === null || validatePathDto === undefined) {
                throw new RequiredError('validatePathDto','Required parameter validatePathDto was null or undefined when calling validatePath.');
            }
            const localVarPath = `/Environment/ValidatePath`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof validatePathDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(validatePathDto !== undefined ? validatePathDto : {}) : (validatePathDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnvironmentApi - functional programming interface
 * @export
 */
export const EnvironmentApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDefaultDirectoryBrowser(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DefaultDirectoryBrowserInfoDto>> {
            const localVarAxiosArgs = await EnvironmentApiAxiosParamCreator(configuration).getDefaultDirectoryBrowser(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} path 
         * @param {boolean} [includeFiles] 
         * @param {boolean} [includeDirectories] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDirectoryContents(path: string, includeFiles?: boolean, includeDirectories?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FileSystemEntryInfo>>> {
            const localVarAxiosArgs = await EnvironmentApiAxiosParamCreator(configuration).getDirectoryContents(path, includeFiles, includeDirectories, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDrives(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FileSystemEntryInfo>>> {
            const localVarAxiosArgs = await EnvironmentApiAxiosParamCreator(configuration).getDrives(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNetworkShares(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FileSystemEntryInfo>>> {
            const localVarAxiosArgs = await EnvironmentApiAxiosParamCreator(configuration).getNetworkShares(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getParentPath(path: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await EnvironmentApiAxiosParamCreator(configuration).getParentPath(path, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {ValidatePathDto} validatePathDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validatePath(validatePathDto: ValidatePathDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await EnvironmentApiAxiosParamCreator(configuration).validatePath(validatePathDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * EnvironmentApi - factory interface
 * @export
 */
export const EnvironmentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultDirectoryBrowser(options?: any): AxiosPromise<DefaultDirectoryBrowserInfoDto> {
            return EnvironmentApiFp(configuration).getDefaultDirectoryBrowser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} path 
         * @param {boolean} [includeFiles] 
         * @param {boolean} [includeDirectories] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDirectoryContents(path: string, includeFiles?: boolean, includeDirectories?: boolean, options?: any): AxiosPromise<Array<FileSystemEntryInfo>> {
            return EnvironmentApiFp(configuration).getDirectoryContents(path, includeFiles, includeDirectories, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDrives(options?: any): AxiosPromise<Array<FileSystemEntryInfo>> {
            return EnvironmentApiFp(configuration).getDrives(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetworkShares(options?: any): AxiosPromise<Array<FileSystemEntryInfo>> {
            return EnvironmentApiFp(configuration).getNetworkShares(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} path 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParentPath(path: string, options?: any): AxiosPromise<string> {
            return EnvironmentApiFp(configuration).getParentPath(path, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValidatePathDto} validatePathDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatePath(validatePathDto: ValidatePathDto, options?: any): AxiosPromise<void> {
            return EnvironmentApiFp(configuration).validatePath(validatePathDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getDirectoryContents operation in EnvironmentApi.
 * @export
 * @interface EnvironmentApiGetDirectoryContentsRequest
 */
export interface EnvironmentApiGetDirectoryContentsRequest {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentApiGetDirectoryContents
     */
    readonly path: string

    /**
     * 
     * @type {boolean}
     * @memberof EnvironmentApiGetDirectoryContents
     */
    readonly includeFiles?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof EnvironmentApiGetDirectoryContents
     */
    readonly includeDirectories?: boolean
}

/**
 * Request parameters for getParentPath operation in EnvironmentApi.
 * @export
 * @interface EnvironmentApiGetParentPathRequest
 */
export interface EnvironmentApiGetParentPathRequest {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentApiGetParentPath
     */
    readonly path: string
}

/**
 * Request parameters for validatePath operation in EnvironmentApi.
 * @export
 * @interface EnvironmentApiValidatePathRequest
 */
export interface EnvironmentApiValidatePathRequest {
    /**
     * 
     * @type {ValidatePathDto}
     * @memberof EnvironmentApiValidatePath
     */
    readonly validatePathDto: ValidatePathDto
}

/**
 * EnvironmentApi - object-oriented interface
 * @export
 * @class EnvironmentApi
 * @extends {BaseAPI}
 */
export class EnvironmentApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentApi
     */
    public getDefaultDirectoryBrowser(options?: any) {
        return EnvironmentApiFp(this.configuration).getDefaultDirectoryBrowser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {EnvironmentApiGetDirectoryContentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentApi
     */
    public getDirectoryContents(requestParameters: EnvironmentApiGetDirectoryContentsRequest, options?: any) {
        return EnvironmentApiFp(this.configuration).getDirectoryContents(requestParameters.path, requestParameters.includeFiles, requestParameters.includeDirectories, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentApi
     */
    public getDrives(options?: any) {
        return EnvironmentApiFp(this.configuration).getDrives(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentApi
     */
    public getNetworkShares(options?: any) {
        return EnvironmentApiFp(this.configuration).getNetworkShares(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {EnvironmentApiGetParentPathRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentApi
     */
    public getParentPath(requestParameters: EnvironmentApiGetParentPathRequest, options?: any) {
        return EnvironmentApiFp(this.configuration).getParentPath(requestParameters.path, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {EnvironmentApiValidatePathRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentApi
     */
    public validatePath(requestParameters: EnvironmentApiValidatePathRequest, options?: any) {
        return EnvironmentApiFp(this.configuration).validatePath(requestParameters.validatePathDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FilterApi - axios parameter creator
 * @export
 */
export const FilterApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [userId] 
         * @param {string} [parentId] 
         * @param {string} [includeItemTypes] 
         * @param {boolean} [isAiring] 
         * @param {boolean} [isMovie] 
         * @param {boolean} [isSports] 
         * @param {boolean} [isKids] 
         * @param {boolean} [isNews] 
         * @param {boolean} [isSeries] 
         * @param {boolean} [recursive] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueryFilters: async (userId?: string, parentId?: string, includeItemTypes?: string, isAiring?: boolean, isMovie?: boolean, isSports?: boolean, isKids?: boolean, isNews?: boolean, isSeries?: boolean, recursive?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Items/Filters2`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (parentId !== undefined) {
                localVarQueryParameter['parentId'] = parentId;
            }

            if (includeItemTypes !== undefined) {
                localVarQueryParameter['includeItemTypes'] = includeItemTypes;
            }

            if (isAiring !== undefined) {
                localVarQueryParameter['isAiring'] = isAiring;
            }

            if (isMovie !== undefined) {
                localVarQueryParameter['isMovie'] = isMovie;
            }

            if (isSports !== undefined) {
                localVarQueryParameter['isSports'] = isSports;
            }

            if (isKids !== undefined) {
                localVarQueryParameter['isKids'] = isKids;
            }

            if (isNews !== undefined) {
                localVarQueryParameter['isNews'] = isNews;
            }

            if (isSeries !== undefined) {
                localVarQueryParameter['isSeries'] = isSeries;
            }

            if (recursive !== undefined) {
                localVarQueryParameter['recursive'] = recursive;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [userId] 
         * @param {string} [parentId] 
         * @param {string} [includeItemTypes] 
         * @param {string} [mediaTypes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueryFiltersLegacy: async (userId?: string, parentId?: string, includeItemTypes?: string, mediaTypes?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Items/Filters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (parentId !== undefined) {
                localVarQueryParameter['parentId'] = parentId;
            }

            if (includeItemTypes !== undefined) {
                localVarQueryParameter['includeItemTypes'] = includeItemTypes;
            }

            if (mediaTypes !== undefined) {
                localVarQueryParameter['mediaTypes'] = mediaTypes;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FilterApi - functional programming interface
 * @export
 */
export const FilterApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [userId] 
         * @param {string} [parentId] 
         * @param {string} [includeItemTypes] 
         * @param {boolean} [isAiring] 
         * @param {boolean} [isMovie] 
         * @param {boolean} [isSports] 
         * @param {boolean} [isKids] 
         * @param {boolean} [isNews] 
         * @param {boolean} [isSeries] 
         * @param {boolean} [recursive] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getQueryFilters(userId?: string, parentId?: string, includeItemTypes?: string, isAiring?: boolean, isMovie?: boolean, isSports?: boolean, isKids?: boolean, isNews?: boolean, isSeries?: boolean, recursive?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryFilters>> {
            const localVarAxiosArgs = await FilterApiAxiosParamCreator(configuration).getQueryFilters(userId, parentId, includeItemTypes, isAiring, isMovie, isSports, isKids, isNews, isSeries, recursive, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [userId] 
         * @param {string} [parentId] 
         * @param {string} [includeItemTypes] 
         * @param {string} [mediaTypes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getQueryFiltersLegacy(userId?: string, parentId?: string, includeItemTypes?: string, mediaTypes?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryFiltersLegacy>> {
            const localVarAxiosArgs = await FilterApiAxiosParamCreator(configuration).getQueryFiltersLegacy(userId, parentId, includeItemTypes, mediaTypes, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * FilterApi - factory interface
 * @export
 */
export const FilterApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} [userId] 
         * @param {string} [parentId] 
         * @param {string} [includeItemTypes] 
         * @param {boolean} [isAiring] 
         * @param {boolean} [isMovie] 
         * @param {boolean} [isSports] 
         * @param {boolean} [isKids] 
         * @param {boolean} [isNews] 
         * @param {boolean} [isSeries] 
         * @param {boolean} [recursive] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueryFilters(userId?: string, parentId?: string, includeItemTypes?: string, isAiring?: boolean, isMovie?: boolean, isSports?: boolean, isKids?: boolean, isNews?: boolean, isSeries?: boolean, recursive?: boolean, options?: any): AxiosPromise<QueryFilters> {
            return FilterApiFp(configuration).getQueryFilters(userId, parentId, includeItemTypes, isAiring, isMovie, isSports, isKids, isNews, isSeries, recursive, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [userId] 
         * @param {string} [parentId] 
         * @param {string} [includeItemTypes] 
         * @param {string} [mediaTypes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueryFiltersLegacy(userId?: string, parentId?: string, includeItemTypes?: string, mediaTypes?: string, options?: any): AxiosPromise<QueryFiltersLegacy> {
            return FilterApiFp(configuration).getQueryFiltersLegacy(userId, parentId, includeItemTypes, mediaTypes, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getQueryFilters operation in FilterApi.
 * @export
 * @interface FilterApiGetQueryFiltersRequest
 */
export interface FilterApiGetQueryFiltersRequest {
    /**
     * 
     * @type {string}
     * @memberof FilterApiGetQueryFilters
     */
    readonly userId?: string

    /**
     * 
     * @type {string}
     * @memberof FilterApiGetQueryFilters
     */
    readonly parentId?: string

    /**
     * 
     * @type {string}
     * @memberof FilterApiGetQueryFilters
     */
    readonly includeItemTypes?: string

    /**
     * 
     * @type {boolean}
     * @memberof FilterApiGetQueryFilters
     */
    readonly isAiring?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof FilterApiGetQueryFilters
     */
    readonly isMovie?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof FilterApiGetQueryFilters
     */
    readonly isSports?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof FilterApiGetQueryFilters
     */
    readonly isKids?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof FilterApiGetQueryFilters
     */
    readonly isNews?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof FilterApiGetQueryFilters
     */
    readonly isSeries?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof FilterApiGetQueryFilters
     */
    readonly recursive?: boolean
}

/**
 * Request parameters for getQueryFiltersLegacy operation in FilterApi.
 * @export
 * @interface FilterApiGetQueryFiltersLegacyRequest
 */
export interface FilterApiGetQueryFiltersLegacyRequest {
    /**
     * 
     * @type {string}
     * @memberof FilterApiGetQueryFiltersLegacy
     */
    readonly userId?: string

    /**
     * 
     * @type {string}
     * @memberof FilterApiGetQueryFiltersLegacy
     */
    readonly parentId?: string

    /**
     * 
     * @type {string}
     * @memberof FilterApiGetQueryFiltersLegacy
     */
    readonly includeItemTypes?: string

    /**
     * 
     * @type {string}
     * @memberof FilterApiGetQueryFiltersLegacy
     */
    readonly mediaTypes?: string
}

/**
 * FilterApi - object-oriented interface
 * @export
 * @class FilterApi
 * @extends {BaseAPI}
 */
export class FilterApi extends BaseAPI {
    /**
     * 
     * @param {FilterApiGetQueryFiltersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilterApi
     */
    public getQueryFilters(requestParameters: FilterApiGetQueryFiltersRequest = {}, options?: any) {
        return FilterApiFp(this.configuration).getQueryFilters(requestParameters.userId, requestParameters.parentId, requestParameters.includeItemTypes, requestParameters.isAiring, requestParameters.isMovie, requestParameters.isSports, requestParameters.isKids, requestParameters.isNews, requestParameters.isSeries, requestParameters.recursive, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FilterApiGetQueryFiltersLegacyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilterApi
     */
    public getQueryFiltersLegacy(requestParameters: FilterApiGetQueryFiltersLegacyRequest = {}, options?: any) {
        return FilterApiFp(this.configuration).getQueryFiltersLegacy(requestParameters.userId, requestParameters.parentId, requestParameters.includeItemTypes, requestParameters.mediaTypes, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GenresApi - axios parameter creator
 * @export
 */
export const GenresApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} genreName 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGenre: async (genreName: string, userId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'genreName' is not null or undefined
            if (genreName === null || genreName === undefined) {
                throw new RequiredError('genreName','Required parameter genreName was null or undefined when calling getGenre.');
            }
            const localVarPath = `/Genres/{genreName}`
                .replace(`{${"genreName"}}`, encodeURIComponent(String(genreName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [minCommunityRating] 
         * @param {number} [startIndex] 
         * @param {number} [limit] 
         * @param {string} [searchTerm] 
         * @param {string} [parentId] 
         * @param {string} [fields] 
         * @param {string} [excludeItemTypes] 
         * @param {string} [includeItemTypes] 
         * @param {string} [filters] 
         * @param {boolean} [isFavorite] 
         * @param {string} [mediaTypes] 
         * @param {string} [genres] 
         * @param {string} [genreIds] 
         * @param {string} [officialRatings] 
         * @param {string} [tags] 
         * @param {string} [years] 
         * @param {boolean} [enableUserData] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {string} [person] 
         * @param {string} [personIds] 
         * @param {string} [personTypes] 
         * @param {string} [studios] 
         * @param {string} [studioIds] 
         * @param {string} [userId] 
         * @param {string} [nameStartsWithOrGreater] 
         * @param {string} [nameStartsWith] 
         * @param {string} [nameLessThan] 
         * @param {boolean} [enableImages] 
         * @param {boolean} [enableTotalRecordCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGenres: async (minCommunityRating?: number, startIndex?: number, limit?: number, searchTerm?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, filters?: string, isFavorite?: boolean, mediaTypes?: string, genres?: string, genreIds?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, studioIds?: string, userId?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, enableImages?: boolean, enableTotalRecordCount?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Genres`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (minCommunityRating !== undefined) {
                localVarQueryParameter['minCommunityRating'] = minCommunityRating;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (searchTerm !== undefined) {
                localVarQueryParameter['searchTerm'] = searchTerm;
            }

            if (parentId !== undefined) {
                localVarQueryParameter['parentId'] = parentId;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeItemTypes !== undefined) {
                localVarQueryParameter['excludeItemTypes'] = excludeItemTypes;
            }

            if (includeItemTypes !== undefined) {
                localVarQueryParameter['includeItemTypes'] = includeItemTypes;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (isFavorite !== undefined) {
                localVarQueryParameter['isFavorite'] = isFavorite;
            }

            if (mediaTypes !== undefined) {
                localVarQueryParameter['mediaTypes'] = mediaTypes;
            }

            if (genres !== undefined) {
                localVarQueryParameter['genres'] = genres;
            }

            if (genreIds !== undefined) {
                localVarQueryParameter['genreIds'] = genreIds;
            }

            if (officialRatings !== undefined) {
                localVarQueryParameter['officialRatings'] = officialRatings;
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }

            if (years !== undefined) {
                localVarQueryParameter['years'] = years;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes !== undefined) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }

            if (person !== undefined) {
                localVarQueryParameter['person'] = person;
            }

            if (personIds !== undefined) {
                localVarQueryParameter['personIds'] = personIds;
            }

            if (personTypes !== undefined) {
                localVarQueryParameter['personTypes'] = personTypes;
            }

            if (studios !== undefined) {
                localVarQueryParameter['studios'] = studios;
            }

            if (studioIds !== undefined) {
                localVarQueryParameter['studioIds'] = studioIds;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (nameStartsWithOrGreater !== undefined) {
                localVarQueryParameter['nameStartsWithOrGreater'] = nameStartsWithOrGreater;
            }

            if (nameStartsWith !== undefined) {
                localVarQueryParameter['nameStartsWith'] = nameStartsWith;
            }

            if (nameLessThan !== undefined) {
                localVarQueryParameter['nameLessThan'] = nameLessThan;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }

            if (enableTotalRecordCount !== undefined) {
                localVarQueryParameter['enableTotalRecordCount'] = enableTotalRecordCount;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GenresApi - functional programming interface
 * @export
 */
export const GenresApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} genreName 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGenre(genreName: string, userId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDto>> {
            const localVarAxiosArgs = await GenresApiAxiosParamCreator(configuration).getGenre(genreName, userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} [minCommunityRating] 
         * @param {number} [startIndex] 
         * @param {number} [limit] 
         * @param {string} [searchTerm] 
         * @param {string} [parentId] 
         * @param {string} [fields] 
         * @param {string} [excludeItemTypes] 
         * @param {string} [includeItemTypes] 
         * @param {string} [filters] 
         * @param {boolean} [isFavorite] 
         * @param {string} [mediaTypes] 
         * @param {string} [genres] 
         * @param {string} [genreIds] 
         * @param {string} [officialRatings] 
         * @param {string} [tags] 
         * @param {string} [years] 
         * @param {boolean} [enableUserData] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {string} [person] 
         * @param {string} [personIds] 
         * @param {string} [personTypes] 
         * @param {string} [studios] 
         * @param {string} [studioIds] 
         * @param {string} [userId] 
         * @param {string} [nameStartsWithOrGreater] 
         * @param {string} [nameStartsWith] 
         * @param {string} [nameLessThan] 
         * @param {boolean} [enableImages] 
         * @param {boolean} [enableTotalRecordCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGenres(minCommunityRating?: number, startIndex?: number, limit?: number, searchTerm?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, filters?: string, isFavorite?: boolean, mediaTypes?: string, genres?: string, genreIds?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, studioIds?: string, userId?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, enableImages?: boolean, enableTotalRecordCount?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await GenresApiAxiosParamCreator(configuration).getGenres(minCommunityRating, startIndex, limit, searchTerm, parentId, fields, excludeItemTypes, includeItemTypes, filters, isFavorite, mediaTypes, genres, genreIds, officialRatings, tags, years, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, studioIds, userId, nameStartsWithOrGreater, nameStartsWith, nameLessThan, enableImages, enableTotalRecordCount, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * GenresApi - factory interface
 * @export
 */
export const GenresApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} genreName 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGenre(genreName: string, userId?: string, options?: any): AxiosPromise<BaseItemDto> {
            return GenresApiFp(configuration).getGenre(genreName, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [minCommunityRating] 
         * @param {number} [startIndex] 
         * @param {number} [limit] 
         * @param {string} [searchTerm] 
         * @param {string} [parentId] 
         * @param {string} [fields] 
         * @param {string} [excludeItemTypes] 
         * @param {string} [includeItemTypes] 
         * @param {string} [filters] 
         * @param {boolean} [isFavorite] 
         * @param {string} [mediaTypes] 
         * @param {string} [genres] 
         * @param {string} [genreIds] 
         * @param {string} [officialRatings] 
         * @param {string} [tags] 
         * @param {string} [years] 
         * @param {boolean} [enableUserData] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {string} [person] 
         * @param {string} [personIds] 
         * @param {string} [personTypes] 
         * @param {string} [studios] 
         * @param {string} [studioIds] 
         * @param {string} [userId] 
         * @param {string} [nameStartsWithOrGreater] 
         * @param {string} [nameStartsWith] 
         * @param {string} [nameLessThan] 
         * @param {boolean} [enableImages] 
         * @param {boolean} [enableTotalRecordCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGenres(minCommunityRating?: number, startIndex?: number, limit?: number, searchTerm?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, filters?: string, isFavorite?: boolean, mediaTypes?: string, genres?: string, genreIds?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, studioIds?: string, userId?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, enableImages?: boolean, enableTotalRecordCount?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return GenresApiFp(configuration).getGenres(minCommunityRating, startIndex, limit, searchTerm, parentId, fields, excludeItemTypes, includeItemTypes, filters, isFavorite, mediaTypes, genres, genreIds, officialRatings, tags, years, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, studioIds, userId, nameStartsWithOrGreater, nameStartsWith, nameLessThan, enableImages, enableTotalRecordCount, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getGenre operation in GenresApi.
 * @export
 * @interface GenresApiGetGenreRequest
 */
export interface GenresApiGetGenreRequest {
    /**
     * 
     * @type {string}
     * @memberof GenresApiGetGenre
     */
    readonly genreName: string

    /**
     * 
     * @type {string}
     * @memberof GenresApiGetGenre
     */
    readonly userId?: string
}

/**
 * Request parameters for getGenres operation in GenresApi.
 * @export
 * @interface GenresApiGetGenresRequest
 */
export interface GenresApiGetGenresRequest {
    /**
     * 
     * @type {number}
     * @memberof GenresApiGetGenres
     */
    readonly minCommunityRating?: number

    /**
     * 
     * @type {number}
     * @memberof GenresApiGetGenres
     */
    readonly startIndex?: number

    /**
     * 
     * @type {number}
     * @memberof GenresApiGetGenres
     */
    readonly limit?: number

    /**
     * 
     * @type {string}
     * @memberof GenresApiGetGenres
     */
    readonly searchTerm?: string

    /**
     * 
     * @type {string}
     * @memberof GenresApiGetGenres
     */
    readonly parentId?: string

    /**
     * 
     * @type {string}
     * @memberof GenresApiGetGenres
     */
    readonly fields?: string

    /**
     * 
     * @type {string}
     * @memberof GenresApiGetGenres
     */
    readonly excludeItemTypes?: string

    /**
     * 
     * @type {string}
     * @memberof GenresApiGetGenres
     */
    readonly includeItemTypes?: string

    /**
     * 
     * @type {string}
     * @memberof GenresApiGetGenres
     */
    readonly filters?: string

    /**
     * 
     * @type {boolean}
     * @memberof GenresApiGetGenres
     */
    readonly isFavorite?: boolean

    /**
     * 
     * @type {string}
     * @memberof GenresApiGetGenres
     */
    readonly mediaTypes?: string

    /**
     * 
     * @type {string}
     * @memberof GenresApiGetGenres
     */
    readonly genres?: string

    /**
     * 
     * @type {string}
     * @memberof GenresApiGetGenres
     */
    readonly genreIds?: string

    /**
     * 
     * @type {string}
     * @memberof GenresApiGetGenres
     */
    readonly officialRatings?: string

    /**
     * 
     * @type {string}
     * @memberof GenresApiGetGenres
     */
    readonly tags?: string

    /**
     * 
     * @type {string}
     * @memberof GenresApiGetGenres
     */
    readonly years?: string

    /**
     * 
     * @type {boolean}
     * @memberof GenresApiGetGenres
     */
    readonly enableUserData?: boolean

    /**
     * 
     * @type {number}
     * @memberof GenresApiGetGenres
     */
    readonly imageTypeLimit?: number

    /**
     * 
     * @type {string}
     * @memberof GenresApiGetGenres
     */
    readonly enableImageTypes?: string

    /**
     * 
     * @type {string}
     * @memberof GenresApiGetGenres
     */
    readonly person?: string

    /**
     * 
     * @type {string}
     * @memberof GenresApiGetGenres
     */
    readonly personIds?: string

    /**
     * 
     * @type {string}
     * @memberof GenresApiGetGenres
     */
    readonly personTypes?: string

    /**
     * 
     * @type {string}
     * @memberof GenresApiGetGenres
     */
    readonly studios?: string

    /**
     * 
     * @type {string}
     * @memberof GenresApiGetGenres
     */
    readonly studioIds?: string

    /**
     * 
     * @type {string}
     * @memberof GenresApiGetGenres
     */
    readonly userId?: string

    /**
     * 
     * @type {string}
     * @memberof GenresApiGetGenres
     */
    readonly nameStartsWithOrGreater?: string

    /**
     * 
     * @type {string}
     * @memberof GenresApiGetGenres
     */
    readonly nameStartsWith?: string

    /**
     * 
     * @type {string}
     * @memberof GenresApiGetGenres
     */
    readonly nameLessThan?: string

    /**
     * 
     * @type {boolean}
     * @memberof GenresApiGetGenres
     */
    readonly enableImages?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof GenresApiGetGenres
     */
    readonly enableTotalRecordCount?: boolean
}

/**
 * GenresApi - object-oriented interface
 * @export
 * @class GenresApi
 * @extends {BaseAPI}
 */
export class GenresApi extends BaseAPI {
    /**
     * 
     * @param {GenresApiGetGenreRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GenresApi
     */
    public getGenre(requestParameters: GenresApiGetGenreRequest, options?: any) {
        return GenresApiFp(this.configuration).getGenre(requestParameters.genreName, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GenresApiGetGenresRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GenresApi
     */
    public getGenres(requestParameters: GenresApiGetGenresRequest = {}, options?: any) {
        return GenresApiFp(this.configuration).getGenres(requestParameters.minCommunityRating, requestParameters.startIndex, requestParameters.limit, requestParameters.searchTerm, requestParameters.parentId, requestParameters.fields, requestParameters.excludeItemTypes, requestParameters.includeItemTypes, requestParameters.filters, requestParameters.isFavorite, requestParameters.mediaTypes, requestParameters.genres, requestParameters.genreIds, requestParameters.officialRatings, requestParameters.tags, requestParameters.years, requestParameters.enableUserData, requestParameters.imageTypeLimit, requestParameters.enableImageTypes, requestParameters.person, requestParameters.personIds, requestParameters.personTypes, requestParameters.studios, requestParameters.studioIds, requestParameters.userId, requestParameters.nameStartsWithOrGreater, requestParameters.nameStartsWith, requestParameters.nameLessThan, requestParameters.enableImages, requestParameters.enableTotalRecordCount, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * HlsSegmentApi - axios parameter creator
 * @export
 */
export const HlsSegmentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} itemId 
         * @param {string} segmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHlsAudioSegmentLegacyAac: async (itemId: string, segmentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getHlsAudioSegmentLegacyAac.');
            }
            // verify required parameter 'segmentId' is not null or undefined
            if (segmentId === null || segmentId === undefined) {
                throw new RequiredError('segmentId','Required parameter segmentId was null or undefined when calling getHlsAudioSegmentLegacyAac.');
            }
            const localVarPath = `/Audio/{itemId}/hls/{segmentId}/stream.aac`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"segmentId"}}`, encodeURIComponent(String(segmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} segmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHlsAudioSegmentLegacyMp3: async (itemId: string, segmentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getHlsAudioSegmentLegacyMp3.');
            }
            // verify required parameter 'segmentId' is not null or undefined
            if (segmentId === null || segmentId === undefined) {
                throw new RequiredError('segmentId','Required parameter segmentId was null or undefined when calling getHlsAudioSegmentLegacyMp3.');
            }
            const localVarPath = `/Audio/{itemId}/hls/{segmentId}/stream.mp3`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"segmentId"}}`, encodeURIComponent(String(segmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} playlistId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHlsPlaylistLegacy: async (itemId: string, playlistId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getHlsPlaylistLegacy.');
            }
            // verify required parameter 'playlistId' is not null or undefined
            if (playlistId === null || playlistId === undefined) {
                throw new RequiredError('playlistId','Required parameter playlistId was null or undefined when calling getHlsPlaylistLegacy.');
            }
            const localVarPath = `/Videos/{itemId}/hls/{playlistId}/stream.m3u8`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"playlistId"}}`, encodeURIComponent(String(playlistId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} playlistId 
         * @param {string} segmentId 
         * @param {string} segmentContainer 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHlsVideoSegmentLegacy: async (itemId: string, playlistId: string, segmentId: string, segmentContainer: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getHlsVideoSegmentLegacy.');
            }
            // verify required parameter 'playlistId' is not null or undefined
            if (playlistId === null || playlistId === undefined) {
                throw new RequiredError('playlistId','Required parameter playlistId was null or undefined when calling getHlsVideoSegmentLegacy.');
            }
            // verify required parameter 'segmentId' is not null or undefined
            if (segmentId === null || segmentId === undefined) {
                throw new RequiredError('segmentId','Required parameter segmentId was null or undefined when calling getHlsVideoSegmentLegacy.');
            }
            // verify required parameter 'segmentContainer' is not null or undefined
            if (segmentContainer === null || segmentContainer === undefined) {
                throw new RequiredError('segmentContainer','Required parameter segmentContainer was null or undefined when calling getHlsVideoSegmentLegacy.');
            }
            const localVarPath = `/Videos/{itemId}/hls/{playlistId}/{segmentId}.{segmentContainer}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"playlistId"}}`, encodeURIComponent(String(playlistId)))
                .replace(`{${"segmentId"}}`, encodeURIComponent(String(segmentId)))
                .replace(`{${"segmentContainer"}}`, encodeURIComponent(String(segmentContainer)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [deviceId] 
         * @param {string} [playSessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopEncodingProcess: async (deviceId?: string, playSessionId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Videos/ActiveEncodings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (playSessionId !== undefined) {
                localVarQueryParameter['playSessionId'] = playSessionId;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HlsSegmentApi - functional programming interface
 * @export
 */
export const HlsSegmentApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} itemId 
         * @param {string} segmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHlsAudioSegmentLegacyAac(itemId: string, segmentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await HlsSegmentApiAxiosParamCreator(configuration).getHlsAudioSegmentLegacyAac(itemId, segmentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} segmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHlsAudioSegmentLegacyMp3(itemId: string, segmentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await HlsSegmentApiAxiosParamCreator(configuration).getHlsAudioSegmentLegacyMp3(itemId, segmentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} playlistId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHlsPlaylistLegacy(itemId: string, playlistId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await HlsSegmentApiAxiosParamCreator(configuration).getHlsPlaylistLegacy(itemId, playlistId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} playlistId 
         * @param {string} segmentId 
         * @param {string} segmentContainer 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHlsVideoSegmentLegacy(itemId: string, playlistId: string, segmentId: string, segmentContainer: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await HlsSegmentApiAxiosParamCreator(configuration).getHlsVideoSegmentLegacy(itemId, playlistId, segmentId, segmentContainer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [deviceId] 
         * @param {string} [playSessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopEncodingProcess(deviceId?: string, playSessionId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await HlsSegmentApiAxiosParamCreator(configuration).stopEncodingProcess(deviceId, playSessionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * HlsSegmentApi - factory interface
 * @export
 */
export const HlsSegmentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} itemId 
         * @param {string} segmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHlsAudioSegmentLegacyAac(itemId: string, segmentId: string, options?: any): AxiosPromise<void> {
            return HlsSegmentApiFp(configuration).getHlsAudioSegmentLegacyAac(itemId, segmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} segmentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHlsAudioSegmentLegacyMp3(itemId: string, segmentId: string, options?: any): AxiosPromise<void> {
            return HlsSegmentApiFp(configuration).getHlsAudioSegmentLegacyMp3(itemId, segmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} playlistId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHlsPlaylistLegacy(itemId: string, playlistId: string, options?: any): AxiosPromise<void> {
            return HlsSegmentApiFp(configuration).getHlsPlaylistLegacy(itemId, playlistId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} playlistId 
         * @param {string} segmentId 
         * @param {string} segmentContainer 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHlsVideoSegmentLegacy(itemId: string, playlistId: string, segmentId: string, segmentContainer: string, options?: any): AxiosPromise<void> {
            return HlsSegmentApiFp(configuration).getHlsVideoSegmentLegacy(itemId, playlistId, segmentId, segmentContainer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [deviceId] 
         * @param {string} [playSessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopEncodingProcess(deviceId?: string, playSessionId?: string, options?: any): AxiosPromise<void> {
            return HlsSegmentApiFp(configuration).stopEncodingProcess(deviceId, playSessionId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getHlsAudioSegmentLegacyAac operation in HlsSegmentApi.
 * @export
 * @interface HlsSegmentApiGetHlsAudioSegmentLegacyAacRequest
 */
export interface HlsSegmentApiGetHlsAudioSegmentLegacyAacRequest {
    /**
     * 
     * @type {string}
     * @memberof HlsSegmentApiGetHlsAudioSegmentLegacyAac
     */
    readonly itemId: string

    /**
     * 
     * @type {string}
     * @memberof HlsSegmentApiGetHlsAudioSegmentLegacyAac
     */
    readonly segmentId: string
}

/**
 * Request parameters for getHlsAudioSegmentLegacyMp3 operation in HlsSegmentApi.
 * @export
 * @interface HlsSegmentApiGetHlsAudioSegmentLegacyMp3Request
 */
export interface HlsSegmentApiGetHlsAudioSegmentLegacyMp3Request {
    /**
     * 
     * @type {string}
     * @memberof HlsSegmentApiGetHlsAudioSegmentLegacyMp3
     */
    readonly itemId: string

    /**
     * 
     * @type {string}
     * @memberof HlsSegmentApiGetHlsAudioSegmentLegacyMp3
     */
    readonly segmentId: string
}

/**
 * Request parameters for getHlsPlaylistLegacy operation in HlsSegmentApi.
 * @export
 * @interface HlsSegmentApiGetHlsPlaylistLegacyRequest
 */
export interface HlsSegmentApiGetHlsPlaylistLegacyRequest {
    /**
     * 
     * @type {string}
     * @memberof HlsSegmentApiGetHlsPlaylistLegacy
     */
    readonly itemId: string

    /**
     * 
     * @type {string}
     * @memberof HlsSegmentApiGetHlsPlaylistLegacy
     */
    readonly playlistId: string
}

/**
 * Request parameters for getHlsVideoSegmentLegacy operation in HlsSegmentApi.
 * @export
 * @interface HlsSegmentApiGetHlsVideoSegmentLegacyRequest
 */
export interface HlsSegmentApiGetHlsVideoSegmentLegacyRequest {
    /**
     * 
     * @type {string}
     * @memberof HlsSegmentApiGetHlsVideoSegmentLegacy
     */
    readonly itemId: string

    /**
     * 
     * @type {string}
     * @memberof HlsSegmentApiGetHlsVideoSegmentLegacy
     */
    readonly playlistId: string

    /**
     * 
     * @type {string}
     * @memberof HlsSegmentApiGetHlsVideoSegmentLegacy
     */
    readonly segmentId: string

    /**
     * 
     * @type {string}
     * @memberof HlsSegmentApiGetHlsVideoSegmentLegacy
     */
    readonly segmentContainer: string
}

/**
 * Request parameters for stopEncodingProcess operation in HlsSegmentApi.
 * @export
 * @interface HlsSegmentApiStopEncodingProcessRequest
 */
export interface HlsSegmentApiStopEncodingProcessRequest {
    /**
     * 
     * @type {string}
     * @memberof HlsSegmentApiStopEncodingProcess
     */
    readonly deviceId?: string

    /**
     * 
     * @type {string}
     * @memberof HlsSegmentApiStopEncodingProcess
     */
    readonly playSessionId?: string
}

/**
 * HlsSegmentApi - object-oriented interface
 * @export
 * @class HlsSegmentApi
 * @extends {BaseAPI}
 */
export class HlsSegmentApi extends BaseAPI {
    /**
     * 
     * @param {HlsSegmentApiGetHlsAudioSegmentLegacyAacRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HlsSegmentApi
     */
    public getHlsAudioSegmentLegacyAac(requestParameters: HlsSegmentApiGetHlsAudioSegmentLegacyAacRequest, options?: any) {
        return HlsSegmentApiFp(this.configuration).getHlsAudioSegmentLegacyAac(requestParameters.itemId, requestParameters.segmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {HlsSegmentApiGetHlsAudioSegmentLegacyMp3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HlsSegmentApi
     */
    public getHlsAudioSegmentLegacyMp3(requestParameters: HlsSegmentApiGetHlsAudioSegmentLegacyMp3Request, options?: any) {
        return HlsSegmentApiFp(this.configuration).getHlsAudioSegmentLegacyMp3(requestParameters.itemId, requestParameters.segmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {HlsSegmentApiGetHlsPlaylistLegacyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HlsSegmentApi
     */
    public getHlsPlaylistLegacy(requestParameters: HlsSegmentApiGetHlsPlaylistLegacyRequest, options?: any) {
        return HlsSegmentApiFp(this.configuration).getHlsPlaylistLegacy(requestParameters.itemId, requestParameters.playlistId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {HlsSegmentApiGetHlsVideoSegmentLegacyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HlsSegmentApi
     */
    public getHlsVideoSegmentLegacy(requestParameters: HlsSegmentApiGetHlsVideoSegmentLegacyRequest, options?: any) {
        return HlsSegmentApiFp(this.configuration).getHlsVideoSegmentLegacy(requestParameters.itemId, requestParameters.playlistId, requestParameters.segmentId, requestParameters.segmentContainer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {HlsSegmentApiStopEncodingProcessRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HlsSegmentApi
     */
    public stopEncodingProcess(requestParameters: HlsSegmentApiStopEncodingProcessRequest = {}, options?: any) {
        return HlsSegmentApiFp(this.configuration).stopEncodingProcess(requestParameters.deviceId, requestParameters.playSessionId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ImageApi - axios parameter creator
 * @export
 */
export const ImageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} itemId 
         * @param {ImageType} imageType 
         * @param {number} imageIndex 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemImage: async (itemId: string, imageType: ImageType, imageIndex: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling deleteItemImage.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling deleteItemImage.');
            }
            // verify required parameter 'imageIndex' is not null or undefined
            if (imageIndex === null || imageIndex === undefined) {
                throw new RequiredError('imageIndex','Required parameter imageIndex was null or undefined when calling deleteItemImage.');
            }
            const localVarPath = `/Items/{itemId}/Images/{imageType}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"imageIndex"}}`, encodeURIComponent(String(imageIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {ImageType} imageType 
         * @param {number} imageIndex 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemImage2: async (itemId: string, imageType: ImageType, imageIndex: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling deleteItemImage2.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling deleteItemImage2.');
            }
            // verify required parameter 'imageIndex' is not null or undefined
            if (imageIndex === null || imageIndex === undefined) {
                throw new RequiredError('imageIndex','Required parameter imageIndex was null or undefined when calling deleteItemImage2.');
            }
            const localVarPath = `/Items/{itemId}/Images/{imageType}/{imageIndex}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"imageIndex"}}`, encodeURIComponent(String(imageIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {ImageType} imageType 
         * @param {number} index 
         * @param {string} itemType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserImage: async (userId: string, imageType: ImageType, index: number, itemType: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling deleteUserImage.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling deleteUserImage.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling deleteUserImage.');
            }
            // verify required parameter 'itemType' is not null or undefined
            if (itemType === null || itemType === undefined) {
                throw new RequiredError('itemType','Required parameter itemType was null or undefined when calling deleteUserImage.');
            }
            const localVarPath = `/Users/{userId}/Images/{itemType}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"itemType"}}`, encodeURIComponent(String(itemType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {ImageType} imageType 
         * @param {number} index 
         * @param {string} itemType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserImage2: async (userId: string, imageType: ImageType, index: number, itemType: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling deleteUserImage2.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling deleteUserImage2.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling deleteUserImage2.');
            }
            // verify required parameter 'itemType' is not null or undefined
            if (itemType === null || itemType === undefined) {
                throw new RequiredError('itemType','Required parameter itemType was null or undefined when calling deleteUserImage2.');
            }
            const localVarPath = `/Users/{userId}/Images/{itemType}/{index}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"itemType"}}`, encodeURIComponent(String(itemType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {ImageType} imageType 
         * @param {string} tag 
         * @param {string} format 
         * @param {number} maxWidth 
         * @param {number} maxHeight 
         * @param {number} percentPlayed 
         * @param {number} unplayedCount 
         * @param {number} imageIndex 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [quality] 
         * @param {boolean} [cropWhitespace] 
         * @param {boolean} [addPlayedIndicator] 
         * @param {number} [blur] 
         * @param {string} [backgroundColor] 
         * @param {string} [foregroundLayer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtistImage: async (name: string, imageType: ImageType, tag: string, format: string, maxWidth: number, maxHeight: number, percentPlayed: number, unplayedCount: number, imageIndex: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getArtistImage.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling getArtistImage.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling getArtistImage.');
            }
            // verify required parameter 'format' is not null or undefined
            if (format === null || format === undefined) {
                throw new RequiredError('format','Required parameter format was null or undefined when calling getArtistImage.');
            }
            // verify required parameter 'maxWidth' is not null or undefined
            if (maxWidth === null || maxWidth === undefined) {
                throw new RequiredError('maxWidth','Required parameter maxWidth was null or undefined when calling getArtistImage.');
            }
            // verify required parameter 'maxHeight' is not null or undefined
            if (maxHeight === null || maxHeight === undefined) {
                throw new RequiredError('maxHeight','Required parameter maxHeight was null or undefined when calling getArtistImage.');
            }
            // verify required parameter 'percentPlayed' is not null or undefined
            if (percentPlayed === null || percentPlayed === undefined) {
                throw new RequiredError('percentPlayed','Required parameter percentPlayed was null or undefined when calling getArtistImage.');
            }
            // verify required parameter 'unplayedCount' is not null or undefined
            if (unplayedCount === null || unplayedCount === undefined) {
                throw new RequiredError('unplayedCount','Required parameter unplayedCount was null or undefined when calling getArtistImage.');
            }
            // verify required parameter 'imageIndex' is not null or undefined
            if (imageIndex === null || imageIndex === undefined) {
                throw new RequiredError('imageIndex','Required parameter imageIndex was null or undefined when calling getArtistImage.');
            }
            const localVarPath = `/Artists/{name}/Images/{imageType}/{imageIndex}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)))
                .replace(`{${"format"}}`, encodeURIComponent(String(format)))
                .replace(`{${"maxWidth"}}`, encodeURIComponent(String(maxWidth)))
                .replace(`{${"maxHeight"}}`, encodeURIComponent(String(maxHeight)))
                .replace(`{${"percentPlayed"}}`, encodeURIComponent(String(percentPlayed)))
                .replace(`{${"unplayedCount"}}`, encodeURIComponent(String(unplayedCount)))
                .replace(`{${"imageIndex"}}`, encodeURIComponent(String(imageIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['quality'] = quality;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['cropWhitespace'] = cropWhitespace;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['addPlayedIndicator'] = addPlayedIndicator;
            }

            if (blur !== undefined) {
                localVarQueryParameter['blur'] = blur;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['backgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['foregroundLayer'] = foregroundLayer;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {ImageType} imageType 
         * @param {string} tag 
         * @param {string} format 
         * @param {number} maxWidth 
         * @param {number} maxHeight 
         * @param {number} percentPlayed 
         * @param {number} unplayedCount 
         * @param {number} imageIndex 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [quality] 
         * @param {boolean} [cropWhitespace] 
         * @param {boolean} [addPlayedIndicator] 
         * @param {number} [blur] 
         * @param {string} [backgroundColor] 
         * @param {string} [foregroundLayer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGenreImage: async (name: string, imageType: ImageType, tag: string, format: string, maxWidth: number, maxHeight: number, percentPlayed: number, unplayedCount: number, imageIndex: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getGenreImage.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling getGenreImage.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling getGenreImage.');
            }
            // verify required parameter 'format' is not null or undefined
            if (format === null || format === undefined) {
                throw new RequiredError('format','Required parameter format was null or undefined when calling getGenreImage.');
            }
            // verify required parameter 'maxWidth' is not null or undefined
            if (maxWidth === null || maxWidth === undefined) {
                throw new RequiredError('maxWidth','Required parameter maxWidth was null or undefined when calling getGenreImage.');
            }
            // verify required parameter 'maxHeight' is not null or undefined
            if (maxHeight === null || maxHeight === undefined) {
                throw new RequiredError('maxHeight','Required parameter maxHeight was null or undefined when calling getGenreImage.');
            }
            // verify required parameter 'percentPlayed' is not null or undefined
            if (percentPlayed === null || percentPlayed === undefined) {
                throw new RequiredError('percentPlayed','Required parameter percentPlayed was null or undefined when calling getGenreImage.');
            }
            // verify required parameter 'unplayedCount' is not null or undefined
            if (unplayedCount === null || unplayedCount === undefined) {
                throw new RequiredError('unplayedCount','Required parameter unplayedCount was null or undefined when calling getGenreImage.');
            }
            // verify required parameter 'imageIndex' is not null or undefined
            if (imageIndex === null || imageIndex === undefined) {
                throw new RequiredError('imageIndex','Required parameter imageIndex was null or undefined when calling getGenreImage.');
            }
            const localVarPath = `/Genres/{name}/Images/{imageType}/{imageIndex}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)))
                .replace(`{${"format"}}`, encodeURIComponent(String(format)))
                .replace(`{${"maxWidth"}}`, encodeURIComponent(String(maxWidth)))
                .replace(`{${"maxHeight"}}`, encodeURIComponent(String(maxHeight)))
                .replace(`{${"percentPlayed"}}`, encodeURIComponent(String(percentPlayed)))
                .replace(`{${"unplayedCount"}}`, encodeURIComponent(String(unplayedCount)))
                .replace(`{${"imageIndex"}}`, encodeURIComponent(String(imageIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['quality'] = quality;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['cropWhitespace'] = cropWhitespace;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['addPlayedIndicator'] = addPlayedIndicator;
            }

            if (blur !== undefined) {
                localVarQueryParameter['blur'] = blur;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['backgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['foregroundLayer'] = foregroundLayer;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {ImageType} imageType 
         * @param {number} maxWidth 
         * @param {number} maxHeight 
         * @param {number} imageIndex 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [quality] 
         * @param {string} [tag] 
         * @param {boolean} [cropWhitespace] 
         * @param {string} [format] 
         * @param {boolean} [addPlayedIndicator] 
         * @param {number} [percentPlayed] 
         * @param {number} [unplayedCount] 
         * @param {number} [blur] 
         * @param {string} [backgroundColor] 
         * @param {string} [foregroundLayer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemImage: async (itemId: string, imageType: ImageType, maxWidth: number, maxHeight: number, imageIndex: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, blur?: number, backgroundColor?: string, foregroundLayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getItemImage.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling getItemImage.');
            }
            // verify required parameter 'maxWidth' is not null or undefined
            if (maxWidth === null || maxWidth === undefined) {
                throw new RequiredError('maxWidth','Required parameter maxWidth was null or undefined when calling getItemImage.');
            }
            // verify required parameter 'maxHeight' is not null or undefined
            if (maxHeight === null || maxHeight === undefined) {
                throw new RequiredError('maxHeight','Required parameter maxHeight was null or undefined when calling getItemImage.');
            }
            // verify required parameter 'imageIndex' is not null or undefined
            if (imageIndex === null || imageIndex === undefined) {
                throw new RequiredError('imageIndex','Required parameter imageIndex was null or undefined when calling getItemImage.');
            }
            const localVarPath = `/Items/{itemId}/Images/{imageType}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"maxWidth"}}`, encodeURIComponent(String(maxWidth)))
                .replace(`{${"maxHeight"}}`, encodeURIComponent(String(maxHeight)))
                .replace(`{${"imageIndex"}}`, encodeURIComponent(String(imageIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['quality'] = quality;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['cropWhitespace'] = cropWhitespace;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['addPlayedIndicator'] = addPlayedIndicator;
            }

            if (percentPlayed !== undefined) {
                localVarQueryParameter['percentPlayed'] = percentPlayed;
            }

            if (unplayedCount !== undefined) {
                localVarQueryParameter['unplayedCount'] = unplayedCount;
            }

            if (blur !== undefined) {
                localVarQueryParameter['blur'] = blur;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['backgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['foregroundLayer'] = foregroundLayer;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {ImageType} imageType 
         * @param {number} maxWidth 
         * @param {number} maxHeight 
         * @param {number} imageIndex 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [quality] 
         * @param {string} [tag] 
         * @param {boolean} [cropWhitespace] 
         * @param {string} [format] 
         * @param {boolean} [addPlayedIndicator] 
         * @param {number} [percentPlayed] 
         * @param {number} [unplayedCount] 
         * @param {number} [blur] 
         * @param {string} [backgroundColor] 
         * @param {string} [foregroundLayer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemImage2: async (itemId: string, imageType: ImageType, maxWidth: number, maxHeight: number, imageIndex: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, blur?: number, backgroundColor?: string, foregroundLayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getItemImage2.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling getItemImage2.');
            }
            // verify required parameter 'maxWidth' is not null or undefined
            if (maxWidth === null || maxWidth === undefined) {
                throw new RequiredError('maxWidth','Required parameter maxWidth was null or undefined when calling getItemImage2.');
            }
            // verify required parameter 'maxHeight' is not null or undefined
            if (maxHeight === null || maxHeight === undefined) {
                throw new RequiredError('maxHeight','Required parameter maxHeight was null or undefined when calling getItemImage2.');
            }
            // verify required parameter 'imageIndex' is not null or undefined
            if (imageIndex === null || imageIndex === undefined) {
                throw new RequiredError('imageIndex','Required parameter imageIndex was null or undefined when calling getItemImage2.');
            }
            const localVarPath = `/Items/{itemId}/Images/{imageType}/{imageIndex}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"maxWidth"}}`, encodeURIComponent(String(maxWidth)))
                .replace(`{${"maxHeight"}}`, encodeURIComponent(String(maxHeight)))
                .replace(`{${"imageIndex"}}`, encodeURIComponent(String(imageIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['quality'] = quality;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['cropWhitespace'] = cropWhitespace;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['addPlayedIndicator'] = addPlayedIndicator;
            }

            if (percentPlayed !== undefined) {
                localVarQueryParameter['percentPlayed'] = percentPlayed;
            }

            if (unplayedCount !== undefined) {
                localVarQueryParameter['unplayedCount'] = unplayedCount;
            }

            if (blur !== undefined) {
                localVarQueryParameter['blur'] = blur;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['backgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['foregroundLayer'] = foregroundLayer;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {ImageType} imageType 
         * @param {number} maxWidth 
         * @param {number} maxHeight 
         * @param {string} tag 
         * @param {string} format 
         * @param {number} percentPlayed 
         * @param {number} unplayedCount 
         * @param {number} imageIndex 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [quality] 
         * @param {boolean} [cropWhitespace] 
         * @param {boolean} [addPlayedIndicator] 
         * @param {number} [blur] 
         * @param {string} [backgroundColor] 
         * @param {string} [foregroundLayer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemImage2_1: async (itemId: string, imageType: ImageType, maxWidth: number, maxHeight: number, tag: string, format: string, percentPlayed: number, unplayedCount: number, imageIndex: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getItemImage2_1.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling getItemImage2_1.');
            }
            // verify required parameter 'maxWidth' is not null or undefined
            if (maxWidth === null || maxWidth === undefined) {
                throw new RequiredError('maxWidth','Required parameter maxWidth was null or undefined when calling getItemImage2_1.');
            }
            // verify required parameter 'maxHeight' is not null or undefined
            if (maxHeight === null || maxHeight === undefined) {
                throw new RequiredError('maxHeight','Required parameter maxHeight was null or undefined when calling getItemImage2_1.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling getItemImage2_1.');
            }
            // verify required parameter 'format' is not null or undefined
            if (format === null || format === undefined) {
                throw new RequiredError('format','Required parameter format was null or undefined when calling getItemImage2_1.');
            }
            // verify required parameter 'percentPlayed' is not null or undefined
            if (percentPlayed === null || percentPlayed === undefined) {
                throw new RequiredError('percentPlayed','Required parameter percentPlayed was null or undefined when calling getItemImage2_1.');
            }
            // verify required parameter 'unplayedCount' is not null or undefined
            if (unplayedCount === null || unplayedCount === undefined) {
                throw new RequiredError('unplayedCount','Required parameter unplayedCount was null or undefined when calling getItemImage2_1.');
            }
            // verify required parameter 'imageIndex' is not null or undefined
            if (imageIndex === null || imageIndex === undefined) {
                throw new RequiredError('imageIndex','Required parameter imageIndex was null or undefined when calling getItemImage2_1.');
            }
            const localVarPath = `/Items/{itemId}/Images/{imageType}/{imageIndex}/{tag}/{format}/{maxWidth}/{maxHeight}/{percentPlayed}/{unplayedCount}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"maxWidth"}}`, encodeURIComponent(String(maxWidth)))
                .replace(`{${"maxHeight"}}`, encodeURIComponent(String(maxHeight)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)))
                .replace(`{${"format"}}`, encodeURIComponent(String(format)))
                .replace(`{${"percentPlayed"}}`, encodeURIComponent(String(percentPlayed)))
                .replace(`{${"unplayedCount"}}`, encodeURIComponent(String(unplayedCount)))
                .replace(`{${"imageIndex"}}`, encodeURIComponent(String(imageIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['quality'] = quality;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['cropWhitespace'] = cropWhitespace;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['addPlayedIndicator'] = addPlayedIndicator;
            }

            if (blur !== undefined) {
                localVarQueryParameter['blur'] = blur;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['backgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['foregroundLayer'] = foregroundLayer;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemImageInfos: async (itemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getItemImageInfos.');
            }
            const localVarPath = `/Items/{itemId}/Images`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {ImageType} imageType 
         * @param {string} tag 
         * @param {string} format 
         * @param {number} maxWidth 
         * @param {number} maxHeight 
         * @param {number} percentPlayed 
         * @param {number} unplayedCount 
         * @param {number} imageIndex 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [quality] 
         * @param {boolean} [cropWhitespace] 
         * @param {boolean} [addPlayedIndicator] 
         * @param {number} [blur] 
         * @param {string} [backgroundColor] 
         * @param {string} [foregroundLayer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMusicGenreImage: async (name: string, imageType: ImageType, tag: string, format: string, maxWidth: number, maxHeight: number, percentPlayed: number, unplayedCount: number, imageIndex: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getMusicGenreImage.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling getMusicGenreImage.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling getMusicGenreImage.');
            }
            // verify required parameter 'format' is not null or undefined
            if (format === null || format === undefined) {
                throw new RequiredError('format','Required parameter format was null or undefined when calling getMusicGenreImage.');
            }
            // verify required parameter 'maxWidth' is not null or undefined
            if (maxWidth === null || maxWidth === undefined) {
                throw new RequiredError('maxWidth','Required parameter maxWidth was null or undefined when calling getMusicGenreImage.');
            }
            // verify required parameter 'maxHeight' is not null or undefined
            if (maxHeight === null || maxHeight === undefined) {
                throw new RequiredError('maxHeight','Required parameter maxHeight was null or undefined when calling getMusicGenreImage.');
            }
            // verify required parameter 'percentPlayed' is not null or undefined
            if (percentPlayed === null || percentPlayed === undefined) {
                throw new RequiredError('percentPlayed','Required parameter percentPlayed was null or undefined when calling getMusicGenreImage.');
            }
            // verify required parameter 'unplayedCount' is not null or undefined
            if (unplayedCount === null || unplayedCount === undefined) {
                throw new RequiredError('unplayedCount','Required parameter unplayedCount was null or undefined when calling getMusicGenreImage.');
            }
            // verify required parameter 'imageIndex' is not null or undefined
            if (imageIndex === null || imageIndex === undefined) {
                throw new RequiredError('imageIndex','Required parameter imageIndex was null or undefined when calling getMusicGenreImage.');
            }
            const localVarPath = `/MusicGenres/{name}/Images/{imageType}/{imageIndex}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)))
                .replace(`{${"format"}}`, encodeURIComponent(String(format)))
                .replace(`{${"maxWidth"}}`, encodeURIComponent(String(maxWidth)))
                .replace(`{${"maxHeight"}}`, encodeURIComponent(String(maxHeight)))
                .replace(`{${"percentPlayed"}}`, encodeURIComponent(String(percentPlayed)))
                .replace(`{${"unplayedCount"}}`, encodeURIComponent(String(unplayedCount)))
                .replace(`{${"imageIndex"}}`, encodeURIComponent(String(imageIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['quality'] = quality;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['cropWhitespace'] = cropWhitespace;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['addPlayedIndicator'] = addPlayedIndicator;
            }

            if (blur !== undefined) {
                localVarQueryParameter['blur'] = blur;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['backgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['foregroundLayer'] = foregroundLayer;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {ImageType} imageType 
         * @param {string} tag 
         * @param {string} format 
         * @param {number} maxWidth 
         * @param {number} maxHeight 
         * @param {number} percentPlayed 
         * @param {number} unplayedCount 
         * @param {number} imageIndex 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [quality] 
         * @param {boolean} [cropWhitespace] 
         * @param {boolean} [addPlayedIndicator] 
         * @param {number} [blur] 
         * @param {string} [backgroundColor] 
         * @param {string} [foregroundLayer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonImage: async (name: string, imageType: ImageType, tag: string, format: string, maxWidth: number, maxHeight: number, percentPlayed: number, unplayedCount: number, imageIndex: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getPersonImage.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling getPersonImage.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling getPersonImage.');
            }
            // verify required parameter 'format' is not null or undefined
            if (format === null || format === undefined) {
                throw new RequiredError('format','Required parameter format was null or undefined when calling getPersonImage.');
            }
            // verify required parameter 'maxWidth' is not null or undefined
            if (maxWidth === null || maxWidth === undefined) {
                throw new RequiredError('maxWidth','Required parameter maxWidth was null or undefined when calling getPersonImage.');
            }
            // verify required parameter 'maxHeight' is not null or undefined
            if (maxHeight === null || maxHeight === undefined) {
                throw new RequiredError('maxHeight','Required parameter maxHeight was null or undefined when calling getPersonImage.');
            }
            // verify required parameter 'percentPlayed' is not null or undefined
            if (percentPlayed === null || percentPlayed === undefined) {
                throw new RequiredError('percentPlayed','Required parameter percentPlayed was null or undefined when calling getPersonImage.');
            }
            // verify required parameter 'unplayedCount' is not null or undefined
            if (unplayedCount === null || unplayedCount === undefined) {
                throw new RequiredError('unplayedCount','Required parameter unplayedCount was null or undefined when calling getPersonImage.');
            }
            // verify required parameter 'imageIndex' is not null or undefined
            if (imageIndex === null || imageIndex === undefined) {
                throw new RequiredError('imageIndex','Required parameter imageIndex was null or undefined when calling getPersonImage.');
            }
            const localVarPath = `/Persons/{name}/Images/{imageType}/{imageIndex}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)))
                .replace(`{${"format"}}`, encodeURIComponent(String(format)))
                .replace(`{${"maxWidth"}}`, encodeURIComponent(String(maxWidth)))
                .replace(`{${"maxHeight"}}`, encodeURIComponent(String(maxHeight)))
                .replace(`{${"percentPlayed"}}`, encodeURIComponent(String(percentPlayed)))
                .replace(`{${"unplayedCount"}}`, encodeURIComponent(String(unplayedCount)))
                .replace(`{${"imageIndex"}}`, encodeURIComponent(String(imageIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['quality'] = quality;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['cropWhitespace'] = cropWhitespace;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['addPlayedIndicator'] = addPlayedIndicator;
            }

            if (blur !== undefined) {
                localVarQueryParameter['blur'] = blur;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['backgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['foregroundLayer'] = foregroundLayer;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {ImageType} imageType 
         * @param {string} tag 
         * @param {string} format 
         * @param {number} maxWidth 
         * @param {number} maxHeight 
         * @param {number} percentPlayed 
         * @param {number} unplayedCount 
         * @param {number} imageIndex 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [quality] 
         * @param {boolean} [cropWhitespace] 
         * @param {boolean} [addPlayedIndicator] 
         * @param {number} [blur] 
         * @param {string} [backgroundColor] 
         * @param {string} [foregroundLayer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudioImage: async (name: string, imageType: ImageType, tag: string, format: string, maxWidth: number, maxHeight: number, percentPlayed: number, unplayedCount: number, imageIndex: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getStudioImage.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling getStudioImage.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling getStudioImage.');
            }
            // verify required parameter 'format' is not null or undefined
            if (format === null || format === undefined) {
                throw new RequiredError('format','Required parameter format was null or undefined when calling getStudioImage.');
            }
            // verify required parameter 'maxWidth' is not null or undefined
            if (maxWidth === null || maxWidth === undefined) {
                throw new RequiredError('maxWidth','Required parameter maxWidth was null or undefined when calling getStudioImage.');
            }
            // verify required parameter 'maxHeight' is not null or undefined
            if (maxHeight === null || maxHeight === undefined) {
                throw new RequiredError('maxHeight','Required parameter maxHeight was null or undefined when calling getStudioImage.');
            }
            // verify required parameter 'percentPlayed' is not null or undefined
            if (percentPlayed === null || percentPlayed === undefined) {
                throw new RequiredError('percentPlayed','Required parameter percentPlayed was null or undefined when calling getStudioImage.');
            }
            // verify required parameter 'unplayedCount' is not null or undefined
            if (unplayedCount === null || unplayedCount === undefined) {
                throw new RequiredError('unplayedCount','Required parameter unplayedCount was null or undefined when calling getStudioImage.');
            }
            // verify required parameter 'imageIndex' is not null or undefined
            if (imageIndex === null || imageIndex === undefined) {
                throw new RequiredError('imageIndex','Required parameter imageIndex was null or undefined when calling getStudioImage.');
            }
            const localVarPath = `/Studios/{name}/Images/{imageType}/{imageIndex}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)))
                .replace(`{${"format"}}`, encodeURIComponent(String(format)))
                .replace(`{${"maxWidth"}}`, encodeURIComponent(String(maxWidth)))
                .replace(`{${"maxHeight"}}`, encodeURIComponent(String(maxHeight)))
                .replace(`{${"percentPlayed"}}`, encodeURIComponent(String(percentPlayed)))
                .replace(`{${"unplayedCount"}}`, encodeURIComponent(String(unplayedCount)))
                .replace(`{${"imageIndex"}}`, encodeURIComponent(String(imageIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['quality'] = quality;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['cropWhitespace'] = cropWhitespace;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['addPlayedIndicator'] = addPlayedIndicator;
            }

            if (blur !== undefined) {
                localVarQueryParameter['blur'] = blur;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['backgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['foregroundLayer'] = foregroundLayer;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {ImageType} imageType 
         * @param {number} imageIndex 
         * @param {string} [tag] 
         * @param {string} [format] 
         * @param {number} [maxWidth] 
         * @param {number} [maxHeight] 
         * @param {number} [percentPlayed] 
         * @param {number} [unplayedCount] 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [quality] 
         * @param {boolean} [cropWhitespace] 
         * @param {boolean} [addPlayedIndicator] 
         * @param {number} [blur] 
         * @param {string} [backgroundColor] 
         * @param {string} [foregroundLayer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserImage: async (userId: string, imageType: ImageType, imageIndex: number, tag?: string, format?: string, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getUserImage.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling getUserImage.');
            }
            // verify required parameter 'imageIndex' is not null or undefined
            if (imageIndex === null || imageIndex === undefined) {
                throw new RequiredError('imageIndex','Required parameter imageIndex was null or undefined when calling getUserImage.');
            }
            const localVarPath = `/Users/{userId}/Images/{imageType}/{imageIndex}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"imageIndex"}}`, encodeURIComponent(String(imageIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (maxWidth !== undefined) {
                localVarQueryParameter['maxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['maxHeight'] = maxHeight;
            }

            if (percentPlayed !== undefined) {
                localVarQueryParameter['percentPlayed'] = percentPlayed;
            }

            if (unplayedCount !== undefined) {
                localVarQueryParameter['unplayedCount'] = unplayedCount;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['quality'] = quality;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['cropWhitespace'] = cropWhitespace;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['addPlayedIndicator'] = addPlayedIndicator;
            }

            if (blur !== undefined) {
                localVarQueryParameter['blur'] = blur;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['backgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['foregroundLayer'] = foregroundLayer;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {ImageType} imageType 
         * @param {string} tag 
         * @param {string} format 
         * @param {number} maxWidth 
         * @param {number} maxHeight 
         * @param {number} percentPlayed 
         * @param {number} unplayedCount 
         * @param {number} imageIndex 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [quality] 
         * @param {boolean} [cropWhitespace] 
         * @param {boolean} [addPlayedIndicator] 
         * @param {number} [blur] 
         * @param {string} [backgroundColor] 
         * @param {string} [foregroundLayer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headArtistImage: async (name: string, imageType: ImageType, tag: string, format: string, maxWidth: number, maxHeight: number, percentPlayed: number, unplayedCount: number, imageIndex: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling headArtistImage.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling headArtistImage.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling headArtistImage.');
            }
            // verify required parameter 'format' is not null or undefined
            if (format === null || format === undefined) {
                throw new RequiredError('format','Required parameter format was null or undefined when calling headArtistImage.');
            }
            // verify required parameter 'maxWidth' is not null or undefined
            if (maxWidth === null || maxWidth === undefined) {
                throw new RequiredError('maxWidth','Required parameter maxWidth was null or undefined when calling headArtistImage.');
            }
            // verify required parameter 'maxHeight' is not null or undefined
            if (maxHeight === null || maxHeight === undefined) {
                throw new RequiredError('maxHeight','Required parameter maxHeight was null or undefined when calling headArtistImage.');
            }
            // verify required parameter 'percentPlayed' is not null or undefined
            if (percentPlayed === null || percentPlayed === undefined) {
                throw new RequiredError('percentPlayed','Required parameter percentPlayed was null or undefined when calling headArtistImage.');
            }
            // verify required parameter 'unplayedCount' is not null or undefined
            if (unplayedCount === null || unplayedCount === undefined) {
                throw new RequiredError('unplayedCount','Required parameter unplayedCount was null or undefined when calling headArtistImage.');
            }
            // verify required parameter 'imageIndex' is not null or undefined
            if (imageIndex === null || imageIndex === undefined) {
                throw new RequiredError('imageIndex','Required parameter imageIndex was null or undefined when calling headArtistImage.');
            }
            const localVarPath = `/Artists/{name}/Images/{imageType}/{imageIndex}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)))
                .replace(`{${"format"}}`, encodeURIComponent(String(format)))
                .replace(`{${"maxWidth"}}`, encodeURIComponent(String(maxWidth)))
                .replace(`{${"maxHeight"}}`, encodeURIComponent(String(maxHeight)))
                .replace(`{${"percentPlayed"}}`, encodeURIComponent(String(percentPlayed)))
                .replace(`{${"unplayedCount"}}`, encodeURIComponent(String(unplayedCount)))
                .replace(`{${"imageIndex"}}`, encodeURIComponent(String(imageIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['quality'] = quality;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['cropWhitespace'] = cropWhitespace;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['addPlayedIndicator'] = addPlayedIndicator;
            }

            if (blur !== undefined) {
                localVarQueryParameter['blur'] = blur;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['backgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['foregroundLayer'] = foregroundLayer;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {ImageType} imageType 
         * @param {string} tag 
         * @param {string} format 
         * @param {number} maxWidth 
         * @param {number} maxHeight 
         * @param {number} percentPlayed 
         * @param {number} unplayedCount 
         * @param {number} imageIndex 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [quality] 
         * @param {boolean} [cropWhitespace] 
         * @param {boolean} [addPlayedIndicator] 
         * @param {number} [blur] 
         * @param {string} [backgroundColor] 
         * @param {string} [foregroundLayer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headGenreImage: async (name: string, imageType: ImageType, tag: string, format: string, maxWidth: number, maxHeight: number, percentPlayed: number, unplayedCount: number, imageIndex: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling headGenreImage.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling headGenreImage.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling headGenreImage.');
            }
            // verify required parameter 'format' is not null or undefined
            if (format === null || format === undefined) {
                throw new RequiredError('format','Required parameter format was null or undefined when calling headGenreImage.');
            }
            // verify required parameter 'maxWidth' is not null or undefined
            if (maxWidth === null || maxWidth === undefined) {
                throw new RequiredError('maxWidth','Required parameter maxWidth was null or undefined when calling headGenreImage.');
            }
            // verify required parameter 'maxHeight' is not null or undefined
            if (maxHeight === null || maxHeight === undefined) {
                throw new RequiredError('maxHeight','Required parameter maxHeight was null or undefined when calling headGenreImage.');
            }
            // verify required parameter 'percentPlayed' is not null or undefined
            if (percentPlayed === null || percentPlayed === undefined) {
                throw new RequiredError('percentPlayed','Required parameter percentPlayed was null or undefined when calling headGenreImage.');
            }
            // verify required parameter 'unplayedCount' is not null or undefined
            if (unplayedCount === null || unplayedCount === undefined) {
                throw new RequiredError('unplayedCount','Required parameter unplayedCount was null or undefined when calling headGenreImage.');
            }
            // verify required parameter 'imageIndex' is not null or undefined
            if (imageIndex === null || imageIndex === undefined) {
                throw new RequiredError('imageIndex','Required parameter imageIndex was null or undefined when calling headGenreImage.');
            }
            const localVarPath = `/Genres/{name}/Images/{imageType}/{imageIndex}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)))
                .replace(`{${"format"}}`, encodeURIComponent(String(format)))
                .replace(`{${"maxWidth"}}`, encodeURIComponent(String(maxWidth)))
                .replace(`{${"maxHeight"}}`, encodeURIComponent(String(maxHeight)))
                .replace(`{${"percentPlayed"}}`, encodeURIComponent(String(percentPlayed)))
                .replace(`{${"unplayedCount"}}`, encodeURIComponent(String(unplayedCount)))
                .replace(`{${"imageIndex"}}`, encodeURIComponent(String(imageIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['quality'] = quality;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['cropWhitespace'] = cropWhitespace;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['addPlayedIndicator'] = addPlayedIndicator;
            }

            if (blur !== undefined) {
                localVarQueryParameter['blur'] = blur;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['backgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['foregroundLayer'] = foregroundLayer;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {ImageType} imageType 
         * @param {number} maxWidth 
         * @param {number} maxHeight 
         * @param {number} imageIndex 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [quality] 
         * @param {string} [tag] 
         * @param {boolean} [cropWhitespace] 
         * @param {string} [format] 
         * @param {boolean} [addPlayedIndicator] 
         * @param {number} [percentPlayed] 
         * @param {number} [unplayedCount] 
         * @param {number} [blur] 
         * @param {string} [backgroundColor] 
         * @param {string} [foregroundLayer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headItemImage: async (itemId: string, imageType: ImageType, maxWidth: number, maxHeight: number, imageIndex: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, blur?: number, backgroundColor?: string, foregroundLayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling headItemImage.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling headItemImage.');
            }
            // verify required parameter 'maxWidth' is not null or undefined
            if (maxWidth === null || maxWidth === undefined) {
                throw new RequiredError('maxWidth','Required parameter maxWidth was null or undefined when calling headItemImage.');
            }
            // verify required parameter 'maxHeight' is not null or undefined
            if (maxHeight === null || maxHeight === undefined) {
                throw new RequiredError('maxHeight','Required parameter maxHeight was null or undefined when calling headItemImage.');
            }
            // verify required parameter 'imageIndex' is not null or undefined
            if (imageIndex === null || imageIndex === undefined) {
                throw new RequiredError('imageIndex','Required parameter imageIndex was null or undefined when calling headItemImage.');
            }
            const localVarPath = `/Items/{itemId}/Images/{imageType}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"maxWidth"}}`, encodeURIComponent(String(maxWidth)))
                .replace(`{${"maxHeight"}}`, encodeURIComponent(String(maxHeight)))
                .replace(`{${"imageIndex"}}`, encodeURIComponent(String(imageIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['quality'] = quality;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['cropWhitespace'] = cropWhitespace;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['addPlayedIndicator'] = addPlayedIndicator;
            }

            if (percentPlayed !== undefined) {
                localVarQueryParameter['percentPlayed'] = percentPlayed;
            }

            if (unplayedCount !== undefined) {
                localVarQueryParameter['unplayedCount'] = unplayedCount;
            }

            if (blur !== undefined) {
                localVarQueryParameter['blur'] = blur;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['backgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['foregroundLayer'] = foregroundLayer;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {ImageType} imageType 
         * @param {number} maxWidth 
         * @param {number} maxHeight 
         * @param {number} imageIndex 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [quality] 
         * @param {string} [tag] 
         * @param {boolean} [cropWhitespace] 
         * @param {string} [format] 
         * @param {boolean} [addPlayedIndicator] 
         * @param {number} [percentPlayed] 
         * @param {number} [unplayedCount] 
         * @param {number} [blur] 
         * @param {string} [backgroundColor] 
         * @param {string} [foregroundLayer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headItemImage2: async (itemId: string, imageType: ImageType, maxWidth: number, maxHeight: number, imageIndex: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, blur?: number, backgroundColor?: string, foregroundLayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling headItemImage2.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling headItemImage2.');
            }
            // verify required parameter 'maxWidth' is not null or undefined
            if (maxWidth === null || maxWidth === undefined) {
                throw new RequiredError('maxWidth','Required parameter maxWidth was null or undefined when calling headItemImage2.');
            }
            // verify required parameter 'maxHeight' is not null or undefined
            if (maxHeight === null || maxHeight === undefined) {
                throw new RequiredError('maxHeight','Required parameter maxHeight was null or undefined when calling headItemImage2.');
            }
            // verify required parameter 'imageIndex' is not null or undefined
            if (imageIndex === null || imageIndex === undefined) {
                throw new RequiredError('imageIndex','Required parameter imageIndex was null or undefined when calling headItemImage2.');
            }
            const localVarPath = `/Items/{itemId}/Images/{imageType}/{imageIndex}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"maxWidth"}}`, encodeURIComponent(String(maxWidth)))
                .replace(`{${"maxHeight"}}`, encodeURIComponent(String(maxHeight)))
                .replace(`{${"imageIndex"}}`, encodeURIComponent(String(imageIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['quality'] = quality;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['cropWhitespace'] = cropWhitespace;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['addPlayedIndicator'] = addPlayedIndicator;
            }

            if (percentPlayed !== undefined) {
                localVarQueryParameter['percentPlayed'] = percentPlayed;
            }

            if (unplayedCount !== undefined) {
                localVarQueryParameter['unplayedCount'] = unplayedCount;
            }

            if (blur !== undefined) {
                localVarQueryParameter['blur'] = blur;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['backgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['foregroundLayer'] = foregroundLayer;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {ImageType} imageType 
         * @param {number} maxWidth 
         * @param {number} maxHeight 
         * @param {string} tag 
         * @param {string} format 
         * @param {number} percentPlayed 
         * @param {number} unplayedCount 
         * @param {number} imageIndex 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [quality] 
         * @param {boolean} [cropWhitespace] 
         * @param {boolean} [addPlayedIndicator] 
         * @param {number} [blur] 
         * @param {string} [backgroundColor] 
         * @param {string} [foregroundLayer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headItemImage2_2: async (itemId: string, imageType: ImageType, maxWidth: number, maxHeight: number, tag: string, format: string, percentPlayed: number, unplayedCount: number, imageIndex: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling headItemImage2_2.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling headItemImage2_2.');
            }
            // verify required parameter 'maxWidth' is not null or undefined
            if (maxWidth === null || maxWidth === undefined) {
                throw new RequiredError('maxWidth','Required parameter maxWidth was null or undefined when calling headItemImage2_2.');
            }
            // verify required parameter 'maxHeight' is not null or undefined
            if (maxHeight === null || maxHeight === undefined) {
                throw new RequiredError('maxHeight','Required parameter maxHeight was null or undefined when calling headItemImage2_2.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling headItemImage2_2.');
            }
            // verify required parameter 'format' is not null or undefined
            if (format === null || format === undefined) {
                throw new RequiredError('format','Required parameter format was null or undefined when calling headItemImage2_2.');
            }
            // verify required parameter 'percentPlayed' is not null or undefined
            if (percentPlayed === null || percentPlayed === undefined) {
                throw new RequiredError('percentPlayed','Required parameter percentPlayed was null or undefined when calling headItemImage2_2.');
            }
            // verify required parameter 'unplayedCount' is not null or undefined
            if (unplayedCount === null || unplayedCount === undefined) {
                throw new RequiredError('unplayedCount','Required parameter unplayedCount was null or undefined when calling headItemImage2_2.');
            }
            // verify required parameter 'imageIndex' is not null or undefined
            if (imageIndex === null || imageIndex === undefined) {
                throw new RequiredError('imageIndex','Required parameter imageIndex was null or undefined when calling headItemImage2_2.');
            }
            const localVarPath = `/Items/{itemId}/Images/{imageType}/{imageIndex}/{tag}/{format}/{maxWidth}/{maxHeight}/{percentPlayed}/{unplayedCount}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"maxWidth"}}`, encodeURIComponent(String(maxWidth)))
                .replace(`{${"maxHeight"}}`, encodeURIComponent(String(maxHeight)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)))
                .replace(`{${"format"}}`, encodeURIComponent(String(format)))
                .replace(`{${"percentPlayed"}}`, encodeURIComponent(String(percentPlayed)))
                .replace(`{${"unplayedCount"}}`, encodeURIComponent(String(unplayedCount)))
                .replace(`{${"imageIndex"}}`, encodeURIComponent(String(imageIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['quality'] = quality;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['cropWhitespace'] = cropWhitespace;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['addPlayedIndicator'] = addPlayedIndicator;
            }

            if (blur !== undefined) {
                localVarQueryParameter['blur'] = blur;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['backgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['foregroundLayer'] = foregroundLayer;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {ImageType} imageType 
         * @param {string} tag 
         * @param {string} format 
         * @param {number} maxWidth 
         * @param {number} maxHeight 
         * @param {number} percentPlayed 
         * @param {number} unplayedCount 
         * @param {number} imageIndex 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [quality] 
         * @param {boolean} [cropWhitespace] 
         * @param {boolean} [addPlayedIndicator] 
         * @param {number} [blur] 
         * @param {string} [backgroundColor] 
         * @param {string} [foregroundLayer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headMusicGenreImage: async (name: string, imageType: ImageType, tag: string, format: string, maxWidth: number, maxHeight: number, percentPlayed: number, unplayedCount: number, imageIndex: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling headMusicGenreImage.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling headMusicGenreImage.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling headMusicGenreImage.');
            }
            // verify required parameter 'format' is not null or undefined
            if (format === null || format === undefined) {
                throw new RequiredError('format','Required parameter format was null or undefined when calling headMusicGenreImage.');
            }
            // verify required parameter 'maxWidth' is not null or undefined
            if (maxWidth === null || maxWidth === undefined) {
                throw new RequiredError('maxWidth','Required parameter maxWidth was null or undefined when calling headMusicGenreImage.');
            }
            // verify required parameter 'maxHeight' is not null or undefined
            if (maxHeight === null || maxHeight === undefined) {
                throw new RequiredError('maxHeight','Required parameter maxHeight was null or undefined when calling headMusicGenreImage.');
            }
            // verify required parameter 'percentPlayed' is not null or undefined
            if (percentPlayed === null || percentPlayed === undefined) {
                throw new RequiredError('percentPlayed','Required parameter percentPlayed was null or undefined when calling headMusicGenreImage.');
            }
            // verify required parameter 'unplayedCount' is not null or undefined
            if (unplayedCount === null || unplayedCount === undefined) {
                throw new RequiredError('unplayedCount','Required parameter unplayedCount was null or undefined when calling headMusicGenreImage.');
            }
            // verify required parameter 'imageIndex' is not null or undefined
            if (imageIndex === null || imageIndex === undefined) {
                throw new RequiredError('imageIndex','Required parameter imageIndex was null or undefined when calling headMusicGenreImage.');
            }
            const localVarPath = `/MusicGenres/{name}/Images/{imageType}/{imageIndex}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)))
                .replace(`{${"format"}}`, encodeURIComponent(String(format)))
                .replace(`{${"maxWidth"}}`, encodeURIComponent(String(maxWidth)))
                .replace(`{${"maxHeight"}}`, encodeURIComponent(String(maxHeight)))
                .replace(`{${"percentPlayed"}}`, encodeURIComponent(String(percentPlayed)))
                .replace(`{${"unplayedCount"}}`, encodeURIComponent(String(unplayedCount)))
                .replace(`{${"imageIndex"}}`, encodeURIComponent(String(imageIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['quality'] = quality;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['cropWhitespace'] = cropWhitespace;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['addPlayedIndicator'] = addPlayedIndicator;
            }

            if (blur !== undefined) {
                localVarQueryParameter['blur'] = blur;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['backgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['foregroundLayer'] = foregroundLayer;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {ImageType} imageType 
         * @param {string} tag 
         * @param {string} format 
         * @param {number} maxWidth 
         * @param {number} maxHeight 
         * @param {number} percentPlayed 
         * @param {number} unplayedCount 
         * @param {number} imageIndex 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [quality] 
         * @param {boolean} [cropWhitespace] 
         * @param {boolean} [addPlayedIndicator] 
         * @param {number} [blur] 
         * @param {string} [backgroundColor] 
         * @param {string} [foregroundLayer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headPersonImage: async (name: string, imageType: ImageType, tag: string, format: string, maxWidth: number, maxHeight: number, percentPlayed: number, unplayedCount: number, imageIndex: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling headPersonImage.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling headPersonImage.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling headPersonImage.');
            }
            // verify required parameter 'format' is not null or undefined
            if (format === null || format === undefined) {
                throw new RequiredError('format','Required parameter format was null or undefined when calling headPersonImage.');
            }
            // verify required parameter 'maxWidth' is not null or undefined
            if (maxWidth === null || maxWidth === undefined) {
                throw new RequiredError('maxWidth','Required parameter maxWidth was null or undefined when calling headPersonImage.');
            }
            // verify required parameter 'maxHeight' is not null or undefined
            if (maxHeight === null || maxHeight === undefined) {
                throw new RequiredError('maxHeight','Required parameter maxHeight was null or undefined when calling headPersonImage.');
            }
            // verify required parameter 'percentPlayed' is not null or undefined
            if (percentPlayed === null || percentPlayed === undefined) {
                throw new RequiredError('percentPlayed','Required parameter percentPlayed was null or undefined when calling headPersonImage.');
            }
            // verify required parameter 'unplayedCount' is not null or undefined
            if (unplayedCount === null || unplayedCount === undefined) {
                throw new RequiredError('unplayedCount','Required parameter unplayedCount was null or undefined when calling headPersonImage.');
            }
            // verify required parameter 'imageIndex' is not null or undefined
            if (imageIndex === null || imageIndex === undefined) {
                throw new RequiredError('imageIndex','Required parameter imageIndex was null or undefined when calling headPersonImage.');
            }
            const localVarPath = `/Persons/{name}/Images/{imageType}/{imageIndex}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)))
                .replace(`{${"format"}}`, encodeURIComponent(String(format)))
                .replace(`{${"maxWidth"}}`, encodeURIComponent(String(maxWidth)))
                .replace(`{${"maxHeight"}}`, encodeURIComponent(String(maxHeight)))
                .replace(`{${"percentPlayed"}}`, encodeURIComponent(String(percentPlayed)))
                .replace(`{${"unplayedCount"}}`, encodeURIComponent(String(unplayedCount)))
                .replace(`{${"imageIndex"}}`, encodeURIComponent(String(imageIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['quality'] = quality;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['cropWhitespace'] = cropWhitespace;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['addPlayedIndicator'] = addPlayedIndicator;
            }

            if (blur !== undefined) {
                localVarQueryParameter['blur'] = blur;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['backgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['foregroundLayer'] = foregroundLayer;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {ImageType} imageType 
         * @param {string} tag 
         * @param {string} format 
         * @param {number} maxWidth 
         * @param {number} maxHeight 
         * @param {number} percentPlayed 
         * @param {number} unplayedCount 
         * @param {number} imageIndex 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [quality] 
         * @param {boolean} [cropWhitespace] 
         * @param {boolean} [addPlayedIndicator] 
         * @param {number} [blur] 
         * @param {string} [backgroundColor] 
         * @param {string} [foregroundLayer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headStudioImage: async (name: string, imageType: ImageType, tag: string, format: string, maxWidth: number, maxHeight: number, percentPlayed: number, unplayedCount: number, imageIndex: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling headStudioImage.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling headStudioImage.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling headStudioImage.');
            }
            // verify required parameter 'format' is not null or undefined
            if (format === null || format === undefined) {
                throw new RequiredError('format','Required parameter format was null or undefined when calling headStudioImage.');
            }
            // verify required parameter 'maxWidth' is not null or undefined
            if (maxWidth === null || maxWidth === undefined) {
                throw new RequiredError('maxWidth','Required parameter maxWidth was null or undefined when calling headStudioImage.');
            }
            // verify required parameter 'maxHeight' is not null or undefined
            if (maxHeight === null || maxHeight === undefined) {
                throw new RequiredError('maxHeight','Required parameter maxHeight was null or undefined when calling headStudioImage.');
            }
            // verify required parameter 'percentPlayed' is not null or undefined
            if (percentPlayed === null || percentPlayed === undefined) {
                throw new RequiredError('percentPlayed','Required parameter percentPlayed was null or undefined when calling headStudioImage.');
            }
            // verify required parameter 'unplayedCount' is not null or undefined
            if (unplayedCount === null || unplayedCount === undefined) {
                throw new RequiredError('unplayedCount','Required parameter unplayedCount was null or undefined when calling headStudioImage.');
            }
            // verify required parameter 'imageIndex' is not null or undefined
            if (imageIndex === null || imageIndex === undefined) {
                throw new RequiredError('imageIndex','Required parameter imageIndex was null or undefined when calling headStudioImage.');
            }
            const localVarPath = `/Studios/{name}/Images/{imageType}/{imageIndex}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)))
                .replace(`{${"format"}}`, encodeURIComponent(String(format)))
                .replace(`{${"maxWidth"}}`, encodeURIComponent(String(maxWidth)))
                .replace(`{${"maxHeight"}}`, encodeURIComponent(String(maxHeight)))
                .replace(`{${"percentPlayed"}}`, encodeURIComponent(String(percentPlayed)))
                .replace(`{${"unplayedCount"}}`, encodeURIComponent(String(unplayedCount)))
                .replace(`{${"imageIndex"}}`, encodeURIComponent(String(imageIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['quality'] = quality;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['cropWhitespace'] = cropWhitespace;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['addPlayedIndicator'] = addPlayedIndicator;
            }

            if (blur !== undefined) {
                localVarQueryParameter['blur'] = blur;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['backgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['foregroundLayer'] = foregroundLayer;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {ImageType} imageType 
         * @param {number} imageIndex 
         * @param {string} [tag] 
         * @param {string} [format] 
         * @param {number} [maxWidth] 
         * @param {number} [maxHeight] 
         * @param {number} [percentPlayed] 
         * @param {number} [unplayedCount] 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [quality] 
         * @param {boolean} [cropWhitespace] 
         * @param {boolean} [addPlayedIndicator] 
         * @param {number} [blur] 
         * @param {string} [backgroundColor] 
         * @param {string} [foregroundLayer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headUserImage: async (userId: string, imageType: ImageType, imageIndex: number, tag?: string, format?: string, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling headUserImage.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling headUserImage.');
            }
            // verify required parameter 'imageIndex' is not null or undefined
            if (imageIndex === null || imageIndex === undefined) {
                throw new RequiredError('imageIndex','Required parameter imageIndex was null or undefined when calling headUserImage.');
            }
            const localVarPath = `/Users/{userId}/Images/{imageType}/{imageIndex}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"imageIndex"}}`, encodeURIComponent(String(imageIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (maxWidth !== undefined) {
                localVarQueryParameter['maxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['maxHeight'] = maxHeight;
            }

            if (percentPlayed !== undefined) {
                localVarQueryParameter['percentPlayed'] = percentPlayed;
            }

            if (unplayedCount !== undefined) {
                localVarQueryParameter['unplayedCount'] = unplayedCount;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (quality !== undefined) {
                localVarQueryParameter['quality'] = quality;
            }

            if (cropWhitespace !== undefined) {
                localVarQueryParameter['cropWhitespace'] = cropWhitespace;
            }

            if (addPlayedIndicator !== undefined) {
                localVarQueryParameter['addPlayedIndicator'] = addPlayedIndicator;
            }

            if (blur !== undefined) {
                localVarQueryParameter['blur'] = blur;
            }

            if (backgroundColor !== undefined) {
                localVarQueryParameter['backgroundColor'] = backgroundColor;
            }

            if (foregroundLayer !== undefined) {
                localVarQueryParameter['foregroundLayer'] = foregroundLayer;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {ImageType} imageType 
         * @param {number} index 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserImage: async (userId: string, imageType: ImageType, index: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling postUserImage.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling postUserImage.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling postUserImage.');
            }
            const localVarPath = `/Users/{userId}/Images/{imageType}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {ImageType} imageType 
         * @param {number} index 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserImage2: async (userId: string, imageType: ImageType, index: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling postUserImage2.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling postUserImage2.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling postUserImage2.');
            }
            const localVarPath = `/Users/{userId}/Images/{imageType}/{index}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {ImageType} imageType 
         * @param {number} imageIndex 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setItemImage: async (itemId: string, imageType: ImageType, imageIndex: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling setItemImage.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling setItemImage.');
            }
            // verify required parameter 'imageIndex' is not null or undefined
            if (imageIndex === null || imageIndex === undefined) {
                throw new RequiredError('imageIndex','Required parameter imageIndex was null or undefined when calling setItemImage.');
            }
            const localVarPath = `/Items/{itemId}/Images/{imageType}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"imageIndex"}}`, encodeURIComponent(String(imageIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {ImageType} imageType 
         * @param {number} imageIndex 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setItemImage2: async (itemId: string, imageType: ImageType, imageIndex: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling setItemImage2.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling setItemImage2.');
            }
            // verify required parameter 'imageIndex' is not null or undefined
            if (imageIndex === null || imageIndex === undefined) {
                throw new RequiredError('imageIndex','Required parameter imageIndex was null or undefined when calling setItemImage2.');
            }
            const localVarPath = `/Items/{itemId}/Images/{imageType}/{imageIndex}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"imageIndex"}}`, encodeURIComponent(String(imageIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {ImageType} imageType 
         * @param {number} imageIndex 
         * @param {number} [newIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItemImageIndex: async (itemId: string, imageType: ImageType, imageIndex: number, newIndex?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling updateItemImageIndex.');
            }
            // verify required parameter 'imageType' is not null or undefined
            if (imageType === null || imageType === undefined) {
                throw new RequiredError('imageType','Required parameter imageType was null or undefined when calling updateItemImageIndex.');
            }
            // verify required parameter 'imageIndex' is not null or undefined
            if (imageIndex === null || imageIndex === undefined) {
                throw new RequiredError('imageIndex','Required parameter imageIndex was null or undefined when calling updateItemImageIndex.');
            }
            const localVarPath = `/Items/{itemId}/Images/{imageType}/{imageIndex}/Index`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"imageType"}}`, encodeURIComponent(String(imageType)))
                .replace(`{${"imageIndex"}}`, encodeURIComponent(String(imageIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (newIndex !== undefined) {
                localVarQueryParameter['newIndex'] = newIndex;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImageApi - functional programming interface
 * @export
 */
export const ImageApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} itemId 
         * @param {ImageType} imageType 
         * @param {number} imageIndex 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItemImage(itemId: string, imageType: ImageType, imageIndex: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).deleteItemImage(itemId, imageType, imageIndex, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {ImageType} imageType 
         * @param {number} imageIndex 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItemImage2(itemId: string, imageType: ImageType, imageIndex: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).deleteItemImage2(itemId, imageType, imageIndex, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {ImageType} imageType 
         * @param {number} index 
         * @param {string} itemType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserImage(userId: string, imageType: ImageType, index: number, itemType: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).deleteUserImage(userId, imageType, index, itemType, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {ImageType} imageType 
         * @param {number} index 
         * @param {string} itemType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserImage2(userId: string, imageType: ImageType, index: number, itemType: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).deleteUserImage2(userId, imageType, index, itemType, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {ImageType} imageType 
         * @param {string} tag 
         * @param {string} format 
         * @param {number} maxWidth 
         * @param {number} maxHeight 
         * @param {number} percentPlayed 
         * @param {number} unplayedCount 
         * @param {number} imageIndex 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [quality] 
         * @param {boolean} [cropWhitespace] 
         * @param {boolean} [addPlayedIndicator] 
         * @param {number} [blur] 
         * @param {string} [backgroundColor] 
         * @param {string} [foregroundLayer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArtistImage(name: string, imageType: ImageType, tag: string, format: string, maxWidth: number, maxHeight: number, percentPlayed: number, unplayedCount: number, imageIndex: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).getArtistImage(name, imageType, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, imageIndex, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {ImageType} imageType 
         * @param {string} tag 
         * @param {string} format 
         * @param {number} maxWidth 
         * @param {number} maxHeight 
         * @param {number} percentPlayed 
         * @param {number} unplayedCount 
         * @param {number} imageIndex 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [quality] 
         * @param {boolean} [cropWhitespace] 
         * @param {boolean} [addPlayedIndicator] 
         * @param {number} [blur] 
         * @param {string} [backgroundColor] 
         * @param {string} [foregroundLayer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGenreImage(name: string, imageType: ImageType, tag: string, format: string, maxWidth: number, maxHeight: number, percentPlayed: number, unplayedCount: number, imageIndex: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).getGenreImage(name, imageType, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, imageIndex, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {ImageType} imageType 
         * @param {number} maxWidth 
         * @param {number} maxHeight 
         * @param {number} imageIndex 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [quality] 
         * @param {string} [tag] 
         * @param {boolean} [cropWhitespace] 
         * @param {string} [format] 
         * @param {boolean} [addPlayedIndicator] 
         * @param {number} [percentPlayed] 
         * @param {number} [unplayedCount] 
         * @param {number} [blur] 
         * @param {string} [backgroundColor] 
         * @param {string} [foregroundLayer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemImage(itemId: string, imageType: ImageType, maxWidth: number, maxHeight: number, imageIndex: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).getItemImage(itemId, imageType, maxWidth, maxHeight, imageIndex, width, height, quality, tag, cropWhitespace, format, addPlayedIndicator, percentPlayed, unplayedCount, blur, backgroundColor, foregroundLayer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {ImageType} imageType 
         * @param {number} maxWidth 
         * @param {number} maxHeight 
         * @param {number} imageIndex 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [quality] 
         * @param {string} [tag] 
         * @param {boolean} [cropWhitespace] 
         * @param {string} [format] 
         * @param {boolean} [addPlayedIndicator] 
         * @param {number} [percentPlayed] 
         * @param {number} [unplayedCount] 
         * @param {number} [blur] 
         * @param {string} [backgroundColor] 
         * @param {string} [foregroundLayer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemImage2(itemId: string, imageType: ImageType, maxWidth: number, maxHeight: number, imageIndex: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).getItemImage2(itemId, imageType, maxWidth, maxHeight, imageIndex, width, height, quality, tag, cropWhitespace, format, addPlayedIndicator, percentPlayed, unplayedCount, blur, backgroundColor, foregroundLayer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {ImageType} imageType 
         * @param {number} maxWidth 
         * @param {number} maxHeight 
         * @param {string} tag 
         * @param {string} format 
         * @param {number} percentPlayed 
         * @param {number} unplayedCount 
         * @param {number} imageIndex 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [quality] 
         * @param {boolean} [cropWhitespace] 
         * @param {boolean} [addPlayedIndicator] 
         * @param {number} [blur] 
         * @param {string} [backgroundColor] 
         * @param {string} [foregroundLayer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemImage2_1(itemId: string, imageType: ImageType, maxWidth: number, maxHeight: number, tag: string, format: string, percentPlayed: number, unplayedCount: number, imageIndex: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).getItemImage2_1(itemId, imageType, maxWidth, maxHeight, tag, format, percentPlayed, unplayedCount, imageIndex, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemImageInfos(itemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ImageInfo>>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).getItemImageInfos(itemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {ImageType} imageType 
         * @param {string} tag 
         * @param {string} format 
         * @param {number} maxWidth 
         * @param {number} maxHeight 
         * @param {number} percentPlayed 
         * @param {number} unplayedCount 
         * @param {number} imageIndex 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [quality] 
         * @param {boolean} [cropWhitespace] 
         * @param {boolean} [addPlayedIndicator] 
         * @param {number} [blur] 
         * @param {string} [backgroundColor] 
         * @param {string} [foregroundLayer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMusicGenreImage(name: string, imageType: ImageType, tag: string, format: string, maxWidth: number, maxHeight: number, percentPlayed: number, unplayedCount: number, imageIndex: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).getMusicGenreImage(name, imageType, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, imageIndex, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {ImageType} imageType 
         * @param {string} tag 
         * @param {string} format 
         * @param {number} maxWidth 
         * @param {number} maxHeight 
         * @param {number} percentPlayed 
         * @param {number} unplayedCount 
         * @param {number} imageIndex 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [quality] 
         * @param {boolean} [cropWhitespace] 
         * @param {boolean} [addPlayedIndicator] 
         * @param {number} [blur] 
         * @param {string} [backgroundColor] 
         * @param {string} [foregroundLayer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPersonImage(name: string, imageType: ImageType, tag: string, format: string, maxWidth: number, maxHeight: number, percentPlayed: number, unplayedCount: number, imageIndex: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).getPersonImage(name, imageType, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, imageIndex, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {ImageType} imageType 
         * @param {string} tag 
         * @param {string} format 
         * @param {number} maxWidth 
         * @param {number} maxHeight 
         * @param {number} percentPlayed 
         * @param {number} unplayedCount 
         * @param {number} imageIndex 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [quality] 
         * @param {boolean} [cropWhitespace] 
         * @param {boolean} [addPlayedIndicator] 
         * @param {number} [blur] 
         * @param {string} [backgroundColor] 
         * @param {string} [foregroundLayer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStudioImage(name: string, imageType: ImageType, tag: string, format: string, maxWidth: number, maxHeight: number, percentPlayed: number, unplayedCount: number, imageIndex: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).getStudioImage(name, imageType, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, imageIndex, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {ImageType} imageType 
         * @param {number} imageIndex 
         * @param {string} [tag] 
         * @param {string} [format] 
         * @param {number} [maxWidth] 
         * @param {number} [maxHeight] 
         * @param {number} [percentPlayed] 
         * @param {number} [unplayedCount] 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [quality] 
         * @param {boolean} [cropWhitespace] 
         * @param {boolean} [addPlayedIndicator] 
         * @param {number} [blur] 
         * @param {string} [backgroundColor] 
         * @param {string} [foregroundLayer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserImage(userId: string, imageType: ImageType, imageIndex: number, tag?: string, format?: string, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).getUserImage(userId, imageType, imageIndex, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {ImageType} imageType 
         * @param {string} tag 
         * @param {string} format 
         * @param {number} maxWidth 
         * @param {number} maxHeight 
         * @param {number} percentPlayed 
         * @param {number} unplayedCount 
         * @param {number} imageIndex 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [quality] 
         * @param {boolean} [cropWhitespace] 
         * @param {boolean} [addPlayedIndicator] 
         * @param {number} [blur] 
         * @param {string} [backgroundColor] 
         * @param {string} [foregroundLayer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headArtistImage(name: string, imageType: ImageType, tag: string, format: string, maxWidth: number, maxHeight: number, percentPlayed: number, unplayedCount: number, imageIndex: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).headArtistImage(name, imageType, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, imageIndex, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {ImageType} imageType 
         * @param {string} tag 
         * @param {string} format 
         * @param {number} maxWidth 
         * @param {number} maxHeight 
         * @param {number} percentPlayed 
         * @param {number} unplayedCount 
         * @param {number} imageIndex 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [quality] 
         * @param {boolean} [cropWhitespace] 
         * @param {boolean} [addPlayedIndicator] 
         * @param {number} [blur] 
         * @param {string} [backgroundColor] 
         * @param {string} [foregroundLayer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headGenreImage(name: string, imageType: ImageType, tag: string, format: string, maxWidth: number, maxHeight: number, percentPlayed: number, unplayedCount: number, imageIndex: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).headGenreImage(name, imageType, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, imageIndex, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {ImageType} imageType 
         * @param {number} maxWidth 
         * @param {number} maxHeight 
         * @param {number} imageIndex 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [quality] 
         * @param {string} [tag] 
         * @param {boolean} [cropWhitespace] 
         * @param {string} [format] 
         * @param {boolean} [addPlayedIndicator] 
         * @param {number} [percentPlayed] 
         * @param {number} [unplayedCount] 
         * @param {number} [blur] 
         * @param {string} [backgroundColor] 
         * @param {string} [foregroundLayer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headItemImage(itemId: string, imageType: ImageType, maxWidth: number, maxHeight: number, imageIndex: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).headItemImage(itemId, imageType, maxWidth, maxHeight, imageIndex, width, height, quality, tag, cropWhitespace, format, addPlayedIndicator, percentPlayed, unplayedCount, blur, backgroundColor, foregroundLayer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {ImageType} imageType 
         * @param {number} maxWidth 
         * @param {number} maxHeight 
         * @param {number} imageIndex 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [quality] 
         * @param {string} [tag] 
         * @param {boolean} [cropWhitespace] 
         * @param {string} [format] 
         * @param {boolean} [addPlayedIndicator] 
         * @param {number} [percentPlayed] 
         * @param {number} [unplayedCount] 
         * @param {number} [blur] 
         * @param {string} [backgroundColor] 
         * @param {string} [foregroundLayer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headItemImage2(itemId: string, imageType: ImageType, maxWidth: number, maxHeight: number, imageIndex: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).headItemImage2(itemId, imageType, maxWidth, maxHeight, imageIndex, width, height, quality, tag, cropWhitespace, format, addPlayedIndicator, percentPlayed, unplayedCount, blur, backgroundColor, foregroundLayer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {ImageType} imageType 
         * @param {number} maxWidth 
         * @param {number} maxHeight 
         * @param {string} tag 
         * @param {string} format 
         * @param {number} percentPlayed 
         * @param {number} unplayedCount 
         * @param {number} imageIndex 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [quality] 
         * @param {boolean} [cropWhitespace] 
         * @param {boolean} [addPlayedIndicator] 
         * @param {number} [blur] 
         * @param {string} [backgroundColor] 
         * @param {string} [foregroundLayer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headItemImage2_2(itemId: string, imageType: ImageType, maxWidth: number, maxHeight: number, tag: string, format: string, percentPlayed: number, unplayedCount: number, imageIndex: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).headItemImage2_2(itemId, imageType, maxWidth, maxHeight, tag, format, percentPlayed, unplayedCount, imageIndex, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {ImageType} imageType 
         * @param {string} tag 
         * @param {string} format 
         * @param {number} maxWidth 
         * @param {number} maxHeight 
         * @param {number} percentPlayed 
         * @param {number} unplayedCount 
         * @param {number} imageIndex 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [quality] 
         * @param {boolean} [cropWhitespace] 
         * @param {boolean} [addPlayedIndicator] 
         * @param {number} [blur] 
         * @param {string} [backgroundColor] 
         * @param {string} [foregroundLayer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headMusicGenreImage(name: string, imageType: ImageType, tag: string, format: string, maxWidth: number, maxHeight: number, percentPlayed: number, unplayedCount: number, imageIndex: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).headMusicGenreImage(name, imageType, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, imageIndex, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {ImageType} imageType 
         * @param {string} tag 
         * @param {string} format 
         * @param {number} maxWidth 
         * @param {number} maxHeight 
         * @param {number} percentPlayed 
         * @param {number} unplayedCount 
         * @param {number} imageIndex 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [quality] 
         * @param {boolean} [cropWhitespace] 
         * @param {boolean} [addPlayedIndicator] 
         * @param {number} [blur] 
         * @param {string} [backgroundColor] 
         * @param {string} [foregroundLayer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headPersonImage(name: string, imageType: ImageType, tag: string, format: string, maxWidth: number, maxHeight: number, percentPlayed: number, unplayedCount: number, imageIndex: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).headPersonImage(name, imageType, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, imageIndex, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {ImageType} imageType 
         * @param {string} tag 
         * @param {string} format 
         * @param {number} maxWidth 
         * @param {number} maxHeight 
         * @param {number} percentPlayed 
         * @param {number} unplayedCount 
         * @param {number} imageIndex 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [quality] 
         * @param {boolean} [cropWhitespace] 
         * @param {boolean} [addPlayedIndicator] 
         * @param {number} [blur] 
         * @param {string} [backgroundColor] 
         * @param {string} [foregroundLayer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headStudioImage(name: string, imageType: ImageType, tag: string, format: string, maxWidth: number, maxHeight: number, percentPlayed: number, unplayedCount: number, imageIndex: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).headStudioImage(name, imageType, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, imageIndex, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {ImageType} imageType 
         * @param {number} imageIndex 
         * @param {string} [tag] 
         * @param {string} [format] 
         * @param {number} [maxWidth] 
         * @param {number} [maxHeight] 
         * @param {number} [percentPlayed] 
         * @param {number} [unplayedCount] 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [quality] 
         * @param {boolean} [cropWhitespace] 
         * @param {boolean} [addPlayedIndicator] 
         * @param {number} [blur] 
         * @param {string} [backgroundColor] 
         * @param {string} [foregroundLayer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headUserImage(userId: string, imageType: ImageType, imageIndex: number, tag?: string, format?: string, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).headUserImage(userId, imageType, imageIndex, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {ImageType} imageType 
         * @param {number} index 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUserImage(userId: string, imageType: ImageType, index: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).postUserImage(userId, imageType, index, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {ImageType} imageType 
         * @param {number} index 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUserImage2(userId: string, imageType: ImageType, index: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).postUserImage2(userId, imageType, index, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {ImageType} imageType 
         * @param {number} imageIndex 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setItemImage(itemId: string, imageType: ImageType, imageIndex: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).setItemImage(itemId, imageType, imageIndex, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {ImageType} imageType 
         * @param {number} imageIndex 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setItemImage2(itemId: string, imageType: ImageType, imageIndex: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).setItemImage2(itemId, imageType, imageIndex, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {ImageType} imageType 
         * @param {number} imageIndex 
         * @param {number} [newIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateItemImageIndex(itemId: string, imageType: ImageType, imageIndex: number, newIndex?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ImageApiAxiosParamCreator(configuration).updateItemImageIndex(itemId, imageType, imageIndex, newIndex, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ImageApi - factory interface
 * @export
 */
export const ImageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} itemId 
         * @param {ImageType} imageType 
         * @param {number} imageIndex 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemImage(itemId: string, imageType: ImageType, imageIndex: number, options?: any): AxiosPromise<void> {
            return ImageApiFp(configuration).deleteItemImage(itemId, imageType, imageIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} itemId 
         * @param {ImageType} imageType 
         * @param {number} imageIndex 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemImage2(itemId: string, imageType: ImageType, imageIndex: number, options?: any): AxiosPromise<void> {
            return ImageApiFp(configuration).deleteItemImage2(itemId, imageType, imageIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {ImageType} imageType 
         * @param {number} index 
         * @param {string} itemType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserImage(userId: string, imageType: ImageType, index: number, itemType: string, options?: any): AxiosPromise<void> {
            return ImageApiFp(configuration).deleteUserImage(userId, imageType, index, itemType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {ImageType} imageType 
         * @param {number} index 
         * @param {string} itemType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserImage2(userId: string, imageType: ImageType, index: number, itemType: string, options?: any): AxiosPromise<void> {
            return ImageApiFp(configuration).deleteUserImage2(userId, imageType, index, itemType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} name 
         * @param {ImageType} imageType 
         * @param {string} tag 
         * @param {string} format 
         * @param {number} maxWidth 
         * @param {number} maxHeight 
         * @param {number} percentPlayed 
         * @param {number} unplayedCount 
         * @param {number} imageIndex 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [quality] 
         * @param {boolean} [cropWhitespace] 
         * @param {boolean} [addPlayedIndicator] 
         * @param {number} [blur] 
         * @param {string} [backgroundColor] 
         * @param {string} [foregroundLayer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtistImage(name: string, imageType: ImageType, tag: string, format: string, maxWidth: number, maxHeight: number, percentPlayed: number, unplayedCount: number, imageIndex: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): AxiosPromise<void> {
            return ImageApiFp(configuration).getArtistImage(name, imageType, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, imageIndex, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} name 
         * @param {ImageType} imageType 
         * @param {string} tag 
         * @param {string} format 
         * @param {number} maxWidth 
         * @param {number} maxHeight 
         * @param {number} percentPlayed 
         * @param {number} unplayedCount 
         * @param {number} imageIndex 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [quality] 
         * @param {boolean} [cropWhitespace] 
         * @param {boolean} [addPlayedIndicator] 
         * @param {number} [blur] 
         * @param {string} [backgroundColor] 
         * @param {string} [foregroundLayer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGenreImage(name: string, imageType: ImageType, tag: string, format: string, maxWidth: number, maxHeight: number, percentPlayed: number, unplayedCount: number, imageIndex: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): AxiosPromise<void> {
            return ImageApiFp(configuration).getGenreImage(name, imageType, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, imageIndex, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} itemId 
         * @param {ImageType} imageType 
         * @param {number} maxWidth 
         * @param {number} maxHeight 
         * @param {number} imageIndex 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [quality] 
         * @param {string} [tag] 
         * @param {boolean} [cropWhitespace] 
         * @param {string} [format] 
         * @param {boolean} [addPlayedIndicator] 
         * @param {number} [percentPlayed] 
         * @param {number} [unplayedCount] 
         * @param {number} [blur] 
         * @param {string} [backgroundColor] 
         * @param {string} [foregroundLayer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemImage(itemId: string, imageType: ImageType, maxWidth: number, maxHeight: number, imageIndex: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): AxiosPromise<void> {
            return ImageApiFp(configuration).getItemImage(itemId, imageType, maxWidth, maxHeight, imageIndex, width, height, quality, tag, cropWhitespace, format, addPlayedIndicator, percentPlayed, unplayedCount, blur, backgroundColor, foregroundLayer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} itemId 
         * @param {ImageType} imageType 
         * @param {number} maxWidth 
         * @param {number} maxHeight 
         * @param {number} imageIndex 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [quality] 
         * @param {string} [tag] 
         * @param {boolean} [cropWhitespace] 
         * @param {string} [format] 
         * @param {boolean} [addPlayedIndicator] 
         * @param {number} [percentPlayed] 
         * @param {number} [unplayedCount] 
         * @param {number} [blur] 
         * @param {string} [backgroundColor] 
         * @param {string} [foregroundLayer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemImage2(itemId: string, imageType: ImageType, maxWidth: number, maxHeight: number, imageIndex: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): AxiosPromise<void> {
            return ImageApiFp(configuration).getItemImage2(itemId, imageType, maxWidth, maxHeight, imageIndex, width, height, quality, tag, cropWhitespace, format, addPlayedIndicator, percentPlayed, unplayedCount, blur, backgroundColor, foregroundLayer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} itemId 
         * @param {ImageType} imageType 
         * @param {number} maxWidth 
         * @param {number} maxHeight 
         * @param {string} tag 
         * @param {string} format 
         * @param {number} percentPlayed 
         * @param {number} unplayedCount 
         * @param {number} imageIndex 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [quality] 
         * @param {boolean} [cropWhitespace] 
         * @param {boolean} [addPlayedIndicator] 
         * @param {number} [blur] 
         * @param {string} [backgroundColor] 
         * @param {string} [foregroundLayer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemImage2_1(itemId: string, imageType: ImageType, maxWidth: number, maxHeight: number, tag: string, format: string, percentPlayed: number, unplayedCount: number, imageIndex: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): AxiosPromise<void> {
            return ImageApiFp(configuration).getItemImage2_1(itemId, imageType, maxWidth, maxHeight, tag, format, percentPlayed, unplayedCount, imageIndex, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemImageInfos(itemId: string, options?: any): AxiosPromise<Array<ImageInfo>> {
            return ImageApiFp(configuration).getItemImageInfos(itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} name 
         * @param {ImageType} imageType 
         * @param {string} tag 
         * @param {string} format 
         * @param {number} maxWidth 
         * @param {number} maxHeight 
         * @param {number} percentPlayed 
         * @param {number} unplayedCount 
         * @param {number} imageIndex 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [quality] 
         * @param {boolean} [cropWhitespace] 
         * @param {boolean} [addPlayedIndicator] 
         * @param {number} [blur] 
         * @param {string} [backgroundColor] 
         * @param {string} [foregroundLayer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMusicGenreImage(name: string, imageType: ImageType, tag: string, format: string, maxWidth: number, maxHeight: number, percentPlayed: number, unplayedCount: number, imageIndex: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): AxiosPromise<void> {
            return ImageApiFp(configuration).getMusicGenreImage(name, imageType, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, imageIndex, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} name 
         * @param {ImageType} imageType 
         * @param {string} tag 
         * @param {string} format 
         * @param {number} maxWidth 
         * @param {number} maxHeight 
         * @param {number} percentPlayed 
         * @param {number} unplayedCount 
         * @param {number} imageIndex 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [quality] 
         * @param {boolean} [cropWhitespace] 
         * @param {boolean} [addPlayedIndicator] 
         * @param {number} [blur] 
         * @param {string} [backgroundColor] 
         * @param {string} [foregroundLayer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonImage(name: string, imageType: ImageType, tag: string, format: string, maxWidth: number, maxHeight: number, percentPlayed: number, unplayedCount: number, imageIndex: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): AxiosPromise<void> {
            return ImageApiFp(configuration).getPersonImage(name, imageType, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, imageIndex, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} name 
         * @param {ImageType} imageType 
         * @param {string} tag 
         * @param {string} format 
         * @param {number} maxWidth 
         * @param {number} maxHeight 
         * @param {number} percentPlayed 
         * @param {number} unplayedCount 
         * @param {number} imageIndex 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [quality] 
         * @param {boolean} [cropWhitespace] 
         * @param {boolean} [addPlayedIndicator] 
         * @param {number} [blur] 
         * @param {string} [backgroundColor] 
         * @param {string} [foregroundLayer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudioImage(name: string, imageType: ImageType, tag: string, format: string, maxWidth: number, maxHeight: number, percentPlayed: number, unplayedCount: number, imageIndex: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): AxiosPromise<void> {
            return ImageApiFp(configuration).getStudioImage(name, imageType, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, imageIndex, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {ImageType} imageType 
         * @param {number} imageIndex 
         * @param {string} [tag] 
         * @param {string} [format] 
         * @param {number} [maxWidth] 
         * @param {number} [maxHeight] 
         * @param {number} [percentPlayed] 
         * @param {number} [unplayedCount] 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [quality] 
         * @param {boolean} [cropWhitespace] 
         * @param {boolean} [addPlayedIndicator] 
         * @param {number} [blur] 
         * @param {string} [backgroundColor] 
         * @param {string} [foregroundLayer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserImage(userId: string, imageType: ImageType, imageIndex: number, tag?: string, format?: string, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): AxiosPromise<void> {
            return ImageApiFp(configuration).getUserImage(userId, imageType, imageIndex, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} name 
         * @param {ImageType} imageType 
         * @param {string} tag 
         * @param {string} format 
         * @param {number} maxWidth 
         * @param {number} maxHeight 
         * @param {number} percentPlayed 
         * @param {number} unplayedCount 
         * @param {number} imageIndex 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [quality] 
         * @param {boolean} [cropWhitespace] 
         * @param {boolean} [addPlayedIndicator] 
         * @param {number} [blur] 
         * @param {string} [backgroundColor] 
         * @param {string} [foregroundLayer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headArtistImage(name: string, imageType: ImageType, tag: string, format: string, maxWidth: number, maxHeight: number, percentPlayed: number, unplayedCount: number, imageIndex: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): AxiosPromise<void> {
            return ImageApiFp(configuration).headArtistImage(name, imageType, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, imageIndex, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} name 
         * @param {ImageType} imageType 
         * @param {string} tag 
         * @param {string} format 
         * @param {number} maxWidth 
         * @param {number} maxHeight 
         * @param {number} percentPlayed 
         * @param {number} unplayedCount 
         * @param {number} imageIndex 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [quality] 
         * @param {boolean} [cropWhitespace] 
         * @param {boolean} [addPlayedIndicator] 
         * @param {number} [blur] 
         * @param {string} [backgroundColor] 
         * @param {string} [foregroundLayer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headGenreImage(name: string, imageType: ImageType, tag: string, format: string, maxWidth: number, maxHeight: number, percentPlayed: number, unplayedCount: number, imageIndex: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): AxiosPromise<void> {
            return ImageApiFp(configuration).headGenreImage(name, imageType, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, imageIndex, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} itemId 
         * @param {ImageType} imageType 
         * @param {number} maxWidth 
         * @param {number} maxHeight 
         * @param {number} imageIndex 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [quality] 
         * @param {string} [tag] 
         * @param {boolean} [cropWhitespace] 
         * @param {string} [format] 
         * @param {boolean} [addPlayedIndicator] 
         * @param {number} [percentPlayed] 
         * @param {number} [unplayedCount] 
         * @param {number} [blur] 
         * @param {string} [backgroundColor] 
         * @param {string} [foregroundLayer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headItemImage(itemId: string, imageType: ImageType, maxWidth: number, maxHeight: number, imageIndex: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): AxiosPromise<void> {
            return ImageApiFp(configuration).headItemImage(itemId, imageType, maxWidth, maxHeight, imageIndex, width, height, quality, tag, cropWhitespace, format, addPlayedIndicator, percentPlayed, unplayedCount, blur, backgroundColor, foregroundLayer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} itemId 
         * @param {ImageType} imageType 
         * @param {number} maxWidth 
         * @param {number} maxHeight 
         * @param {number} imageIndex 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [quality] 
         * @param {string} [tag] 
         * @param {boolean} [cropWhitespace] 
         * @param {string} [format] 
         * @param {boolean} [addPlayedIndicator] 
         * @param {number} [percentPlayed] 
         * @param {number} [unplayedCount] 
         * @param {number} [blur] 
         * @param {string} [backgroundColor] 
         * @param {string} [foregroundLayer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headItemImage2(itemId: string, imageType: ImageType, maxWidth: number, maxHeight: number, imageIndex: number, width?: number, height?: number, quality?: number, tag?: string, cropWhitespace?: boolean, format?: string, addPlayedIndicator?: boolean, percentPlayed?: number, unplayedCount?: number, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): AxiosPromise<void> {
            return ImageApiFp(configuration).headItemImage2(itemId, imageType, maxWidth, maxHeight, imageIndex, width, height, quality, tag, cropWhitespace, format, addPlayedIndicator, percentPlayed, unplayedCount, blur, backgroundColor, foregroundLayer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} itemId 
         * @param {ImageType} imageType 
         * @param {number} maxWidth 
         * @param {number} maxHeight 
         * @param {string} tag 
         * @param {string} format 
         * @param {number} percentPlayed 
         * @param {number} unplayedCount 
         * @param {number} imageIndex 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [quality] 
         * @param {boolean} [cropWhitespace] 
         * @param {boolean} [addPlayedIndicator] 
         * @param {number} [blur] 
         * @param {string} [backgroundColor] 
         * @param {string} [foregroundLayer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headItemImage2_2(itemId: string, imageType: ImageType, maxWidth: number, maxHeight: number, tag: string, format: string, percentPlayed: number, unplayedCount: number, imageIndex: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): AxiosPromise<void> {
            return ImageApiFp(configuration).headItemImage2_2(itemId, imageType, maxWidth, maxHeight, tag, format, percentPlayed, unplayedCount, imageIndex, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} name 
         * @param {ImageType} imageType 
         * @param {string} tag 
         * @param {string} format 
         * @param {number} maxWidth 
         * @param {number} maxHeight 
         * @param {number} percentPlayed 
         * @param {number} unplayedCount 
         * @param {number} imageIndex 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [quality] 
         * @param {boolean} [cropWhitespace] 
         * @param {boolean} [addPlayedIndicator] 
         * @param {number} [blur] 
         * @param {string} [backgroundColor] 
         * @param {string} [foregroundLayer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headMusicGenreImage(name: string, imageType: ImageType, tag: string, format: string, maxWidth: number, maxHeight: number, percentPlayed: number, unplayedCount: number, imageIndex: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): AxiosPromise<void> {
            return ImageApiFp(configuration).headMusicGenreImage(name, imageType, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, imageIndex, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} name 
         * @param {ImageType} imageType 
         * @param {string} tag 
         * @param {string} format 
         * @param {number} maxWidth 
         * @param {number} maxHeight 
         * @param {number} percentPlayed 
         * @param {number} unplayedCount 
         * @param {number} imageIndex 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [quality] 
         * @param {boolean} [cropWhitespace] 
         * @param {boolean} [addPlayedIndicator] 
         * @param {number} [blur] 
         * @param {string} [backgroundColor] 
         * @param {string} [foregroundLayer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headPersonImage(name: string, imageType: ImageType, tag: string, format: string, maxWidth: number, maxHeight: number, percentPlayed: number, unplayedCount: number, imageIndex: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): AxiosPromise<void> {
            return ImageApiFp(configuration).headPersonImage(name, imageType, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, imageIndex, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} name 
         * @param {ImageType} imageType 
         * @param {string} tag 
         * @param {string} format 
         * @param {number} maxWidth 
         * @param {number} maxHeight 
         * @param {number} percentPlayed 
         * @param {number} unplayedCount 
         * @param {number} imageIndex 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [quality] 
         * @param {boolean} [cropWhitespace] 
         * @param {boolean} [addPlayedIndicator] 
         * @param {number} [blur] 
         * @param {string} [backgroundColor] 
         * @param {string} [foregroundLayer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headStudioImage(name: string, imageType: ImageType, tag: string, format: string, maxWidth: number, maxHeight: number, percentPlayed: number, unplayedCount: number, imageIndex: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): AxiosPromise<void> {
            return ImageApiFp(configuration).headStudioImage(name, imageType, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, imageIndex, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {ImageType} imageType 
         * @param {number} imageIndex 
         * @param {string} [tag] 
         * @param {string} [format] 
         * @param {number} [maxWidth] 
         * @param {number} [maxHeight] 
         * @param {number} [percentPlayed] 
         * @param {number} [unplayedCount] 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [quality] 
         * @param {boolean} [cropWhitespace] 
         * @param {boolean} [addPlayedIndicator] 
         * @param {number} [blur] 
         * @param {string} [backgroundColor] 
         * @param {string} [foregroundLayer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headUserImage(userId: string, imageType: ImageType, imageIndex: number, tag?: string, format?: string, maxWidth?: number, maxHeight?: number, percentPlayed?: number, unplayedCount?: number, width?: number, height?: number, quality?: number, cropWhitespace?: boolean, addPlayedIndicator?: boolean, blur?: number, backgroundColor?: string, foregroundLayer?: string, options?: any): AxiosPromise<void> {
            return ImageApiFp(configuration).headUserImage(userId, imageType, imageIndex, tag, format, maxWidth, maxHeight, percentPlayed, unplayedCount, width, height, quality, cropWhitespace, addPlayedIndicator, blur, backgroundColor, foregroundLayer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {ImageType} imageType 
         * @param {number} index 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserImage(userId: string, imageType: ImageType, index: number, options?: any): AxiosPromise<void> {
            return ImageApiFp(configuration).postUserImage(userId, imageType, index, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {ImageType} imageType 
         * @param {number} index 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserImage2(userId: string, imageType: ImageType, index: number, options?: any): AxiosPromise<void> {
            return ImageApiFp(configuration).postUserImage2(userId, imageType, index, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} itemId 
         * @param {ImageType} imageType 
         * @param {number} imageIndex 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setItemImage(itemId: string, imageType: ImageType, imageIndex: number, options?: any): AxiosPromise<void> {
            return ImageApiFp(configuration).setItemImage(itemId, imageType, imageIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} itemId 
         * @param {ImageType} imageType 
         * @param {number} imageIndex 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setItemImage2(itemId: string, imageType: ImageType, imageIndex: number, options?: any): AxiosPromise<void> {
            return ImageApiFp(configuration).setItemImage2(itemId, imageType, imageIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} itemId 
         * @param {ImageType} imageType 
         * @param {number} imageIndex 
         * @param {number} [newIndex] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItemImageIndex(itemId: string, imageType: ImageType, imageIndex: number, newIndex?: number, options?: any): AxiosPromise<void> {
            return ImageApiFp(configuration).updateItemImageIndex(itemId, imageType, imageIndex, newIndex, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deleteItemImage operation in ImageApi.
 * @export
 * @interface ImageApiDeleteItemImageRequest
 */
export interface ImageApiDeleteItemImageRequest {
    /**
     * 
     * @type {string}
     * @memberof ImageApiDeleteItemImage
     */
    readonly itemId: string

    /**
     * 
     * @type {ImageType}
     * @memberof ImageApiDeleteItemImage
     */
    readonly imageType: ImageType

    /**
     * 
     * @type {number}
     * @memberof ImageApiDeleteItemImage
     */
    readonly imageIndex: number
}

/**
 * Request parameters for deleteItemImage2 operation in ImageApi.
 * @export
 * @interface ImageApiDeleteItemImage2Request
 */
export interface ImageApiDeleteItemImage2Request {
    /**
     * 
     * @type {string}
     * @memberof ImageApiDeleteItemImage2
     */
    readonly itemId: string

    /**
     * 
     * @type {ImageType}
     * @memberof ImageApiDeleteItemImage2
     */
    readonly imageType: ImageType

    /**
     * 
     * @type {number}
     * @memberof ImageApiDeleteItemImage2
     */
    readonly imageIndex: number
}

/**
 * Request parameters for deleteUserImage operation in ImageApi.
 * @export
 * @interface ImageApiDeleteUserImageRequest
 */
export interface ImageApiDeleteUserImageRequest {
    /**
     * 
     * @type {string}
     * @memberof ImageApiDeleteUserImage
     */
    readonly userId: string

    /**
     * 
     * @type {ImageType}
     * @memberof ImageApiDeleteUserImage
     */
    readonly imageType: ImageType

    /**
     * 
     * @type {number}
     * @memberof ImageApiDeleteUserImage
     */
    readonly index: number

    /**
     * 
     * @type {string}
     * @memberof ImageApiDeleteUserImage
     */
    readonly itemType: string
}

/**
 * Request parameters for deleteUserImage2 operation in ImageApi.
 * @export
 * @interface ImageApiDeleteUserImage2Request
 */
export interface ImageApiDeleteUserImage2Request {
    /**
     * 
     * @type {string}
     * @memberof ImageApiDeleteUserImage2
     */
    readonly userId: string

    /**
     * 
     * @type {ImageType}
     * @memberof ImageApiDeleteUserImage2
     */
    readonly imageType: ImageType

    /**
     * 
     * @type {number}
     * @memberof ImageApiDeleteUserImage2
     */
    readonly index: number

    /**
     * 
     * @type {string}
     * @memberof ImageApiDeleteUserImage2
     */
    readonly itemType: string
}

/**
 * Request parameters for getArtistImage operation in ImageApi.
 * @export
 * @interface ImageApiGetArtistImageRequest
 */
export interface ImageApiGetArtistImageRequest {
    /**
     * 
     * @type {string}
     * @memberof ImageApiGetArtistImage
     */
    readonly name: string

    /**
     * 
     * @type {ImageType}
     * @memberof ImageApiGetArtistImage
     */
    readonly imageType: ImageType

    /**
     * 
     * @type {string}
     * @memberof ImageApiGetArtistImage
     */
    readonly tag: string

    /**
     * 
     * @type {string}
     * @memberof ImageApiGetArtistImage
     */
    readonly format: string

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetArtistImage
     */
    readonly maxWidth: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetArtistImage
     */
    readonly maxHeight: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetArtistImage
     */
    readonly percentPlayed: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetArtistImage
     */
    readonly unplayedCount: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetArtistImage
     */
    readonly imageIndex: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetArtistImage
     */
    readonly width?: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetArtistImage
     */
    readonly height?: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetArtistImage
     */
    readonly quality?: number

    /**
     * 
     * @type {boolean}
     * @memberof ImageApiGetArtistImage
     */
    readonly cropWhitespace?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ImageApiGetArtistImage
     */
    readonly addPlayedIndicator?: boolean

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetArtistImage
     */
    readonly blur?: number

    /**
     * 
     * @type {string}
     * @memberof ImageApiGetArtistImage
     */
    readonly backgroundColor?: string

    /**
     * 
     * @type {string}
     * @memberof ImageApiGetArtistImage
     */
    readonly foregroundLayer?: string
}

/**
 * Request parameters for getGenreImage operation in ImageApi.
 * @export
 * @interface ImageApiGetGenreImageRequest
 */
export interface ImageApiGetGenreImageRequest {
    /**
     * 
     * @type {string}
     * @memberof ImageApiGetGenreImage
     */
    readonly name: string

    /**
     * 
     * @type {ImageType}
     * @memberof ImageApiGetGenreImage
     */
    readonly imageType: ImageType

    /**
     * 
     * @type {string}
     * @memberof ImageApiGetGenreImage
     */
    readonly tag: string

    /**
     * 
     * @type {string}
     * @memberof ImageApiGetGenreImage
     */
    readonly format: string

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetGenreImage
     */
    readonly maxWidth: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetGenreImage
     */
    readonly maxHeight: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetGenreImage
     */
    readonly percentPlayed: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetGenreImage
     */
    readonly unplayedCount: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetGenreImage
     */
    readonly imageIndex: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetGenreImage
     */
    readonly width?: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetGenreImage
     */
    readonly height?: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetGenreImage
     */
    readonly quality?: number

    /**
     * 
     * @type {boolean}
     * @memberof ImageApiGetGenreImage
     */
    readonly cropWhitespace?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ImageApiGetGenreImage
     */
    readonly addPlayedIndicator?: boolean

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetGenreImage
     */
    readonly blur?: number

    /**
     * 
     * @type {string}
     * @memberof ImageApiGetGenreImage
     */
    readonly backgroundColor?: string

    /**
     * 
     * @type {string}
     * @memberof ImageApiGetGenreImage
     */
    readonly foregroundLayer?: string
}

/**
 * Request parameters for getItemImage operation in ImageApi.
 * @export
 * @interface ImageApiGetItemImageRequest
 */
export interface ImageApiGetItemImageRequest {
    /**
     * 
     * @type {string}
     * @memberof ImageApiGetItemImage
     */
    readonly itemId: string

    /**
     * 
     * @type {ImageType}
     * @memberof ImageApiGetItemImage
     */
    readonly imageType: ImageType

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetItemImage
     */
    readonly maxWidth: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetItemImage
     */
    readonly maxHeight: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetItemImage
     */
    readonly imageIndex: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetItemImage
     */
    readonly width?: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetItemImage
     */
    readonly height?: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetItemImage
     */
    readonly quality?: number

    /**
     * 
     * @type {string}
     * @memberof ImageApiGetItemImage
     */
    readonly tag?: string

    /**
     * 
     * @type {boolean}
     * @memberof ImageApiGetItemImage
     */
    readonly cropWhitespace?: boolean

    /**
     * 
     * @type {string}
     * @memberof ImageApiGetItemImage
     */
    readonly format?: string

    /**
     * 
     * @type {boolean}
     * @memberof ImageApiGetItemImage
     */
    readonly addPlayedIndicator?: boolean

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetItemImage
     */
    readonly percentPlayed?: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetItemImage
     */
    readonly unplayedCount?: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetItemImage
     */
    readonly blur?: number

    /**
     * 
     * @type {string}
     * @memberof ImageApiGetItemImage
     */
    readonly backgroundColor?: string

    /**
     * 
     * @type {string}
     * @memberof ImageApiGetItemImage
     */
    readonly foregroundLayer?: string
}

/**
 * Request parameters for getItemImage2 operation in ImageApi.
 * @export
 * @interface ImageApiGetItemImage2Request
 */
export interface ImageApiGetItemImage2Request {
    /**
     * 
     * @type {string}
     * @memberof ImageApiGetItemImage2
     */
    readonly itemId: string

    /**
     * 
     * @type {ImageType}
     * @memberof ImageApiGetItemImage2
     */
    readonly imageType: ImageType

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetItemImage2
     */
    readonly maxWidth: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetItemImage2
     */
    readonly maxHeight: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetItemImage2
     */
    readonly imageIndex: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetItemImage2
     */
    readonly width?: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetItemImage2
     */
    readonly height?: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetItemImage2
     */
    readonly quality?: number

    /**
     * 
     * @type {string}
     * @memberof ImageApiGetItemImage2
     */
    readonly tag?: string

    /**
     * 
     * @type {boolean}
     * @memberof ImageApiGetItemImage2
     */
    readonly cropWhitespace?: boolean

    /**
     * 
     * @type {string}
     * @memberof ImageApiGetItemImage2
     */
    readonly format?: string

    /**
     * 
     * @type {boolean}
     * @memberof ImageApiGetItemImage2
     */
    readonly addPlayedIndicator?: boolean

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetItemImage2
     */
    readonly percentPlayed?: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetItemImage2
     */
    readonly unplayedCount?: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetItemImage2
     */
    readonly blur?: number

    /**
     * 
     * @type {string}
     * @memberof ImageApiGetItemImage2
     */
    readonly backgroundColor?: string

    /**
     * 
     * @type {string}
     * @memberof ImageApiGetItemImage2
     */
    readonly foregroundLayer?: string
}

/**
 * Request parameters for getItemImage2_1 operation in ImageApi.
 * @export
 * @interface ImageApiGetItemImage20Request
 */
export interface ImageApiGetItemImage20Request {
    /**
     * 
     * @type {string}
     * @memberof ImageApiGetItemImage20
     */
    readonly itemId: string

    /**
     * 
     * @type {ImageType}
     * @memberof ImageApiGetItemImage20
     */
    readonly imageType: ImageType

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetItemImage20
     */
    readonly maxWidth: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetItemImage20
     */
    readonly maxHeight: number

    /**
     * 
     * @type {string}
     * @memberof ImageApiGetItemImage20
     */
    readonly tag: string

    /**
     * 
     * @type {string}
     * @memberof ImageApiGetItemImage20
     */
    readonly format: string

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetItemImage20
     */
    readonly percentPlayed: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetItemImage20
     */
    readonly unplayedCount: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetItemImage20
     */
    readonly imageIndex: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetItemImage20
     */
    readonly width?: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetItemImage20
     */
    readonly height?: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetItemImage20
     */
    readonly quality?: number

    /**
     * 
     * @type {boolean}
     * @memberof ImageApiGetItemImage20
     */
    readonly cropWhitespace?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ImageApiGetItemImage20
     */
    readonly addPlayedIndicator?: boolean

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetItemImage20
     */
    readonly blur?: number

    /**
     * 
     * @type {string}
     * @memberof ImageApiGetItemImage20
     */
    readonly backgroundColor?: string

    /**
     * 
     * @type {string}
     * @memberof ImageApiGetItemImage20
     */
    readonly foregroundLayer?: string
}

/**
 * Request parameters for getItemImageInfos operation in ImageApi.
 * @export
 * @interface ImageApiGetItemImageInfosRequest
 */
export interface ImageApiGetItemImageInfosRequest {
    /**
     * 
     * @type {string}
     * @memberof ImageApiGetItemImageInfos
     */
    readonly itemId: string
}

/**
 * Request parameters for getMusicGenreImage operation in ImageApi.
 * @export
 * @interface ImageApiGetMusicGenreImageRequest
 */
export interface ImageApiGetMusicGenreImageRequest {
    /**
     * 
     * @type {string}
     * @memberof ImageApiGetMusicGenreImage
     */
    readonly name: string

    /**
     * 
     * @type {ImageType}
     * @memberof ImageApiGetMusicGenreImage
     */
    readonly imageType: ImageType

    /**
     * 
     * @type {string}
     * @memberof ImageApiGetMusicGenreImage
     */
    readonly tag: string

    /**
     * 
     * @type {string}
     * @memberof ImageApiGetMusicGenreImage
     */
    readonly format: string

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetMusicGenreImage
     */
    readonly maxWidth: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetMusicGenreImage
     */
    readonly maxHeight: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetMusicGenreImage
     */
    readonly percentPlayed: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetMusicGenreImage
     */
    readonly unplayedCount: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetMusicGenreImage
     */
    readonly imageIndex: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetMusicGenreImage
     */
    readonly width?: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetMusicGenreImage
     */
    readonly height?: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetMusicGenreImage
     */
    readonly quality?: number

    /**
     * 
     * @type {boolean}
     * @memberof ImageApiGetMusicGenreImage
     */
    readonly cropWhitespace?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ImageApiGetMusicGenreImage
     */
    readonly addPlayedIndicator?: boolean

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetMusicGenreImage
     */
    readonly blur?: number

    /**
     * 
     * @type {string}
     * @memberof ImageApiGetMusicGenreImage
     */
    readonly backgroundColor?: string

    /**
     * 
     * @type {string}
     * @memberof ImageApiGetMusicGenreImage
     */
    readonly foregroundLayer?: string
}

/**
 * Request parameters for getPersonImage operation in ImageApi.
 * @export
 * @interface ImageApiGetPersonImageRequest
 */
export interface ImageApiGetPersonImageRequest {
    /**
     * 
     * @type {string}
     * @memberof ImageApiGetPersonImage
     */
    readonly name: string

    /**
     * 
     * @type {ImageType}
     * @memberof ImageApiGetPersonImage
     */
    readonly imageType: ImageType

    /**
     * 
     * @type {string}
     * @memberof ImageApiGetPersonImage
     */
    readonly tag: string

    /**
     * 
     * @type {string}
     * @memberof ImageApiGetPersonImage
     */
    readonly format: string

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetPersonImage
     */
    readonly maxWidth: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetPersonImage
     */
    readonly maxHeight: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetPersonImage
     */
    readonly percentPlayed: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetPersonImage
     */
    readonly unplayedCount: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetPersonImage
     */
    readonly imageIndex: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetPersonImage
     */
    readonly width?: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetPersonImage
     */
    readonly height?: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetPersonImage
     */
    readonly quality?: number

    /**
     * 
     * @type {boolean}
     * @memberof ImageApiGetPersonImage
     */
    readonly cropWhitespace?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ImageApiGetPersonImage
     */
    readonly addPlayedIndicator?: boolean

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetPersonImage
     */
    readonly blur?: number

    /**
     * 
     * @type {string}
     * @memberof ImageApiGetPersonImage
     */
    readonly backgroundColor?: string

    /**
     * 
     * @type {string}
     * @memberof ImageApiGetPersonImage
     */
    readonly foregroundLayer?: string
}

/**
 * Request parameters for getStudioImage operation in ImageApi.
 * @export
 * @interface ImageApiGetStudioImageRequest
 */
export interface ImageApiGetStudioImageRequest {
    /**
     * 
     * @type {string}
     * @memberof ImageApiGetStudioImage
     */
    readonly name: string

    /**
     * 
     * @type {ImageType}
     * @memberof ImageApiGetStudioImage
     */
    readonly imageType: ImageType

    /**
     * 
     * @type {string}
     * @memberof ImageApiGetStudioImage
     */
    readonly tag: string

    /**
     * 
     * @type {string}
     * @memberof ImageApiGetStudioImage
     */
    readonly format: string

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetStudioImage
     */
    readonly maxWidth: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetStudioImage
     */
    readonly maxHeight: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetStudioImage
     */
    readonly percentPlayed: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetStudioImage
     */
    readonly unplayedCount: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetStudioImage
     */
    readonly imageIndex: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetStudioImage
     */
    readonly width?: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetStudioImage
     */
    readonly height?: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetStudioImage
     */
    readonly quality?: number

    /**
     * 
     * @type {boolean}
     * @memberof ImageApiGetStudioImage
     */
    readonly cropWhitespace?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ImageApiGetStudioImage
     */
    readonly addPlayedIndicator?: boolean

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetStudioImage
     */
    readonly blur?: number

    /**
     * 
     * @type {string}
     * @memberof ImageApiGetStudioImage
     */
    readonly backgroundColor?: string

    /**
     * 
     * @type {string}
     * @memberof ImageApiGetStudioImage
     */
    readonly foregroundLayer?: string
}

/**
 * Request parameters for getUserImage operation in ImageApi.
 * @export
 * @interface ImageApiGetUserImageRequest
 */
export interface ImageApiGetUserImageRequest {
    /**
     * 
     * @type {string}
     * @memberof ImageApiGetUserImage
     */
    readonly userId: string

    /**
     * 
     * @type {ImageType}
     * @memberof ImageApiGetUserImage
     */
    readonly imageType: ImageType

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetUserImage
     */
    readonly imageIndex: number

    /**
     * 
     * @type {string}
     * @memberof ImageApiGetUserImage
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof ImageApiGetUserImage
     */
    readonly format?: string

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetUserImage
     */
    readonly maxWidth?: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetUserImage
     */
    readonly maxHeight?: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetUserImage
     */
    readonly percentPlayed?: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetUserImage
     */
    readonly unplayedCount?: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetUserImage
     */
    readonly width?: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetUserImage
     */
    readonly height?: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetUserImage
     */
    readonly quality?: number

    /**
     * 
     * @type {boolean}
     * @memberof ImageApiGetUserImage
     */
    readonly cropWhitespace?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ImageApiGetUserImage
     */
    readonly addPlayedIndicator?: boolean

    /**
     * 
     * @type {number}
     * @memberof ImageApiGetUserImage
     */
    readonly blur?: number

    /**
     * 
     * @type {string}
     * @memberof ImageApiGetUserImage
     */
    readonly backgroundColor?: string

    /**
     * 
     * @type {string}
     * @memberof ImageApiGetUserImage
     */
    readonly foregroundLayer?: string
}

/**
 * Request parameters for headArtistImage operation in ImageApi.
 * @export
 * @interface ImageApiHeadArtistImageRequest
 */
export interface ImageApiHeadArtistImageRequest {
    /**
     * 
     * @type {string}
     * @memberof ImageApiHeadArtistImage
     */
    readonly name: string

    /**
     * 
     * @type {ImageType}
     * @memberof ImageApiHeadArtistImage
     */
    readonly imageType: ImageType

    /**
     * 
     * @type {string}
     * @memberof ImageApiHeadArtistImage
     */
    readonly tag: string

    /**
     * 
     * @type {string}
     * @memberof ImageApiHeadArtistImage
     */
    readonly format: string

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadArtistImage
     */
    readonly maxWidth: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadArtistImage
     */
    readonly maxHeight: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadArtistImage
     */
    readonly percentPlayed: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadArtistImage
     */
    readonly unplayedCount: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadArtistImage
     */
    readonly imageIndex: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadArtistImage
     */
    readonly width?: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadArtistImage
     */
    readonly height?: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadArtistImage
     */
    readonly quality?: number

    /**
     * 
     * @type {boolean}
     * @memberof ImageApiHeadArtistImage
     */
    readonly cropWhitespace?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ImageApiHeadArtistImage
     */
    readonly addPlayedIndicator?: boolean

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadArtistImage
     */
    readonly blur?: number

    /**
     * 
     * @type {string}
     * @memberof ImageApiHeadArtistImage
     */
    readonly backgroundColor?: string

    /**
     * 
     * @type {string}
     * @memberof ImageApiHeadArtistImage
     */
    readonly foregroundLayer?: string
}

/**
 * Request parameters for headGenreImage operation in ImageApi.
 * @export
 * @interface ImageApiHeadGenreImageRequest
 */
export interface ImageApiHeadGenreImageRequest {
    /**
     * 
     * @type {string}
     * @memberof ImageApiHeadGenreImage
     */
    readonly name: string

    /**
     * 
     * @type {ImageType}
     * @memberof ImageApiHeadGenreImage
     */
    readonly imageType: ImageType

    /**
     * 
     * @type {string}
     * @memberof ImageApiHeadGenreImage
     */
    readonly tag: string

    /**
     * 
     * @type {string}
     * @memberof ImageApiHeadGenreImage
     */
    readonly format: string

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadGenreImage
     */
    readonly maxWidth: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadGenreImage
     */
    readonly maxHeight: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadGenreImage
     */
    readonly percentPlayed: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadGenreImage
     */
    readonly unplayedCount: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadGenreImage
     */
    readonly imageIndex: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadGenreImage
     */
    readonly width?: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadGenreImage
     */
    readonly height?: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadGenreImage
     */
    readonly quality?: number

    /**
     * 
     * @type {boolean}
     * @memberof ImageApiHeadGenreImage
     */
    readonly cropWhitespace?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ImageApiHeadGenreImage
     */
    readonly addPlayedIndicator?: boolean

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadGenreImage
     */
    readonly blur?: number

    /**
     * 
     * @type {string}
     * @memberof ImageApiHeadGenreImage
     */
    readonly backgroundColor?: string

    /**
     * 
     * @type {string}
     * @memberof ImageApiHeadGenreImage
     */
    readonly foregroundLayer?: string
}

/**
 * Request parameters for headItemImage operation in ImageApi.
 * @export
 * @interface ImageApiHeadItemImageRequest
 */
export interface ImageApiHeadItemImageRequest {
    /**
     * 
     * @type {string}
     * @memberof ImageApiHeadItemImage
     */
    readonly itemId: string

    /**
     * 
     * @type {ImageType}
     * @memberof ImageApiHeadItemImage
     */
    readonly imageType: ImageType

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadItemImage
     */
    readonly maxWidth: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadItemImage
     */
    readonly maxHeight: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadItemImage
     */
    readonly imageIndex: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadItemImage
     */
    readonly width?: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadItemImage
     */
    readonly height?: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadItemImage
     */
    readonly quality?: number

    /**
     * 
     * @type {string}
     * @memberof ImageApiHeadItemImage
     */
    readonly tag?: string

    /**
     * 
     * @type {boolean}
     * @memberof ImageApiHeadItemImage
     */
    readonly cropWhitespace?: boolean

    /**
     * 
     * @type {string}
     * @memberof ImageApiHeadItemImage
     */
    readonly format?: string

    /**
     * 
     * @type {boolean}
     * @memberof ImageApiHeadItemImage
     */
    readonly addPlayedIndicator?: boolean

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadItemImage
     */
    readonly percentPlayed?: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadItemImage
     */
    readonly unplayedCount?: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadItemImage
     */
    readonly blur?: number

    /**
     * 
     * @type {string}
     * @memberof ImageApiHeadItemImage
     */
    readonly backgroundColor?: string

    /**
     * 
     * @type {string}
     * @memberof ImageApiHeadItemImage
     */
    readonly foregroundLayer?: string
}

/**
 * Request parameters for headItemImage2 operation in ImageApi.
 * @export
 * @interface ImageApiHeadItemImage2Request
 */
export interface ImageApiHeadItemImage2Request {
    /**
     * 
     * @type {string}
     * @memberof ImageApiHeadItemImage2
     */
    readonly itemId: string

    /**
     * 
     * @type {ImageType}
     * @memberof ImageApiHeadItemImage2
     */
    readonly imageType: ImageType

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadItemImage2
     */
    readonly maxWidth: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadItemImage2
     */
    readonly maxHeight: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadItemImage2
     */
    readonly imageIndex: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadItemImage2
     */
    readonly width?: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadItemImage2
     */
    readonly height?: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadItemImage2
     */
    readonly quality?: number

    /**
     * 
     * @type {string}
     * @memberof ImageApiHeadItemImage2
     */
    readonly tag?: string

    /**
     * 
     * @type {boolean}
     * @memberof ImageApiHeadItemImage2
     */
    readonly cropWhitespace?: boolean

    /**
     * 
     * @type {string}
     * @memberof ImageApiHeadItemImage2
     */
    readonly format?: string

    /**
     * 
     * @type {boolean}
     * @memberof ImageApiHeadItemImage2
     */
    readonly addPlayedIndicator?: boolean

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadItemImage2
     */
    readonly percentPlayed?: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadItemImage2
     */
    readonly unplayedCount?: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadItemImage2
     */
    readonly blur?: number

    /**
     * 
     * @type {string}
     * @memberof ImageApiHeadItemImage2
     */
    readonly backgroundColor?: string

    /**
     * 
     * @type {string}
     * @memberof ImageApiHeadItemImage2
     */
    readonly foregroundLayer?: string
}

/**
 * Request parameters for headItemImage2_2 operation in ImageApi.
 * @export
 * @interface ImageApiHeadItemImage20Request
 */
export interface ImageApiHeadItemImage20Request {
    /**
     * 
     * @type {string}
     * @memberof ImageApiHeadItemImage20
     */
    readonly itemId: string

    /**
     * 
     * @type {ImageType}
     * @memberof ImageApiHeadItemImage20
     */
    readonly imageType: ImageType

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadItemImage20
     */
    readonly maxWidth: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadItemImage20
     */
    readonly maxHeight: number

    /**
     * 
     * @type {string}
     * @memberof ImageApiHeadItemImage20
     */
    readonly tag: string

    /**
     * 
     * @type {string}
     * @memberof ImageApiHeadItemImage20
     */
    readonly format: string

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadItemImage20
     */
    readonly percentPlayed: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadItemImage20
     */
    readonly unplayedCount: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadItemImage20
     */
    readonly imageIndex: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadItemImage20
     */
    readonly width?: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadItemImage20
     */
    readonly height?: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadItemImage20
     */
    readonly quality?: number

    /**
     * 
     * @type {boolean}
     * @memberof ImageApiHeadItemImage20
     */
    readonly cropWhitespace?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ImageApiHeadItemImage20
     */
    readonly addPlayedIndicator?: boolean

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadItemImage20
     */
    readonly blur?: number

    /**
     * 
     * @type {string}
     * @memberof ImageApiHeadItemImage20
     */
    readonly backgroundColor?: string

    /**
     * 
     * @type {string}
     * @memberof ImageApiHeadItemImage20
     */
    readonly foregroundLayer?: string
}

/**
 * Request parameters for headMusicGenreImage operation in ImageApi.
 * @export
 * @interface ImageApiHeadMusicGenreImageRequest
 */
export interface ImageApiHeadMusicGenreImageRequest {
    /**
     * 
     * @type {string}
     * @memberof ImageApiHeadMusicGenreImage
     */
    readonly name: string

    /**
     * 
     * @type {ImageType}
     * @memberof ImageApiHeadMusicGenreImage
     */
    readonly imageType: ImageType

    /**
     * 
     * @type {string}
     * @memberof ImageApiHeadMusicGenreImage
     */
    readonly tag: string

    /**
     * 
     * @type {string}
     * @memberof ImageApiHeadMusicGenreImage
     */
    readonly format: string

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadMusicGenreImage
     */
    readonly maxWidth: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadMusicGenreImage
     */
    readonly maxHeight: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadMusicGenreImage
     */
    readonly percentPlayed: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadMusicGenreImage
     */
    readonly unplayedCount: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadMusicGenreImage
     */
    readonly imageIndex: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadMusicGenreImage
     */
    readonly width?: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadMusicGenreImage
     */
    readonly height?: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadMusicGenreImage
     */
    readonly quality?: number

    /**
     * 
     * @type {boolean}
     * @memberof ImageApiHeadMusicGenreImage
     */
    readonly cropWhitespace?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ImageApiHeadMusicGenreImage
     */
    readonly addPlayedIndicator?: boolean

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadMusicGenreImage
     */
    readonly blur?: number

    /**
     * 
     * @type {string}
     * @memberof ImageApiHeadMusicGenreImage
     */
    readonly backgroundColor?: string

    /**
     * 
     * @type {string}
     * @memberof ImageApiHeadMusicGenreImage
     */
    readonly foregroundLayer?: string
}

/**
 * Request parameters for headPersonImage operation in ImageApi.
 * @export
 * @interface ImageApiHeadPersonImageRequest
 */
export interface ImageApiHeadPersonImageRequest {
    /**
     * 
     * @type {string}
     * @memberof ImageApiHeadPersonImage
     */
    readonly name: string

    /**
     * 
     * @type {ImageType}
     * @memberof ImageApiHeadPersonImage
     */
    readonly imageType: ImageType

    /**
     * 
     * @type {string}
     * @memberof ImageApiHeadPersonImage
     */
    readonly tag: string

    /**
     * 
     * @type {string}
     * @memberof ImageApiHeadPersonImage
     */
    readonly format: string

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadPersonImage
     */
    readonly maxWidth: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadPersonImage
     */
    readonly maxHeight: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadPersonImage
     */
    readonly percentPlayed: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadPersonImage
     */
    readonly unplayedCount: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadPersonImage
     */
    readonly imageIndex: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadPersonImage
     */
    readonly width?: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadPersonImage
     */
    readonly height?: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadPersonImage
     */
    readonly quality?: number

    /**
     * 
     * @type {boolean}
     * @memberof ImageApiHeadPersonImage
     */
    readonly cropWhitespace?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ImageApiHeadPersonImage
     */
    readonly addPlayedIndicator?: boolean

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadPersonImage
     */
    readonly blur?: number

    /**
     * 
     * @type {string}
     * @memberof ImageApiHeadPersonImage
     */
    readonly backgroundColor?: string

    /**
     * 
     * @type {string}
     * @memberof ImageApiHeadPersonImage
     */
    readonly foregroundLayer?: string
}

/**
 * Request parameters for headStudioImage operation in ImageApi.
 * @export
 * @interface ImageApiHeadStudioImageRequest
 */
export interface ImageApiHeadStudioImageRequest {
    /**
     * 
     * @type {string}
     * @memberof ImageApiHeadStudioImage
     */
    readonly name: string

    /**
     * 
     * @type {ImageType}
     * @memberof ImageApiHeadStudioImage
     */
    readonly imageType: ImageType

    /**
     * 
     * @type {string}
     * @memberof ImageApiHeadStudioImage
     */
    readonly tag: string

    /**
     * 
     * @type {string}
     * @memberof ImageApiHeadStudioImage
     */
    readonly format: string

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadStudioImage
     */
    readonly maxWidth: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadStudioImage
     */
    readonly maxHeight: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadStudioImage
     */
    readonly percentPlayed: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadStudioImage
     */
    readonly unplayedCount: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadStudioImage
     */
    readonly imageIndex: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadStudioImage
     */
    readonly width?: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadStudioImage
     */
    readonly height?: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadStudioImage
     */
    readonly quality?: number

    /**
     * 
     * @type {boolean}
     * @memberof ImageApiHeadStudioImage
     */
    readonly cropWhitespace?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ImageApiHeadStudioImage
     */
    readonly addPlayedIndicator?: boolean

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadStudioImage
     */
    readonly blur?: number

    /**
     * 
     * @type {string}
     * @memberof ImageApiHeadStudioImage
     */
    readonly backgroundColor?: string

    /**
     * 
     * @type {string}
     * @memberof ImageApiHeadStudioImage
     */
    readonly foregroundLayer?: string
}

/**
 * Request parameters for headUserImage operation in ImageApi.
 * @export
 * @interface ImageApiHeadUserImageRequest
 */
export interface ImageApiHeadUserImageRequest {
    /**
     * 
     * @type {string}
     * @memberof ImageApiHeadUserImage
     */
    readonly userId: string

    /**
     * 
     * @type {ImageType}
     * @memberof ImageApiHeadUserImage
     */
    readonly imageType: ImageType

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadUserImage
     */
    readonly imageIndex: number

    /**
     * 
     * @type {string}
     * @memberof ImageApiHeadUserImage
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof ImageApiHeadUserImage
     */
    readonly format?: string

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadUserImage
     */
    readonly maxWidth?: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadUserImage
     */
    readonly maxHeight?: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadUserImage
     */
    readonly percentPlayed?: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadUserImage
     */
    readonly unplayedCount?: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadUserImage
     */
    readonly width?: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadUserImage
     */
    readonly height?: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadUserImage
     */
    readonly quality?: number

    /**
     * 
     * @type {boolean}
     * @memberof ImageApiHeadUserImage
     */
    readonly cropWhitespace?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ImageApiHeadUserImage
     */
    readonly addPlayedIndicator?: boolean

    /**
     * 
     * @type {number}
     * @memberof ImageApiHeadUserImage
     */
    readonly blur?: number

    /**
     * 
     * @type {string}
     * @memberof ImageApiHeadUserImage
     */
    readonly backgroundColor?: string

    /**
     * 
     * @type {string}
     * @memberof ImageApiHeadUserImage
     */
    readonly foregroundLayer?: string
}

/**
 * Request parameters for postUserImage operation in ImageApi.
 * @export
 * @interface ImageApiPostUserImageRequest
 */
export interface ImageApiPostUserImageRequest {
    /**
     * 
     * @type {string}
     * @memberof ImageApiPostUserImage
     */
    readonly userId: string

    /**
     * 
     * @type {ImageType}
     * @memberof ImageApiPostUserImage
     */
    readonly imageType: ImageType

    /**
     * 
     * @type {number}
     * @memberof ImageApiPostUserImage
     */
    readonly index: number
}

/**
 * Request parameters for postUserImage2 operation in ImageApi.
 * @export
 * @interface ImageApiPostUserImage2Request
 */
export interface ImageApiPostUserImage2Request {
    /**
     * 
     * @type {string}
     * @memberof ImageApiPostUserImage2
     */
    readonly userId: string

    /**
     * 
     * @type {ImageType}
     * @memberof ImageApiPostUserImage2
     */
    readonly imageType: ImageType

    /**
     * 
     * @type {number}
     * @memberof ImageApiPostUserImage2
     */
    readonly index: number
}

/**
 * Request parameters for setItemImage operation in ImageApi.
 * @export
 * @interface ImageApiSetItemImageRequest
 */
export interface ImageApiSetItemImageRequest {
    /**
     * 
     * @type {string}
     * @memberof ImageApiSetItemImage
     */
    readonly itemId: string

    /**
     * 
     * @type {ImageType}
     * @memberof ImageApiSetItemImage
     */
    readonly imageType: ImageType

    /**
     * 
     * @type {number}
     * @memberof ImageApiSetItemImage
     */
    readonly imageIndex: number
}

/**
 * Request parameters for setItemImage2 operation in ImageApi.
 * @export
 * @interface ImageApiSetItemImage2Request
 */
export interface ImageApiSetItemImage2Request {
    /**
     * 
     * @type {string}
     * @memberof ImageApiSetItemImage2
     */
    readonly itemId: string

    /**
     * 
     * @type {ImageType}
     * @memberof ImageApiSetItemImage2
     */
    readonly imageType: ImageType

    /**
     * 
     * @type {number}
     * @memberof ImageApiSetItemImage2
     */
    readonly imageIndex: number
}

/**
 * Request parameters for updateItemImageIndex operation in ImageApi.
 * @export
 * @interface ImageApiUpdateItemImageIndexRequest
 */
export interface ImageApiUpdateItemImageIndexRequest {
    /**
     * 
     * @type {string}
     * @memberof ImageApiUpdateItemImageIndex
     */
    readonly itemId: string

    /**
     * 
     * @type {ImageType}
     * @memberof ImageApiUpdateItemImageIndex
     */
    readonly imageType: ImageType

    /**
     * 
     * @type {number}
     * @memberof ImageApiUpdateItemImageIndex
     */
    readonly imageIndex: number

    /**
     * 
     * @type {number}
     * @memberof ImageApiUpdateItemImageIndex
     */
    readonly newIndex?: number
}

/**
 * ImageApi - object-oriented interface
 * @export
 * @class ImageApi
 * @extends {BaseAPI}
 */
export class ImageApi extends BaseAPI {
    /**
     * 
     * @param {ImageApiDeleteItemImageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public deleteItemImage(requestParameters: ImageApiDeleteItemImageRequest, options?: any) {
        return ImageApiFp(this.configuration).deleteItemImage(requestParameters.itemId, requestParameters.imageType, requestParameters.imageIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ImageApiDeleteItemImage2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public deleteItemImage2(requestParameters: ImageApiDeleteItemImage2Request, options?: any) {
        return ImageApiFp(this.configuration).deleteItemImage2(requestParameters.itemId, requestParameters.imageType, requestParameters.imageIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ImageApiDeleteUserImageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public deleteUserImage(requestParameters: ImageApiDeleteUserImageRequest, options?: any) {
        return ImageApiFp(this.configuration).deleteUserImage(requestParameters.userId, requestParameters.imageType, requestParameters.index, requestParameters.itemType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ImageApiDeleteUserImage2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public deleteUserImage2(requestParameters: ImageApiDeleteUserImage2Request, options?: any) {
        return ImageApiFp(this.configuration).deleteUserImage2(requestParameters.userId, requestParameters.imageType, requestParameters.index, requestParameters.itemType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ImageApiGetArtistImageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public getArtistImage(requestParameters: ImageApiGetArtistImageRequest, options?: any) {
        return ImageApiFp(this.configuration).getArtistImage(requestParameters.name, requestParameters.imageType, requestParameters.tag, requestParameters.format, requestParameters.maxWidth, requestParameters.maxHeight, requestParameters.percentPlayed, requestParameters.unplayedCount, requestParameters.imageIndex, requestParameters.width, requestParameters.height, requestParameters.quality, requestParameters.cropWhitespace, requestParameters.addPlayedIndicator, requestParameters.blur, requestParameters.backgroundColor, requestParameters.foregroundLayer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ImageApiGetGenreImageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public getGenreImage(requestParameters: ImageApiGetGenreImageRequest, options?: any) {
        return ImageApiFp(this.configuration).getGenreImage(requestParameters.name, requestParameters.imageType, requestParameters.tag, requestParameters.format, requestParameters.maxWidth, requestParameters.maxHeight, requestParameters.percentPlayed, requestParameters.unplayedCount, requestParameters.imageIndex, requestParameters.width, requestParameters.height, requestParameters.quality, requestParameters.cropWhitespace, requestParameters.addPlayedIndicator, requestParameters.blur, requestParameters.backgroundColor, requestParameters.foregroundLayer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ImageApiGetItemImageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public getItemImage(requestParameters: ImageApiGetItemImageRequest, options?: any) {
        return ImageApiFp(this.configuration).getItemImage(requestParameters.itemId, requestParameters.imageType, requestParameters.maxWidth, requestParameters.maxHeight, requestParameters.imageIndex, requestParameters.width, requestParameters.height, requestParameters.quality, requestParameters.tag, requestParameters.cropWhitespace, requestParameters.format, requestParameters.addPlayedIndicator, requestParameters.percentPlayed, requestParameters.unplayedCount, requestParameters.blur, requestParameters.backgroundColor, requestParameters.foregroundLayer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ImageApiGetItemImage2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public getItemImage2(requestParameters: ImageApiGetItemImage2Request, options?: any) {
        return ImageApiFp(this.configuration).getItemImage2(requestParameters.itemId, requestParameters.imageType, requestParameters.maxWidth, requestParameters.maxHeight, requestParameters.imageIndex, requestParameters.width, requestParameters.height, requestParameters.quality, requestParameters.tag, requestParameters.cropWhitespace, requestParameters.format, requestParameters.addPlayedIndicator, requestParameters.percentPlayed, requestParameters.unplayedCount, requestParameters.blur, requestParameters.backgroundColor, requestParameters.foregroundLayer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ImageApiGetItemImage20Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public getItemImage2_1(requestParameters: ImageApiGetItemImage20Request, options?: any) {
        return ImageApiFp(this.configuration).getItemImage2_1(requestParameters.itemId, requestParameters.imageType, requestParameters.maxWidth, requestParameters.maxHeight, requestParameters.tag, requestParameters.format, requestParameters.percentPlayed, requestParameters.unplayedCount, requestParameters.imageIndex, requestParameters.width, requestParameters.height, requestParameters.quality, requestParameters.cropWhitespace, requestParameters.addPlayedIndicator, requestParameters.blur, requestParameters.backgroundColor, requestParameters.foregroundLayer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ImageApiGetItemImageInfosRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public getItemImageInfos(requestParameters: ImageApiGetItemImageInfosRequest, options?: any) {
        return ImageApiFp(this.configuration).getItemImageInfos(requestParameters.itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ImageApiGetMusicGenreImageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public getMusicGenreImage(requestParameters: ImageApiGetMusicGenreImageRequest, options?: any) {
        return ImageApiFp(this.configuration).getMusicGenreImage(requestParameters.name, requestParameters.imageType, requestParameters.tag, requestParameters.format, requestParameters.maxWidth, requestParameters.maxHeight, requestParameters.percentPlayed, requestParameters.unplayedCount, requestParameters.imageIndex, requestParameters.width, requestParameters.height, requestParameters.quality, requestParameters.cropWhitespace, requestParameters.addPlayedIndicator, requestParameters.blur, requestParameters.backgroundColor, requestParameters.foregroundLayer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ImageApiGetPersonImageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public getPersonImage(requestParameters: ImageApiGetPersonImageRequest, options?: any) {
        return ImageApiFp(this.configuration).getPersonImage(requestParameters.name, requestParameters.imageType, requestParameters.tag, requestParameters.format, requestParameters.maxWidth, requestParameters.maxHeight, requestParameters.percentPlayed, requestParameters.unplayedCount, requestParameters.imageIndex, requestParameters.width, requestParameters.height, requestParameters.quality, requestParameters.cropWhitespace, requestParameters.addPlayedIndicator, requestParameters.blur, requestParameters.backgroundColor, requestParameters.foregroundLayer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ImageApiGetStudioImageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public getStudioImage(requestParameters: ImageApiGetStudioImageRequest, options?: any) {
        return ImageApiFp(this.configuration).getStudioImage(requestParameters.name, requestParameters.imageType, requestParameters.tag, requestParameters.format, requestParameters.maxWidth, requestParameters.maxHeight, requestParameters.percentPlayed, requestParameters.unplayedCount, requestParameters.imageIndex, requestParameters.width, requestParameters.height, requestParameters.quality, requestParameters.cropWhitespace, requestParameters.addPlayedIndicator, requestParameters.blur, requestParameters.backgroundColor, requestParameters.foregroundLayer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ImageApiGetUserImageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public getUserImage(requestParameters: ImageApiGetUserImageRequest, options?: any) {
        return ImageApiFp(this.configuration).getUserImage(requestParameters.userId, requestParameters.imageType, requestParameters.imageIndex, requestParameters.tag, requestParameters.format, requestParameters.maxWidth, requestParameters.maxHeight, requestParameters.percentPlayed, requestParameters.unplayedCount, requestParameters.width, requestParameters.height, requestParameters.quality, requestParameters.cropWhitespace, requestParameters.addPlayedIndicator, requestParameters.blur, requestParameters.backgroundColor, requestParameters.foregroundLayer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ImageApiHeadArtistImageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public headArtistImage(requestParameters: ImageApiHeadArtistImageRequest, options?: any) {
        return ImageApiFp(this.configuration).headArtistImage(requestParameters.name, requestParameters.imageType, requestParameters.tag, requestParameters.format, requestParameters.maxWidth, requestParameters.maxHeight, requestParameters.percentPlayed, requestParameters.unplayedCount, requestParameters.imageIndex, requestParameters.width, requestParameters.height, requestParameters.quality, requestParameters.cropWhitespace, requestParameters.addPlayedIndicator, requestParameters.blur, requestParameters.backgroundColor, requestParameters.foregroundLayer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ImageApiHeadGenreImageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public headGenreImage(requestParameters: ImageApiHeadGenreImageRequest, options?: any) {
        return ImageApiFp(this.configuration).headGenreImage(requestParameters.name, requestParameters.imageType, requestParameters.tag, requestParameters.format, requestParameters.maxWidth, requestParameters.maxHeight, requestParameters.percentPlayed, requestParameters.unplayedCount, requestParameters.imageIndex, requestParameters.width, requestParameters.height, requestParameters.quality, requestParameters.cropWhitespace, requestParameters.addPlayedIndicator, requestParameters.blur, requestParameters.backgroundColor, requestParameters.foregroundLayer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ImageApiHeadItemImageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public headItemImage(requestParameters: ImageApiHeadItemImageRequest, options?: any) {
        return ImageApiFp(this.configuration).headItemImage(requestParameters.itemId, requestParameters.imageType, requestParameters.maxWidth, requestParameters.maxHeight, requestParameters.imageIndex, requestParameters.width, requestParameters.height, requestParameters.quality, requestParameters.tag, requestParameters.cropWhitespace, requestParameters.format, requestParameters.addPlayedIndicator, requestParameters.percentPlayed, requestParameters.unplayedCount, requestParameters.blur, requestParameters.backgroundColor, requestParameters.foregroundLayer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ImageApiHeadItemImage2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public headItemImage2(requestParameters: ImageApiHeadItemImage2Request, options?: any) {
        return ImageApiFp(this.configuration).headItemImage2(requestParameters.itemId, requestParameters.imageType, requestParameters.maxWidth, requestParameters.maxHeight, requestParameters.imageIndex, requestParameters.width, requestParameters.height, requestParameters.quality, requestParameters.tag, requestParameters.cropWhitespace, requestParameters.format, requestParameters.addPlayedIndicator, requestParameters.percentPlayed, requestParameters.unplayedCount, requestParameters.blur, requestParameters.backgroundColor, requestParameters.foregroundLayer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ImageApiHeadItemImage20Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public headItemImage2_2(requestParameters: ImageApiHeadItemImage20Request, options?: any) {
        return ImageApiFp(this.configuration).headItemImage2_2(requestParameters.itemId, requestParameters.imageType, requestParameters.maxWidth, requestParameters.maxHeight, requestParameters.tag, requestParameters.format, requestParameters.percentPlayed, requestParameters.unplayedCount, requestParameters.imageIndex, requestParameters.width, requestParameters.height, requestParameters.quality, requestParameters.cropWhitespace, requestParameters.addPlayedIndicator, requestParameters.blur, requestParameters.backgroundColor, requestParameters.foregroundLayer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ImageApiHeadMusicGenreImageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public headMusicGenreImage(requestParameters: ImageApiHeadMusicGenreImageRequest, options?: any) {
        return ImageApiFp(this.configuration).headMusicGenreImage(requestParameters.name, requestParameters.imageType, requestParameters.tag, requestParameters.format, requestParameters.maxWidth, requestParameters.maxHeight, requestParameters.percentPlayed, requestParameters.unplayedCount, requestParameters.imageIndex, requestParameters.width, requestParameters.height, requestParameters.quality, requestParameters.cropWhitespace, requestParameters.addPlayedIndicator, requestParameters.blur, requestParameters.backgroundColor, requestParameters.foregroundLayer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ImageApiHeadPersonImageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public headPersonImage(requestParameters: ImageApiHeadPersonImageRequest, options?: any) {
        return ImageApiFp(this.configuration).headPersonImage(requestParameters.name, requestParameters.imageType, requestParameters.tag, requestParameters.format, requestParameters.maxWidth, requestParameters.maxHeight, requestParameters.percentPlayed, requestParameters.unplayedCount, requestParameters.imageIndex, requestParameters.width, requestParameters.height, requestParameters.quality, requestParameters.cropWhitespace, requestParameters.addPlayedIndicator, requestParameters.blur, requestParameters.backgroundColor, requestParameters.foregroundLayer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ImageApiHeadStudioImageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public headStudioImage(requestParameters: ImageApiHeadStudioImageRequest, options?: any) {
        return ImageApiFp(this.configuration).headStudioImage(requestParameters.name, requestParameters.imageType, requestParameters.tag, requestParameters.format, requestParameters.maxWidth, requestParameters.maxHeight, requestParameters.percentPlayed, requestParameters.unplayedCount, requestParameters.imageIndex, requestParameters.width, requestParameters.height, requestParameters.quality, requestParameters.cropWhitespace, requestParameters.addPlayedIndicator, requestParameters.blur, requestParameters.backgroundColor, requestParameters.foregroundLayer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ImageApiHeadUserImageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public headUserImage(requestParameters: ImageApiHeadUserImageRequest, options?: any) {
        return ImageApiFp(this.configuration).headUserImage(requestParameters.userId, requestParameters.imageType, requestParameters.imageIndex, requestParameters.tag, requestParameters.format, requestParameters.maxWidth, requestParameters.maxHeight, requestParameters.percentPlayed, requestParameters.unplayedCount, requestParameters.width, requestParameters.height, requestParameters.quality, requestParameters.cropWhitespace, requestParameters.addPlayedIndicator, requestParameters.blur, requestParameters.backgroundColor, requestParameters.foregroundLayer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ImageApiPostUserImageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public postUserImage(requestParameters: ImageApiPostUserImageRequest, options?: any) {
        return ImageApiFp(this.configuration).postUserImage(requestParameters.userId, requestParameters.imageType, requestParameters.index, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ImageApiPostUserImage2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public postUserImage2(requestParameters: ImageApiPostUserImage2Request, options?: any) {
        return ImageApiFp(this.configuration).postUserImage2(requestParameters.userId, requestParameters.imageType, requestParameters.index, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ImageApiSetItemImageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public setItemImage(requestParameters: ImageApiSetItemImageRequest, options?: any) {
        return ImageApiFp(this.configuration).setItemImage(requestParameters.itemId, requestParameters.imageType, requestParameters.imageIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ImageApiSetItemImage2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public setItemImage2(requestParameters: ImageApiSetItemImage2Request, options?: any) {
        return ImageApiFp(this.configuration).setItemImage2(requestParameters.itemId, requestParameters.imageType, requestParameters.imageIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ImageApiUpdateItemImageIndexRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public updateItemImageIndex(requestParameters: ImageApiUpdateItemImageIndexRequest, options?: any) {
        return ImageApiFp(this.configuration).updateItemImageIndex(requestParameters.itemId, requestParameters.imageType, requestParameters.imageIndex, requestParameters.newIndex, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ImageByNameApi - axios parameter creator
 * @export
 */
export const ImageByNameApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} name 
         * @param {string} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGeneralImage: async (name: string, type: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getGeneralImage.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling getGeneralImage.');
            }
            const localVarPath = `/Images/General/{name}/{type}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGeneralImages: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Images/General`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} theme 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediaInfoImage: async (theme: string, name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'theme' is not null or undefined
            if (theme === null || theme === undefined) {
                throw new RequiredError('theme','Required parameter theme was null or undefined when calling getMediaInfoImage.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getMediaInfoImage.');
            }
            const localVarPath = `/Images/MediaInfo/{theme}/{name}`
                .replace(`{${"theme"}}`, encodeURIComponent(String(theme)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediaInfoImages: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Images/MediaInfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} theme 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRatingImage: async (theme: string, name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'theme' is not null or undefined
            if (theme === null || theme === undefined) {
                throw new RequiredError('theme','Required parameter theme was null or undefined when calling getRatingImage.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getRatingImage.');
            }
            const localVarPath = `/Images/Ratings/{theme}/{name}`
                .replace(`{${"theme"}}`, encodeURIComponent(String(theme)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRatingImages: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Images/Ratings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImageByNameApi - functional programming interface
 * @export
 */
export const ImageByNameApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} name 
         * @param {string} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGeneralImage(name: string, type: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await ImageByNameApiAxiosParamCreator(configuration).getGeneralImage(name, type, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGeneralImages(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ImageByNameInfo>>> {
            const localVarAxiosArgs = await ImageByNameApiAxiosParamCreator(configuration).getGeneralImages(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} theme 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMediaInfoImage(theme: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await ImageByNameApiAxiosParamCreator(configuration).getMediaInfoImage(theme, name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMediaInfoImages(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ImageByNameInfo>>> {
            const localVarAxiosArgs = await ImageByNameApiAxiosParamCreator(configuration).getMediaInfoImages(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} theme 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRatingImage(theme: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await ImageByNameApiAxiosParamCreator(configuration).getRatingImage(theme, name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRatingImages(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ImageByNameInfo>>> {
            const localVarAxiosArgs = await ImageByNameApiAxiosParamCreator(configuration).getRatingImages(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ImageByNameApi - factory interface
 * @export
 */
export const ImageByNameApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} name 
         * @param {string} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGeneralImage(name: string, type: string, options?: any): AxiosPromise<any> {
            return ImageByNameApiFp(configuration).getGeneralImage(name, type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGeneralImages(options?: any): AxiosPromise<Array<ImageByNameInfo>> {
            return ImageByNameApiFp(configuration).getGeneralImages(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} theme 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediaInfoImage(theme: string, name: string, options?: any): AxiosPromise<any> {
            return ImageByNameApiFp(configuration).getMediaInfoImage(theme, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediaInfoImages(options?: any): AxiosPromise<Array<ImageByNameInfo>> {
            return ImageByNameApiFp(configuration).getMediaInfoImages(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} theme 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRatingImage(theme: string, name: string, options?: any): AxiosPromise<any> {
            return ImageByNameApiFp(configuration).getRatingImage(theme, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRatingImages(options?: any): AxiosPromise<Array<ImageByNameInfo>> {
            return ImageByNameApiFp(configuration).getRatingImages(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getGeneralImage operation in ImageByNameApi.
 * @export
 * @interface ImageByNameApiGetGeneralImageRequest
 */
export interface ImageByNameApiGetGeneralImageRequest {
    /**
     * 
     * @type {string}
     * @memberof ImageByNameApiGetGeneralImage
     */
    readonly name: string

    /**
     * 
     * @type {string}
     * @memberof ImageByNameApiGetGeneralImage
     */
    readonly type: string
}

/**
 * Request parameters for getMediaInfoImage operation in ImageByNameApi.
 * @export
 * @interface ImageByNameApiGetMediaInfoImageRequest
 */
export interface ImageByNameApiGetMediaInfoImageRequest {
    /**
     * 
     * @type {string}
     * @memberof ImageByNameApiGetMediaInfoImage
     */
    readonly theme: string

    /**
     * 
     * @type {string}
     * @memberof ImageByNameApiGetMediaInfoImage
     */
    readonly name: string
}

/**
 * Request parameters for getRatingImage operation in ImageByNameApi.
 * @export
 * @interface ImageByNameApiGetRatingImageRequest
 */
export interface ImageByNameApiGetRatingImageRequest {
    /**
     * 
     * @type {string}
     * @memberof ImageByNameApiGetRatingImage
     */
    readonly theme: string

    /**
     * 
     * @type {string}
     * @memberof ImageByNameApiGetRatingImage
     */
    readonly name: string
}

/**
 * ImageByNameApi - object-oriented interface
 * @export
 * @class ImageByNameApi
 * @extends {BaseAPI}
 */
export class ImageByNameApi extends BaseAPI {
    /**
     * 
     * @param {ImageByNameApiGetGeneralImageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageByNameApi
     */
    public getGeneralImage(requestParameters: ImageByNameApiGetGeneralImageRequest, options?: any) {
        return ImageByNameApiFp(this.configuration).getGeneralImage(requestParameters.name, requestParameters.type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageByNameApi
     */
    public getGeneralImages(options?: any) {
        return ImageByNameApiFp(this.configuration).getGeneralImages(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ImageByNameApiGetMediaInfoImageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageByNameApi
     */
    public getMediaInfoImage(requestParameters: ImageByNameApiGetMediaInfoImageRequest, options?: any) {
        return ImageByNameApiFp(this.configuration).getMediaInfoImage(requestParameters.theme, requestParameters.name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageByNameApi
     */
    public getMediaInfoImages(options?: any) {
        return ImageByNameApiFp(this.configuration).getMediaInfoImages(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ImageByNameApiGetRatingImageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageByNameApi
     */
    public getRatingImage(requestParameters: ImageByNameApiGetRatingImageRequest, options?: any) {
        return ImageByNameApiFp(this.configuration).getRatingImage(requestParameters.theme, requestParameters.name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageByNameApi
     */
    public getRatingImages(options?: any) {
        return ImageByNameApiFp(this.configuration).getRatingImages(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * InstantMixApi - axios parameter creator
 * @export
 */
export const InstantMixApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {string} [userId] 
         * @param {number} [limit] 
         * @param {string} [fields] 
         * @param {boolean} [enableImages] 
         * @param {boolean} [enableUserData] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstantMixFromAlbum: async (id: string, userId?: string, limit?: number, fields?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getInstantMixFromAlbum.');
            }
            const localVarPath = `/Albums/{id}/InstantMix`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes !== undefined) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [userId] 
         * @param {number} [limit] 
         * @param {string} [fields] 
         * @param {boolean} [enableImages] 
         * @param {boolean} [enableUserData] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstantMixFromArtists: async (id: string, userId?: string, limit?: number, fields?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getInstantMixFromArtists.');
            }
            const localVarPath = `/Artists/InstantMix`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes !== undefined) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [userId] 
         * @param {number} [limit] 
         * @param {string} [fields] 
         * @param {boolean} [enableImages] 
         * @param {boolean} [enableUserData] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstantMixFromItem: async (id: string, userId?: string, limit?: number, fields?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getInstantMixFromItem.');
            }
            const localVarPath = `/Items/{id}/InstantMix`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes !== undefined) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {string} [userId] 
         * @param {number} [limit] 
         * @param {string} [fields] 
         * @param {boolean} [enableImages] 
         * @param {boolean} [enableUserData] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstantMixFromMusicGenre: async (name: string, userId?: string, limit?: number, fields?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getInstantMixFromMusicGenre.');
            }
            const localVarPath = `/MusicGenres/{name}/InstantMix`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes !== undefined) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [userId] 
         * @param {number} [limit] 
         * @param {string} [fields] 
         * @param {boolean} [enableImages] 
         * @param {boolean} [enableUserData] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstantMixFromMusicGenres: async (id: string, userId?: string, limit?: number, fields?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getInstantMixFromMusicGenres.');
            }
            const localVarPath = `/MusicGenres/InstantMix`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes !== undefined) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [userId] 
         * @param {number} [limit] 
         * @param {string} [fields] 
         * @param {boolean} [enableImages] 
         * @param {boolean} [enableUserData] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstantMixFromPlaylist: async (id: string, userId?: string, limit?: number, fields?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getInstantMixFromPlaylist.');
            }
            const localVarPath = `/Playlists/{id}/InstantMix`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes !== undefined) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [userId] 
         * @param {number} [limit] 
         * @param {string} [fields] 
         * @param {boolean} [enableImages] 
         * @param {boolean} [enableUserData] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstantMixFromSong: async (id: string, userId?: string, limit?: number, fields?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getInstantMixFromSong.');
            }
            const localVarPath = `/Songs/{id}/InstantMix`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes !== undefined) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InstantMixApi - functional programming interface
 * @export
 */
export const InstantMixApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {string} [userId] 
         * @param {number} [limit] 
         * @param {string} [fields] 
         * @param {boolean} [enableImages] 
         * @param {boolean} [enableUserData] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInstantMixFromAlbum(id: string, userId?: string, limit?: number, fields?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await InstantMixApiAxiosParamCreator(configuration).getInstantMixFromAlbum(id, userId, limit, fields, enableImages, enableUserData, imageTypeLimit, enableImageTypes, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [userId] 
         * @param {number} [limit] 
         * @param {string} [fields] 
         * @param {boolean} [enableImages] 
         * @param {boolean} [enableUserData] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInstantMixFromArtists(id: string, userId?: string, limit?: number, fields?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await InstantMixApiAxiosParamCreator(configuration).getInstantMixFromArtists(id, userId, limit, fields, enableImages, enableUserData, imageTypeLimit, enableImageTypes, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [userId] 
         * @param {number} [limit] 
         * @param {string} [fields] 
         * @param {boolean} [enableImages] 
         * @param {boolean} [enableUserData] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInstantMixFromItem(id: string, userId?: string, limit?: number, fields?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await InstantMixApiAxiosParamCreator(configuration).getInstantMixFromItem(id, userId, limit, fields, enableImages, enableUserData, imageTypeLimit, enableImageTypes, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {string} [userId] 
         * @param {number} [limit] 
         * @param {string} [fields] 
         * @param {boolean} [enableImages] 
         * @param {boolean} [enableUserData] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInstantMixFromMusicGenre(name: string, userId?: string, limit?: number, fields?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await InstantMixApiAxiosParamCreator(configuration).getInstantMixFromMusicGenre(name, userId, limit, fields, enableImages, enableUserData, imageTypeLimit, enableImageTypes, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [userId] 
         * @param {number} [limit] 
         * @param {string} [fields] 
         * @param {boolean} [enableImages] 
         * @param {boolean} [enableUserData] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInstantMixFromMusicGenres(id: string, userId?: string, limit?: number, fields?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await InstantMixApiAxiosParamCreator(configuration).getInstantMixFromMusicGenres(id, userId, limit, fields, enableImages, enableUserData, imageTypeLimit, enableImageTypes, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [userId] 
         * @param {number} [limit] 
         * @param {string} [fields] 
         * @param {boolean} [enableImages] 
         * @param {boolean} [enableUserData] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInstantMixFromPlaylist(id: string, userId?: string, limit?: number, fields?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await InstantMixApiAxiosParamCreator(configuration).getInstantMixFromPlaylist(id, userId, limit, fields, enableImages, enableUserData, imageTypeLimit, enableImageTypes, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [userId] 
         * @param {number} [limit] 
         * @param {string} [fields] 
         * @param {boolean} [enableImages] 
         * @param {boolean} [enableUserData] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInstantMixFromSong(id: string, userId?: string, limit?: number, fields?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await InstantMixApiAxiosParamCreator(configuration).getInstantMixFromSong(id, userId, limit, fields, enableImages, enableUserData, imageTypeLimit, enableImageTypes, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * InstantMixApi - factory interface
 * @export
 */
export const InstantMixApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {string} [userId] 
         * @param {number} [limit] 
         * @param {string} [fields] 
         * @param {boolean} [enableImages] 
         * @param {boolean} [enableUserData] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstantMixFromAlbum(id: string, userId?: string, limit?: number, fields?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return InstantMixApiFp(configuration).getInstantMixFromAlbum(id, userId, limit, fields, enableImages, enableUserData, imageTypeLimit, enableImageTypes, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [userId] 
         * @param {number} [limit] 
         * @param {string} [fields] 
         * @param {boolean} [enableImages] 
         * @param {boolean} [enableUserData] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstantMixFromArtists(id: string, userId?: string, limit?: number, fields?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return InstantMixApiFp(configuration).getInstantMixFromArtists(id, userId, limit, fields, enableImages, enableUserData, imageTypeLimit, enableImageTypes, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [userId] 
         * @param {number} [limit] 
         * @param {string} [fields] 
         * @param {boolean} [enableImages] 
         * @param {boolean} [enableUserData] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstantMixFromItem(id: string, userId?: string, limit?: number, fields?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return InstantMixApiFp(configuration).getInstantMixFromItem(id, userId, limit, fields, enableImages, enableUserData, imageTypeLimit, enableImageTypes, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} name 
         * @param {string} [userId] 
         * @param {number} [limit] 
         * @param {string} [fields] 
         * @param {boolean} [enableImages] 
         * @param {boolean} [enableUserData] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstantMixFromMusicGenre(name: string, userId?: string, limit?: number, fields?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return InstantMixApiFp(configuration).getInstantMixFromMusicGenre(name, userId, limit, fields, enableImages, enableUserData, imageTypeLimit, enableImageTypes, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [userId] 
         * @param {number} [limit] 
         * @param {string} [fields] 
         * @param {boolean} [enableImages] 
         * @param {boolean} [enableUserData] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstantMixFromMusicGenres(id: string, userId?: string, limit?: number, fields?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return InstantMixApiFp(configuration).getInstantMixFromMusicGenres(id, userId, limit, fields, enableImages, enableUserData, imageTypeLimit, enableImageTypes, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [userId] 
         * @param {number} [limit] 
         * @param {string} [fields] 
         * @param {boolean} [enableImages] 
         * @param {boolean} [enableUserData] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstantMixFromPlaylist(id: string, userId?: string, limit?: number, fields?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return InstantMixApiFp(configuration).getInstantMixFromPlaylist(id, userId, limit, fields, enableImages, enableUserData, imageTypeLimit, enableImageTypes, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [userId] 
         * @param {number} [limit] 
         * @param {string} [fields] 
         * @param {boolean} [enableImages] 
         * @param {boolean} [enableUserData] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstantMixFromSong(id: string, userId?: string, limit?: number, fields?: string, enableImages?: boolean, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return InstantMixApiFp(configuration).getInstantMixFromSong(id, userId, limit, fields, enableImages, enableUserData, imageTypeLimit, enableImageTypes, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getInstantMixFromAlbum operation in InstantMixApi.
 * @export
 * @interface InstantMixApiGetInstantMixFromAlbumRequest
 */
export interface InstantMixApiGetInstantMixFromAlbumRequest {
    /**
     * 
     * @type {string}
     * @memberof InstantMixApiGetInstantMixFromAlbum
     */
    readonly id: string

    /**
     * 
     * @type {string}
     * @memberof InstantMixApiGetInstantMixFromAlbum
     */
    readonly userId?: string

    /**
     * 
     * @type {number}
     * @memberof InstantMixApiGetInstantMixFromAlbum
     */
    readonly limit?: number

    /**
     * 
     * @type {string}
     * @memberof InstantMixApiGetInstantMixFromAlbum
     */
    readonly fields?: string

    /**
     * 
     * @type {boolean}
     * @memberof InstantMixApiGetInstantMixFromAlbum
     */
    readonly enableImages?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof InstantMixApiGetInstantMixFromAlbum
     */
    readonly enableUserData?: boolean

    /**
     * 
     * @type {number}
     * @memberof InstantMixApiGetInstantMixFromAlbum
     */
    readonly imageTypeLimit?: number

    /**
     * 
     * @type {string}
     * @memberof InstantMixApiGetInstantMixFromAlbum
     */
    readonly enableImageTypes?: string
}

/**
 * Request parameters for getInstantMixFromArtists operation in InstantMixApi.
 * @export
 * @interface InstantMixApiGetInstantMixFromArtistsRequest
 */
export interface InstantMixApiGetInstantMixFromArtistsRequest {
    /**
     * 
     * @type {string}
     * @memberof InstantMixApiGetInstantMixFromArtists
     */
    readonly id: string

    /**
     * 
     * @type {string}
     * @memberof InstantMixApiGetInstantMixFromArtists
     */
    readonly userId?: string

    /**
     * 
     * @type {number}
     * @memberof InstantMixApiGetInstantMixFromArtists
     */
    readonly limit?: number

    /**
     * 
     * @type {string}
     * @memberof InstantMixApiGetInstantMixFromArtists
     */
    readonly fields?: string

    /**
     * 
     * @type {boolean}
     * @memberof InstantMixApiGetInstantMixFromArtists
     */
    readonly enableImages?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof InstantMixApiGetInstantMixFromArtists
     */
    readonly enableUserData?: boolean

    /**
     * 
     * @type {number}
     * @memberof InstantMixApiGetInstantMixFromArtists
     */
    readonly imageTypeLimit?: number

    /**
     * 
     * @type {string}
     * @memberof InstantMixApiGetInstantMixFromArtists
     */
    readonly enableImageTypes?: string
}

/**
 * Request parameters for getInstantMixFromItem operation in InstantMixApi.
 * @export
 * @interface InstantMixApiGetInstantMixFromItemRequest
 */
export interface InstantMixApiGetInstantMixFromItemRequest {
    /**
     * 
     * @type {string}
     * @memberof InstantMixApiGetInstantMixFromItem
     */
    readonly id: string

    /**
     * 
     * @type {string}
     * @memberof InstantMixApiGetInstantMixFromItem
     */
    readonly userId?: string

    /**
     * 
     * @type {number}
     * @memberof InstantMixApiGetInstantMixFromItem
     */
    readonly limit?: number

    /**
     * 
     * @type {string}
     * @memberof InstantMixApiGetInstantMixFromItem
     */
    readonly fields?: string

    /**
     * 
     * @type {boolean}
     * @memberof InstantMixApiGetInstantMixFromItem
     */
    readonly enableImages?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof InstantMixApiGetInstantMixFromItem
     */
    readonly enableUserData?: boolean

    /**
     * 
     * @type {number}
     * @memberof InstantMixApiGetInstantMixFromItem
     */
    readonly imageTypeLimit?: number

    /**
     * 
     * @type {string}
     * @memberof InstantMixApiGetInstantMixFromItem
     */
    readonly enableImageTypes?: string
}

/**
 * Request parameters for getInstantMixFromMusicGenre operation in InstantMixApi.
 * @export
 * @interface InstantMixApiGetInstantMixFromMusicGenreRequest
 */
export interface InstantMixApiGetInstantMixFromMusicGenreRequest {
    /**
     * 
     * @type {string}
     * @memberof InstantMixApiGetInstantMixFromMusicGenre
     */
    readonly name: string

    /**
     * 
     * @type {string}
     * @memberof InstantMixApiGetInstantMixFromMusicGenre
     */
    readonly userId?: string

    /**
     * 
     * @type {number}
     * @memberof InstantMixApiGetInstantMixFromMusicGenre
     */
    readonly limit?: number

    /**
     * 
     * @type {string}
     * @memberof InstantMixApiGetInstantMixFromMusicGenre
     */
    readonly fields?: string

    /**
     * 
     * @type {boolean}
     * @memberof InstantMixApiGetInstantMixFromMusicGenre
     */
    readonly enableImages?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof InstantMixApiGetInstantMixFromMusicGenre
     */
    readonly enableUserData?: boolean

    /**
     * 
     * @type {number}
     * @memberof InstantMixApiGetInstantMixFromMusicGenre
     */
    readonly imageTypeLimit?: number

    /**
     * 
     * @type {string}
     * @memberof InstantMixApiGetInstantMixFromMusicGenre
     */
    readonly enableImageTypes?: string
}

/**
 * Request parameters for getInstantMixFromMusicGenres operation in InstantMixApi.
 * @export
 * @interface InstantMixApiGetInstantMixFromMusicGenresRequest
 */
export interface InstantMixApiGetInstantMixFromMusicGenresRequest {
    /**
     * 
     * @type {string}
     * @memberof InstantMixApiGetInstantMixFromMusicGenres
     */
    readonly id: string

    /**
     * 
     * @type {string}
     * @memberof InstantMixApiGetInstantMixFromMusicGenres
     */
    readonly userId?: string

    /**
     * 
     * @type {number}
     * @memberof InstantMixApiGetInstantMixFromMusicGenres
     */
    readonly limit?: number

    /**
     * 
     * @type {string}
     * @memberof InstantMixApiGetInstantMixFromMusicGenres
     */
    readonly fields?: string

    /**
     * 
     * @type {boolean}
     * @memberof InstantMixApiGetInstantMixFromMusicGenres
     */
    readonly enableImages?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof InstantMixApiGetInstantMixFromMusicGenres
     */
    readonly enableUserData?: boolean

    /**
     * 
     * @type {number}
     * @memberof InstantMixApiGetInstantMixFromMusicGenres
     */
    readonly imageTypeLimit?: number

    /**
     * 
     * @type {string}
     * @memberof InstantMixApiGetInstantMixFromMusicGenres
     */
    readonly enableImageTypes?: string
}

/**
 * Request parameters for getInstantMixFromPlaylist operation in InstantMixApi.
 * @export
 * @interface InstantMixApiGetInstantMixFromPlaylistRequest
 */
export interface InstantMixApiGetInstantMixFromPlaylistRequest {
    /**
     * 
     * @type {string}
     * @memberof InstantMixApiGetInstantMixFromPlaylist
     */
    readonly id: string

    /**
     * 
     * @type {string}
     * @memberof InstantMixApiGetInstantMixFromPlaylist
     */
    readonly userId?: string

    /**
     * 
     * @type {number}
     * @memberof InstantMixApiGetInstantMixFromPlaylist
     */
    readonly limit?: number

    /**
     * 
     * @type {string}
     * @memberof InstantMixApiGetInstantMixFromPlaylist
     */
    readonly fields?: string

    /**
     * 
     * @type {boolean}
     * @memberof InstantMixApiGetInstantMixFromPlaylist
     */
    readonly enableImages?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof InstantMixApiGetInstantMixFromPlaylist
     */
    readonly enableUserData?: boolean

    /**
     * 
     * @type {number}
     * @memberof InstantMixApiGetInstantMixFromPlaylist
     */
    readonly imageTypeLimit?: number

    /**
     * 
     * @type {string}
     * @memberof InstantMixApiGetInstantMixFromPlaylist
     */
    readonly enableImageTypes?: string
}

/**
 * Request parameters for getInstantMixFromSong operation in InstantMixApi.
 * @export
 * @interface InstantMixApiGetInstantMixFromSongRequest
 */
export interface InstantMixApiGetInstantMixFromSongRequest {
    /**
     * 
     * @type {string}
     * @memberof InstantMixApiGetInstantMixFromSong
     */
    readonly id: string

    /**
     * 
     * @type {string}
     * @memberof InstantMixApiGetInstantMixFromSong
     */
    readonly userId?: string

    /**
     * 
     * @type {number}
     * @memberof InstantMixApiGetInstantMixFromSong
     */
    readonly limit?: number

    /**
     * 
     * @type {string}
     * @memberof InstantMixApiGetInstantMixFromSong
     */
    readonly fields?: string

    /**
     * 
     * @type {boolean}
     * @memberof InstantMixApiGetInstantMixFromSong
     */
    readonly enableImages?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof InstantMixApiGetInstantMixFromSong
     */
    readonly enableUserData?: boolean

    /**
     * 
     * @type {number}
     * @memberof InstantMixApiGetInstantMixFromSong
     */
    readonly imageTypeLimit?: number

    /**
     * 
     * @type {string}
     * @memberof InstantMixApiGetInstantMixFromSong
     */
    readonly enableImageTypes?: string
}

/**
 * InstantMixApi - object-oriented interface
 * @export
 * @class InstantMixApi
 * @extends {BaseAPI}
 */
export class InstantMixApi extends BaseAPI {
    /**
     * 
     * @param {InstantMixApiGetInstantMixFromAlbumRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstantMixApi
     */
    public getInstantMixFromAlbum(requestParameters: InstantMixApiGetInstantMixFromAlbumRequest, options?: any) {
        return InstantMixApiFp(this.configuration).getInstantMixFromAlbum(requestParameters.id, requestParameters.userId, requestParameters.limit, requestParameters.fields, requestParameters.enableImages, requestParameters.enableUserData, requestParameters.imageTypeLimit, requestParameters.enableImageTypes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {InstantMixApiGetInstantMixFromArtistsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstantMixApi
     */
    public getInstantMixFromArtists(requestParameters: InstantMixApiGetInstantMixFromArtistsRequest, options?: any) {
        return InstantMixApiFp(this.configuration).getInstantMixFromArtists(requestParameters.id, requestParameters.userId, requestParameters.limit, requestParameters.fields, requestParameters.enableImages, requestParameters.enableUserData, requestParameters.imageTypeLimit, requestParameters.enableImageTypes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {InstantMixApiGetInstantMixFromItemRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstantMixApi
     */
    public getInstantMixFromItem(requestParameters: InstantMixApiGetInstantMixFromItemRequest, options?: any) {
        return InstantMixApiFp(this.configuration).getInstantMixFromItem(requestParameters.id, requestParameters.userId, requestParameters.limit, requestParameters.fields, requestParameters.enableImages, requestParameters.enableUserData, requestParameters.imageTypeLimit, requestParameters.enableImageTypes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {InstantMixApiGetInstantMixFromMusicGenreRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstantMixApi
     */
    public getInstantMixFromMusicGenre(requestParameters: InstantMixApiGetInstantMixFromMusicGenreRequest, options?: any) {
        return InstantMixApiFp(this.configuration).getInstantMixFromMusicGenre(requestParameters.name, requestParameters.userId, requestParameters.limit, requestParameters.fields, requestParameters.enableImages, requestParameters.enableUserData, requestParameters.imageTypeLimit, requestParameters.enableImageTypes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {InstantMixApiGetInstantMixFromMusicGenresRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstantMixApi
     */
    public getInstantMixFromMusicGenres(requestParameters: InstantMixApiGetInstantMixFromMusicGenresRequest, options?: any) {
        return InstantMixApiFp(this.configuration).getInstantMixFromMusicGenres(requestParameters.id, requestParameters.userId, requestParameters.limit, requestParameters.fields, requestParameters.enableImages, requestParameters.enableUserData, requestParameters.imageTypeLimit, requestParameters.enableImageTypes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {InstantMixApiGetInstantMixFromPlaylistRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstantMixApi
     */
    public getInstantMixFromPlaylist(requestParameters: InstantMixApiGetInstantMixFromPlaylistRequest, options?: any) {
        return InstantMixApiFp(this.configuration).getInstantMixFromPlaylist(requestParameters.id, requestParameters.userId, requestParameters.limit, requestParameters.fields, requestParameters.enableImages, requestParameters.enableUserData, requestParameters.imageTypeLimit, requestParameters.enableImageTypes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {InstantMixApiGetInstantMixFromSongRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstantMixApi
     */
    public getInstantMixFromSong(requestParameters: InstantMixApiGetInstantMixFromSongRequest, options?: any) {
        return InstantMixApiFp(this.configuration).getInstantMixFromSong(requestParameters.id, requestParameters.userId, requestParameters.limit, requestParameters.fields, requestParameters.enableImages, requestParameters.enableUserData, requestParameters.imageTypeLimit, requestParameters.enableImageTypes, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ItemLookupApi - axios parameter creator
 * @export
 */
export const ItemLookupApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} itemId 
         * @param {string} id 
         * @param {RemoteSearchResult} remoteSearchResult 
         * @param {boolean} [replaceAllImages] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applySearchCriteria: async (itemId: string, id: string, remoteSearchResult: RemoteSearchResult, replaceAllImages?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling applySearchCriteria.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling applySearchCriteria.');
            }
            // verify required parameter 'remoteSearchResult' is not null or undefined
            if (remoteSearchResult === null || remoteSearchResult === undefined) {
                throw new RequiredError('remoteSearchResult','Required parameter remoteSearchResult was null or undefined when calling applySearchCriteria.');
            }
            const localVarPath = `/Items/RemoteSearch/Apply/{id}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (replaceAllImages !== undefined) {
                localVarQueryParameter['replaceAllImages'] = replaceAllImages;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof remoteSearchResult !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(remoteSearchResult !== undefined ? remoteSearchResult : {}) : (remoteSearchResult || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {BookInfoRemoteSearchQuery} bookInfoRemoteSearchQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBookRemoteSearchResults: async (bookInfoRemoteSearchQuery: BookInfoRemoteSearchQuery, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bookInfoRemoteSearchQuery' is not null or undefined
            if (bookInfoRemoteSearchQuery === null || bookInfoRemoteSearchQuery === undefined) {
                throw new RequiredError('bookInfoRemoteSearchQuery','Required parameter bookInfoRemoteSearchQuery was null or undefined when calling getBookRemoteSearchResults.');
            }
            const localVarPath = `/Items/RemoteSearch/Book`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof bookInfoRemoteSearchQuery !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(bookInfoRemoteSearchQuery !== undefined ? bookInfoRemoteSearchQuery : {}) : (bookInfoRemoteSearchQuery || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {BoxSetInfoRemoteSearchQuery} boxSetInfoRemoteSearchQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBoxSetRemoteSearchResults: async (boxSetInfoRemoteSearchQuery: BoxSetInfoRemoteSearchQuery, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'boxSetInfoRemoteSearchQuery' is not null or undefined
            if (boxSetInfoRemoteSearchQuery === null || boxSetInfoRemoteSearchQuery === undefined) {
                throw new RequiredError('boxSetInfoRemoteSearchQuery','Required parameter boxSetInfoRemoteSearchQuery was null or undefined when calling getBoxSetRemoteSearchResults.');
            }
            const localVarPath = `/Items/RemoteSearch/BoxSet`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof boxSetInfoRemoteSearchQuery !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(boxSetInfoRemoteSearchQuery !== undefined ? boxSetInfoRemoteSearchQuery : {}) : (boxSetInfoRemoteSearchQuery || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExternalIdInfos: async (itemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getExternalIdInfos.');
            }
            const localVarPath = `/Items/{itemId}/ExternalIdInfos`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {MovieInfoRemoteSearchQuery} movieInfoRemoteSearchQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMovieRemoteSearchResults: async (movieInfoRemoteSearchQuery: MovieInfoRemoteSearchQuery, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'movieInfoRemoteSearchQuery' is not null or undefined
            if (movieInfoRemoteSearchQuery === null || movieInfoRemoteSearchQuery === undefined) {
                throw new RequiredError('movieInfoRemoteSearchQuery','Required parameter movieInfoRemoteSearchQuery was null or undefined when calling getMovieRemoteSearchResults.');
            }
            const localVarPath = `/Items/RemoteSearch/Movie`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof movieInfoRemoteSearchQuery !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(movieInfoRemoteSearchQuery !== undefined ? movieInfoRemoteSearchQuery : {}) : (movieInfoRemoteSearchQuery || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AlbumInfoRemoteSearchQuery} albumInfoRemoteSearchQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMusicAlbumRemoteSearchResults: async (albumInfoRemoteSearchQuery: AlbumInfoRemoteSearchQuery, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'albumInfoRemoteSearchQuery' is not null or undefined
            if (albumInfoRemoteSearchQuery === null || albumInfoRemoteSearchQuery === undefined) {
                throw new RequiredError('albumInfoRemoteSearchQuery','Required parameter albumInfoRemoteSearchQuery was null or undefined when calling getMusicAlbumRemoteSearchResults.');
            }
            const localVarPath = `/Items/RemoteSearch/MusicAlbum`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof albumInfoRemoteSearchQuery !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(albumInfoRemoteSearchQuery !== undefined ? albumInfoRemoteSearchQuery : {}) : (albumInfoRemoteSearchQuery || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ArtistInfoRemoteSearchQuery} artistInfoRemoteSearchQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMusicArtistRemoteSearchResults: async (artistInfoRemoteSearchQuery: ArtistInfoRemoteSearchQuery, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'artistInfoRemoteSearchQuery' is not null or undefined
            if (artistInfoRemoteSearchQuery === null || artistInfoRemoteSearchQuery === undefined) {
                throw new RequiredError('artistInfoRemoteSearchQuery','Required parameter artistInfoRemoteSearchQuery was null or undefined when calling getMusicArtistRemoteSearchResults.');
            }
            const localVarPath = `/Items/RemoteSearch/MusicArtist`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof artistInfoRemoteSearchQuery !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(artistInfoRemoteSearchQuery !== undefined ? artistInfoRemoteSearchQuery : {}) : (artistInfoRemoteSearchQuery || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {MusicVideoInfoRemoteSearchQuery} musicVideoInfoRemoteSearchQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMusicVideoRemoteSearchResults: async (musicVideoInfoRemoteSearchQuery: MusicVideoInfoRemoteSearchQuery, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'musicVideoInfoRemoteSearchQuery' is not null or undefined
            if (musicVideoInfoRemoteSearchQuery === null || musicVideoInfoRemoteSearchQuery === undefined) {
                throw new RequiredError('musicVideoInfoRemoteSearchQuery','Required parameter musicVideoInfoRemoteSearchQuery was null or undefined when calling getMusicVideoRemoteSearchResults.');
            }
            const localVarPath = `/Items/RemoteSearch/MusicVideo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof musicVideoInfoRemoteSearchQuery !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(musicVideoInfoRemoteSearchQuery !== undefined ? musicVideoInfoRemoteSearchQuery : {}) : (musicVideoInfoRemoteSearchQuery || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PersonLookupInfoRemoteSearchQuery} personLookupInfoRemoteSearchQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonRemoteSearchResults: async (personLookupInfoRemoteSearchQuery: PersonLookupInfoRemoteSearchQuery, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'personLookupInfoRemoteSearchQuery' is not null or undefined
            if (personLookupInfoRemoteSearchQuery === null || personLookupInfoRemoteSearchQuery === undefined) {
                throw new RequiredError('personLookupInfoRemoteSearchQuery','Required parameter personLookupInfoRemoteSearchQuery was null or undefined when calling getPersonRemoteSearchResults.');
            }
            const localVarPath = `/Items/RemoteSearch/Person`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof personLookupInfoRemoteSearchQuery !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(personLookupInfoRemoteSearchQuery !== undefined ? personLookupInfoRemoteSearchQuery : {}) : (personLookupInfoRemoteSearchQuery || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} imageUrl 
         * @param {string} providerName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRemoteSearchImage: async (imageUrl: string, providerName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'imageUrl' is not null or undefined
            if (imageUrl === null || imageUrl === undefined) {
                throw new RequiredError('imageUrl','Required parameter imageUrl was null or undefined when calling getRemoteSearchImage.');
            }
            // verify required parameter 'providerName' is not null or undefined
            if (providerName === null || providerName === undefined) {
                throw new RequiredError('providerName','Required parameter providerName was null or undefined when calling getRemoteSearchImage.');
            }
            const localVarPath = `/Items/RemoteSearch/Image`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (imageUrl !== undefined) {
                localVarQueryParameter['imageUrl'] = imageUrl;
            }

            if (providerName !== undefined) {
                localVarQueryParameter['providerName'] = providerName;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SeriesInfoRemoteSearchQuery} seriesInfoRemoteSearchQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSeriesRemoteSearchResults: async (seriesInfoRemoteSearchQuery: SeriesInfoRemoteSearchQuery, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'seriesInfoRemoteSearchQuery' is not null or undefined
            if (seriesInfoRemoteSearchQuery === null || seriesInfoRemoteSearchQuery === undefined) {
                throw new RequiredError('seriesInfoRemoteSearchQuery','Required parameter seriesInfoRemoteSearchQuery was null or undefined when calling getSeriesRemoteSearchResults.');
            }
            const localVarPath = `/Items/RemoteSearch/Series`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof seriesInfoRemoteSearchQuery !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(seriesInfoRemoteSearchQuery !== undefined ? seriesInfoRemoteSearchQuery : {}) : (seriesInfoRemoteSearchQuery || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TrailerInfoRemoteSearchQuery} trailerInfoRemoteSearchQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrailerRemoteSearchResults: async (trailerInfoRemoteSearchQuery: TrailerInfoRemoteSearchQuery, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'trailerInfoRemoteSearchQuery' is not null or undefined
            if (trailerInfoRemoteSearchQuery === null || trailerInfoRemoteSearchQuery === undefined) {
                throw new RequiredError('trailerInfoRemoteSearchQuery','Required parameter trailerInfoRemoteSearchQuery was null or undefined when calling getTrailerRemoteSearchResults.');
            }
            const localVarPath = `/Items/RemoteSearch/Trailer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof trailerInfoRemoteSearchQuery !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(trailerInfoRemoteSearchQuery !== undefined ? trailerInfoRemoteSearchQuery : {}) : (trailerInfoRemoteSearchQuery || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemLookupApi - functional programming interface
 * @export
 */
export const ItemLookupApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} itemId 
         * @param {string} id 
         * @param {RemoteSearchResult} remoteSearchResult 
         * @param {boolean} [replaceAllImages] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async applySearchCriteria(itemId: string, id: string, remoteSearchResult: RemoteSearchResult, replaceAllImages?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ItemLookupApiAxiosParamCreator(configuration).applySearchCriteria(itemId, id, remoteSearchResult, replaceAllImages, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {BookInfoRemoteSearchQuery} bookInfoRemoteSearchQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBookRemoteSearchResults(bookInfoRemoteSearchQuery: BookInfoRemoteSearchQuery, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RemoteSearchResult>>> {
            const localVarAxiosArgs = await ItemLookupApiAxiosParamCreator(configuration).getBookRemoteSearchResults(bookInfoRemoteSearchQuery, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {BoxSetInfoRemoteSearchQuery} boxSetInfoRemoteSearchQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBoxSetRemoteSearchResults(boxSetInfoRemoteSearchQuery: BoxSetInfoRemoteSearchQuery, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RemoteSearchResult>>> {
            const localVarAxiosArgs = await ItemLookupApiAxiosParamCreator(configuration).getBoxSetRemoteSearchResults(boxSetInfoRemoteSearchQuery, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExternalIdInfos(itemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ExternalIdInfo>>> {
            const localVarAxiosArgs = await ItemLookupApiAxiosParamCreator(configuration).getExternalIdInfos(itemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {MovieInfoRemoteSearchQuery} movieInfoRemoteSearchQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMovieRemoteSearchResults(movieInfoRemoteSearchQuery: MovieInfoRemoteSearchQuery, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RemoteSearchResult>>> {
            const localVarAxiosArgs = await ItemLookupApiAxiosParamCreator(configuration).getMovieRemoteSearchResults(movieInfoRemoteSearchQuery, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {AlbumInfoRemoteSearchQuery} albumInfoRemoteSearchQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMusicAlbumRemoteSearchResults(albumInfoRemoteSearchQuery: AlbumInfoRemoteSearchQuery, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RemoteSearchResult>>> {
            const localVarAxiosArgs = await ItemLookupApiAxiosParamCreator(configuration).getMusicAlbumRemoteSearchResults(albumInfoRemoteSearchQuery, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {ArtistInfoRemoteSearchQuery} artistInfoRemoteSearchQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMusicArtistRemoteSearchResults(artistInfoRemoteSearchQuery: ArtistInfoRemoteSearchQuery, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RemoteSearchResult>>> {
            const localVarAxiosArgs = await ItemLookupApiAxiosParamCreator(configuration).getMusicArtistRemoteSearchResults(artistInfoRemoteSearchQuery, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {MusicVideoInfoRemoteSearchQuery} musicVideoInfoRemoteSearchQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMusicVideoRemoteSearchResults(musicVideoInfoRemoteSearchQuery: MusicVideoInfoRemoteSearchQuery, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RemoteSearchResult>>> {
            const localVarAxiosArgs = await ItemLookupApiAxiosParamCreator(configuration).getMusicVideoRemoteSearchResults(musicVideoInfoRemoteSearchQuery, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {PersonLookupInfoRemoteSearchQuery} personLookupInfoRemoteSearchQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPersonRemoteSearchResults(personLookupInfoRemoteSearchQuery: PersonLookupInfoRemoteSearchQuery, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RemoteSearchResult>>> {
            const localVarAxiosArgs = await ItemLookupApiAxiosParamCreator(configuration).getPersonRemoteSearchResults(personLookupInfoRemoteSearchQuery, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} imageUrl 
         * @param {string} providerName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRemoteSearchImage(imageUrl: string, providerName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ItemLookupApiAxiosParamCreator(configuration).getRemoteSearchImage(imageUrl, providerName, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {SeriesInfoRemoteSearchQuery} seriesInfoRemoteSearchQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSeriesRemoteSearchResults(seriesInfoRemoteSearchQuery: SeriesInfoRemoteSearchQuery, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RemoteSearchResult>>> {
            const localVarAxiosArgs = await ItemLookupApiAxiosParamCreator(configuration).getSeriesRemoteSearchResults(seriesInfoRemoteSearchQuery, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {TrailerInfoRemoteSearchQuery} trailerInfoRemoteSearchQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTrailerRemoteSearchResults(trailerInfoRemoteSearchQuery: TrailerInfoRemoteSearchQuery, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RemoteSearchResult>>> {
            const localVarAxiosArgs = await ItemLookupApiAxiosParamCreator(configuration).getTrailerRemoteSearchResults(trailerInfoRemoteSearchQuery, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ItemLookupApi - factory interface
 * @export
 */
export const ItemLookupApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} itemId 
         * @param {string} id 
         * @param {RemoteSearchResult} remoteSearchResult 
         * @param {boolean} [replaceAllImages] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applySearchCriteria(itemId: string, id: string, remoteSearchResult: RemoteSearchResult, replaceAllImages?: boolean, options?: any): AxiosPromise<void> {
            return ItemLookupApiFp(configuration).applySearchCriteria(itemId, id, remoteSearchResult, replaceAllImages, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {BookInfoRemoteSearchQuery} bookInfoRemoteSearchQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBookRemoteSearchResults(bookInfoRemoteSearchQuery: BookInfoRemoteSearchQuery, options?: any): AxiosPromise<Array<RemoteSearchResult>> {
            return ItemLookupApiFp(configuration).getBookRemoteSearchResults(bookInfoRemoteSearchQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {BoxSetInfoRemoteSearchQuery} boxSetInfoRemoteSearchQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBoxSetRemoteSearchResults(boxSetInfoRemoteSearchQuery: BoxSetInfoRemoteSearchQuery, options?: any): AxiosPromise<Array<RemoteSearchResult>> {
            return ItemLookupApiFp(configuration).getBoxSetRemoteSearchResults(boxSetInfoRemoteSearchQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExternalIdInfos(itemId: string, options?: any): AxiosPromise<Array<ExternalIdInfo>> {
            return ItemLookupApiFp(configuration).getExternalIdInfos(itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {MovieInfoRemoteSearchQuery} movieInfoRemoteSearchQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMovieRemoteSearchResults(movieInfoRemoteSearchQuery: MovieInfoRemoteSearchQuery, options?: any): AxiosPromise<Array<RemoteSearchResult>> {
            return ItemLookupApiFp(configuration).getMovieRemoteSearchResults(movieInfoRemoteSearchQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AlbumInfoRemoteSearchQuery} albumInfoRemoteSearchQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMusicAlbumRemoteSearchResults(albumInfoRemoteSearchQuery: AlbumInfoRemoteSearchQuery, options?: any): AxiosPromise<Array<RemoteSearchResult>> {
            return ItemLookupApiFp(configuration).getMusicAlbumRemoteSearchResults(albumInfoRemoteSearchQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ArtistInfoRemoteSearchQuery} artistInfoRemoteSearchQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMusicArtistRemoteSearchResults(artistInfoRemoteSearchQuery: ArtistInfoRemoteSearchQuery, options?: any): AxiosPromise<Array<RemoteSearchResult>> {
            return ItemLookupApiFp(configuration).getMusicArtistRemoteSearchResults(artistInfoRemoteSearchQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {MusicVideoInfoRemoteSearchQuery} musicVideoInfoRemoteSearchQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMusicVideoRemoteSearchResults(musicVideoInfoRemoteSearchQuery: MusicVideoInfoRemoteSearchQuery, options?: any): AxiosPromise<Array<RemoteSearchResult>> {
            return ItemLookupApiFp(configuration).getMusicVideoRemoteSearchResults(musicVideoInfoRemoteSearchQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PersonLookupInfoRemoteSearchQuery} personLookupInfoRemoteSearchQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonRemoteSearchResults(personLookupInfoRemoteSearchQuery: PersonLookupInfoRemoteSearchQuery, options?: any): AxiosPromise<Array<RemoteSearchResult>> {
            return ItemLookupApiFp(configuration).getPersonRemoteSearchResults(personLookupInfoRemoteSearchQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} imageUrl 
         * @param {string} providerName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRemoteSearchImage(imageUrl: string, providerName: string, options?: any): AxiosPromise<void> {
            return ItemLookupApiFp(configuration).getRemoteSearchImage(imageUrl, providerName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SeriesInfoRemoteSearchQuery} seriesInfoRemoteSearchQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSeriesRemoteSearchResults(seriesInfoRemoteSearchQuery: SeriesInfoRemoteSearchQuery, options?: any): AxiosPromise<Array<RemoteSearchResult>> {
            return ItemLookupApiFp(configuration).getSeriesRemoteSearchResults(seriesInfoRemoteSearchQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TrailerInfoRemoteSearchQuery} trailerInfoRemoteSearchQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrailerRemoteSearchResults(trailerInfoRemoteSearchQuery: TrailerInfoRemoteSearchQuery, options?: any): AxiosPromise<Array<RemoteSearchResult>> {
            return ItemLookupApiFp(configuration).getTrailerRemoteSearchResults(trailerInfoRemoteSearchQuery, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for applySearchCriteria operation in ItemLookupApi.
 * @export
 * @interface ItemLookupApiApplySearchCriteriaRequest
 */
export interface ItemLookupApiApplySearchCriteriaRequest {
    /**
     * 
     * @type {string}
     * @memberof ItemLookupApiApplySearchCriteria
     */
    readonly itemId: string

    /**
     * 
     * @type {string}
     * @memberof ItemLookupApiApplySearchCriteria
     */
    readonly id: string

    /**
     * 
     * @type {RemoteSearchResult}
     * @memberof ItemLookupApiApplySearchCriteria
     */
    readonly remoteSearchResult: RemoteSearchResult

    /**
     * 
     * @type {boolean}
     * @memberof ItemLookupApiApplySearchCriteria
     */
    readonly replaceAllImages?: boolean
}

/**
 * Request parameters for getBookRemoteSearchResults operation in ItemLookupApi.
 * @export
 * @interface ItemLookupApiGetBookRemoteSearchResultsRequest
 */
export interface ItemLookupApiGetBookRemoteSearchResultsRequest {
    /**
     * 
     * @type {BookInfoRemoteSearchQuery}
     * @memberof ItemLookupApiGetBookRemoteSearchResults
     */
    readonly bookInfoRemoteSearchQuery: BookInfoRemoteSearchQuery
}

/**
 * Request parameters for getBoxSetRemoteSearchResults operation in ItemLookupApi.
 * @export
 * @interface ItemLookupApiGetBoxSetRemoteSearchResultsRequest
 */
export interface ItemLookupApiGetBoxSetRemoteSearchResultsRequest {
    /**
     * 
     * @type {BoxSetInfoRemoteSearchQuery}
     * @memberof ItemLookupApiGetBoxSetRemoteSearchResults
     */
    readonly boxSetInfoRemoteSearchQuery: BoxSetInfoRemoteSearchQuery
}

/**
 * Request parameters for getExternalIdInfos operation in ItemLookupApi.
 * @export
 * @interface ItemLookupApiGetExternalIdInfosRequest
 */
export interface ItemLookupApiGetExternalIdInfosRequest {
    /**
     * 
     * @type {string}
     * @memberof ItemLookupApiGetExternalIdInfos
     */
    readonly itemId: string
}

/**
 * Request parameters for getMovieRemoteSearchResults operation in ItemLookupApi.
 * @export
 * @interface ItemLookupApiGetMovieRemoteSearchResultsRequest
 */
export interface ItemLookupApiGetMovieRemoteSearchResultsRequest {
    /**
     * 
     * @type {MovieInfoRemoteSearchQuery}
     * @memberof ItemLookupApiGetMovieRemoteSearchResults
     */
    readonly movieInfoRemoteSearchQuery: MovieInfoRemoteSearchQuery
}

/**
 * Request parameters for getMusicAlbumRemoteSearchResults operation in ItemLookupApi.
 * @export
 * @interface ItemLookupApiGetMusicAlbumRemoteSearchResultsRequest
 */
export interface ItemLookupApiGetMusicAlbumRemoteSearchResultsRequest {
    /**
     * 
     * @type {AlbumInfoRemoteSearchQuery}
     * @memberof ItemLookupApiGetMusicAlbumRemoteSearchResults
     */
    readonly albumInfoRemoteSearchQuery: AlbumInfoRemoteSearchQuery
}

/**
 * Request parameters for getMusicArtistRemoteSearchResults operation in ItemLookupApi.
 * @export
 * @interface ItemLookupApiGetMusicArtistRemoteSearchResultsRequest
 */
export interface ItemLookupApiGetMusicArtistRemoteSearchResultsRequest {
    /**
     * 
     * @type {ArtistInfoRemoteSearchQuery}
     * @memberof ItemLookupApiGetMusicArtistRemoteSearchResults
     */
    readonly artistInfoRemoteSearchQuery: ArtistInfoRemoteSearchQuery
}

/**
 * Request parameters for getMusicVideoRemoteSearchResults operation in ItemLookupApi.
 * @export
 * @interface ItemLookupApiGetMusicVideoRemoteSearchResultsRequest
 */
export interface ItemLookupApiGetMusicVideoRemoteSearchResultsRequest {
    /**
     * 
     * @type {MusicVideoInfoRemoteSearchQuery}
     * @memberof ItemLookupApiGetMusicVideoRemoteSearchResults
     */
    readonly musicVideoInfoRemoteSearchQuery: MusicVideoInfoRemoteSearchQuery
}

/**
 * Request parameters for getPersonRemoteSearchResults operation in ItemLookupApi.
 * @export
 * @interface ItemLookupApiGetPersonRemoteSearchResultsRequest
 */
export interface ItemLookupApiGetPersonRemoteSearchResultsRequest {
    /**
     * 
     * @type {PersonLookupInfoRemoteSearchQuery}
     * @memberof ItemLookupApiGetPersonRemoteSearchResults
     */
    readonly personLookupInfoRemoteSearchQuery: PersonLookupInfoRemoteSearchQuery
}

/**
 * Request parameters for getRemoteSearchImage operation in ItemLookupApi.
 * @export
 * @interface ItemLookupApiGetRemoteSearchImageRequest
 */
export interface ItemLookupApiGetRemoteSearchImageRequest {
    /**
     * 
     * @type {string}
     * @memberof ItemLookupApiGetRemoteSearchImage
     */
    readonly imageUrl: string

    /**
     * 
     * @type {string}
     * @memberof ItemLookupApiGetRemoteSearchImage
     */
    readonly providerName: string
}

/**
 * Request parameters for getSeriesRemoteSearchResults operation in ItemLookupApi.
 * @export
 * @interface ItemLookupApiGetSeriesRemoteSearchResultsRequest
 */
export interface ItemLookupApiGetSeriesRemoteSearchResultsRequest {
    /**
     * 
     * @type {SeriesInfoRemoteSearchQuery}
     * @memberof ItemLookupApiGetSeriesRemoteSearchResults
     */
    readonly seriesInfoRemoteSearchQuery: SeriesInfoRemoteSearchQuery
}

/**
 * Request parameters for getTrailerRemoteSearchResults operation in ItemLookupApi.
 * @export
 * @interface ItemLookupApiGetTrailerRemoteSearchResultsRequest
 */
export interface ItemLookupApiGetTrailerRemoteSearchResultsRequest {
    /**
     * 
     * @type {TrailerInfoRemoteSearchQuery}
     * @memberof ItemLookupApiGetTrailerRemoteSearchResults
     */
    readonly trailerInfoRemoteSearchQuery: TrailerInfoRemoteSearchQuery
}

/**
 * ItemLookupApi - object-oriented interface
 * @export
 * @class ItemLookupApi
 * @extends {BaseAPI}
 */
export class ItemLookupApi extends BaseAPI {
    /**
     * 
     * @param {ItemLookupApiApplySearchCriteriaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemLookupApi
     */
    public applySearchCriteria(requestParameters: ItemLookupApiApplySearchCriteriaRequest, options?: any) {
        return ItemLookupApiFp(this.configuration).applySearchCriteria(requestParameters.itemId, requestParameters.id, requestParameters.remoteSearchResult, requestParameters.replaceAllImages, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ItemLookupApiGetBookRemoteSearchResultsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemLookupApi
     */
    public getBookRemoteSearchResults(requestParameters: ItemLookupApiGetBookRemoteSearchResultsRequest, options?: any) {
        return ItemLookupApiFp(this.configuration).getBookRemoteSearchResults(requestParameters.bookInfoRemoteSearchQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ItemLookupApiGetBoxSetRemoteSearchResultsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemLookupApi
     */
    public getBoxSetRemoteSearchResults(requestParameters: ItemLookupApiGetBoxSetRemoteSearchResultsRequest, options?: any) {
        return ItemLookupApiFp(this.configuration).getBoxSetRemoteSearchResults(requestParameters.boxSetInfoRemoteSearchQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ItemLookupApiGetExternalIdInfosRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemLookupApi
     */
    public getExternalIdInfos(requestParameters: ItemLookupApiGetExternalIdInfosRequest, options?: any) {
        return ItemLookupApiFp(this.configuration).getExternalIdInfos(requestParameters.itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ItemLookupApiGetMovieRemoteSearchResultsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemLookupApi
     */
    public getMovieRemoteSearchResults(requestParameters: ItemLookupApiGetMovieRemoteSearchResultsRequest, options?: any) {
        return ItemLookupApiFp(this.configuration).getMovieRemoteSearchResults(requestParameters.movieInfoRemoteSearchQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ItemLookupApiGetMusicAlbumRemoteSearchResultsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemLookupApi
     */
    public getMusicAlbumRemoteSearchResults(requestParameters: ItemLookupApiGetMusicAlbumRemoteSearchResultsRequest, options?: any) {
        return ItemLookupApiFp(this.configuration).getMusicAlbumRemoteSearchResults(requestParameters.albumInfoRemoteSearchQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ItemLookupApiGetMusicArtistRemoteSearchResultsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemLookupApi
     */
    public getMusicArtistRemoteSearchResults(requestParameters: ItemLookupApiGetMusicArtistRemoteSearchResultsRequest, options?: any) {
        return ItemLookupApiFp(this.configuration).getMusicArtistRemoteSearchResults(requestParameters.artistInfoRemoteSearchQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ItemLookupApiGetMusicVideoRemoteSearchResultsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemLookupApi
     */
    public getMusicVideoRemoteSearchResults(requestParameters: ItemLookupApiGetMusicVideoRemoteSearchResultsRequest, options?: any) {
        return ItemLookupApiFp(this.configuration).getMusicVideoRemoteSearchResults(requestParameters.musicVideoInfoRemoteSearchQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ItemLookupApiGetPersonRemoteSearchResultsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemLookupApi
     */
    public getPersonRemoteSearchResults(requestParameters: ItemLookupApiGetPersonRemoteSearchResultsRequest, options?: any) {
        return ItemLookupApiFp(this.configuration).getPersonRemoteSearchResults(requestParameters.personLookupInfoRemoteSearchQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ItemLookupApiGetRemoteSearchImageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemLookupApi
     */
    public getRemoteSearchImage(requestParameters: ItemLookupApiGetRemoteSearchImageRequest, options?: any) {
        return ItemLookupApiFp(this.configuration).getRemoteSearchImage(requestParameters.imageUrl, requestParameters.providerName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ItemLookupApiGetSeriesRemoteSearchResultsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemLookupApi
     */
    public getSeriesRemoteSearchResults(requestParameters: ItemLookupApiGetSeriesRemoteSearchResultsRequest, options?: any) {
        return ItemLookupApiFp(this.configuration).getSeriesRemoteSearchResults(requestParameters.seriesInfoRemoteSearchQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ItemLookupApiGetTrailerRemoteSearchResultsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemLookupApi
     */
    public getTrailerRemoteSearchResults(requestParameters: ItemLookupApiGetTrailerRemoteSearchResultsRequest, options?: any) {
        return ItemLookupApiFp(this.configuration).getTrailerRemoteSearchResults(requestParameters.trailerInfoRemoteSearchQuery, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ItemRefreshApi - axios parameter creator
 * @export
 */
export const ItemRefreshApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} itemId 
         * @param {MetadataRefreshMode} [metadataRefreshMode] 
         * @param {MetadataRefreshMode} [imageRefreshMode] 
         * @param {boolean} [replaceAllMetadata] 
         * @param {boolean} [replaceAllImages] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post: async (itemId: string, metadataRefreshMode?: MetadataRefreshMode, imageRefreshMode?: MetadataRefreshMode, replaceAllMetadata?: boolean, replaceAllImages?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling post.');
            }
            const localVarPath = `/Items/{itemId}/Refresh`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (metadataRefreshMode !== undefined) {
                localVarQueryParameter['metadataRefreshMode'] = metadataRefreshMode;
            }

            if (imageRefreshMode !== undefined) {
                localVarQueryParameter['imageRefreshMode'] = imageRefreshMode;
            }

            if (replaceAllMetadata !== undefined) {
                localVarQueryParameter['replaceAllMetadata'] = replaceAllMetadata;
            }

            if (replaceAllImages !== undefined) {
                localVarQueryParameter['replaceAllImages'] = replaceAllImages;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemRefreshApi - functional programming interface
 * @export
 */
export const ItemRefreshApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} itemId 
         * @param {MetadataRefreshMode} [metadataRefreshMode] 
         * @param {MetadataRefreshMode} [imageRefreshMode] 
         * @param {boolean} [replaceAllMetadata] 
         * @param {boolean} [replaceAllImages] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async post(itemId: string, metadataRefreshMode?: MetadataRefreshMode, imageRefreshMode?: MetadataRefreshMode, replaceAllMetadata?: boolean, replaceAllImages?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ItemRefreshApiAxiosParamCreator(configuration).post(itemId, metadataRefreshMode, imageRefreshMode, replaceAllMetadata, replaceAllImages, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ItemRefreshApi - factory interface
 * @export
 */
export const ItemRefreshApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} itemId 
         * @param {MetadataRefreshMode} [metadataRefreshMode] 
         * @param {MetadataRefreshMode} [imageRefreshMode] 
         * @param {boolean} [replaceAllMetadata] 
         * @param {boolean} [replaceAllImages] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        post(itemId: string, metadataRefreshMode?: MetadataRefreshMode, imageRefreshMode?: MetadataRefreshMode, replaceAllMetadata?: boolean, replaceAllImages?: boolean, options?: any): AxiosPromise<void> {
            return ItemRefreshApiFp(configuration).post(itemId, metadataRefreshMode, imageRefreshMode, replaceAllMetadata, replaceAllImages, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for post operation in ItemRefreshApi.
 * @export
 * @interface ItemRefreshApiPostRequest
 */
export interface ItemRefreshApiPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ItemRefreshApiPost
     */
    readonly itemId: string

    /**
     * 
     * @type {MetadataRefreshMode}
     * @memberof ItemRefreshApiPost
     */
    readonly metadataRefreshMode?: MetadataRefreshMode

    /**
     * 
     * @type {MetadataRefreshMode}
     * @memberof ItemRefreshApiPost
     */
    readonly imageRefreshMode?: MetadataRefreshMode

    /**
     * 
     * @type {boolean}
     * @memberof ItemRefreshApiPost
     */
    readonly replaceAllMetadata?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ItemRefreshApiPost
     */
    readonly replaceAllImages?: boolean
}

/**
 * ItemRefreshApi - object-oriented interface
 * @export
 * @class ItemRefreshApi
 * @extends {BaseAPI}
 */
export class ItemRefreshApi extends BaseAPI {
    /**
     * 
     * @param {ItemRefreshApiPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemRefreshApi
     */
    public post(requestParameters: ItemRefreshApiPostRequest, options?: any) {
        return ItemRefreshApiFp(this.configuration).post(requestParameters.itemId, requestParameters.metadataRefreshMode, requestParameters.imageRefreshMode, requestParameters.replaceAllMetadata, requestParameters.replaceAllImages, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ItemUpdateApi - axios parameter creator
 * @export
 */
export const ItemUpdateApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadataEditorInfo: async (itemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getMetadataEditorInfo.');
            }
            const localVarPath = `/Items/{itemId}/MetadataEditor`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {BaseItemDto} baseItemDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItem: async (itemId: string, baseItemDto: BaseItemDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling updateItem.');
            }
            // verify required parameter 'baseItemDto' is not null or undefined
            if (baseItemDto === null || baseItemDto === undefined) {
                throw new RequiredError('baseItemDto','Required parameter baseItemDto was null or undefined when calling updateItem.');
            }
            const localVarPath = `/Items/{itemId}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof baseItemDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(baseItemDto !== undefined ? baseItemDto : {}) : (baseItemDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} contentType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItemContentType: async (itemId: string, contentType: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling updateItemContentType.');
            }
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType','Required parameter contentType was null or undefined when calling updateItemContentType.');
            }
            const localVarPath = `/Items/{itemId}/ContentType`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (contentType !== undefined) {
                localVarQueryParameter['contentType'] = contentType;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemUpdateApi - functional programming interface
 * @export
 */
export const ItemUpdateApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetadataEditorInfo(itemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetadataEditorInfo>> {
            const localVarAxiosArgs = await ItemUpdateApiAxiosParamCreator(configuration).getMetadataEditorInfo(itemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {BaseItemDto} baseItemDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateItem(itemId: string, baseItemDto: BaseItemDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ItemUpdateApiAxiosParamCreator(configuration).updateItem(itemId, baseItemDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} contentType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateItemContentType(itemId: string, contentType: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ItemUpdateApiAxiosParamCreator(configuration).updateItemContentType(itemId, contentType, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ItemUpdateApi - factory interface
 * @export
 */
export const ItemUpdateApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadataEditorInfo(itemId: string, options?: any): AxiosPromise<MetadataEditorInfo> {
            return ItemUpdateApiFp(configuration).getMetadataEditorInfo(itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} itemId 
         * @param {BaseItemDto} baseItemDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItem(itemId: string, baseItemDto: BaseItemDto, options?: any): AxiosPromise<void> {
            return ItemUpdateApiFp(configuration).updateItem(itemId, baseItemDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} contentType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItemContentType(itemId: string, contentType: string, options?: any): AxiosPromise<void> {
            return ItemUpdateApiFp(configuration).updateItemContentType(itemId, contentType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getMetadataEditorInfo operation in ItemUpdateApi.
 * @export
 * @interface ItemUpdateApiGetMetadataEditorInfoRequest
 */
export interface ItemUpdateApiGetMetadataEditorInfoRequest {
    /**
     * 
     * @type {string}
     * @memberof ItemUpdateApiGetMetadataEditorInfo
     */
    readonly itemId: string
}

/**
 * Request parameters for updateItem operation in ItemUpdateApi.
 * @export
 * @interface ItemUpdateApiUpdateItemRequest
 */
export interface ItemUpdateApiUpdateItemRequest {
    /**
     * 
     * @type {string}
     * @memberof ItemUpdateApiUpdateItem
     */
    readonly itemId: string

    /**
     * 
     * @type {BaseItemDto}
     * @memberof ItemUpdateApiUpdateItem
     */
    readonly baseItemDto: BaseItemDto
}

/**
 * Request parameters for updateItemContentType operation in ItemUpdateApi.
 * @export
 * @interface ItemUpdateApiUpdateItemContentTypeRequest
 */
export interface ItemUpdateApiUpdateItemContentTypeRequest {
    /**
     * 
     * @type {string}
     * @memberof ItemUpdateApiUpdateItemContentType
     */
    readonly itemId: string

    /**
     * 
     * @type {string}
     * @memberof ItemUpdateApiUpdateItemContentType
     */
    readonly contentType: string
}

/**
 * ItemUpdateApi - object-oriented interface
 * @export
 * @class ItemUpdateApi
 * @extends {BaseAPI}
 */
export class ItemUpdateApi extends BaseAPI {
    /**
     * 
     * @param {ItemUpdateApiGetMetadataEditorInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemUpdateApi
     */
    public getMetadataEditorInfo(requestParameters: ItemUpdateApiGetMetadataEditorInfoRequest, options?: any) {
        return ItemUpdateApiFp(this.configuration).getMetadataEditorInfo(requestParameters.itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ItemUpdateApiUpdateItemRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemUpdateApi
     */
    public updateItem(requestParameters: ItemUpdateApiUpdateItemRequest, options?: any) {
        return ItemUpdateApiFp(this.configuration).updateItem(requestParameters.itemId, requestParameters.baseItemDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ItemUpdateApiUpdateItemContentTypeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemUpdateApi
     */
    public updateItemContentType(requestParameters: ItemUpdateApiUpdateItemContentTypeRequest, options?: any) {
        return ItemUpdateApiFp(this.configuration).updateItemContentType(requestParameters.itemId, requestParameters.contentType, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ItemsApi - axios parameter creator
 * @export
 */
export const ItemsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} uId 
         * @param {string} [userId] 
         * @param {string} [maxOfficialRating] 
         * @param {boolean} [hasThemeSong] 
         * @param {boolean} [hasThemeVideo] 
         * @param {boolean} [hasSubtitles] 
         * @param {boolean} [hasSpecialFeature] 
         * @param {boolean} [hasTrailer] 
         * @param {string} [adjacentTo] 
         * @param {number} [parentIndexNumber] 
         * @param {boolean} [hasParentalRating] 
         * @param {boolean} [isHd] 
         * @param {boolean} [is4K] 
         * @param {string} [locationTypes] 
         * @param {string} [excludeLocationTypes] 
         * @param {boolean} [isMissing] 
         * @param {boolean} [isUnaired] 
         * @param {number} [minCommunityRating] 
         * @param {number} [minCriticRating] 
         * @param {string} [minPremiereDate] 
         * @param {string} [minDateLastSaved] 
         * @param {string} [minDateLastSavedForUser] 
         * @param {string} [maxPremiereDate] 
         * @param {boolean} [hasOverview] 
         * @param {boolean} [hasImdbId] 
         * @param {boolean} [hasTmdbId] 
         * @param {boolean} [hasTvdbId] 
         * @param {string} [excludeItemIds] 
         * @param {number} [startIndex] 
         * @param {number} [limit] 
         * @param {boolean} [recursive] 
         * @param {string} [searchTerm] 
         * @param {string} [sortOrder] 
         * @param {string} [parentId] 
         * @param {string} [fields] 
         * @param {string} [excludeItemTypes] 
         * @param {string} [includeItemTypes] 
         * @param {string} [filters] 
         * @param {boolean} [isFavorite] 
         * @param {string} [mediaTypes] 
         * @param {string} [imageTypes] 
         * @param {string} [sortBy] 
         * @param {boolean} [isPlayed] 
         * @param {string} [genres] 
         * @param {string} [officialRatings] 
         * @param {string} [tags] 
         * @param {string} [years] 
         * @param {boolean} [enableUserData] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {string} [person] 
         * @param {string} [personIds] 
         * @param {string} [personTypes] 
         * @param {string} [studios] 
         * @param {string} [artists] 
         * @param {string} [excludeArtistIds] 
         * @param {string} [artistIds] 
         * @param {string} [albumArtistIds] 
         * @param {string} [contributingArtistIds] 
         * @param {string} [albums] 
         * @param {string} [albumIds] 
         * @param {string} [ids] 
         * @param {string} [videoTypes] 
         * @param {string} [minOfficialRating] 
         * @param {boolean} [isLocked] 
         * @param {boolean} [isPlaceHolder] 
         * @param {boolean} [hasOfficialRating] 
         * @param {boolean} [collapseBoxSetItems] 
         * @param {number} [minWidth] 
         * @param {number} [minHeight] 
         * @param {number} [maxWidth] 
         * @param {number} [maxHeight] 
         * @param {boolean} [is3D] 
         * @param {string} [seriesStatus] 
         * @param {string} [nameStartsWithOrGreater] 
         * @param {string} [nameStartsWith] 
         * @param {string} [nameLessThan] 
         * @param {string} [studioIds] 
         * @param {string} [genreIds] 
         * @param {boolean} [enableTotalRecordCount] 
         * @param {boolean} [enableImages] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItems: async (uId: string, userId?: string, maxOfficialRating?: string, hasThemeSong?: boolean, hasThemeVideo?: boolean, hasSubtitles?: boolean, hasSpecialFeature?: boolean, hasTrailer?: boolean, adjacentTo?: string, parentIndexNumber?: number, hasParentalRating?: boolean, isHd?: boolean, is4K?: boolean, locationTypes?: string, excludeLocationTypes?: string, isMissing?: boolean, isUnaired?: boolean, minCommunityRating?: number, minCriticRating?: number, minPremiereDate?: string, minDateLastSaved?: string, minDateLastSavedForUser?: string, maxPremiereDate?: string, hasOverview?: boolean, hasImdbId?: boolean, hasTmdbId?: boolean, hasTvdbId?: boolean, excludeItemIds?: string, startIndex?: number, limit?: number, recursive?: boolean, searchTerm?: string, sortOrder?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, filters?: string, isFavorite?: boolean, mediaTypes?: string, imageTypes?: string, sortBy?: string, isPlayed?: boolean, genres?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, artists?: string, excludeArtistIds?: string, artistIds?: string, albumArtistIds?: string, contributingArtistIds?: string, albums?: string, albumIds?: string, ids?: string, videoTypes?: string, minOfficialRating?: string, isLocked?: boolean, isPlaceHolder?: boolean, hasOfficialRating?: boolean, collapseBoxSetItems?: boolean, minWidth?: number, minHeight?: number, maxWidth?: number, maxHeight?: number, is3D?: boolean, seriesStatus?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, studioIds?: string, genreIds?: string, enableTotalRecordCount?: boolean, enableImages?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uId' is not null or undefined
            if (uId === null || uId === undefined) {
                throw new RequiredError('uId','Required parameter uId was null or undefined when calling getItems.');
            }
            const localVarPath = `/Items`
                .replace(`{${"uId"}}`, encodeURIComponent(String(uId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (maxOfficialRating !== undefined) {
                localVarQueryParameter['maxOfficialRating'] = maxOfficialRating;
            }

            if (hasThemeSong !== undefined) {
                localVarQueryParameter['hasThemeSong'] = hasThemeSong;
            }

            if (hasThemeVideo !== undefined) {
                localVarQueryParameter['hasThemeVideo'] = hasThemeVideo;
            }

            if (hasSubtitles !== undefined) {
                localVarQueryParameter['hasSubtitles'] = hasSubtitles;
            }

            if (hasSpecialFeature !== undefined) {
                localVarQueryParameter['hasSpecialFeature'] = hasSpecialFeature;
            }

            if (hasTrailer !== undefined) {
                localVarQueryParameter['hasTrailer'] = hasTrailer;
            }

            if (adjacentTo !== undefined) {
                localVarQueryParameter['adjacentTo'] = adjacentTo;
            }

            if (parentIndexNumber !== undefined) {
                localVarQueryParameter['parentIndexNumber'] = parentIndexNumber;
            }

            if (hasParentalRating !== undefined) {
                localVarQueryParameter['hasParentalRating'] = hasParentalRating;
            }

            if (isHd !== undefined) {
                localVarQueryParameter['isHd'] = isHd;
            }

            if (is4K !== undefined) {
                localVarQueryParameter['is4K'] = is4K;
            }

            if (locationTypes !== undefined) {
                localVarQueryParameter['locationTypes'] = locationTypes;
            }

            if (excludeLocationTypes !== undefined) {
                localVarQueryParameter['excludeLocationTypes'] = excludeLocationTypes;
            }

            if (isMissing !== undefined) {
                localVarQueryParameter['isMissing'] = isMissing;
            }

            if (isUnaired !== undefined) {
                localVarQueryParameter['isUnaired'] = isUnaired;
            }

            if (minCommunityRating !== undefined) {
                localVarQueryParameter['minCommunityRating'] = minCommunityRating;
            }

            if (minCriticRating !== undefined) {
                localVarQueryParameter['minCriticRating'] = minCriticRating;
            }

            if (minPremiereDate !== undefined) {
                localVarQueryParameter['minPremiereDate'] = (minPremiereDate as any instanceof Date) ?
                    (minPremiereDate as any).toISOString() :
                    minPremiereDate;
            }

            if (minDateLastSaved !== undefined) {
                localVarQueryParameter['minDateLastSaved'] = (minDateLastSaved as any instanceof Date) ?
                    (minDateLastSaved as any).toISOString() :
                    minDateLastSaved;
            }

            if (minDateLastSavedForUser !== undefined) {
                localVarQueryParameter['minDateLastSavedForUser'] = (minDateLastSavedForUser as any instanceof Date) ?
                    (minDateLastSavedForUser as any).toISOString() :
                    minDateLastSavedForUser;
            }

            if (maxPremiereDate !== undefined) {
                localVarQueryParameter['maxPremiereDate'] = (maxPremiereDate as any instanceof Date) ?
                    (maxPremiereDate as any).toISOString() :
                    maxPremiereDate;
            }

            if (hasOverview !== undefined) {
                localVarQueryParameter['hasOverview'] = hasOverview;
            }

            if (hasImdbId !== undefined) {
                localVarQueryParameter['hasImdbId'] = hasImdbId;
            }

            if (hasTmdbId !== undefined) {
                localVarQueryParameter['hasTmdbId'] = hasTmdbId;
            }

            if (hasTvdbId !== undefined) {
                localVarQueryParameter['hasTvdbId'] = hasTvdbId;
            }

            if (excludeItemIds !== undefined) {
                localVarQueryParameter['excludeItemIds'] = excludeItemIds;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recursive !== undefined) {
                localVarQueryParameter['recursive'] = recursive;
            }

            if (searchTerm !== undefined) {
                localVarQueryParameter['searchTerm'] = searchTerm;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (parentId !== undefined) {
                localVarQueryParameter['parentId'] = parentId;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeItemTypes !== undefined) {
                localVarQueryParameter['excludeItemTypes'] = excludeItemTypes;
            }

            if (includeItemTypes !== undefined) {
                localVarQueryParameter['includeItemTypes'] = includeItemTypes;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (isFavorite !== undefined) {
                localVarQueryParameter['isFavorite'] = isFavorite;
            }

            if (mediaTypes !== undefined) {
                localVarQueryParameter['mediaTypes'] = mediaTypes;
            }

            if (imageTypes !== undefined) {
                localVarQueryParameter['imageTypes'] = imageTypes;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (isPlayed !== undefined) {
                localVarQueryParameter['isPlayed'] = isPlayed;
            }

            if (genres !== undefined) {
                localVarQueryParameter['genres'] = genres;
            }

            if (officialRatings !== undefined) {
                localVarQueryParameter['officialRatings'] = officialRatings;
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }

            if (years !== undefined) {
                localVarQueryParameter['years'] = years;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes !== undefined) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }

            if (person !== undefined) {
                localVarQueryParameter['person'] = person;
            }

            if (personIds !== undefined) {
                localVarQueryParameter['personIds'] = personIds;
            }

            if (personTypes !== undefined) {
                localVarQueryParameter['personTypes'] = personTypes;
            }

            if (studios !== undefined) {
                localVarQueryParameter['studios'] = studios;
            }

            if (artists !== undefined) {
                localVarQueryParameter['artists'] = artists;
            }

            if (excludeArtistIds !== undefined) {
                localVarQueryParameter['excludeArtistIds'] = excludeArtistIds;
            }

            if (artistIds !== undefined) {
                localVarQueryParameter['artistIds'] = artistIds;
            }

            if (albumArtistIds !== undefined) {
                localVarQueryParameter['albumArtistIds'] = albumArtistIds;
            }

            if (contributingArtistIds !== undefined) {
                localVarQueryParameter['contributingArtistIds'] = contributingArtistIds;
            }

            if (albums !== undefined) {
                localVarQueryParameter['albums'] = albums;
            }

            if (albumIds !== undefined) {
                localVarQueryParameter['albumIds'] = albumIds;
            }

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }

            if (videoTypes !== undefined) {
                localVarQueryParameter['videoTypes'] = videoTypes;
            }

            if (minOfficialRating !== undefined) {
                localVarQueryParameter['minOfficialRating'] = minOfficialRating;
            }

            if (isLocked !== undefined) {
                localVarQueryParameter['isLocked'] = isLocked;
            }

            if (isPlaceHolder !== undefined) {
                localVarQueryParameter['isPlaceHolder'] = isPlaceHolder;
            }

            if (hasOfficialRating !== undefined) {
                localVarQueryParameter['hasOfficialRating'] = hasOfficialRating;
            }

            if (collapseBoxSetItems !== undefined) {
                localVarQueryParameter['collapseBoxSetItems'] = collapseBoxSetItems;
            }

            if (minWidth !== undefined) {
                localVarQueryParameter['minWidth'] = minWidth;
            }

            if (minHeight !== undefined) {
                localVarQueryParameter['minHeight'] = minHeight;
            }

            if (maxWidth !== undefined) {
                localVarQueryParameter['maxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['maxHeight'] = maxHeight;
            }

            if (is3D !== undefined) {
                localVarQueryParameter['is3D'] = is3D;
            }

            if (seriesStatus !== undefined) {
                localVarQueryParameter['seriesStatus'] = seriesStatus;
            }

            if (nameStartsWithOrGreater !== undefined) {
                localVarQueryParameter['nameStartsWithOrGreater'] = nameStartsWithOrGreater;
            }

            if (nameStartsWith !== undefined) {
                localVarQueryParameter['nameStartsWith'] = nameStartsWith;
            }

            if (nameLessThan !== undefined) {
                localVarQueryParameter['nameLessThan'] = nameLessThan;
            }

            if (studioIds !== undefined) {
                localVarQueryParameter['studioIds'] = studioIds;
            }

            if (genreIds !== undefined) {
                localVarQueryParameter['genreIds'] = genreIds;
            }

            if (enableTotalRecordCount !== undefined) {
                localVarQueryParameter['enableTotalRecordCount'] = enableTotalRecordCount;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uId 
         * @param {string} [userId] 
         * @param {string} [maxOfficialRating] 
         * @param {boolean} [hasThemeSong] 
         * @param {boolean} [hasThemeVideo] 
         * @param {boolean} [hasSubtitles] 
         * @param {boolean} [hasSpecialFeature] 
         * @param {boolean} [hasTrailer] 
         * @param {string} [adjacentTo] 
         * @param {number} [parentIndexNumber] 
         * @param {boolean} [hasParentalRating] 
         * @param {boolean} [isHd] 
         * @param {boolean} [is4K] 
         * @param {string} [locationTypes] 
         * @param {string} [excludeLocationTypes] 
         * @param {boolean} [isMissing] 
         * @param {boolean} [isUnaired] 
         * @param {number} [minCommunityRating] 
         * @param {number} [minCriticRating] 
         * @param {string} [minPremiereDate] 
         * @param {string} [minDateLastSaved] 
         * @param {string} [minDateLastSavedForUser] 
         * @param {string} [maxPremiereDate] 
         * @param {boolean} [hasOverview] 
         * @param {boolean} [hasImdbId] 
         * @param {boolean} [hasTmdbId] 
         * @param {boolean} [hasTvdbId] 
         * @param {string} [excludeItemIds] 
         * @param {number} [startIndex] 
         * @param {number} [limit] 
         * @param {boolean} [recursive] 
         * @param {string} [searchTerm] 
         * @param {string} [sortOrder] 
         * @param {string} [parentId] 
         * @param {string} [fields] 
         * @param {string} [excludeItemTypes] 
         * @param {string} [includeItemTypes] 
         * @param {string} [filters] 
         * @param {boolean} [isFavorite] 
         * @param {string} [mediaTypes] 
         * @param {string} [imageTypes] 
         * @param {string} [sortBy] 
         * @param {boolean} [isPlayed] 
         * @param {string} [genres] 
         * @param {string} [officialRatings] 
         * @param {string} [tags] 
         * @param {string} [years] 
         * @param {boolean} [enableUserData] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {string} [person] 
         * @param {string} [personIds] 
         * @param {string} [personTypes] 
         * @param {string} [studios] 
         * @param {string} [artists] 
         * @param {string} [excludeArtistIds] 
         * @param {string} [artistIds] 
         * @param {string} [albumArtistIds] 
         * @param {string} [contributingArtistIds] 
         * @param {string} [albums] 
         * @param {string} [albumIds] 
         * @param {string} [ids] 
         * @param {string} [videoTypes] 
         * @param {string} [minOfficialRating] 
         * @param {boolean} [isLocked] 
         * @param {boolean} [isPlaceHolder] 
         * @param {boolean} [hasOfficialRating] 
         * @param {boolean} [collapseBoxSetItems] 
         * @param {number} [minWidth] 
         * @param {number} [minHeight] 
         * @param {number} [maxWidth] 
         * @param {number} [maxHeight] 
         * @param {boolean} [is3D] 
         * @param {string} [seriesStatus] 
         * @param {string} [nameStartsWithOrGreater] 
         * @param {string} [nameStartsWith] 
         * @param {string} [nameLessThan] 
         * @param {string} [studioIds] 
         * @param {string} [genreIds] 
         * @param {boolean} [enableTotalRecordCount] 
         * @param {boolean} [enableImages] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItems2: async (uId: string, userId?: string, maxOfficialRating?: string, hasThemeSong?: boolean, hasThemeVideo?: boolean, hasSubtitles?: boolean, hasSpecialFeature?: boolean, hasTrailer?: boolean, adjacentTo?: string, parentIndexNumber?: number, hasParentalRating?: boolean, isHd?: boolean, is4K?: boolean, locationTypes?: string, excludeLocationTypes?: string, isMissing?: boolean, isUnaired?: boolean, minCommunityRating?: number, minCriticRating?: number, minPremiereDate?: string, minDateLastSaved?: string, minDateLastSavedForUser?: string, maxPremiereDate?: string, hasOverview?: boolean, hasImdbId?: boolean, hasTmdbId?: boolean, hasTvdbId?: boolean, excludeItemIds?: string, startIndex?: number, limit?: number, recursive?: boolean, searchTerm?: string, sortOrder?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, filters?: string, isFavorite?: boolean, mediaTypes?: string, imageTypes?: string, sortBy?: string, isPlayed?: boolean, genres?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, artists?: string, excludeArtistIds?: string, artistIds?: string, albumArtistIds?: string, contributingArtistIds?: string, albums?: string, albumIds?: string, ids?: string, videoTypes?: string, minOfficialRating?: string, isLocked?: boolean, isPlaceHolder?: boolean, hasOfficialRating?: boolean, collapseBoxSetItems?: boolean, minWidth?: number, minHeight?: number, maxWidth?: number, maxHeight?: number, is3D?: boolean, seriesStatus?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, studioIds?: string, genreIds?: string, enableTotalRecordCount?: boolean, enableImages?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uId' is not null or undefined
            if (uId === null || uId === undefined) {
                throw new RequiredError('uId','Required parameter uId was null or undefined when calling getItems2.');
            }
            const localVarPath = `/Users/{uId}/Items`
                .replace(`{${"uId"}}`, encodeURIComponent(String(uId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (maxOfficialRating !== undefined) {
                localVarQueryParameter['maxOfficialRating'] = maxOfficialRating;
            }

            if (hasThemeSong !== undefined) {
                localVarQueryParameter['hasThemeSong'] = hasThemeSong;
            }

            if (hasThemeVideo !== undefined) {
                localVarQueryParameter['hasThemeVideo'] = hasThemeVideo;
            }

            if (hasSubtitles !== undefined) {
                localVarQueryParameter['hasSubtitles'] = hasSubtitles;
            }

            if (hasSpecialFeature !== undefined) {
                localVarQueryParameter['hasSpecialFeature'] = hasSpecialFeature;
            }

            if (hasTrailer !== undefined) {
                localVarQueryParameter['hasTrailer'] = hasTrailer;
            }

            if (adjacentTo !== undefined) {
                localVarQueryParameter['adjacentTo'] = adjacentTo;
            }

            if (parentIndexNumber !== undefined) {
                localVarQueryParameter['parentIndexNumber'] = parentIndexNumber;
            }

            if (hasParentalRating !== undefined) {
                localVarQueryParameter['hasParentalRating'] = hasParentalRating;
            }

            if (isHd !== undefined) {
                localVarQueryParameter['isHd'] = isHd;
            }

            if (is4K !== undefined) {
                localVarQueryParameter['is4K'] = is4K;
            }

            if (locationTypes !== undefined) {
                localVarQueryParameter['locationTypes'] = locationTypes;
            }

            if (excludeLocationTypes !== undefined) {
                localVarQueryParameter['excludeLocationTypes'] = excludeLocationTypes;
            }

            if (isMissing !== undefined) {
                localVarQueryParameter['isMissing'] = isMissing;
            }

            if (isUnaired !== undefined) {
                localVarQueryParameter['isUnaired'] = isUnaired;
            }

            if (minCommunityRating !== undefined) {
                localVarQueryParameter['minCommunityRating'] = minCommunityRating;
            }

            if (minCriticRating !== undefined) {
                localVarQueryParameter['minCriticRating'] = minCriticRating;
            }

            if (minPremiereDate !== undefined) {
                localVarQueryParameter['minPremiereDate'] = (minPremiereDate as any instanceof Date) ?
                    (minPremiereDate as any).toISOString() :
                    minPremiereDate;
            }

            if (minDateLastSaved !== undefined) {
                localVarQueryParameter['minDateLastSaved'] = (minDateLastSaved as any instanceof Date) ?
                    (minDateLastSaved as any).toISOString() :
                    minDateLastSaved;
            }

            if (minDateLastSavedForUser !== undefined) {
                localVarQueryParameter['minDateLastSavedForUser'] = (minDateLastSavedForUser as any instanceof Date) ?
                    (minDateLastSavedForUser as any).toISOString() :
                    minDateLastSavedForUser;
            }

            if (maxPremiereDate !== undefined) {
                localVarQueryParameter['maxPremiereDate'] = (maxPremiereDate as any instanceof Date) ?
                    (maxPremiereDate as any).toISOString() :
                    maxPremiereDate;
            }

            if (hasOverview !== undefined) {
                localVarQueryParameter['hasOverview'] = hasOverview;
            }

            if (hasImdbId !== undefined) {
                localVarQueryParameter['hasImdbId'] = hasImdbId;
            }

            if (hasTmdbId !== undefined) {
                localVarQueryParameter['hasTmdbId'] = hasTmdbId;
            }

            if (hasTvdbId !== undefined) {
                localVarQueryParameter['hasTvdbId'] = hasTvdbId;
            }

            if (excludeItemIds !== undefined) {
                localVarQueryParameter['excludeItemIds'] = excludeItemIds;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recursive !== undefined) {
                localVarQueryParameter['recursive'] = recursive;
            }

            if (searchTerm !== undefined) {
                localVarQueryParameter['searchTerm'] = searchTerm;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (parentId !== undefined) {
                localVarQueryParameter['parentId'] = parentId;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeItemTypes !== undefined) {
                localVarQueryParameter['excludeItemTypes'] = excludeItemTypes;
            }

            if (includeItemTypes !== undefined) {
                localVarQueryParameter['includeItemTypes'] = includeItemTypes;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (isFavorite !== undefined) {
                localVarQueryParameter['isFavorite'] = isFavorite;
            }

            if (mediaTypes !== undefined) {
                localVarQueryParameter['mediaTypes'] = mediaTypes;
            }

            if (imageTypes !== undefined) {
                localVarQueryParameter['imageTypes'] = imageTypes;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (isPlayed !== undefined) {
                localVarQueryParameter['isPlayed'] = isPlayed;
            }

            if (genres !== undefined) {
                localVarQueryParameter['genres'] = genres;
            }

            if (officialRatings !== undefined) {
                localVarQueryParameter['officialRatings'] = officialRatings;
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }

            if (years !== undefined) {
                localVarQueryParameter['years'] = years;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes !== undefined) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }

            if (person !== undefined) {
                localVarQueryParameter['person'] = person;
            }

            if (personIds !== undefined) {
                localVarQueryParameter['personIds'] = personIds;
            }

            if (personTypes !== undefined) {
                localVarQueryParameter['personTypes'] = personTypes;
            }

            if (studios !== undefined) {
                localVarQueryParameter['studios'] = studios;
            }

            if (artists !== undefined) {
                localVarQueryParameter['artists'] = artists;
            }

            if (excludeArtistIds !== undefined) {
                localVarQueryParameter['excludeArtistIds'] = excludeArtistIds;
            }

            if (artistIds !== undefined) {
                localVarQueryParameter['artistIds'] = artistIds;
            }

            if (albumArtistIds !== undefined) {
                localVarQueryParameter['albumArtistIds'] = albumArtistIds;
            }

            if (contributingArtistIds !== undefined) {
                localVarQueryParameter['contributingArtistIds'] = contributingArtistIds;
            }

            if (albums !== undefined) {
                localVarQueryParameter['albums'] = albums;
            }

            if (albumIds !== undefined) {
                localVarQueryParameter['albumIds'] = albumIds;
            }

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }

            if (videoTypes !== undefined) {
                localVarQueryParameter['videoTypes'] = videoTypes;
            }

            if (minOfficialRating !== undefined) {
                localVarQueryParameter['minOfficialRating'] = minOfficialRating;
            }

            if (isLocked !== undefined) {
                localVarQueryParameter['isLocked'] = isLocked;
            }

            if (isPlaceHolder !== undefined) {
                localVarQueryParameter['isPlaceHolder'] = isPlaceHolder;
            }

            if (hasOfficialRating !== undefined) {
                localVarQueryParameter['hasOfficialRating'] = hasOfficialRating;
            }

            if (collapseBoxSetItems !== undefined) {
                localVarQueryParameter['collapseBoxSetItems'] = collapseBoxSetItems;
            }

            if (minWidth !== undefined) {
                localVarQueryParameter['minWidth'] = minWidth;
            }

            if (minHeight !== undefined) {
                localVarQueryParameter['minHeight'] = minHeight;
            }

            if (maxWidth !== undefined) {
                localVarQueryParameter['maxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['maxHeight'] = maxHeight;
            }

            if (is3D !== undefined) {
                localVarQueryParameter['is3D'] = is3D;
            }

            if (seriesStatus !== undefined) {
                localVarQueryParameter['seriesStatus'] = seriesStatus;
            }

            if (nameStartsWithOrGreater !== undefined) {
                localVarQueryParameter['nameStartsWithOrGreater'] = nameStartsWithOrGreater;
            }

            if (nameStartsWith !== undefined) {
                localVarQueryParameter['nameStartsWith'] = nameStartsWith;
            }

            if (nameLessThan !== undefined) {
                localVarQueryParameter['nameLessThan'] = nameLessThan;
            }

            if (studioIds !== undefined) {
                localVarQueryParameter['studioIds'] = studioIds;
            }

            if (genreIds !== undefined) {
                localVarQueryParameter['genreIds'] = genreIds;
            }

            if (enableTotalRecordCount !== undefined) {
                localVarQueryParameter['enableTotalRecordCount'] = enableTotalRecordCount;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {number} [startIndex] 
         * @param {number} [limit] 
         * @param {string} [searchTerm] 
         * @param {string} [parentId] 
         * @param {string} [fields] 
         * @param {string} [mediaTypes] 
         * @param {boolean} [enableUserData] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {string} [excludeItemTypes] 
         * @param {string} [includeItemTypes] 
         * @param {boolean} [enableTotalRecordCount] 
         * @param {boolean} [enableImages] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResumeItems: async (userId: string, startIndex?: number, limit?: number, searchTerm?: string, parentId?: string, fields?: string, mediaTypes?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, excludeItemTypes?: string, includeItemTypes?: string, enableTotalRecordCount?: boolean, enableImages?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getResumeItems.');
            }
            const localVarPath = `/Users/{userId}/Items/Resume`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (searchTerm !== undefined) {
                localVarQueryParameter['searchTerm'] = searchTerm;
            }

            if (parentId !== undefined) {
                localVarQueryParameter['parentId'] = parentId;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (mediaTypes !== undefined) {
                localVarQueryParameter['mediaTypes'] = mediaTypes;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes !== undefined) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }

            if (excludeItemTypes !== undefined) {
                localVarQueryParameter['excludeItemTypes'] = excludeItemTypes;
            }

            if (includeItemTypes !== undefined) {
                localVarQueryParameter['includeItemTypes'] = includeItemTypes;
            }

            if (enableTotalRecordCount !== undefined) {
                localVarQueryParameter['enableTotalRecordCount'] = enableTotalRecordCount;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemsApi - functional programming interface
 * @export
 */
export const ItemsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} uId 
         * @param {string} [userId] 
         * @param {string} [maxOfficialRating] 
         * @param {boolean} [hasThemeSong] 
         * @param {boolean} [hasThemeVideo] 
         * @param {boolean} [hasSubtitles] 
         * @param {boolean} [hasSpecialFeature] 
         * @param {boolean} [hasTrailer] 
         * @param {string} [adjacentTo] 
         * @param {number} [parentIndexNumber] 
         * @param {boolean} [hasParentalRating] 
         * @param {boolean} [isHd] 
         * @param {boolean} [is4K] 
         * @param {string} [locationTypes] 
         * @param {string} [excludeLocationTypes] 
         * @param {boolean} [isMissing] 
         * @param {boolean} [isUnaired] 
         * @param {number} [minCommunityRating] 
         * @param {number} [minCriticRating] 
         * @param {string} [minPremiereDate] 
         * @param {string} [minDateLastSaved] 
         * @param {string} [minDateLastSavedForUser] 
         * @param {string} [maxPremiereDate] 
         * @param {boolean} [hasOverview] 
         * @param {boolean} [hasImdbId] 
         * @param {boolean} [hasTmdbId] 
         * @param {boolean} [hasTvdbId] 
         * @param {string} [excludeItemIds] 
         * @param {number} [startIndex] 
         * @param {number} [limit] 
         * @param {boolean} [recursive] 
         * @param {string} [searchTerm] 
         * @param {string} [sortOrder] 
         * @param {string} [parentId] 
         * @param {string} [fields] 
         * @param {string} [excludeItemTypes] 
         * @param {string} [includeItemTypes] 
         * @param {string} [filters] 
         * @param {boolean} [isFavorite] 
         * @param {string} [mediaTypes] 
         * @param {string} [imageTypes] 
         * @param {string} [sortBy] 
         * @param {boolean} [isPlayed] 
         * @param {string} [genres] 
         * @param {string} [officialRatings] 
         * @param {string} [tags] 
         * @param {string} [years] 
         * @param {boolean} [enableUserData] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {string} [person] 
         * @param {string} [personIds] 
         * @param {string} [personTypes] 
         * @param {string} [studios] 
         * @param {string} [artists] 
         * @param {string} [excludeArtistIds] 
         * @param {string} [artistIds] 
         * @param {string} [albumArtistIds] 
         * @param {string} [contributingArtistIds] 
         * @param {string} [albums] 
         * @param {string} [albumIds] 
         * @param {string} [ids] 
         * @param {string} [videoTypes] 
         * @param {string} [minOfficialRating] 
         * @param {boolean} [isLocked] 
         * @param {boolean} [isPlaceHolder] 
         * @param {boolean} [hasOfficialRating] 
         * @param {boolean} [collapseBoxSetItems] 
         * @param {number} [minWidth] 
         * @param {number} [minHeight] 
         * @param {number} [maxWidth] 
         * @param {number} [maxHeight] 
         * @param {boolean} [is3D] 
         * @param {string} [seriesStatus] 
         * @param {string} [nameStartsWithOrGreater] 
         * @param {string} [nameStartsWith] 
         * @param {string} [nameLessThan] 
         * @param {string} [studioIds] 
         * @param {string} [genreIds] 
         * @param {boolean} [enableTotalRecordCount] 
         * @param {boolean} [enableImages] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItems(uId: string, userId?: string, maxOfficialRating?: string, hasThemeSong?: boolean, hasThemeVideo?: boolean, hasSubtitles?: boolean, hasSpecialFeature?: boolean, hasTrailer?: boolean, adjacentTo?: string, parentIndexNumber?: number, hasParentalRating?: boolean, isHd?: boolean, is4K?: boolean, locationTypes?: string, excludeLocationTypes?: string, isMissing?: boolean, isUnaired?: boolean, minCommunityRating?: number, minCriticRating?: number, minPremiereDate?: string, minDateLastSaved?: string, minDateLastSavedForUser?: string, maxPremiereDate?: string, hasOverview?: boolean, hasImdbId?: boolean, hasTmdbId?: boolean, hasTvdbId?: boolean, excludeItemIds?: string, startIndex?: number, limit?: number, recursive?: boolean, searchTerm?: string, sortOrder?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, filters?: string, isFavorite?: boolean, mediaTypes?: string, imageTypes?: string, sortBy?: string, isPlayed?: boolean, genres?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, artists?: string, excludeArtistIds?: string, artistIds?: string, albumArtistIds?: string, contributingArtistIds?: string, albums?: string, albumIds?: string, ids?: string, videoTypes?: string, minOfficialRating?: string, isLocked?: boolean, isPlaceHolder?: boolean, hasOfficialRating?: boolean, collapseBoxSetItems?: boolean, minWidth?: number, minHeight?: number, maxWidth?: number, maxHeight?: number, is3D?: boolean, seriesStatus?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, studioIds?: string, genreIds?: string, enableTotalRecordCount?: boolean, enableImages?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await ItemsApiAxiosParamCreator(configuration).getItems(uId, userId, maxOfficialRating, hasThemeSong, hasThemeVideo, hasSubtitles, hasSpecialFeature, hasTrailer, adjacentTo, parentIndexNumber, hasParentalRating, isHd, is4K, locationTypes, excludeLocationTypes, isMissing, isUnaired, minCommunityRating, minCriticRating, minPremiereDate, minDateLastSaved, minDateLastSavedForUser, maxPremiereDate, hasOverview, hasImdbId, hasTmdbId, hasTvdbId, excludeItemIds, startIndex, limit, recursive, searchTerm, sortOrder, parentId, fields, excludeItemTypes, includeItemTypes, filters, isFavorite, mediaTypes, imageTypes, sortBy, isPlayed, genres, officialRatings, tags, years, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, artists, excludeArtistIds, artistIds, albumArtistIds, contributingArtistIds, albums, albumIds, ids, videoTypes, minOfficialRating, isLocked, isPlaceHolder, hasOfficialRating, collapseBoxSetItems, minWidth, minHeight, maxWidth, maxHeight, is3D, seriesStatus, nameStartsWithOrGreater, nameStartsWith, nameLessThan, studioIds, genreIds, enableTotalRecordCount, enableImages, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} uId 
         * @param {string} [userId] 
         * @param {string} [maxOfficialRating] 
         * @param {boolean} [hasThemeSong] 
         * @param {boolean} [hasThemeVideo] 
         * @param {boolean} [hasSubtitles] 
         * @param {boolean} [hasSpecialFeature] 
         * @param {boolean} [hasTrailer] 
         * @param {string} [adjacentTo] 
         * @param {number} [parentIndexNumber] 
         * @param {boolean} [hasParentalRating] 
         * @param {boolean} [isHd] 
         * @param {boolean} [is4K] 
         * @param {string} [locationTypes] 
         * @param {string} [excludeLocationTypes] 
         * @param {boolean} [isMissing] 
         * @param {boolean} [isUnaired] 
         * @param {number} [minCommunityRating] 
         * @param {number} [minCriticRating] 
         * @param {string} [minPremiereDate] 
         * @param {string} [minDateLastSaved] 
         * @param {string} [minDateLastSavedForUser] 
         * @param {string} [maxPremiereDate] 
         * @param {boolean} [hasOverview] 
         * @param {boolean} [hasImdbId] 
         * @param {boolean} [hasTmdbId] 
         * @param {boolean} [hasTvdbId] 
         * @param {string} [excludeItemIds] 
         * @param {number} [startIndex] 
         * @param {number} [limit] 
         * @param {boolean} [recursive] 
         * @param {string} [searchTerm] 
         * @param {string} [sortOrder] 
         * @param {string} [parentId] 
         * @param {string} [fields] 
         * @param {string} [excludeItemTypes] 
         * @param {string} [includeItemTypes] 
         * @param {string} [filters] 
         * @param {boolean} [isFavorite] 
         * @param {string} [mediaTypes] 
         * @param {string} [imageTypes] 
         * @param {string} [sortBy] 
         * @param {boolean} [isPlayed] 
         * @param {string} [genres] 
         * @param {string} [officialRatings] 
         * @param {string} [tags] 
         * @param {string} [years] 
         * @param {boolean} [enableUserData] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {string} [person] 
         * @param {string} [personIds] 
         * @param {string} [personTypes] 
         * @param {string} [studios] 
         * @param {string} [artists] 
         * @param {string} [excludeArtistIds] 
         * @param {string} [artistIds] 
         * @param {string} [albumArtistIds] 
         * @param {string} [contributingArtistIds] 
         * @param {string} [albums] 
         * @param {string} [albumIds] 
         * @param {string} [ids] 
         * @param {string} [videoTypes] 
         * @param {string} [minOfficialRating] 
         * @param {boolean} [isLocked] 
         * @param {boolean} [isPlaceHolder] 
         * @param {boolean} [hasOfficialRating] 
         * @param {boolean} [collapseBoxSetItems] 
         * @param {number} [minWidth] 
         * @param {number} [minHeight] 
         * @param {number} [maxWidth] 
         * @param {number} [maxHeight] 
         * @param {boolean} [is3D] 
         * @param {string} [seriesStatus] 
         * @param {string} [nameStartsWithOrGreater] 
         * @param {string} [nameStartsWith] 
         * @param {string} [nameLessThan] 
         * @param {string} [studioIds] 
         * @param {string} [genreIds] 
         * @param {boolean} [enableTotalRecordCount] 
         * @param {boolean} [enableImages] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItems2(uId: string, userId?: string, maxOfficialRating?: string, hasThemeSong?: boolean, hasThemeVideo?: boolean, hasSubtitles?: boolean, hasSpecialFeature?: boolean, hasTrailer?: boolean, adjacentTo?: string, parentIndexNumber?: number, hasParentalRating?: boolean, isHd?: boolean, is4K?: boolean, locationTypes?: string, excludeLocationTypes?: string, isMissing?: boolean, isUnaired?: boolean, minCommunityRating?: number, minCriticRating?: number, minPremiereDate?: string, minDateLastSaved?: string, minDateLastSavedForUser?: string, maxPremiereDate?: string, hasOverview?: boolean, hasImdbId?: boolean, hasTmdbId?: boolean, hasTvdbId?: boolean, excludeItemIds?: string, startIndex?: number, limit?: number, recursive?: boolean, searchTerm?: string, sortOrder?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, filters?: string, isFavorite?: boolean, mediaTypes?: string, imageTypes?: string, sortBy?: string, isPlayed?: boolean, genres?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, artists?: string, excludeArtistIds?: string, artistIds?: string, albumArtistIds?: string, contributingArtistIds?: string, albums?: string, albumIds?: string, ids?: string, videoTypes?: string, minOfficialRating?: string, isLocked?: boolean, isPlaceHolder?: boolean, hasOfficialRating?: boolean, collapseBoxSetItems?: boolean, minWidth?: number, minHeight?: number, maxWidth?: number, maxHeight?: number, is3D?: boolean, seriesStatus?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, studioIds?: string, genreIds?: string, enableTotalRecordCount?: boolean, enableImages?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await ItemsApiAxiosParamCreator(configuration).getItems2(uId, userId, maxOfficialRating, hasThemeSong, hasThemeVideo, hasSubtitles, hasSpecialFeature, hasTrailer, adjacentTo, parentIndexNumber, hasParentalRating, isHd, is4K, locationTypes, excludeLocationTypes, isMissing, isUnaired, minCommunityRating, minCriticRating, minPremiereDate, minDateLastSaved, minDateLastSavedForUser, maxPremiereDate, hasOverview, hasImdbId, hasTmdbId, hasTvdbId, excludeItemIds, startIndex, limit, recursive, searchTerm, sortOrder, parentId, fields, excludeItemTypes, includeItemTypes, filters, isFavorite, mediaTypes, imageTypes, sortBy, isPlayed, genres, officialRatings, tags, years, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, artists, excludeArtistIds, artistIds, albumArtistIds, contributingArtistIds, albums, albumIds, ids, videoTypes, minOfficialRating, isLocked, isPlaceHolder, hasOfficialRating, collapseBoxSetItems, minWidth, minHeight, maxWidth, maxHeight, is3D, seriesStatus, nameStartsWithOrGreater, nameStartsWith, nameLessThan, studioIds, genreIds, enableTotalRecordCount, enableImages, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {number} [startIndex] 
         * @param {number} [limit] 
         * @param {string} [searchTerm] 
         * @param {string} [parentId] 
         * @param {string} [fields] 
         * @param {string} [mediaTypes] 
         * @param {boolean} [enableUserData] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {string} [excludeItemTypes] 
         * @param {string} [includeItemTypes] 
         * @param {boolean} [enableTotalRecordCount] 
         * @param {boolean} [enableImages] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResumeItems(userId: string, startIndex?: number, limit?: number, searchTerm?: string, parentId?: string, fields?: string, mediaTypes?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, excludeItemTypes?: string, includeItemTypes?: string, enableTotalRecordCount?: boolean, enableImages?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await ItemsApiAxiosParamCreator(configuration).getResumeItems(userId, startIndex, limit, searchTerm, parentId, fields, mediaTypes, enableUserData, imageTypeLimit, enableImageTypes, excludeItemTypes, includeItemTypes, enableTotalRecordCount, enableImages, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ItemsApi - factory interface
 * @export
 */
export const ItemsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} uId 
         * @param {string} [userId] 
         * @param {string} [maxOfficialRating] 
         * @param {boolean} [hasThemeSong] 
         * @param {boolean} [hasThemeVideo] 
         * @param {boolean} [hasSubtitles] 
         * @param {boolean} [hasSpecialFeature] 
         * @param {boolean} [hasTrailer] 
         * @param {string} [adjacentTo] 
         * @param {number} [parentIndexNumber] 
         * @param {boolean} [hasParentalRating] 
         * @param {boolean} [isHd] 
         * @param {boolean} [is4K] 
         * @param {string} [locationTypes] 
         * @param {string} [excludeLocationTypes] 
         * @param {boolean} [isMissing] 
         * @param {boolean} [isUnaired] 
         * @param {number} [minCommunityRating] 
         * @param {number} [minCriticRating] 
         * @param {string} [minPremiereDate] 
         * @param {string} [minDateLastSaved] 
         * @param {string} [minDateLastSavedForUser] 
         * @param {string} [maxPremiereDate] 
         * @param {boolean} [hasOverview] 
         * @param {boolean} [hasImdbId] 
         * @param {boolean} [hasTmdbId] 
         * @param {boolean} [hasTvdbId] 
         * @param {string} [excludeItemIds] 
         * @param {number} [startIndex] 
         * @param {number} [limit] 
         * @param {boolean} [recursive] 
         * @param {string} [searchTerm] 
         * @param {string} [sortOrder] 
         * @param {string} [parentId] 
         * @param {string} [fields] 
         * @param {string} [excludeItemTypes] 
         * @param {string} [includeItemTypes] 
         * @param {string} [filters] 
         * @param {boolean} [isFavorite] 
         * @param {string} [mediaTypes] 
         * @param {string} [imageTypes] 
         * @param {string} [sortBy] 
         * @param {boolean} [isPlayed] 
         * @param {string} [genres] 
         * @param {string} [officialRatings] 
         * @param {string} [tags] 
         * @param {string} [years] 
         * @param {boolean} [enableUserData] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {string} [person] 
         * @param {string} [personIds] 
         * @param {string} [personTypes] 
         * @param {string} [studios] 
         * @param {string} [artists] 
         * @param {string} [excludeArtistIds] 
         * @param {string} [artistIds] 
         * @param {string} [albumArtistIds] 
         * @param {string} [contributingArtistIds] 
         * @param {string} [albums] 
         * @param {string} [albumIds] 
         * @param {string} [ids] 
         * @param {string} [videoTypes] 
         * @param {string} [minOfficialRating] 
         * @param {boolean} [isLocked] 
         * @param {boolean} [isPlaceHolder] 
         * @param {boolean} [hasOfficialRating] 
         * @param {boolean} [collapseBoxSetItems] 
         * @param {number} [minWidth] 
         * @param {number} [minHeight] 
         * @param {number} [maxWidth] 
         * @param {number} [maxHeight] 
         * @param {boolean} [is3D] 
         * @param {string} [seriesStatus] 
         * @param {string} [nameStartsWithOrGreater] 
         * @param {string} [nameStartsWith] 
         * @param {string} [nameLessThan] 
         * @param {string} [studioIds] 
         * @param {string} [genreIds] 
         * @param {boolean} [enableTotalRecordCount] 
         * @param {boolean} [enableImages] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItems(uId: string, userId?: string, maxOfficialRating?: string, hasThemeSong?: boolean, hasThemeVideo?: boolean, hasSubtitles?: boolean, hasSpecialFeature?: boolean, hasTrailer?: boolean, adjacentTo?: string, parentIndexNumber?: number, hasParentalRating?: boolean, isHd?: boolean, is4K?: boolean, locationTypes?: string, excludeLocationTypes?: string, isMissing?: boolean, isUnaired?: boolean, minCommunityRating?: number, minCriticRating?: number, minPremiereDate?: string, minDateLastSaved?: string, minDateLastSavedForUser?: string, maxPremiereDate?: string, hasOverview?: boolean, hasImdbId?: boolean, hasTmdbId?: boolean, hasTvdbId?: boolean, excludeItemIds?: string, startIndex?: number, limit?: number, recursive?: boolean, searchTerm?: string, sortOrder?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, filters?: string, isFavorite?: boolean, mediaTypes?: string, imageTypes?: string, sortBy?: string, isPlayed?: boolean, genres?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, artists?: string, excludeArtistIds?: string, artistIds?: string, albumArtistIds?: string, contributingArtistIds?: string, albums?: string, albumIds?: string, ids?: string, videoTypes?: string, minOfficialRating?: string, isLocked?: boolean, isPlaceHolder?: boolean, hasOfficialRating?: boolean, collapseBoxSetItems?: boolean, minWidth?: number, minHeight?: number, maxWidth?: number, maxHeight?: number, is3D?: boolean, seriesStatus?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, studioIds?: string, genreIds?: string, enableTotalRecordCount?: boolean, enableImages?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return ItemsApiFp(configuration).getItems(uId, userId, maxOfficialRating, hasThemeSong, hasThemeVideo, hasSubtitles, hasSpecialFeature, hasTrailer, adjacentTo, parentIndexNumber, hasParentalRating, isHd, is4K, locationTypes, excludeLocationTypes, isMissing, isUnaired, minCommunityRating, minCriticRating, minPremiereDate, minDateLastSaved, minDateLastSavedForUser, maxPremiereDate, hasOverview, hasImdbId, hasTmdbId, hasTvdbId, excludeItemIds, startIndex, limit, recursive, searchTerm, sortOrder, parentId, fields, excludeItemTypes, includeItemTypes, filters, isFavorite, mediaTypes, imageTypes, sortBy, isPlayed, genres, officialRatings, tags, years, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, artists, excludeArtistIds, artistIds, albumArtistIds, contributingArtistIds, albums, albumIds, ids, videoTypes, minOfficialRating, isLocked, isPlaceHolder, hasOfficialRating, collapseBoxSetItems, minWidth, minHeight, maxWidth, maxHeight, is3D, seriesStatus, nameStartsWithOrGreater, nameStartsWith, nameLessThan, studioIds, genreIds, enableTotalRecordCount, enableImages, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} uId 
         * @param {string} [userId] 
         * @param {string} [maxOfficialRating] 
         * @param {boolean} [hasThemeSong] 
         * @param {boolean} [hasThemeVideo] 
         * @param {boolean} [hasSubtitles] 
         * @param {boolean} [hasSpecialFeature] 
         * @param {boolean} [hasTrailer] 
         * @param {string} [adjacentTo] 
         * @param {number} [parentIndexNumber] 
         * @param {boolean} [hasParentalRating] 
         * @param {boolean} [isHd] 
         * @param {boolean} [is4K] 
         * @param {string} [locationTypes] 
         * @param {string} [excludeLocationTypes] 
         * @param {boolean} [isMissing] 
         * @param {boolean} [isUnaired] 
         * @param {number} [minCommunityRating] 
         * @param {number} [minCriticRating] 
         * @param {string} [minPremiereDate] 
         * @param {string} [minDateLastSaved] 
         * @param {string} [minDateLastSavedForUser] 
         * @param {string} [maxPremiereDate] 
         * @param {boolean} [hasOverview] 
         * @param {boolean} [hasImdbId] 
         * @param {boolean} [hasTmdbId] 
         * @param {boolean} [hasTvdbId] 
         * @param {string} [excludeItemIds] 
         * @param {number} [startIndex] 
         * @param {number} [limit] 
         * @param {boolean} [recursive] 
         * @param {string} [searchTerm] 
         * @param {string} [sortOrder] 
         * @param {string} [parentId] 
         * @param {string} [fields] 
         * @param {string} [excludeItemTypes] 
         * @param {string} [includeItemTypes] 
         * @param {string} [filters] 
         * @param {boolean} [isFavorite] 
         * @param {string} [mediaTypes] 
         * @param {string} [imageTypes] 
         * @param {string} [sortBy] 
         * @param {boolean} [isPlayed] 
         * @param {string} [genres] 
         * @param {string} [officialRatings] 
         * @param {string} [tags] 
         * @param {string} [years] 
         * @param {boolean} [enableUserData] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {string} [person] 
         * @param {string} [personIds] 
         * @param {string} [personTypes] 
         * @param {string} [studios] 
         * @param {string} [artists] 
         * @param {string} [excludeArtistIds] 
         * @param {string} [artistIds] 
         * @param {string} [albumArtistIds] 
         * @param {string} [contributingArtistIds] 
         * @param {string} [albums] 
         * @param {string} [albumIds] 
         * @param {string} [ids] 
         * @param {string} [videoTypes] 
         * @param {string} [minOfficialRating] 
         * @param {boolean} [isLocked] 
         * @param {boolean} [isPlaceHolder] 
         * @param {boolean} [hasOfficialRating] 
         * @param {boolean} [collapseBoxSetItems] 
         * @param {number} [minWidth] 
         * @param {number} [minHeight] 
         * @param {number} [maxWidth] 
         * @param {number} [maxHeight] 
         * @param {boolean} [is3D] 
         * @param {string} [seriesStatus] 
         * @param {string} [nameStartsWithOrGreater] 
         * @param {string} [nameStartsWith] 
         * @param {string} [nameLessThan] 
         * @param {string} [studioIds] 
         * @param {string} [genreIds] 
         * @param {boolean} [enableTotalRecordCount] 
         * @param {boolean} [enableImages] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItems2(uId: string, userId?: string, maxOfficialRating?: string, hasThemeSong?: boolean, hasThemeVideo?: boolean, hasSubtitles?: boolean, hasSpecialFeature?: boolean, hasTrailer?: boolean, adjacentTo?: string, parentIndexNumber?: number, hasParentalRating?: boolean, isHd?: boolean, is4K?: boolean, locationTypes?: string, excludeLocationTypes?: string, isMissing?: boolean, isUnaired?: boolean, minCommunityRating?: number, minCriticRating?: number, minPremiereDate?: string, minDateLastSaved?: string, minDateLastSavedForUser?: string, maxPremiereDate?: string, hasOverview?: boolean, hasImdbId?: boolean, hasTmdbId?: boolean, hasTvdbId?: boolean, excludeItemIds?: string, startIndex?: number, limit?: number, recursive?: boolean, searchTerm?: string, sortOrder?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, filters?: string, isFavorite?: boolean, mediaTypes?: string, imageTypes?: string, sortBy?: string, isPlayed?: boolean, genres?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, artists?: string, excludeArtistIds?: string, artistIds?: string, albumArtistIds?: string, contributingArtistIds?: string, albums?: string, albumIds?: string, ids?: string, videoTypes?: string, minOfficialRating?: string, isLocked?: boolean, isPlaceHolder?: boolean, hasOfficialRating?: boolean, collapseBoxSetItems?: boolean, minWidth?: number, minHeight?: number, maxWidth?: number, maxHeight?: number, is3D?: boolean, seriesStatus?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, studioIds?: string, genreIds?: string, enableTotalRecordCount?: boolean, enableImages?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return ItemsApiFp(configuration).getItems2(uId, userId, maxOfficialRating, hasThemeSong, hasThemeVideo, hasSubtitles, hasSpecialFeature, hasTrailer, adjacentTo, parentIndexNumber, hasParentalRating, isHd, is4K, locationTypes, excludeLocationTypes, isMissing, isUnaired, minCommunityRating, minCriticRating, minPremiereDate, minDateLastSaved, minDateLastSavedForUser, maxPremiereDate, hasOverview, hasImdbId, hasTmdbId, hasTvdbId, excludeItemIds, startIndex, limit, recursive, searchTerm, sortOrder, parentId, fields, excludeItemTypes, includeItemTypes, filters, isFavorite, mediaTypes, imageTypes, sortBy, isPlayed, genres, officialRatings, tags, years, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, artists, excludeArtistIds, artistIds, albumArtistIds, contributingArtistIds, albums, albumIds, ids, videoTypes, minOfficialRating, isLocked, isPlaceHolder, hasOfficialRating, collapseBoxSetItems, minWidth, minHeight, maxWidth, maxHeight, is3D, seriesStatus, nameStartsWithOrGreater, nameStartsWith, nameLessThan, studioIds, genreIds, enableTotalRecordCount, enableImages, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {number} [startIndex] 
         * @param {number} [limit] 
         * @param {string} [searchTerm] 
         * @param {string} [parentId] 
         * @param {string} [fields] 
         * @param {string} [mediaTypes] 
         * @param {boolean} [enableUserData] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {string} [excludeItemTypes] 
         * @param {string} [includeItemTypes] 
         * @param {boolean} [enableTotalRecordCount] 
         * @param {boolean} [enableImages] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResumeItems(userId: string, startIndex?: number, limit?: number, searchTerm?: string, parentId?: string, fields?: string, mediaTypes?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, excludeItemTypes?: string, includeItemTypes?: string, enableTotalRecordCount?: boolean, enableImages?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return ItemsApiFp(configuration).getResumeItems(userId, startIndex, limit, searchTerm, parentId, fields, mediaTypes, enableUserData, imageTypeLimit, enableImageTypes, excludeItemTypes, includeItemTypes, enableTotalRecordCount, enableImages, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getItems operation in ItemsApi.
 * @export
 * @interface ItemsApiGetItemsRequest
 */
export interface ItemsApiGetItemsRequest {
    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly uId: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly userId?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly maxOfficialRating?: string

    /**
     * 
     * @type {boolean}
     * @memberof ItemsApiGetItems
     */
    readonly hasThemeSong?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ItemsApiGetItems
     */
    readonly hasThemeVideo?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ItemsApiGetItems
     */
    readonly hasSubtitles?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ItemsApiGetItems
     */
    readonly hasSpecialFeature?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ItemsApiGetItems
     */
    readonly hasTrailer?: boolean

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly adjacentTo?: string

    /**
     * 
     * @type {number}
     * @memberof ItemsApiGetItems
     */
    readonly parentIndexNumber?: number

    /**
     * 
     * @type {boolean}
     * @memberof ItemsApiGetItems
     */
    readonly hasParentalRating?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ItemsApiGetItems
     */
    readonly isHd?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ItemsApiGetItems
     */
    readonly is4K?: boolean

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly locationTypes?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly excludeLocationTypes?: string

    /**
     * 
     * @type {boolean}
     * @memberof ItemsApiGetItems
     */
    readonly isMissing?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ItemsApiGetItems
     */
    readonly isUnaired?: boolean

    /**
     * 
     * @type {number}
     * @memberof ItemsApiGetItems
     */
    readonly minCommunityRating?: number

    /**
     * 
     * @type {number}
     * @memberof ItemsApiGetItems
     */
    readonly minCriticRating?: number

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly minPremiereDate?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly minDateLastSaved?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly minDateLastSavedForUser?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly maxPremiereDate?: string

    /**
     * 
     * @type {boolean}
     * @memberof ItemsApiGetItems
     */
    readonly hasOverview?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ItemsApiGetItems
     */
    readonly hasImdbId?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ItemsApiGetItems
     */
    readonly hasTmdbId?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ItemsApiGetItems
     */
    readonly hasTvdbId?: boolean

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly excludeItemIds?: string

    /**
     * 
     * @type {number}
     * @memberof ItemsApiGetItems
     */
    readonly startIndex?: number

    /**
     * 
     * @type {number}
     * @memberof ItemsApiGetItems
     */
    readonly limit?: number

    /**
     * 
     * @type {boolean}
     * @memberof ItemsApiGetItems
     */
    readonly recursive?: boolean

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly searchTerm?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly sortOrder?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly parentId?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly fields?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly excludeItemTypes?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly includeItemTypes?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly filters?: string

    /**
     * 
     * @type {boolean}
     * @memberof ItemsApiGetItems
     */
    readonly isFavorite?: boolean

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly mediaTypes?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly imageTypes?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly sortBy?: string

    /**
     * 
     * @type {boolean}
     * @memberof ItemsApiGetItems
     */
    readonly isPlayed?: boolean

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly genres?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly officialRatings?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly tags?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly years?: string

    /**
     * 
     * @type {boolean}
     * @memberof ItemsApiGetItems
     */
    readonly enableUserData?: boolean

    /**
     * 
     * @type {number}
     * @memberof ItemsApiGetItems
     */
    readonly imageTypeLimit?: number

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly enableImageTypes?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly person?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly personIds?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly personTypes?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly studios?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly artists?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly excludeArtistIds?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly artistIds?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly albumArtistIds?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly contributingArtistIds?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly albums?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly albumIds?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly ids?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly videoTypes?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly minOfficialRating?: string

    /**
     * 
     * @type {boolean}
     * @memberof ItemsApiGetItems
     */
    readonly isLocked?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ItemsApiGetItems
     */
    readonly isPlaceHolder?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ItemsApiGetItems
     */
    readonly hasOfficialRating?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ItemsApiGetItems
     */
    readonly collapseBoxSetItems?: boolean

    /**
     * 
     * @type {number}
     * @memberof ItemsApiGetItems
     */
    readonly minWidth?: number

    /**
     * 
     * @type {number}
     * @memberof ItemsApiGetItems
     */
    readonly minHeight?: number

    /**
     * 
     * @type {number}
     * @memberof ItemsApiGetItems
     */
    readonly maxWidth?: number

    /**
     * 
     * @type {number}
     * @memberof ItemsApiGetItems
     */
    readonly maxHeight?: number

    /**
     * 
     * @type {boolean}
     * @memberof ItemsApiGetItems
     */
    readonly is3D?: boolean

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly seriesStatus?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly nameStartsWithOrGreater?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly nameStartsWith?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly nameLessThan?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly studioIds?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems
     */
    readonly genreIds?: string

    /**
     * 
     * @type {boolean}
     * @memberof ItemsApiGetItems
     */
    readonly enableTotalRecordCount?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ItemsApiGetItems
     */
    readonly enableImages?: boolean
}

/**
 * Request parameters for getItems2 operation in ItemsApi.
 * @export
 * @interface ItemsApiGetItems2Request
 */
export interface ItemsApiGetItems2Request {
    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly uId: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly userId?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly maxOfficialRating?: string

    /**
     * 
     * @type {boolean}
     * @memberof ItemsApiGetItems2
     */
    readonly hasThemeSong?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ItemsApiGetItems2
     */
    readonly hasThemeVideo?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ItemsApiGetItems2
     */
    readonly hasSubtitles?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ItemsApiGetItems2
     */
    readonly hasSpecialFeature?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ItemsApiGetItems2
     */
    readonly hasTrailer?: boolean

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly adjacentTo?: string

    /**
     * 
     * @type {number}
     * @memberof ItemsApiGetItems2
     */
    readonly parentIndexNumber?: number

    /**
     * 
     * @type {boolean}
     * @memberof ItemsApiGetItems2
     */
    readonly hasParentalRating?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ItemsApiGetItems2
     */
    readonly isHd?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ItemsApiGetItems2
     */
    readonly is4K?: boolean

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly locationTypes?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly excludeLocationTypes?: string

    /**
     * 
     * @type {boolean}
     * @memberof ItemsApiGetItems2
     */
    readonly isMissing?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ItemsApiGetItems2
     */
    readonly isUnaired?: boolean

    /**
     * 
     * @type {number}
     * @memberof ItemsApiGetItems2
     */
    readonly minCommunityRating?: number

    /**
     * 
     * @type {number}
     * @memberof ItemsApiGetItems2
     */
    readonly minCriticRating?: number

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly minPremiereDate?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly minDateLastSaved?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly minDateLastSavedForUser?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly maxPremiereDate?: string

    /**
     * 
     * @type {boolean}
     * @memberof ItemsApiGetItems2
     */
    readonly hasOverview?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ItemsApiGetItems2
     */
    readonly hasImdbId?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ItemsApiGetItems2
     */
    readonly hasTmdbId?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ItemsApiGetItems2
     */
    readonly hasTvdbId?: boolean

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly excludeItemIds?: string

    /**
     * 
     * @type {number}
     * @memberof ItemsApiGetItems2
     */
    readonly startIndex?: number

    /**
     * 
     * @type {number}
     * @memberof ItemsApiGetItems2
     */
    readonly limit?: number

    /**
     * 
     * @type {boolean}
     * @memberof ItemsApiGetItems2
     */
    readonly recursive?: boolean

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly searchTerm?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly sortOrder?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly parentId?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly fields?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly excludeItemTypes?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly includeItemTypes?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly filters?: string

    /**
     * 
     * @type {boolean}
     * @memberof ItemsApiGetItems2
     */
    readonly isFavorite?: boolean

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly mediaTypes?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly imageTypes?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly sortBy?: string

    /**
     * 
     * @type {boolean}
     * @memberof ItemsApiGetItems2
     */
    readonly isPlayed?: boolean

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly genres?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly officialRatings?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly tags?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly years?: string

    /**
     * 
     * @type {boolean}
     * @memberof ItemsApiGetItems2
     */
    readonly enableUserData?: boolean

    /**
     * 
     * @type {number}
     * @memberof ItemsApiGetItems2
     */
    readonly imageTypeLimit?: number

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly enableImageTypes?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly person?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly personIds?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly personTypes?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly studios?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly artists?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly excludeArtistIds?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly artistIds?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly albumArtistIds?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly contributingArtistIds?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly albums?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly albumIds?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly ids?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly videoTypes?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly minOfficialRating?: string

    /**
     * 
     * @type {boolean}
     * @memberof ItemsApiGetItems2
     */
    readonly isLocked?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ItemsApiGetItems2
     */
    readonly isPlaceHolder?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ItemsApiGetItems2
     */
    readonly hasOfficialRating?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ItemsApiGetItems2
     */
    readonly collapseBoxSetItems?: boolean

    /**
     * 
     * @type {number}
     * @memberof ItemsApiGetItems2
     */
    readonly minWidth?: number

    /**
     * 
     * @type {number}
     * @memberof ItemsApiGetItems2
     */
    readonly minHeight?: number

    /**
     * 
     * @type {number}
     * @memberof ItemsApiGetItems2
     */
    readonly maxWidth?: number

    /**
     * 
     * @type {number}
     * @memberof ItemsApiGetItems2
     */
    readonly maxHeight?: number

    /**
     * 
     * @type {boolean}
     * @memberof ItemsApiGetItems2
     */
    readonly is3D?: boolean

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly seriesStatus?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly nameStartsWithOrGreater?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly nameStartsWith?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly nameLessThan?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly studioIds?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetItems2
     */
    readonly genreIds?: string

    /**
     * 
     * @type {boolean}
     * @memberof ItemsApiGetItems2
     */
    readonly enableTotalRecordCount?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ItemsApiGetItems2
     */
    readonly enableImages?: boolean
}

/**
 * Request parameters for getResumeItems operation in ItemsApi.
 * @export
 * @interface ItemsApiGetResumeItemsRequest
 */
export interface ItemsApiGetResumeItemsRequest {
    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetResumeItems
     */
    readonly userId: string

    /**
     * 
     * @type {number}
     * @memberof ItemsApiGetResumeItems
     */
    readonly startIndex?: number

    /**
     * 
     * @type {number}
     * @memberof ItemsApiGetResumeItems
     */
    readonly limit?: number

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetResumeItems
     */
    readonly searchTerm?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetResumeItems
     */
    readonly parentId?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetResumeItems
     */
    readonly fields?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetResumeItems
     */
    readonly mediaTypes?: string

    /**
     * 
     * @type {boolean}
     * @memberof ItemsApiGetResumeItems
     */
    readonly enableUserData?: boolean

    /**
     * 
     * @type {number}
     * @memberof ItemsApiGetResumeItems
     */
    readonly imageTypeLimit?: number

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetResumeItems
     */
    readonly enableImageTypes?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetResumeItems
     */
    readonly excludeItemTypes?: string

    /**
     * 
     * @type {string}
     * @memberof ItemsApiGetResumeItems
     */
    readonly includeItemTypes?: string

    /**
     * 
     * @type {boolean}
     * @memberof ItemsApiGetResumeItems
     */
    readonly enableTotalRecordCount?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ItemsApiGetResumeItems
     */
    readonly enableImages?: boolean
}

/**
 * ItemsApi - object-oriented interface
 * @export
 * @class ItemsApi
 * @extends {BaseAPI}
 */
export class ItemsApi extends BaseAPI {
    /**
     * 
     * @param {ItemsApiGetItemsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public getItems(requestParameters: ItemsApiGetItemsRequest, options?: any) {
        return ItemsApiFp(this.configuration).getItems(requestParameters.uId, requestParameters.userId, requestParameters.maxOfficialRating, requestParameters.hasThemeSong, requestParameters.hasThemeVideo, requestParameters.hasSubtitles, requestParameters.hasSpecialFeature, requestParameters.hasTrailer, requestParameters.adjacentTo, requestParameters.parentIndexNumber, requestParameters.hasParentalRating, requestParameters.isHd, requestParameters.is4K, requestParameters.locationTypes, requestParameters.excludeLocationTypes, requestParameters.isMissing, requestParameters.isUnaired, requestParameters.minCommunityRating, requestParameters.minCriticRating, requestParameters.minPremiereDate, requestParameters.minDateLastSaved, requestParameters.minDateLastSavedForUser, requestParameters.maxPremiereDate, requestParameters.hasOverview, requestParameters.hasImdbId, requestParameters.hasTmdbId, requestParameters.hasTvdbId, requestParameters.excludeItemIds, requestParameters.startIndex, requestParameters.limit, requestParameters.recursive, requestParameters.searchTerm, requestParameters.sortOrder, requestParameters.parentId, requestParameters.fields, requestParameters.excludeItemTypes, requestParameters.includeItemTypes, requestParameters.filters, requestParameters.isFavorite, requestParameters.mediaTypes, requestParameters.imageTypes, requestParameters.sortBy, requestParameters.isPlayed, requestParameters.genres, requestParameters.officialRatings, requestParameters.tags, requestParameters.years, requestParameters.enableUserData, requestParameters.imageTypeLimit, requestParameters.enableImageTypes, requestParameters.person, requestParameters.personIds, requestParameters.personTypes, requestParameters.studios, requestParameters.artists, requestParameters.excludeArtistIds, requestParameters.artistIds, requestParameters.albumArtistIds, requestParameters.contributingArtistIds, requestParameters.albums, requestParameters.albumIds, requestParameters.ids, requestParameters.videoTypes, requestParameters.minOfficialRating, requestParameters.isLocked, requestParameters.isPlaceHolder, requestParameters.hasOfficialRating, requestParameters.collapseBoxSetItems, requestParameters.minWidth, requestParameters.minHeight, requestParameters.maxWidth, requestParameters.maxHeight, requestParameters.is3D, requestParameters.seriesStatus, requestParameters.nameStartsWithOrGreater, requestParameters.nameStartsWith, requestParameters.nameLessThan, requestParameters.studioIds, requestParameters.genreIds, requestParameters.enableTotalRecordCount, requestParameters.enableImages, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ItemsApiGetItems2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public getItems2(requestParameters: ItemsApiGetItems2Request, options?: any) {
        return ItemsApiFp(this.configuration).getItems2(requestParameters.uId, requestParameters.userId, requestParameters.maxOfficialRating, requestParameters.hasThemeSong, requestParameters.hasThemeVideo, requestParameters.hasSubtitles, requestParameters.hasSpecialFeature, requestParameters.hasTrailer, requestParameters.adjacentTo, requestParameters.parentIndexNumber, requestParameters.hasParentalRating, requestParameters.isHd, requestParameters.is4K, requestParameters.locationTypes, requestParameters.excludeLocationTypes, requestParameters.isMissing, requestParameters.isUnaired, requestParameters.minCommunityRating, requestParameters.minCriticRating, requestParameters.minPremiereDate, requestParameters.minDateLastSaved, requestParameters.minDateLastSavedForUser, requestParameters.maxPremiereDate, requestParameters.hasOverview, requestParameters.hasImdbId, requestParameters.hasTmdbId, requestParameters.hasTvdbId, requestParameters.excludeItemIds, requestParameters.startIndex, requestParameters.limit, requestParameters.recursive, requestParameters.searchTerm, requestParameters.sortOrder, requestParameters.parentId, requestParameters.fields, requestParameters.excludeItemTypes, requestParameters.includeItemTypes, requestParameters.filters, requestParameters.isFavorite, requestParameters.mediaTypes, requestParameters.imageTypes, requestParameters.sortBy, requestParameters.isPlayed, requestParameters.genres, requestParameters.officialRatings, requestParameters.tags, requestParameters.years, requestParameters.enableUserData, requestParameters.imageTypeLimit, requestParameters.enableImageTypes, requestParameters.person, requestParameters.personIds, requestParameters.personTypes, requestParameters.studios, requestParameters.artists, requestParameters.excludeArtistIds, requestParameters.artistIds, requestParameters.albumArtistIds, requestParameters.contributingArtistIds, requestParameters.albums, requestParameters.albumIds, requestParameters.ids, requestParameters.videoTypes, requestParameters.minOfficialRating, requestParameters.isLocked, requestParameters.isPlaceHolder, requestParameters.hasOfficialRating, requestParameters.collapseBoxSetItems, requestParameters.minWidth, requestParameters.minHeight, requestParameters.maxWidth, requestParameters.maxHeight, requestParameters.is3D, requestParameters.seriesStatus, requestParameters.nameStartsWithOrGreater, requestParameters.nameStartsWith, requestParameters.nameLessThan, requestParameters.studioIds, requestParameters.genreIds, requestParameters.enableTotalRecordCount, requestParameters.enableImages, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ItemsApiGetResumeItemsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public getResumeItems(requestParameters: ItemsApiGetResumeItemsRequest, options?: any) {
        return ItemsApiFp(this.configuration).getResumeItems(requestParameters.userId, requestParameters.startIndex, requestParameters.limit, requestParameters.searchTerm, requestParameters.parentId, requestParameters.fields, requestParameters.mediaTypes, requestParameters.enableUserData, requestParameters.imageTypeLimit, requestParameters.enableImageTypes, requestParameters.excludeItemTypes, requestParameters.includeItemTypes, requestParameters.enableTotalRecordCount, requestParameters.enableImages, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LibraryApi - axios parameter creator
 * @export
 */
export const LibraryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItem: async (itemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling deleteItem.');
            }
            const localVarPath = `/Items/{itemId}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [ids] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItems: async (ids?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Items`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAncestors: async (itemId: string, userId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getAncestors.');
            }
            const localVarPath = `/Items/{itemId}/Ancestors`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCriticReviews: async (itemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getCriticReviews.');
            }
            const localVarPath = `/Items/{itemId}/CriticReviews`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDownload: async (itemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getDownload.');
            }
            const localVarPath = `/Items/{itemId}/Download`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile: async (itemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getFile.');
            }
            const localVarPath = `/Items/{itemId}/File`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [userId] 
         * @param {boolean} [isFavorite] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemCounts: async (userId?: string, isFavorite?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Items/Counts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (isFavorite !== undefined) {
                localVarQueryParameter['isFavorite'] = isFavorite;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [libraryContentType] 
         * @param {boolean} [isNewLibrary] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLibraryOptionsInfo: async (libraryContentType?: string, isNewLibrary?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Libraries/AvailableOptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (libraryContentType !== undefined) {
                localVarQueryParameter['libraryContentType'] = libraryContentType;
            }

            if (isNewLibrary !== undefined) {
                localVarQueryParameter['isNewLibrary'] = isNewLibrary;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {boolean} [isHidden] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediaFolders: async (isHidden?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Library/MediaFolders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (isHidden !== undefined) {
                localVarQueryParameter['isHidden'] = isHidden;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhysicalPaths: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Library/PhysicalPaths`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} [excludeArtistIds] 
         * @param {string} [userId] 
         * @param {number} [limit] 
         * @param {string} [fields] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimilarAlbums2: async (itemId: string, excludeArtistIds?: string, userId?: string, limit?: number, fields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getSimilarAlbums2.');
            }
            const localVarPath = `/Albums/{itemId}/Similar`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (excludeArtistIds !== undefined) {
                localVarQueryParameter['excludeArtistIds'] = excludeArtistIds;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} [excludeArtistIds] 
         * @param {string} [userId] 
         * @param {number} [limit] 
         * @param {string} [fields] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimilarArtists2: async (itemId: string, excludeArtistIds?: string, userId?: string, limit?: number, fields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getSimilarArtists2.');
            }
            const localVarPath = `/Artists/{itemId}/Similar`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (excludeArtistIds !== undefined) {
                localVarQueryParameter['excludeArtistIds'] = excludeArtistIds;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} [excludeArtistIds] 
         * @param {string} [userId] 
         * @param {number} [limit] 
         * @param {string} [fields] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimilarItems: async (itemId: string, excludeArtistIds?: string, userId?: string, limit?: number, fields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getSimilarItems.');
            }
            const localVarPath = `/Items/{itemId}/Similar`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (excludeArtistIds !== undefined) {
                localVarQueryParameter['excludeArtistIds'] = excludeArtistIds;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} [excludeArtistIds] 
         * @param {string} [userId] 
         * @param {number} [limit] 
         * @param {string} [fields] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimilarMovies2: async (itemId: string, excludeArtistIds?: string, userId?: string, limit?: number, fields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getSimilarMovies2.');
            }
            const localVarPath = `/Movies/{itemId}/Similar`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (excludeArtistIds !== undefined) {
                localVarQueryParameter['excludeArtistIds'] = excludeArtistIds;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} [excludeArtistIds] 
         * @param {string} [userId] 
         * @param {number} [limit] 
         * @param {string} [fields] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimilarShows2: async (itemId: string, excludeArtistIds?: string, userId?: string, limit?: number, fields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getSimilarShows2.');
            }
            const localVarPath = `/Shows/{itemId}/Similar`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (excludeArtistIds !== undefined) {
                localVarQueryParameter['excludeArtistIds'] = excludeArtistIds;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} [excludeArtistIds] 
         * @param {string} [userId] 
         * @param {number} [limit] 
         * @param {string} [fields] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimilarTrailers2: async (itemId: string, excludeArtistIds?: string, userId?: string, limit?: number, fields?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getSimilarTrailers2.');
            }
            const localVarPath = `/Trailers/{itemId}/Similar`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (excludeArtistIds !== undefined) {
                localVarQueryParameter['excludeArtistIds'] = excludeArtistIds;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} [userId] 
         * @param {boolean} [inheritFromParent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThemeMedia: async (itemId: string, userId?: string, inheritFromParent?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getThemeMedia.');
            }
            const localVarPath = `/Items/{itemId}/ThemeMedia`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (inheritFromParent !== undefined) {
                localVarQueryParameter['inheritFromParent'] = inheritFromParent;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} [userId] 
         * @param {boolean} [inheritFromParent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThemeSongs: async (itemId: string, userId?: string, inheritFromParent?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getThemeSongs.');
            }
            const localVarPath = `/Items/{itemId}/ThemeSongs`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (inheritFromParent !== undefined) {
                localVarQueryParameter['inheritFromParent'] = inheritFromParent;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} [userId] 
         * @param {boolean} [inheritFromParent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThemeVideos: async (itemId: string, userId?: string, inheritFromParent?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getThemeVideos.');
            }
            const localVarPath = `/Items/{itemId}/ThemeVideos`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (inheritFromParent !== undefined) {
                localVarQueryParameter['inheritFromParent'] = inheritFromParent;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} tmdbId 
         * @param {string} imdbId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAddedMovies: async (tmdbId: string, imdbId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tmdbId' is not null or undefined
            if (tmdbId === null || tmdbId === undefined) {
                throw new RequiredError('tmdbId','Required parameter tmdbId was null or undefined when calling postAddedMovies.');
            }
            // verify required parameter 'imdbId' is not null or undefined
            if (imdbId === null || imdbId === undefined) {
                throw new RequiredError('imdbId','Required parameter imdbId was null or undefined when calling postAddedMovies.');
            }
            const localVarPath = `/Library/Movies/Added`
                .replace(`{${"tmdbId"}}`, encodeURIComponent(String(tmdbId)))
                .replace(`{${"imdbId"}}`, encodeURIComponent(String(imdbId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [tvdbId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAddedSeries: async (tvdbId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Library/Series/Added`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (tvdbId !== undefined) {
                localVarQueryParameter['tvdbId'] = tvdbId;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<MediaUpdateInfoDto>} mediaUpdateInfoDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUpdatedMedia: async (mediaUpdateInfoDto: Array<MediaUpdateInfoDto>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'mediaUpdateInfoDto' is not null or undefined
            if (mediaUpdateInfoDto === null || mediaUpdateInfoDto === undefined) {
                throw new RequiredError('mediaUpdateInfoDto','Required parameter mediaUpdateInfoDto was null or undefined when calling postUpdatedMedia.');
            }
            const localVarPath = `/Library/Media/Updated`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof mediaUpdateInfoDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(mediaUpdateInfoDto !== undefined ? mediaUpdateInfoDto : {}) : (mediaUpdateInfoDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} tmdbId 
         * @param {string} imdbId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUpdatedMovies: async (tmdbId: string, imdbId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tmdbId' is not null or undefined
            if (tmdbId === null || tmdbId === undefined) {
                throw new RequiredError('tmdbId','Required parameter tmdbId was null or undefined when calling postUpdatedMovies.');
            }
            // verify required parameter 'imdbId' is not null or undefined
            if (imdbId === null || imdbId === undefined) {
                throw new RequiredError('imdbId','Required parameter imdbId was null or undefined when calling postUpdatedMovies.');
            }
            const localVarPath = `/Library/Movies/Updated`
                .replace(`{${"tmdbId"}}`, encodeURIComponent(String(tmdbId)))
                .replace(`{${"imdbId"}}`, encodeURIComponent(String(imdbId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [tvdbId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUpdatedSeries: async (tvdbId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Library/Series/Updated`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (tvdbId !== undefined) {
                localVarQueryParameter['tvdbId'] = tvdbId;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshLibrary: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Library/Refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LibraryApi - functional programming interface
 * @export
 */
export const LibraryApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItem(itemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).deleteItem(itemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [ids] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItems(ids?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).deleteItems(ids, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAncestors(itemId: string, userId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BaseItemDto>>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).getAncestors(itemId, userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCriticReviews(itemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).getCriticReviews(itemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDownload(itemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).getDownload(itemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFile(itemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).getFile(itemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [userId] 
         * @param {boolean} [isFavorite] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemCounts(userId?: string, isFavorite?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemCounts>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).getItemCounts(userId, isFavorite, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [libraryContentType] 
         * @param {boolean} [isNewLibrary] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLibraryOptionsInfo(libraryContentType?: string, isNewLibrary?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LibraryOptionsResultDto>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).getLibraryOptionsInfo(libraryContentType, isNewLibrary, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {boolean} [isHidden] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMediaFolders(isHidden?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).getMediaFolders(isHidden, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPhysicalPaths(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).getPhysicalPaths(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} [excludeArtistIds] 
         * @param {string} [userId] 
         * @param {number} [limit] 
         * @param {string} [fields] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSimilarAlbums2(itemId: string, excludeArtistIds?: string, userId?: string, limit?: number, fields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).getSimilarAlbums2(itemId, excludeArtistIds, userId, limit, fields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} [excludeArtistIds] 
         * @param {string} [userId] 
         * @param {number} [limit] 
         * @param {string} [fields] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSimilarArtists2(itemId: string, excludeArtistIds?: string, userId?: string, limit?: number, fields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).getSimilarArtists2(itemId, excludeArtistIds, userId, limit, fields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} [excludeArtistIds] 
         * @param {string} [userId] 
         * @param {number} [limit] 
         * @param {string} [fields] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSimilarItems(itemId: string, excludeArtistIds?: string, userId?: string, limit?: number, fields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).getSimilarItems(itemId, excludeArtistIds, userId, limit, fields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} [excludeArtistIds] 
         * @param {string} [userId] 
         * @param {number} [limit] 
         * @param {string} [fields] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSimilarMovies2(itemId: string, excludeArtistIds?: string, userId?: string, limit?: number, fields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).getSimilarMovies2(itemId, excludeArtistIds, userId, limit, fields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} [excludeArtistIds] 
         * @param {string} [userId] 
         * @param {number} [limit] 
         * @param {string} [fields] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSimilarShows2(itemId: string, excludeArtistIds?: string, userId?: string, limit?: number, fields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).getSimilarShows2(itemId, excludeArtistIds, userId, limit, fields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} [excludeArtistIds] 
         * @param {string} [userId] 
         * @param {number} [limit] 
         * @param {string} [fields] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSimilarTrailers2(itemId: string, excludeArtistIds?: string, userId?: string, limit?: number, fields?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).getSimilarTrailers2(itemId, excludeArtistIds, userId, limit, fields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} [userId] 
         * @param {boolean} [inheritFromParent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getThemeMedia(itemId: string, userId?: string, inheritFromParent?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AllThemeMediaResult>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).getThemeMedia(itemId, userId, inheritFromParent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} [userId] 
         * @param {boolean} [inheritFromParent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getThemeSongs(itemId: string, userId?: string, inheritFromParent?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThemeMediaResult>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).getThemeSongs(itemId, userId, inheritFromParent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} [userId] 
         * @param {boolean} [inheritFromParent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getThemeVideos(itemId: string, userId?: string, inheritFromParent?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThemeMediaResult>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).getThemeVideos(itemId, userId, inheritFromParent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} tmdbId 
         * @param {string} imdbId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postAddedMovies(tmdbId: string, imdbId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).postAddedMovies(tmdbId, imdbId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [tvdbId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postAddedSeries(tvdbId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).postAddedSeries(tvdbId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Array<MediaUpdateInfoDto>} mediaUpdateInfoDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUpdatedMedia(mediaUpdateInfoDto: Array<MediaUpdateInfoDto>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).postUpdatedMedia(mediaUpdateInfoDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} tmdbId 
         * @param {string} imdbId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUpdatedMovies(tmdbId: string, imdbId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).postUpdatedMovies(tmdbId, imdbId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [tvdbId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUpdatedSeries(tvdbId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).postUpdatedSeries(tvdbId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshLibrary(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LibraryApiAxiosParamCreator(configuration).refreshLibrary(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * LibraryApi - factory interface
 * @export
 */
export const LibraryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItem(itemId: string, options?: any): AxiosPromise<void> {
            return LibraryApiFp(configuration).deleteItem(itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [ids] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItems(ids?: string, options?: any): AxiosPromise<void> {
            return LibraryApiFp(configuration).deleteItems(ids, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAncestors(itemId: string, userId?: string, options?: any): AxiosPromise<Array<BaseItemDto>> {
            return LibraryApiFp(configuration).getAncestors(itemId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCriticReviews(itemId: string, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return LibraryApiFp(configuration).getCriticReviews(itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDownload(itemId: string, options?: any): AxiosPromise<void> {
            return LibraryApiFp(configuration).getDownload(itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile(itemId: string, options?: any): AxiosPromise<void> {
            return LibraryApiFp(configuration).getFile(itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [userId] 
         * @param {boolean} [isFavorite] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemCounts(userId?: string, isFavorite?: boolean, options?: any): AxiosPromise<ItemCounts> {
            return LibraryApiFp(configuration).getItemCounts(userId, isFavorite, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [libraryContentType] 
         * @param {boolean} [isNewLibrary] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLibraryOptionsInfo(libraryContentType?: string, isNewLibrary?: boolean, options?: any): AxiosPromise<LibraryOptionsResultDto> {
            return LibraryApiFp(configuration).getLibraryOptionsInfo(libraryContentType, isNewLibrary, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {boolean} [isHidden] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediaFolders(isHidden?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return LibraryApiFp(configuration).getMediaFolders(isHidden, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhysicalPaths(options?: any): AxiosPromise<Array<string>> {
            return LibraryApiFp(configuration).getPhysicalPaths(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} [excludeArtistIds] 
         * @param {string} [userId] 
         * @param {number} [limit] 
         * @param {string} [fields] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimilarAlbums2(itemId: string, excludeArtistIds?: string, userId?: string, limit?: number, fields?: string, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return LibraryApiFp(configuration).getSimilarAlbums2(itemId, excludeArtistIds, userId, limit, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} [excludeArtistIds] 
         * @param {string} [userId] 
         * @param {number} [limit] 
         * @param {string} [fields] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimilarArtists2(itemId: string, excludeArtistIds?: string, userId?: string, limit?: number, fields?: string, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return LibraryApiFp(configuration).getSimilarArtists2(itemId, excludeArtistIds, userId, limit, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} [excludeArtistIds] 
         * @param {string} [userId] 
         * @param {number} [limit] 
         * @param {string} [fields] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimilarItems(itemId: string, excludeArtistIds?: string, userId?: string, limit?: number, fields?: string, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return LibraryApiFp(configuration).getSimilarItems(itemId, excludeArtistIds, userId, limit, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} [excludeArtistIds] 
         * @param {string} [userId] 
         * @param {number} [limit] 
         * @param {string} [fields] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimilarMovies2(itemId: string, excludeArtistIds?: string, userId?: string, limit?: number, fields?: string, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return LibraryApiFp(configuration).getSimilarMovies2(itemId, excludeArtistIds, userId, limit, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} [excludeArtistIds] 
         * @param {string} [userId] 
         * @param {number} [limit] 
         * @param {string} [fields] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimilarShows2(itemId: string, excludeArtistIds?: string, userId?: string, limit?: number, fields?: string, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return LibraryApiFp(configuration).getSimilarShows2(itemId, excludeArtistIds, userId, limit, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} [excludeArtistIds] 
         * @param {string} [userId] 
         * @param {number} [limit] 
         * @param {string} [fields] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimilarTrailers2(itemId: string, excludeArtistIds?: string, userId?: string, limit?: number, fields?: string, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return LibraryApiFp(configuration).getSimilarTrailers2(itemId, excludeArtistIds, userId, limit, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} [userId] 
         * @param {boolean} [inheritFromParent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThemeMedia(itemId: string, userId?: string, inheritFromParent?: boolean, options?: any): AxiosPromise<AllThemeMediaResult> {
            return LibraryApiFp(configuration).getThemeMedia(itemId, userId, inheritFromParent, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} [userId] 
         * @param {boolean} [inheritFromParent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThemeSongs(itemId: string, userId?: string, inheritFromParent?: boolean, options?: any): AxiosPromise<ThemeMediaResult> {
            return LibraryApiFp(configuration).getThemeSongs(itemId, userId, inheritFromParent, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} [userId] 
         * @param {boolean} [inheritFromParent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThemeVideos(itemId: string, userId?: string, inheritFromParent?: boolean, options?: any): AxiosPromise<ThemeMediaResult> {
            return LibraryApiFp(configuration).getThemeVideos(itemId, userId, inheritFromParent, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} tmdbId 
         * @param {string} imdbId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAddedMovies(tmdbId: string, imdbId: string, options?: any): AxiosPromise<void> {
            return LibraryApiFp(configuration).postAddedMovies(tmdbId, imdbId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [tvdbId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAddedSeries(tvdbId?: string, options?: any): AxiosPromise<void> {
            return LibraryApiFp(configuration).postAddedSeries(tvdbId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<MediaUpdateInfoDto>} mediaUpdateInfoDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUpdatedMedia(mediaUpdateInfoDto: Array<MediaUpdateInfoDto>, options?: any): AxiosPromise<void> {
            return LibraryApiFp(configuration).postUpdatedMedia(mediaUpdateInfoDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} tmdbId 
         * @param {string} imdbId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUpdatedMovies(tmdbId: string, imdbId: string, options?: any): AxiosPromise<void> {
            return LibraryApiFp(configuration).postUpdatedMovies(tmdbId, imdbId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [tvdbId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUpdatedSeries(tvdbId?: string, options?: any): AxiosPromise<void> {
            return LibraryApiFp(configuration).postUpdatedSeries(tvdbId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshLibrary(options?: any): AxiosPromise<void> {
            return LibraryApiFp(configuration).refreshLibrary(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deleteItem operation in LibraryApi.
 * @export
 * @interface LibraryApiDeleteItemRequest
 */
export interface LibraryApiDeleteItemRequest {
    /**
     * 
     * @type {string}
     * @memberof LibraryApiDeleteItem
     */
    readonly itemId: string
}

/**
 * Request parameters for deleteItems operation in LibraryApi.
 * @export
 * @interface LibraryApiDeleteItemsRequest
 */
export interface LibraryApiDeleteItemsRequest {
    /**
     * 
     * @type {string}
     * @memberof LibraryApiDeleteItems
     */
    readonly ids?: string
}

/**
 * Request parameters for getAncestors operation in LibraryApi.
 * @export
 * @interface LibraryApiGetAncestorsRequest
 */
export interface LibraryApiGetAncestorsRequest {
    /**
     * 
     * @type {string}
     * @memberof LibraryApiGetAncestors
     */
    readonly itemId: string

    /**
     * 
     * @type {string}
     * @memberof LibraryApiGetAncestors
     */
    readonly userId?: string
}

/**
 * Request parameters for getCriticReviews operation in LibraryApi.
 * @export
 * @interface LibraryApiGetCriticReviewsRequest
 */
export interface LibraryApiGetCriticReviewsRequest {
    /**
     * 
     * @type {string}
     * @memberof LibraryApiGetCriticReviews
     */
    readonly itemId: string
}

/**
 * Request parameters for getDownload operation in LibraryApi.
 * @export
 * @interface LibraryApiGetDownloadRequest
 */
export interface LibraryApiGetDownloadRequest {
    /**
     * 
     * @type {string}
     * @memberof LibraryApiGetDownload
     */
    readonly itemId: string
}

/**
 * Request parameters for getFile operation in LibraryApi.
 * @export
 * @interface LibraryApiGetFileRequest
 */
export interface LibraryApiGetFileRequest {
    /**
     * 
     * @type {string}
     * @memberof LibraryApiGetFile
     */
    readonly itemId: string
}

/**
 * Request parameters for getItemCounts operation in LibraryApi.
 * @export
 * @interface LibraryApiGetItemCountsRequest
 */
export interface LibraryApiGetItemCountsRequest {
    /**
     * 
     * @type {string}
     * @memberof LibraryApiGetItemCounts
     */
    readonly userId?: string

    /**
     * 
     * @type {boolean}
     * @memberof LibraryApiGetItemCounts
     */
    readonly isFavorite?: boolean
}

/**
 * Request parameters for getLibraryOptionsInfo operation in LibraryApi.
 * @export
 * @interface LibraryApiGetLibraryOptionsInfoRequest
 */
export interface LibraryApiGetLibraryOptionsInfoRequest {
    /**
     * 
     * @type {string}
     * @memberof LibraryApiGetLibraryOptionsInfo
     */
    readonly libraryContentType?: string

    /**
     * 
     * @type {boolean}
     * @memberof LibraryApiGetLibraryOptionsInfo
     */
    readonly isNewLibrary?: boolean
}

/**
 * Request parameters for getMediaFolders operation in LibraryApi.
 * @export
 * @interface LibraryApiGetMediaFoldersRequest
 */
export interface LibraryApiGetMediaFoldersRequest {
    /**
     * 
     * @type {boolean}
     * @memberof LibraryApiGetMediaFolders
     */
    readonly isHidden?: boolean
}

/**
 * Request parameters for getSimilarAlbums2 operation in LibraryApi.
 * @export
 * @interface LibraryApiGetSimilarAlbums2Request
 */
export interface LibraryApiGetSimilarAlbums2Request {
    /**
     * 
     * @type {string}
     * @memberof LibraryApiGetSimilarAlbums2
     */
    readonly itemId: string

    /**
     * 
     * @type {string}
     * @memberof LibraryApiGetSimilarAlbums2
     */
    readonly excludeArtistIds?: string

    /**
     * 
     * @type {string}
     * @memberof LibraryApiGetSimilarAlbums2
     */
    readonly userId?: string

    /**
     * 
     * @type {number}
     * @memberof LibraryApiGetSimilarAlbums2
     */
    readonly limit?: number

    /**
     * 
     * @type {string}
     * @memberof LibraryApiGetSimilarAlbums2
     */
    readonly fields?: string
}

/**
 * Request parameters for getSimilarArtists2 operation in LibraryApi.
 * @export
 * @interface LibraryApiGetSimilarArtists2Request
 */
export interface LibraryApiGetSimilarArtists2Request {
    /**
     * 
     * @type {string}
     * @memberof LibraryApiGetSimilarArtists2
     */
    readonly itemId: string

    /**
     * 
     * @type {string}
     * @memberof LibraryApiGetSimilarArtists2
     */
    readonly excludeArtistIds?: string

    /**
     * 
     * @type {string}
     * @memberof LibraryApiGetSimilarArtists2
     */
    readonly userId?: string

    /**
     * 
     * @type {number}
     * @memberof LibraryApiGetSimilarArtists2
     */
    readonly limit?: number

    /**
     * 
     * @type {string}
     * @memberof LibraryApiGetSimilarArtists2
     */
    readonly fields?: string
}

/**
 * Request parameters for getSimilarItems operation in LibraryApi.
 * @export
 * @interface LibraryApiGetSimilarItemsRequest
 */
export interface LibraryApiGetSimilarItemsRequest {
    /**
     * 
     * @type {string}
     * @memberof LibraryApiGetSimilarItems
     */
    readonly itemId: string

    /**
     * 
     * @type {string}
     * @memberof LibraryApiGetSimilarItems
     */
    readonly excludeArtistIds?: string

    /**
     * 
     * @type {string}
     * @memberof LibraryApiGetSimilarItems
     */
    readonly userId?: string

    /**
     * 
     * @type {number}
     * @memberof LibraryApiGetSimilarItems
     */
    readonly limit?: number

    /**
     * 
     * @type {string}
     * @memberof LibraryApiGetSimilarItems
     */
    readonly fields?: string
}

/**
 * Request parameters for getSimilarMovies2 operation in LibraryApi.
 * @export
 * @interface LibraryApiGetSimilarMovies2Request
 */
export interface LibraryApiGetSimilarMovies2Request {
    /**
     * 
     * @type {string}
     * @memberof LibraryApiGetSimilarMovies2
     */
    readonly itemId: string

    /**
     * 
     * @type {string}
     * @memberof LibraryApiGetSimilarMovies2
     */
    readonly excludeArtistIds?: string

    /**
     * 
     * @type {string}
     * @memberof LibraryApiGetSimilarMovies2
     */
    readonly userId?: string

    /**
     * 
     * @type {number}
     * @memberof LibraryApiGetSimilarMovies2
     */
    readonly limit?: number

    /**
     * 
     * @type {string}
     * @memberof LibraryApiGetSimilarMovies2
     */
    readonly fields?: string
}

/**
 * Request parameters for getSimilarShows2 operation in LibraryApi.
 * @export
 * @interface LibraryApiGetSimilarShows2Request
 */
export interface LibraryApiGetSimilarShows2Request {
    /**
     * 
     * @type {string}
     * @memberof LibraryApiGetSimilarShows2
     */
    readonly itemId: string

    /**
     * 
     * @type {string}
     * @memberof LibraryApiGetSimilarShows2
     */
    readonly excludeArtistIds?: string

    /**
     * 
     * @type {string}
     * @memberof LibraryApiGetSimilarShows2
     */
    readonly userId?: string

    /**
     * 
     * @type {number}
     * @memberof LibraryApiGetSimilarShows2
     */
    readonly limit?: number

    /**
     * 
     * @type {string}
     * @memberof LibraryApiGetSimilarShows2
     */
    readonly fields?: string
}

/**
 * Request parameters for getSimilarTrailers2 operation in LibraryApi.
 * @export
 * @interface LibraryApiGetSimilarTrailers2Request
 */
export interface LibraryApiGetSimilarTrailers2Request {
    /**
     * 
     * @type {string}
     * @memberof LibraryApiGetSimilarTrailers2
     */
    readonly itemId: string

    /**
     * 
     * @type {string}
     * @memberof LibraryApiGetSimilarTrailers2
     */
    readonly excludeArtistIds?: string

    /**
     * 
     * @type {string}
     * @memberof LibraryApiGetSimilarTrailers2
     */
    readonly userId?: string

    /**
     * 
     * @type {number}
     * @memberof LibraryApiGetSimilarTrailers2
     */
    readonly limit?: number

    /**
     * 
     * @type {string}
     * @memberof LibraryApiGetSimilarTrailers2
     */
    readonly fields?: string
}

/**
 * Request parameters for getThemeMedia operation in LibraryApi.
 * @export
 * @interface LibraryApiGetThemeMediaRequest
 */
export interface LibraryApiGetThemeMediaRequest {
    /**
     * 
     * @type {string}
     * @memberof LibraryApiGetThemeMedia
     */
    readonly itemId: string

    /**
     * 
     * @type {string}
     * @memberof LibraryApiGetThemeMedia
     */
    readonly userId?: string

    /**
     * 
     * @type {boolean}
     * @memberof LibraryApiGetThemeMedia
     */
    readonly inheritFromParent?: boolean
}

/**
 * Request parameters for getThemeSongs operation in LibraryApi.
 * @export
 * @interface LibraryApiGetThemeSongsRequest
 */
export interface LibraryApiGetThemeSongsRequest {
    /**
     * 
     * @type {string}
     * @memberof LibraryApiGetThemeSongs
     */
    readonly itemId: string

    /**
     * 
     * @type {string}
     * @memberof LibraryApiGetThemeSongs
     */
    readonly userId?: string

    /**
     * 
     * @type {boolean}
     * @memberof LibraryApiGetThemeSongs
     */
    readonly inheritFromParent?: boolean
}

/**
 * Request parameters for getThemeVideos operation in LibraryApi.
 * @export
 * @interface LibraryApiGetThemeVideosRequest
 */
export interface LibraryApiGetThemeVideosRequest {
    /**
     * 
     * @type {string}
     * @memberof LibraryApiGetThemeVideos
     */
    readonly itemId: string

    /**
     * 
     * @type {string}
     * @memberof LibraryApiGetThemeVideos
     */
    readonly userId?: string

    /**
     * 
     * @type {boolean}
     * @memberof LibraryApiGetThemeVideos
     */
    readonly inheritFromParent?: boolean
}

/**
 * Request parameters for postAddedMovies operation in LibraryApi.
 * @export
 * @interface LibraryApiPostAddedMoviesRequest
 */
export interface LibraryApiPostAddedMoviesRequest {
    /**
     * 
     * @type {string}
     * @memberof LibraryApiPostAddedMovies
     */
    readonly tmdbId: string

    /**
     * 
     * @type {string}
     * @memberof LibraryApiPostAddedMovies
     */
    readonly imdbId: string
}

/**
 * Request parameters for postAddedSeries operation in LibraryApi.
 * @export
 * @interface LibraryApiPostAddedSeriesRequest
 */
export interface LibraryApiPostAddedSeriesRequest {
    /**
     * 
     * @type {string}
     * @memberof LibraryApiPostAddedSeries
     */
    readonly tvdbId?: string
}

/**
 * Request parameters for postUpdatedMedia operation in LibraryApi.
 * @export
 * @interface LibraryApiPostUpdatedMediaRequest
 */
export interface LibraryApiPostUpdatedMediaRequest {
    /**
     * 
     * @type {Array<MediaUpdateInfoDto>}
     * @memberof LibraryApiPostUpdatedMedia
     */
    readonly mediaUpdateInfoDto: Array<MediaUpdateInfoDto>
}

/**
 * Request parameters for postUpdatedMovies operation in LibraryApi.
 * @export
 * @interface LibraryApiPostUpdatedMoviesRequest
 */
export interface LibraryApiPostUpdatedMoviesRequest {
    /**
     * 
     * @type {string}
     * @memberof LibraryApiPostUpdatedMovies
     */
    readonly tmdbId: string

    /**
     * 
     * @type {string}
     * @memberof LibraryApiPostUpdatedMovies
     */
    readonly imdbId: string
}

/**
 * Request parameters for postUpdatedSeries operation in LibraryApi.
 * @export
 * @interface LibraryApiPostUpdatedSeriesRequest
 */
export interface LibraryApiPostUpdatedSeriesRequest {
    /**
     * 
     * @type {string}
     * @memberof LibraryApiPostUpdatedSeries
     */
    readonly tvdbId?: string
}

/**
 * LibraryApi - object-oriented interface
 * @export
 * @class LibraryApi
 * @extends {BaseAPI}
 */
export class LibraryApi extends BaseAPI {
    /**
     * 
     * @param {LibraryApiDeleteItemRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public deleteItem(requestParameters: LibraryApiDeleteItemRequest, options?: any) {
        return LibraryApiFp(this.configuration).deleteItem(requestParameters.itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LibraryApiDeleteItemsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public deleteItems(requestParameters: LibraryApiDeleteItemsRequest = {}, options?: any) {
        return LibraryApiFp(this.configuration).deleteItems(requestParameters.ids, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LibraryApiGetAncestorsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public getAncestors(requestParameters: LibraryApiGetAncestorsRequest, options?: any) {
        return LibraryApiFp(this.configuration).getAncestors(requestParameters.itemId, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LibraryApiGetCriticReviewsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public getCriticReviews(requestParameters: LibraryApiGetCriticReviewsRequest, options?: any) {
        return LibraryApiFp(this.configuration).getCriticReviews(requestParameters.itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LibraryApiGetDownloadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public getDownload(requestParameters: LibraryApiGetDownloadRequest, options?: any) {
        return LibraryApiFp(this.configuration).getDownload(requestParameters.itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LibraryApiGetFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public getFile(requestParameters: LibraryApiGetFileRequest, options?: any) {
        return LibraryApiFp(this.configuration).getFile(requestParameters.itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LibraryApiGetItemCountsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public getItemCounts(requestParameters: LibraryApiGetItemCountsRequest = {}, options?: any) {
        return LibraryApiFp(this.configuration).getItemCounts(requestParameters.userId, requestParameters.isFavorite, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LibraryApiGetLibraryOptionsInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public getLibraryOptionsInfo(requestParameters: LibraryApiGetLibraryOptionsInfoRequest = {}, options?: any) {
        return LibraryApiFp(this.configuration).getLibraryOptionsInfo(requestParameters.libraryContentType, requestParameters.isNewLibrary, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LibraryApiGetMediaFoldersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public getMediaFolders(requestParameters: LibraryApiGetMediaFoldersRequest = {}, options?: any) {
        return LibraryApiFp(this.configuration).getMediaFolders(requestParameters.isHidden, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public getPhysicalPaths(options?: any) {
        return LibraryApiFp(this.configuration).getPhysicalPaths(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LibraryApiGetSimilarAlbums2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public getSimilarAlbums2(requestParameters: LibraryApiGetSimilarAlbums2Request, options?: any) {
        return LibraryApiFp(this.configuration).getSimilarAlbums2(requestParameters.itemId, requestParameters.excludeArtistIds, requestParameters.userId, requestParameters.limit, requestParameters.fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LibraryApiGetSimilarArtists2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public getSimilarArtists2(requestParameters: LibraryApiGetSimilarArtists2Request, options?: any) {
        return LibraryApiFp(this.configuration).getSimilarArtists2(requestParameters.itemId, requestParameters.excludeArtistIds, requestParameters.userId, requestParameters.limit, requestParameters.fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LibraryApiGetSimilarItemsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public getSimilarItems(requestParameters: LibraryApiGetSimilarItemsRequest, options?: any) {
        return LibraryApiFp(this.configuration).getSimilarItems(requestParameters.itemId, requestParameters.excludeArtistIds, requestParameters.userId, requestParameters.limit, requestParameters.fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LibraryApiGetSimilarMovies2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public getSimilarMovies2(requestParameters: LibraryApiGetSimilarMovies2Request, options?: any) {
        return LibraryApiFp(this.configuration).getSimilarMovies2(requestParameters.itemId, requestParameters.excludeArtistIds, requestParameters.userId, requestParameters.limit, requestParameters.fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LibraryApiGetSimilarShows2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public getSimilarShows2(requestParameters: LibraryApiGetSimilarShows2Request, options?: any) {
        return LibraryApiFp(this.configuration).getSimilarShows2(requestParameters.itemId, requestParameters.excludeArtistIds, requestParameters.userId, requestParameters.limit, requestParameters.fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LibraryApiGetSimilarTrailers2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public getSimilarTrailers2(requestParameters: LibraryApiGetSimilarTrailers2Request, options?: any) {
        return LibraryApiFp(this.configuration).getSimilarTrailers2(requestParameters.itemId, requestParameters.excludeArtistIds, requestParameters.userId, requestParameters.limit, requestParameters.fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LibraryApiGetThemeMediaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public getThemeMedia(requestParameters: LibraryApiGetThemeMediaRequest, options?: any) {
        return LibraryApiFp(this.configuration).getThemeMedia(requestParameters.itemId, requestParameters.userId, requestParameters.inheritFromParent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LibraryApiGetThemeSongsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public getThemeSongs(requestParameters: LibraryApiGetThemeSongsRequest, options?: any) {
        return LibraryApiFp(this.configuration).getThemeSongs(requestParameters.itemId, requestParameters.userId, requestParameters.inheritFromParent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LibraryApiGetThemeVideosRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public getThemeVideos(requestParameters: LibraryApiGetThemeVideosRequest, options?: any) {
        return LibraryApiFp(this.configuration).getThemeVideos(requestParameters.itemId, requestParameters.userId, requestParameters.inheritFromParent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LibraryApiPostAddedMoviesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public postAddedMovies(requestParameters: LibraryApiPostAddedMoviesRequest, options?: any) {
        return LibraryApiFp(this.configuration).postAddedMovies(requestParameters.tmdbId, requestParameters.imdbId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LibraryApiPostAddedSeriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public postAddedSeries(requestParameters: LibraryApiPostAddedSeriesRequest = {}, options?: any) {
        return LibraryApiFp(this.configuration).postAddedSeries(requestParameters.tvdbId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LibraryApiPostUpdatedMediaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public postUpdatedMedia(requestParameters: LibraryApiPostUpdatedMediaRequest, options?: any) {
        return LibraryApiFp(this.configuration).postUpdatedMedia(requestParameters.mediaUpdateInfoDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LibraryApiPostUpdatedMoviesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public postUpdatedMovies(requestParameters: LibraryApiPostUpdatedMoviesRequest, options?: any) {
        return LibraryApiFp(this.configuration).postUpdatedMovies(requestParameters.tmdbId, requestParameters.imdbId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LibraryApiPostUpdatedSeriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public postUpdatedSeries(requestParameters: LibraryApiPostUpdatedSeriesRequest = {}, options?: any) {
        return LibraryApiFp(this.configuration).postUpdatedSeries(requestParameters.tvdbId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApi
     */
    public refreshLibrary(options?: any) {
        return LibraryApiFp(this.configuration).refreshLibrary(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LibraryStructureApi - axios parameter creator
 * @export
 */
export const LibraryStructureApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {MediaPathDto} mediaPathDto 
         * @param {boolean} [refreshLibrary] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMediaPath: async (mediaPathDto: MediaPathDto, refreshLibrary?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'mediaPathDto' is not null or undefined
            if (mediaPathDto === null || mediaPathDto === undefined) {
                throw new RequiredError('mediaPathDto','Required parameter mediaPathDto was null or undefined when calling addMediaPath.');
            }
            const localVarPath = `/Library/VirtualFolders/Paths`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (refreshLibrary !== undefined) {
                localVarQueryParameter['refreshLibrary'] = refreshLibrary;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof mediaPathDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(mediaPathDto !== undefined ? mediaPathDto : {}) : (mediaPathDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [name] 
         * @param {string} [collectionType] 
         * @param {Array<string>} [paths] 
         * @param {boolean} [refreshLibrary] 
         * @param {AddVirtualFolderDto} [addVirtualFolderDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addVirtualFolder: async (name?: string, collectionType?: string, paths?: Array<string>, refreshLibrary?: boolean, addVirtualFolderDto?: AddVirtualFolderDto, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Library/VirtualFolders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (collectionType !== undefined) {
                localVarQueryParameter['collectionType'] = collectionType;
            }

            if (paths) {
                localVarQueryParameter['paths'] = paths;
            }

            if (refreshLibrary !== undefined) {
                localVarQueryParameter['refreshLibrary'] = refreshLibrary;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof addVirtualFolderDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(addVirtualFolderDto !== undefined ? addVirtualFolderDto : {}) : (addVirtualFolderDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualFolders: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Library/VirtualFolders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [name] 
         * @param {string} [path] 
         * @param {boolean} [refreshLibrary] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMediaPath: async (name?: string, path?: string, refreshLibrary?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Library/VirtualFolders/Paths`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            if (refreshLibrary !== undefined) {
                localVarQueryParameter['refreshLibrary'] = refreshLibrary;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [name] 
         * @param {boolean} [refreshLibrary] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeVirtualFolder: async (name?: string, refreshLibrary?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Library/VirtualFolders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (refreshLibrary !== undefined) {
                localVarQueryParameter['refreshLibrary'] = refreshLibrary;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [name] 
         * @param {string} [newName] 
         * @param {boolean} [refreshLibrary] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renameVirtualFolder: async (name?: string, newName?: string, refreshLibrary?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Library/VirtualFolders/Name`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (newName !== undefined) {
                localVarQueryParameter['newName'] = newName;
            }

            if (refreshLibrary !== undefined) {
                localVarQueryParameter['refreshLibrary'] = refreshLibrary;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateLibraryOptionsDto} [updateLibraryOptionsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLibraryOptions: async (updateLibraryOptionsDto?: UpdateLibraryOptionsDto, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Library/VirtualFolders/LibraryOptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof updateLibraryOptionsDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(updateLibraryOptionsDto !== undefined ? updateLibraryOptionsDto : {}) : (updateLibraryOptionsDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [name] 
         * @param {MediaPathInfo} [mediaPathInfo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMediaPath: async (name?: string, mediaPathInfo?: MediaPathInfo, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Library/VirtualFolders/Paths/Update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof mediaPathInfo !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(mediaPathInfo !== undefined ? mediaPathInfo : {}) : (mediaPathInfo || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LibraryStructureApi - functional programming interface
 * @export
 */
export const LibraryStructureApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {MediaPathDto} mediaPathDto 
         * @param {boolean} [refreshLibrary] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addMediaPath(mediaPathDto: MediaPathDto, refreshLibrary?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LibraryStructureApiAxiosParamCreator(configuration).addMediaPath(mediaPathDto, refreshLibrary, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [name] 
         * @param {string} [collectionType] 
         * @param {Array<string>} [paths] 
         * @param {boolean} [refreshLibrary] 
         * @param {AddVirtualFolderDto} [addVirtualFolderDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addVirtualFolder(name?: string, collectionType?: string, paths?: Array<string>, refreshLibrary?: boolean, addVirtualFolderDto?: AddVirtualFolderDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LibraryStructureApiAxiosParamCreator(configuration).addVirtualFolder(name, collectionType, paths, refreshLibrary, addVirtualFolderDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVirtualFolders(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VirtualFolderInfo>>> {
            const localVarAxiosArgs = await LibraryStructureApiAxiosParamCreator(configuration).getVirtualFolders(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [name] 
         * @param {string} [path] 
         * @param {boolean} [refreshLibrary] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeMediaPath(name?: string, path?: string, refreshLibrary?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LibraryStructureApiAxiosParamCreator(configuration).removeMediaPath(name, path, refreshLibrary, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [name] 
         * @param {boolean} [refreshLibrary] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeVirtualFolder(name?: string, refreshLibrary?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LibraryStructureApiAxiosParamCreator(configuration).removeVirtualFolder(name, refreshLibrary, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [name] 
         * @param {string} [newName] 
         * @param {boolean} [refreshLibrary] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async renameVirtualFolder(name?: string, newName?: string, refreshLibrary?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LibraryStructureApiAxiosParamCreator(configuration).renameVirtualFolder(name, newName, refreshLibrary, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {UpdateLibraryOptionsDto} [updateLibraryOptionsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateLibraryOptions(updateLibraryOptionsDto?: UpdateLibraryOptionsDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LibraryStructureApiAxiosParamCreator(configuration).updateLibraryOptions(updateLibraryOptionsDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [name] 
         * @param {MediaPathInfo} [mediaPathInfo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMediaPath(name?: string, mediaPathInfo?: MediaPathInfo, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LibraryStructureApiAxiosParamCreator(configuration).updateMediaPath(name, mediaPathInfo, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * LibraryStructureApi - factory interface
 * @export
 */
export const LibraryStructureApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {MediaPathDto} mediaPathDto 
         * @param {boolean} [refreshLibrary] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMediaPath(mediaPathDto: MediaPathDto, refreshLibrary?: boolean, options?: any): AxiosPromise<void> {
            return LibraryStructureApiFp(configuration).addMediaPath(mediaPathDto, refreshLibrary, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [name] 
         * @param {string} [collectionType] 
         * @param {Array<string>} [paths] 
         * @param {boolean} [refreshLibrary] 
         * @param {AddVirtualFolderDto} [addVirtualFolderDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addVirtualFolder(name?: string, collectionType?: string, paths?: Array<string>, refreshLibrary?: boolean, addVirtualFolderDto?: AddVirtualFolderDto, options?: any): AxiosPromise<void> {
            return LibraryStructureApiFp(configuration).addVirtualFolder(name, collectionType, paths, refreshLibrary, addVirtualFolderDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVirtualFolders(options?: any): AxiosPromise<Array<VirtualFolderInfo>> {
            return LibraryStructureApiFp(configuration).getVirtualFolders(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [name] 
         * @param {string} [path] 
         * @param {boolean} [refreshLibrary] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMediaPath(name?: string, path?: string, refreshLibrary?: boolean, options?: any): AxiosPromise<void> {
            return LibraryStructureApiFp(configuration).removeMediaPath(name, path, refreshLibrary, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [name] 
         * @param {boolean} [refreshLibrary] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeVirtualFolder(name?: string, refreshLibrary?: boolean, options?: any): AxiosPromise<void> {
            return LibraryStructureApiFp(configuration).removeVirtualFolder(name, refreshLibrary, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [name] 
         * @param {string} [newName] 
         * @param {boolean} [refreshLibrary] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renameVirtualFolder(name?: string, newName?: string, refreshLibrary?: boolean, options?: any): AxiosPromise<void> {
            return LibraryStructureApiFp(configuration).renameVirtualFolder(name, newName, refreshLibrary, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateLibraryOptionsDto} [updateLibraryOptionsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLibraryOptions(updateLibraryOptionsDto?: UpdateLibraryOptionsDto, options?: any): AxiosPromise<void> {
            return LibraryStructureApiFp(configuration).updateLibraryOptions(updateLibraryOptionsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [name] 
         * @param {MediaPathInfo} [mediaPathInfo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMediaPath(name?: string, mediaPathInfo?: MediaPathInfo, options?: any): AxiosPromise<void> {
            return LibraryStructureApiFp(configuration).updateMediaPath(name, mediaPathInfo, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addMediaPath operation in LibraryStructureApi.
 * @export
 * @interface LibraryStructureApiAddMediaPathRequest
 */
export interface LibraryStructureApiAddMediaPathRequest {
    /**
     * 
     * @type {MediaPathDto}
     * @memberof LibraryStructureApiAddMediaPath
     */
    readonly mediaPathDto: MediaPathDto

    /**
     * 
     * @type {boolean}
     * @memberof LibraryStructureApiAddMediaPath
     */
    readonly refreshLibrary?: boolean
}

/**
 * Request parameters for addVirtualFolder operation in LibraryStructureApi.
 * @export
 * @interface LibraryStructureApiAddVirtualFolderRequest
 */
export interface LibraryStructureApiAddVirtualFolderRequest {
    /**
     * 
     * @type {string}
     * @memberof LibraryStructureApiAddVirtualFolder
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof LibraryStructureApiAddVirtualFolder
     */
    readonly collectionType?: string

    /**
     * 
     * @type {Array<string>}
     * @memberof LibraryStructureApiAddVirtualFolder
     */
    readonly paths?: Array<string>

    /**
     * 
     * @type {boolean}
     * @memberof LibraryStructureApiAddVirtualFolder
     */
    readonly refreshLibrary?: boolean

    /**
     * 
     * @type {AddVirtualFolderDto}
     * @memberof LibraryStructureApiAddVirtualFolder
     */
    readonly addVirtualFolderDto?: AddVirtualFolderDto
}

/**
 * Request parameters for removeMediaPath operation in LibraryStructureApi.
 * @export
 * @interface LibraryStructureApiRemoveMediaPathRequest
 */
export interface LibraryStructureApiRemoveMediaPathRequest {
    /**
     * 
     * @type {string}
     * @memberof LibraryStructureApiRemoveMediaPath
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof LibraryStructureApiRemoveMediaPath
     */
    readonly path?: string

    /**
     * 
     * @type {boolean}
     * @memberof LibraryStructureApiRemoveMediaPath
     */
    readonly refreshLibrary?: boolean
}

/**
 * Request parameters for removeVirtualFolder operation in LibraryStructureApi.
 * @export
 * @interface LibraryStructureApiRemoveVirtualFolderRequest
 */
export interface LibraryStructureApiRemoveVirtualFolderRequest {
    /**
     * 
     * @type {string}
     * @memberof LibraryStructureApiRemoveVirtualFolder
     */
    readonly name?: string

    /**
     * 
     * @type {boolean}
     * @memberof LibraryStructureApiRemoveVirtualFolder
     */
    readonly refreshLibrary?: boolean
}

/**
 * Request parameters for renameVirtualFolder operation in LibraryStructureApi.
 * @export
 * @interface LibraryStructureApiRenameVirtualFolderRequest
 */
export interface LibraryStructureApiRenameVirtualFolderRequest {
    /**
     * 
     * @type {string}
     * @memberof LibraryStructureApiRenameVirtualFolder
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof LibraryStructureApiRenameVirtualFolder
     */
    readonly newName?: string

    /**
     * 
     * @type {boolean}
     * @memberof LibraryStructureApiRenameVirtualFolder
     */
    readonly refreshLibrary?: boolean
}

/**
 * Request parameters for updateLibraryOptions operation in LibraryStructureApi.
 * @export
 * @interface LibraryStructureApiUpdateLibraryOptionsRequest
 */
export interface LibraryStructureApiUpdateLibraryOptionsRequest {
    /**
     * 
     * @type {UpdateLibraryOptionsDto}
     * @memberof LibraryStructureApiUpdateLibraryOptions
     */
    readonly updateLibraryOptionsDto?: UpdateLibraryOptionsDto
}

/**
 * Request parameters for updateMediaPath operation in LibraryStructureApi.
 * @export
 * @interface LibraryStructureApiUpdateMediaPathRequest
 */
export interface LibraryStructureApiUpdateMediaPathRequest {
    /**
     * 
     * @type {string}
     * @memberof LibraryStructureApiUpdateMediaPath
     */
    readonly name?: string

    /**
     * 
     * @type {MediaPathInfo}
     * @memberof LibraryStructureApiUpdateMediaPath
     */
    readonly mediaPathInfo?: MediaPathInfo
}

/**
 * LibraryStructureApi - object-oriented interface
 * @export
 * @class LibraryStructureApi
 * @extends {BaseAPI}
 */
export class LibraryStructureApi extends BaseAPI {
    /**
     * 
     * @param {LibraryStructureApiAddMediaPathRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryStructureApi
     */
    public addMediaPath(requestParameters: LibraryStructureApiAddMediaPathRequest, options?: any) {
        return LibraryStructureApiFp(this.configuration).addMediaPath(requestParameters.mediaPathDto, requestParameters.refreshLibrary, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LibraryStructureApiAddVirtualFolderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryStructureApi
     */
    public addVirtualFolder(requestParameters: LibraryStructureApiAddVirtualFolderRequest = {}, options?: any) {
        return LibraryStructureApiFp(this.configuration).addVirtualFolder(requestParameters.name, requestParameters.collectionType, requestParameters.paths, requestParameters.refreshLibrary, requestParameters.addVirtualFolderDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryStructureApi
     */
    public getVirtualFolders(options?: any) {
        return LibraryStructureApiFp(this.configuration).getVirtualFolders(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LibraryStructureApiRemoveMediaPathRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryStructureApi
     */
    public removeMediaPath(requestParameters: LibraryStructureApiRemoveMediaPathRequest = {}, options?: any) {
        return LibraryStructureApiFp(this.configuration).removeMediaPath(requestParameters.name, requestParameters.path, requestParameters.refreshLibrary, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LibraryStructureApiRemoveVirtualFolderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryStructureApi
     */
    public removeVirtualFolder(requestParameters: LibraryStructureApiRemoveVirtualFolderRequest = {}, options?: any) {
        return LibraryStructureApiFp(this.configuration).removeVirtualFolder(requestParameters.name, requestParameters.refreshLibrary, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LibraryStructureApiRenameVirtualFolderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryStructureApi
     */
    public renameVirtualFolder(requestParameters: LibraryStructureApiRenameVirtualFolderRequest = {}, options?: any) {
        return LibraryStructureApiFp(this.configuration).renameVirtualFolder(requestParameters.name, requestParameters.newName, requestParameters.refreshLibrary, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LibraryStructureApiUpdateLibraryOptionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryStructureApi
     */
    public updateLibraryOptions(requestParameters: LibraryStructureApiUpdateLibraryOptionsRequest = {}, options?: any) {
        return LibraryStructureApiFp(this.configuration).updateLibraryOptions(requestParameters.updateLibraryOptionsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LibraryStructureApiUpdateMediaPathRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryStructureApi
     */
    public updateMediaPath(requestParameters: LibraryStructureApiUpdateMediaPathRequest = {}, options?: any) {
        return LibraryStructureApiFp(this.configuration).updateMediaPath(requestParameters.name, requestParameters.mediaPathInfo, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LiveTvApi - axios parameter creator
 * @export
 */
export const LiveTvApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [pw] 
         * @param {boolean} [validateListings] 
         * @param {boolean} [validateLogin] 
         * @param {ListingsProviderInfo} [listingsProviderInfo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addListingProvider: async (pw?: string, validateListings?: boolean, validateLogin?: boolean, listingsProviderInfo?: ListingsProviderInfo, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/ListingProviders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (pw !== undefined) {
                localVarQueryParameter['pw'] = pw;
            }

            if (validateListings !== undefined) {
                localVarQueryParameter['validateListings'] = validateListings;
            }

            if (validateLogin !== undefined) {
                localVarQueryParameter['validateLogin'] = validateLogin;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof listingsProviderInfo !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(listingsProviderInfo !== undefined ? listingsProviderInfo : {}) : (listingsProviderInfo || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TunerHostInfo} [tunerHostInfo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTunerHost: async (tunerHostInfo?: TunerHostInfo, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/TunerHosts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof tunerHostInfo !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(tunerHostInfo !== undefined ? tunerHostInfo : {}) : (tunerHostInfo || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} timerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelSeriesTimer: async (timerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'timerId' is not null or undefined
            if (timerId === null || timerId === undefined) {
                throw new RequiredError('timerId','Required parameter timerId was null or undefined when calling cancelSeriesTimer.');
            }
            const localVarPath = `/LiveTv/SeriesTimers/{timerId}`
                .replace(`{${"timerId"}}`, encodeURIComponent(String(timerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} timerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelTimer: async (timerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'timerId' is not null or undefined
            if (timerId === null || timerId === undefined) {
                throw new RequiredError('timerId','Required parameter timerId was null or undefined when calling cancelTimer.');
            }
            const localVarPath = `/LiveTv/Timers/{timerId}`
                .replace(`{${"timerId"}}`, encodeURIComponent(String(timerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SeriesTimerInfoDto} [seriesTimerInfoDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSeriesTimer: async (seriesTimerInfoDto?: SeriesTimerInfoDto, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/SeriesTimers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof seriesTimerInfoDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(seriesTimerInfoDto !== undefined ? seriesTimerInfoDto : {}) : (seriesTimerInfoDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TimerInfoDto} [timerInfoDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTimer: async (timerInfoDto?: TimerInfoDto, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Timers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof timerInfoDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(timerInfoDto !== undefined ? timerInfoDto : {}) : (timerInfoDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteListingProvider: async (id?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/ListingProviders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} recordingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecording: async (recordingId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'recordingId' is not null or undefined
            if (recordingId === null || recordingId === undefined) {
                throw new RequiredError('recordingId','Required parameter recordingId was null or undefined when calling deleteRecording.');
            }
            const localVarPath = `/LiveTv/Recordings/{recordingId}`
                .replace(`{${"recordingId"}}`, encodeURIComponent(String(recordingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTunerHost: async (id?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/TunerHosts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {boolean} [newDevicesOnly] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discoverTuners: async (newDevicesOnly?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Tuners/Discvover`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (newDevicesOnly !== undefined) {
                localVarQueryParameter['newDevicesOnly'] = newDevicesOnly;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannel: async (channelId: string, userId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            if (channelId === null || channelId === undefined) {
                throw new RequiredError('channelId','Required parameter channelId was null or undefined when calling getChannel.');
            }
            const localVarPath = `/LiveTv/Channels/{channelId}`
                .replace(`{${"channelId"}}`, encodeURIComponent(String(channelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [providerId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelMappingOptions: async (providerId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/ChannelMappingOptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (providerId !== undefined) {
                localVarQueryParameter['providerId'] = providerId;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultListingProvider: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/ListingProviders/Default`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [programId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultTimer: async (programId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Timers/Defaults`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (programId !== undefined) {
                localVarQueryParameter['programId'] = programId;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGuideInfo: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/GuideInfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [type] 
         * @param {string} [location] 
         * @param {string} [country] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLineups: async (id?: string, type?: string, location?: string, country?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/ListingProviders/Lineups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (location !== undefined) {
                localVarQueryParameter['location'] = location;
            }

            if (country !== undefined) {
                localVarQueryParameter['country'] = country;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} recordingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveRecordingFile: async (recordingId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'recordingId' is not null or undefined
            if (recordingId === null || recordingId === undefined) {
                throw new RequiredError('recordingId','Required parameter recordingId was null or undefined when calling getLiveRecordingFile.');
            }
            const localVarPath = `/LiveTv/LiveRecordings/{recordingId}/stream`
                .replace(`{${"recordingId"}}`, encodeURIComponent(String(recordingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} streamId 
         * @param {string} container 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveStreamFile: async (streamId: string, container: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'streamId' is not null or undefined
            if (streamId === null || streamId === undefined) {
                throw new RequiredError('streamId','Required parameter streamId was null or undefined when calling getLiveStreamFile.');
            }
            // verify required parameter 'container' is not null or undefined
            if (container === null || container === undefined) {
                throw new RequiredError('container','Required parameter container was null or undefined when calling getLiveStreamFile.');
            }
            const localVarPath = `/LiveTv/LiveStreamFiles/{streamId}/stream.{container}`
                .replace(`{${"streamId"}}`, encodeURIComponent(String(streamId)))
                .replace(`{${"container"}}`, encodeURIComponent(String(container)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ChannelType} [type] 
         * @param {string} [userId] 
         * @param {number} [startIndex] 
         * @param {boolean} [isMovie] 
         * @param {boolean} [isSeries] 
         * @param {boolean} [isNews] 
         * @param {boolean} [isKids] 
         * @param {boolean} [isSports] 
         * @param {number} [limit] 
         * @param {boolean} [isFavorite] 
         * @param {boolean} [isLiked] 
         * @param {boolean} [isDisliked] 
         * @param {boolean} [enableImages] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {string} [fields] 
         * @param {boolean} [enableUserData] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {boolean} [enableFavoriteSorting] 
         * @param {boolean} [addCurrentProgram] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveTvChannels: async (type?: ChannelType, userId?: string, startIndex?: number, isMovie?: boolean, isSeries?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, limit?: number, isFavorite?: boolean, isLiked?: boolean, isDisliked?: boolean, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: string, fields?: string, enableUserData?: boolean, sortBy?: string, sortOrder?: SortOrder, enableFavoriteSorting?: boolean, addCurrentProgram?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Channels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (isMovie !== undefined) {
                localVarQueryParameter['isMovie'] = isMovie;
            }

            if (isSeries !== undefined) {
                localVarQueryParameter['isSeries'] = isSeries;
            }

            if (isNews !== undefined) {
                localVarQueryParameter['isNews'] = isNews;
            }

            if (isKids !== undefined) {
                localVarQueryParameter['isKids'] = isKids;
            }

            if (isSports !== undefined) {
                localVarQueryParameter['isSports'] = isSports;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (isFavorite !== undefined) {
                localVarQueryParameter['isFavorite'] = isFavorite;
            }

            if (isLiked !== undefined) {
                localVarQueryParameter['isLiked'] = isLiked;
            }

            if (isDisliked !== undefined) {
                localVarQueryParameter['isDisliked'] = isDisliked;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes !== undefined) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (enableFavoriteSorting !== undefined) {
                localVarQueryParameter['enableFavoriteSorting'] = enableFavoriteSorting;
            }

            if (addCurrentProgram !== undefined) {
                localVarQueryParameter['addCurrentProgram'] = addCurrentProgram;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveTvInfo: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [channelIds] 
         * @param {string} [userId] 
         * @param {string} [minStartDate] 
         * @param {boolean} [hasAired] 
         * @param {boolean} [isAiring] 
         * @param {string} [maxStartDate] 
         * @param {string} [minEndDate] 
         * @param {string} [maxEndDate] 
         * @param {boolean} [isMovie] 
         * @param {boolean} [isSeries] 
         * @param {boolean} [isNews] 
         * @param {boolean} [isKids] 
         * @param {boolean} [isSports] 
         * @param {number} [startIndex] 
         * @param {number} [limit] 
         * @param {string} [sortBy] 
         * @param {string} [sortOrder] 
         * @param {string} [genres] 
         * @param {string} [genreIds] 
         * @param {boolean} [enableImages] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {boolean} [enableUserData] 
         * @param {string} [seriesTimerId] 
         * @param {string} [librarySeriesId] 
         * @param {string} [fields] 
         * @param {boolean} [enableTotalRecordCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveTvPrograms: async (channelIds?: string, userId?: string, minStartDate?: string, hasAired?: boolean, isAiring?: boolean, maxStartDate?: string, minEndDate?: string, maxEndDate?: string, isMovie?: boolean, isSeries?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, startIndex?: number, limit?: number, sortBy?: string, sortOrder?: string, genres?: string, genreIds?: string, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: string, enableUserData?: boolean, seriesTimerId?: string, librarySeriesId?: string, fields?: string, enableTotalRecordCount?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Programs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (channelIds !== undefined) {
                localVarQueryParameter['channelIds'] = channelIds;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (minStartDate !== undefined) {
                localVarQueryParameter['minStartDate'] = (minStartDate as any instanceof Date) ?
                    (minStartDate as any).toISOString() :
                    minStartDate;
            }

            if (hasAired !== undefined) {
                localVarQueryParameter['hasAired'] = hasAired;
            }

            if (isAiring !== undefined) {
                localVarQueryParameter['isAiring'] = isAiring;
            }

            if (maxStartDate !== undefined) {
                localVarQueryParameter['maxStartDate'] = (maxStartDate as any instanceof Date) ?
                    (maxStartDate as any).toISOString() :
                    maxStartDate;
            }

            if (minEndDate !== undefined) {
                localVarQueryParameter['minEndDate'] = (minEndDate as any instanceof Date) ?
                    (minEndDate as any).toISOString() :
                    minEndDate;
            }

            if (maxEndDate !== undefined) {
                localVarQueryParameter['maxEndDate'] = (maxEndDate as any instanceof Date) ?
                    (maxEndDate as any).toISOString() :
                    maxEndDate;
            }

            if (isMovie !== undefined) {
                localVarQueryParameter['isMovie'] = isMovie;
            }

            if (isSeries !== undefined) {
                localVarQueryParameter['isSeries'] = isSeries;
            }

            if (isNews !== undefined) {
                localVarQueryParameter['isNews'] = isNews;
            }

            if (isKids !== undefined) {
                localVarQueryParameter['isKids'] = isKids;
            }

            if (isSports !== undefined) {
                localVarQueryParameter['isSports'] = isSports;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (genres !== undefined) {
                localVarQueryParameter['genres'] = genres;
            }

            if (genreIds !== undefined) {
                localVarQueryParameter['genreIds'] = genreIds;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes !== undefined) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (seriesTimerId !== undefined) {
                localVarQueryParameter['seriesTimerId'] = seriesTimerId;
            }

            if (librarySeriesId !== undefined) {
                localVarQueryParameter['librarySeriesId'] = librarySeriesId;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (enableTotalRecordCount !== undefined) {
                localVarQueryParameter['enableTotalRecordCount'] = enableTotalRecordCount;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgram: async (programId: string, userId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            if (programId === null || programId === undefined) {
                throw new RequiredError('programId','Required parameter programId was null or undefined when calling getProgram.');
            }
            const localVarPath = `/LiveTv/Programs/{programId}`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GetProgramsDto} [getProgramsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPrograms: async (getProgramsDto?: GetProgramsDto, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Programs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof getProgramsDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(getProgramsDto !== undefined ? getProgramsDto : {}) : (getProgramsDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [userId] 
         * @param {number} [limit] 
         * @param {boolean} [isAiring] 
         * @param {boolean} [hasAired] 
         * @param {boolean} [isSeries] 
         * @param {boolean} [isMovie] 
         * @param {boolean} [isNews] 
         * @param {boolean} [isKids] 
         * @param {boolean} [isSports] 
         * @param {boolean} [enableImages] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {string} [genreIds] 
         * @param {string} [fields] 
         * @param {boolean} [enableUserData] 
         * @param {boolean} [enableTotalRecordCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecommendedPrograms: async (userId?: string, limit?: number, isAiring?: boolean, hasAired?: boolean, isSeries?: boolean, isMovie?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: string, genreIds?: string, fields?: string, enableUserData?: boolean, enableTotalRecordCount?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Programs/Recommended`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (isAiring !== undefined) {
                localVarQueryParameter['isAiring'] = isAiring;
            }

            if (hasAired !== undefined) {
                localVarQueryParameter['hasAired'] = hasAired;
            }

            if (isSeries !== undefined) {
                localVarQueryParameter['isSeries'] = isSeries;
            }

            if (isMovie !== undefined) {
                localVarQueryParameter['isMovie'] = isMovie;
            }

            if (isNews !== undefined) {
                localVarQueryParameter['isNews'] = isNews;
            }

            if (isKids !== undefined) {
                localVarQueryParameter['isKids'] = isKids;
            }

            if (isSports !== undefined) {
                localVarQueryParameter['isSports'] = isSports;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes !== undefined) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }

            if (genreIds !== undefined) {
                localVarQueryParameter['genreIds'] = genreIds;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (enableTotalRecordCount !== undefined) {
                localVarQueryParameter['enableTotalRecordCount'] = enableTotalRecordCount;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} recordingId 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecording: async (recordingId: string, userId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'recordingId' is not null or undefined
            if (recordingId === null || recordingId === undefined) {
                throw new RequiredError('recordingId','Required parameter recordingId was null or undefined when calling getRecording.');
            }
            const localVarPath = `/LiveTv/Recordings/{recordingId}`
                .replace(`{${"recordingId"}}`, encodeURIComponent(String(recordingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecordingFolders: async (userId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Recordings/Folders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecordingGroup: async (groupId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            if (groupId === null || groupId === undefined) {
                throw new RequiredError('groupId','Required parameter groupId was null or undefined when calling getRecordingGroup.');
            }
            const localVarPath = `/LiveTv/Recordings/Groups/{groupId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecordingGroups: async (userId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Recordings/Groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [channelId] 
         * @param {string} [userId] 
         * @param {number} [startIndex] 
         * @param {number} [limit] 
         * @param {RecordingStatus} [status] 
         * @param {boolean} [isInProgress] 
         * @param {string} [seriesTimerId] 
         * @param {boolean} [enableImages] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {string} [fields] 
         * @param {boolean} [enableUserData] 
         * @param {boolean} [isMovie] 
         * @param {boolean} [isSeries] 
         * @param {boolean} [isKids] 
         * @param {boolean} [isSports] 
         * @param {boolean} [isNews] 
         * @param {boolean} [isLibraryItem] 
         * @param {boolean} [enableTotalRecordCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecordings: async (channelId?: string, userId?: string, startIndex?: number, limit?: number, status?: RecordingStatus, isInProgress?: boolean, seriesTimerId?: string, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: string, fields?: string, enableUserData?: boolean, isMovie?: boolean, isSeries?: boolean, isKids?: boolean, isSports?: boolean, isNews?: boolean, isLibraryItem?: boolean, enableTotalRecordCount?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Recordings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (channelId !== undefined) {
                localVarQueryParameter['channelId'] = channelId;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (isInProgress !== undefined) {
                localVarQueryParameter['isInProgress'] = isInProgress;
            }

            if (seriesTimerId !== undefined) {
                localVarQueryParameter['seriesTimerId'] = seriesTimerId;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes !== undefined) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (isMovie !== undefined) {
                localVarQueryParameter['isMovie'] = isMovie;
            }

            if (isSeries !== undefined) {
                localVarQueryParameter['isSeries'] = isSeries;
            }

            if (isKids !== undefined) {
                localVarQueryParameter['isKids'] = isKids;
            }

            if (isSports !== undefined) {
                localVarQueryParameter['isSports'] = isSports;
            }

            if (isNews !== undefined) {
                localVarQueryParameter['isNews'] = isNews;
            }

            if (isLibraryItem !== undefined) {
                localVarQueryParameter['isLibraryItem'] = isLibraryItem;
            }

            if (enableTotalRecordCount !== undefined) {
                localVarQueryParameter['enableTotalRecordCount'] = enableTotalRecordCount;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [channelId] 
         * @param {string} [userId] 
         * @param {string} [groupId] 
         * @param {number} [startIndex] 
         * @param {number} [limit] 
         * @param {RecordingStatus} [status] 
         * @param {boolean} [isInProgress] 
         * @param {string} [seriesTimerId] 
         * @param {boolean} [enableImages] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {string} [fields] 
         * @param {boolean} [enableUserData] 
         * @param {boolean} [enableTotalRecordCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecordingsSeries: async (channelId?: string, userId?: string, groupId?: string, startIndex?: number, limit?: number, status?: RecordingStatus, isInProgress?: boolean, seriesTimerId?: string, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: string, fields?: string, enableUserData?: boolean, enableTotalRecordCount?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Recordings/Series`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (channelId !== undefined) {
                localVarQueryParameter['channelId'] = channelId;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (groupId !== undefined) {
                localVarQueryParameter['groupId'] = groupId;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (isInProgress !== undefined) {
                localVarQueryParameter['isInProgress'] = isInProgress;
            }

            if (seriesTimerId !== undefined) {
                localVarQueryParameter['seriesTimerId'] = seriesTimerId;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes !== undefined) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (enableTotalRecordCount !== undefined) {
                localVarQueryParameter['enableTotalRecordCount'] = enableTotalRecordCount;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchedulesDirectCountries: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/ListingProviders/SchedulesDirect/Countries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} timerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSeriesTimer: async (timerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'timerId' is not null or undefined
            if (timerId === null || timerId === undefined) {
                throw new RequiredError('timerId','Required parameter timerId was null or undefined when calling getSeriesTimer.');
            }
            const localVarPath = `/LiveTv/SeriesTimers/{timerId}`
                .replace(`{${"timerId"}}`, encodeURIComponent(String(timerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSeriesTimers: async (sortBy?: string, sortOrder?: SortOrder, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/SeriesTimers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} timerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimer: async (timerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'timerId' is not null or undefined
            if (timerId === null || timerId === undefined) {
                throw new RequiredError('timerId','Required parameter timerId was null or undefined when calling getTimer.');
            }
            const localVarPath = `/LiveTv/Timers/{timerId}`
                .replace(`{${"timerId"}}`, encodeURIComponent(String(timerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [channelId] 
         * @param {string} [seriesTimerId] 
         * @param {boolean} [isActive] 
         * @param {boolean} [isScheduled] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimers: async (channelId?: string, seriesTimerId?: string, isActive?: boolean, isScheduled?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/Timers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (channelId !== undefined) {
                localVarQueryParameter['channelId'] = channelId;
            }

            if (seriesTimerId !== undefined) {
                localVarQueryParameter['seriesTimerId'] = seriesTimerId;
            }

            if (isActive !== undefined) {
                localVarQueryParameter['isActive'] = isActive;
            }

            if (isScheduled !== undefined) {
                localVarQueryParameter['isScheduled'] = isScheduled;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTunerHostTypes: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/TunerHosts/Types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} tunerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetTuner: async (tunerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tunerId' is not null or undefined
            if (tunerId === null || tunerId === undefined) {
                throw new RequiredError('tunerId','Required parameter tunerId was null or undefined when calling resetTuner.');
            }
            const localVarPath = `/LiveTv/Tuners/{tunerId}/Reset`
                .replace(`{${"tunerId"}}`, encodeURIComponent(String(tunerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [providerId] 
         * @param {string} [tunerChannelId] 
         * @param {string} [providerChannelId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setChannelMapping: async (providerId?: string, tunerChannelId?: string, providerChannelId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveTv/ChannelMappings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (providerId !== undefined) {
                localVarQueryParameter['providerId'] = providerId;
            }

            if (tunerChannelId !== undefined) {
                localVarQueryParameter['tunerChannelId'] = tunerChannelId;
            }

            if (providerChannelId !== undefined) {
                localVarQueryParameter['providerChannelId'] = providerChannelId;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} timerId 
         * @param {SeriesTimerInfoDto} [seriesTimerInfoDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSeriesTimer: async (timerId: string, seriesTimerInfoDto?: SeriesTimerInfoDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'timerId' is not null or undefined
            if (timerId === null || timerId === undefined) {
                throw new RequiredError('timerId','Required parameter timerId was null or undefined when calling updateSeriesTimer.');
            }
            const localVarPath = `/LiveTv/SeriesTimers/{timerId}`
                .replace(`{${"timerId"}}`, encodeURIComponent(String(timerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof seriesTimerInfoDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(seriesTimerInfoDto !== undefined ? seriesTimerInfoDto : {}) : (seriesTimerInfoDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} timerId 
         * @param {TimerInfoDto} [timerInfoDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTimer: async (timerId: string, timerInfoDto?: TimerInfoDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'timerId' is not null or undefined
            if (timerId === null || timerId === undefined) {
                throw new RequiredError('timerId','Required parameter timerId was null or undefined when calling updateTimer.');
            }
            const localVarPath = `/LiveTv/Timers/{timerId}`
                .replace(`{${"timerId"}}`, encodeURIComponent(String(timerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof timerInfoDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(timerInfoDto !== undefined ? timerInfoDto : {}) : (timerInfoDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LiveTvApi - functional programming interface
 * @export
 */
export const LiveTvApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [pw] 
         * @param {boolean} [validateListings] 
         * @param {boolean} [validateLogin] 
         * @param {ListingsProviderInfo} [listingsProviderInfo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addListingProvider(pw?: string, validateListings?: boolean, validateLogin?: boolean, listingsProviderInfo?: ListingsProviderInfo, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListingsProviderInfo>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).addListingProvider(pw, validateListings, validateLogin, listingsProviderInfo, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {TunerHostInfo} [tunerHostInfo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addTunerHost(tunerHostInfo?: TunerHostInfo, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TunerHostInfo>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).addTunerHost(tunerHostInfo, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} timerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelSeriesTimer(timerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).cancelSeriesTimer(timerId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} timerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelTimer(timerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).cancelTimer(timerId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {SeriesTimerInfoDto} [seriesTimerInfoDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSeriesTimer(seriesTimerInfoDto?: SeriesTimerInfoDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).createSeriesTimer(seriesTimerInfoDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {TimerInfoDto} [timerInfoDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTimer(timerInfoDto?: TimerInfoDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).createTimer(timerInfoDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteListingProvider(id?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).deleteListingProvider(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} recordingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRecording(recordingId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).deleteRecording(recordingId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTunerHost(id?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).deleteTunerHost(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {boolean} [newDevicesOnly] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discoverTuners(newDevicesOnly?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TunerHostInfo>>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).discoverTuners(newDevicesOnly, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChannel(channelId: string, userId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDto>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getChannel(channelId, userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [providerId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChannelMappingOptions(providerId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChannelMappingOptionsDto>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getChannelMappingOptions(providerId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDefaultListingProvider(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListingsProviderInfo>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getDefaultListingProvider(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [programId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDefaultTimer(programId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SeriesTimerInfoDto>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getDefaultTimer(programId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGuideInfo(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuideInfo>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getGuideInfo(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [type] 
         * @param {string} [location] 
         * @param {string} [country] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLineups(id?: string, type?: string, location?: string, country?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NameIdPair>>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getLineups(id, type, location, country, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} recordingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLiveRecordingFile(recordingId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getLiveRecordingFile(recordingId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} streamId 
         * @param {string} container 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLiveStreamFile(streamId: string, container: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getLiveStreamFile(streamId, container, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {ChannelType} [type] 
         * @param {string} [userId] 
         * @param {number} [startIndex] 
         * @param {boolean} [isMovie] 
         * @param {boolean} [isSeries] 
         * @param {boolean} [isNews] 
         * @param {boolean} [isKids] 
         * @param {boolean} [isSports] 
         * @param {number} [limit] 
         * @param {boolean} [isFavorite] 
         * @param {boolean} [isLiked] 
         * @param {boolean} [isDisliked] 
         * @param {boolean} [enableImages] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {string} [fields] 
         * @param {boolean} [enableUserData] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {boolean} [enableFavoriteSorting] 
         * @param {boolean} [addCurrentProgram] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLiveTvChannels(type?: ChannelType, userId?: string, startIndex?: number, isMovie?: boolean, isSeries?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, limit?: number, isFavorite?: boolean, isLiked?: boolean, isDisliked?: boolean, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: string, fields?: string, enableUserData?: boolean, sortBy?: string, sortOrder?: SortOrder, enableFavoriteSorting?: boolean, addCurrentProgram?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getLiveTvChannels(type, userId, startIndex, isMovie, isSeries, isNews, isKids, isSports, limit, isFavorite, isLiked, isDisliked, enableImages, imageTypeLimit, enableImageTypes, fields, enableUserData, sortBy, sortOrder, enableFavoriteSorting, addCurrentProgram, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLiveTvInfo(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LiveTvInfo>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getLiveTvInfo(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [channelIds] 
         * @param {string} [userId] 
         * @param {string} [minStartDate] 
         * @param {boolean} [hasAired] 
         * @param {boolean} [isAiring] 
         * @param {string} [maxStartDate] 
         * @param {string} [minEndDate] 
         * @param {string} [maxEndDate] 
         * @param {boolean} [isMovie] 
         * @param {boolean} [isSeries] 
         * @param {boolean} [isNews] 
         * @param {boolean} [isKids] 
         * @param {boolean} [isSports] 
         * @param {number} [startIndex] 
         * @param {number} [limit] 
         * @param {string} [sortBy] 
         * @param {string} [sortOrder] 
         * @param {string} [genres] 
         * @param {string} [genreIds] 
         * @param {boolean} [enableImages] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {boolean} [enableUserData] 
         * @param {string} [seriesTimerId] 
         * @param {string} [librarySeriesId] 
         * @param {string} [fields] 
         * @param {boolean} [enableTotalRecordCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLiveTvPrograms(channelIds?: string, userId?: string, minStartDate?: string, hasAired?: boolean, isAiring?: boolean, maxStartDate?: string, minEndDate?: string, maxEndDate?: string, isMovie?: boolean, isSeries?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, startIndex?: number, limit?: number, sortBy?: string, sortOrder?: string, genres?: string, genreIds?: string, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: string, enableUserData?: boolean, seriesTimerId?: string, librarySeriesId?: string, fields?: string, enableTotalRecordCount?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getLiveTvPrograms(channelIds, userId, minStartDate, hasAired, isAiring, maxStartDate, minEndDate, maxEndDate, isMovie, isSeries, isNews, isKids, isSports, startIndex, limit, sortBy, sortOrder, genres, genreIds, enableImages, imageTypeLimit, enableImageTypes, enableUserData, seriesTimerId, librarySeriesId, fields, enableTotalRecordCount, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProgram(programId: string, userId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDto>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getProgram(programId, userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {GetProgramsDto} [getProgramsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPrograms(getProgramsDto?: GetProgramsDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getPrograms(getProgramsDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [userId] 
         * @param {number} [limit] 
         * @param {boolean} [isAiring] 
         * @param {boolean} [hasAired] 
         * @param {boolean} [isSeries] 
         * @param {boolean} [isMovie] 
         * @param {boolean} [isNews] 
         * @param {boolean} [isKids] 
         * @param {boolean} [isSports] 
         * @param {boolean} [enableImages] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {string} [genreIds] 
         * @param {string} [fields] 
         * @param {boolean} [enableUserData] 
         * @param {boolean} [enableTotalRecordCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecommendedPrograms(userId?: string, limit?: number, isAiring?: boolean, hasAired?: boolean, isSeries?: boolean, isMovie?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: string, genreIds?: string, fields?: string, enableUserData?: boolean, enableTotalRecordCount?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getRecommendedPrograms(userId, limit, isAiring, hasAired, isSeries, isMovie, isNews, isKids, isSports, enableImages, imageTypeLimit, enableImageTypes, genreIds, fields, enableUserData, enableTotalRecordCount, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} recordingId 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecording(recordingId: string, userId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDto>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getRecording(recordingId, userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecordingFolders(userId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getRecordingFolders(userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecordingGroup(groupId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getRecordingGroup(groupId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecordingGroups(userId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getRecordingGroups(userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [channelId] 
         * @param {string} [userId] 
         * @param {number} [startIndex] 
         * @param {number} [limit] 
         * @param {RecordingStatus} [status] 
         * @param {boolean} [isInProgress] 
         * @param {string} [seriesTimerId] 
         * @param {boolean} [enableImages] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {string} [fields] 
         * @param {boolean} [enableUserData] 
         * @param {boolean} [isMovie] 
         * @param {boolean} [isSeries] 
         * @param {boolean} [isKids] 
         * @param {boolean} [isSports] 
         * @param {boolean} [isNews] 
         * @param {boolean} [isLibraryItem] 
         * @param {boolean} [enableTotalRecordCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecordings(channelId?: string, userId?: string, startIndex?: number, limit?: number, status?: RecordingStatus, isInProgress?: boolean, seriesTimerId?: string, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: string, fields?: string, enableUserData?: boolean, isMovie?: boolean, isSeries?: boolean, isKids?: boolean, isSports?: boolean, isNews?: boolean, isLibraryItem?: boolean, enableTotalRecordCount?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getRecordings(channelId, userId, startIndex, limit, status, isInProgress, seriesTimerId, enableImages, imageTypeLimit, enableImageTypes, fields, enableUserData, isMovie, isSeries, isKids, isSports, isNews, isLibraryItem, enableTotalRecordCount, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [channelId] 
         * @param {string} [userId] 
         * @param {string} [groupId] 
         * @param {number} [startIndex] 
         * @param {number} [limit] 
         * @param {RecordingStatus} [status] 
         * @param {boolean} [isInProgress] 
         * @param {string} [seriesTimerId] 
         * @param {boolean} [enableImages] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {string} [fields] 
         * @param {boolean} [enableUserData] 
         * @param {boolean} [enableTotalRecordCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecordingsSeries(channelId?: string, userId?: string, groupId?: string, startIndex?: number, limit?: number, status?: RecordingStatus, isInProgress?: boolean, seriesTimerId?: string, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: string, fields?: string, enableUserData?: boolean, enableTotalRecordCount?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getRecordingsSeries(channelId, userId, groupId, startIndex, limit, status, isInProgress, seriesTimerId, enableImages, imageTypeLimit, enableImageTypes, fields, enableUserData, enableTotalRecordCount, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSchedulesDirectCountries(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getSchedulesDirectCountries(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} timerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSeriesTimer(timerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SeriesTimerInfoDto>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getSeriesTimer(timerId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSeriesTimers(sortBy?: string, sortOrder?: SortOrder, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SeriesTimerInfoDtoQueryResult>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getSeriesTimers(sortBy, sortOrder, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} timerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTimer(timerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TimerInfoDto>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getTimer(timerId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [channelId] 
         * @param {string} [seriesTimerId] 
         * @param {boolean} [isActive] 
         * @param {boolean} [isScheduled] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTimers(channelId?: string, seriesTimerId?: string, isActive?: boolean, isScheduled?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TimerInfoDtoQueryResult>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getTimers(channelId, seriesTimerId, isActive, isScheduled, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTunerHostTypes(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NameIdPair>>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).getTunerHostTypes(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} tunerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetTuner(tunerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).resetTuner(tunerId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [providerId] 
         * @param {string} [tunerChannelId] 
         * @param {string} [providerChannelId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setChannelMapping(providerId?: string, tunerChannelId?: string, providerChannelId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TunerChannelMapping>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).setChannelMapping(providerId, tunerChannelId, providerChannelId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} timerId 
         * @param {SeriesTimerInfoDto} [seriesTimerInfoDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSeriesTimer(timerId: string, seriesTimerInfoDto?: SeriesTimerInfoDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).updateSeriesTimer(timerId, seriesTimerInfoDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} timerId 
         * @param {TimerInfoDto} [timerInfoDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTimer(timerId: string, timerInfoDto?: TimerInfoDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LiveTvApiAxiosParamCreator(configuration).updateTimer(timerId, timerInfoDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * LiveTvApi - factory interface
 * @export
 */
export const LiveTvApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} [pw] 
         * @param {boolean} [validateListings] 
         * @param {boolean} [validateLogin] 
         * @param {ListingsProviderInfo} [listingsProviderInfo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addListingProvider(pw?: string, validateListings?: boolean, validateLogin?: boolean, listingsProviderInfo?: ListingsProviderInfo, options?: any): AxiosPromise<ListingsProviderInfo> {
            return LiveTvApiFp(configuration).addListingProvider(pw, validateListings, validateLogin, listingsProviderInfo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TunerHostInfo} [tunerHostInfo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTunerHost(tunerHostInfo?: TunerHostInfo, options?: any): AxiosPromise<TunerHostInfo> {
            return LiveTvApiFp(configuration).addTunerHost(tunerHostInfo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} timerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelSeriesTimer(timerId: string, options?: any): AxiosPromise<void> {
            return LiveTvApiFp(configuration).cancelSeriesTimer(timerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} timerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelTimer(timerId: string, options?: any): AxiosPromise<void> {
            return LiveTvApiFp(configuration).cancelTimer(timerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SeriesTimerInfoDto} [seriesTimerInfoDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSeriesTimer(seriesTimerInfoDto?: SeriesTimerInfoDto, options?: any): AxiosPromise<void> {
            return LiveTvApiFp(configuration).createSeriesTimer(seriesTimerInfoDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TimerInfoDto} [timerInfoDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTimer(timerInfoDto?: TimerInfoDto, options?: any): AxiosPromise<void> {
            return LiveTvApiFp(configuration).createTimer(timerInfoDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteListingProvider(id?: string, options?: any): AxiosPromise<void> {
            return LiveTvApiFp(configuration).deleteListingProvider(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} recordingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecording(recordingId: string, options?: any): AxiosPromise<void> {
            return LiveTvApiFp(configuration).deleteRecording(recordingId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTunerHost(id?: string, options?: any): AxiosPromise<void> {
            return LiveTvApiFp(configuration).deleteTunerHost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {boolean} [newDevicesOnly] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discoverTuners(newDevicesOnly?: boolean, options?: any): AxiosPromise<Array<TunerHostInfo>> {
            return LiveTvApiFp(configuration).discoverTuners(newDevicesOnly, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} channelId 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannel(channelId: string, userId?: string, options?: any): AxiosPromise<BaseItemDto> {
            return LiveTvApiFp(configuration).getChannel(channelId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [providerId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelMappingOptions(providerId?: string, options?: any): AxiosPromise<ChannelMappingOptionsDto> {
            return LiveTvApiFp(configuration).getChannelMappingOptions(providerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultListingProvider(options?: any): AxiosPromise<ListingsProviderInfo> {
            return LiveTvApiFp(configuration).getDefaultListingProvider(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [programId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultTimer(programId?: string, options?: any): AxiosPromise<SeriesTimerInfoDto> {
            return LiveTvApiFp(configuration).getDefaultTimer(programId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGuideInfo(options?: any): AxiosPromise<GuideInfo> {
            return LiveTvApiFp(configuration).getGuideInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [type] 
         * @param {string} [location] 
         * @param {string} [country] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLineups(id?: string, type?: string, location?: string, country?: string, options?: any): AxiosPromise<Array<NameIdPair>> {
            return LiveTvApiFp(configuration).getLineups(id, type, location, country, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} recordingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveRecordingFile(recordingId: string, options?: any): AxiosPromise<void> {
            return LiveTvApiFp(configuration).getLiveRecordingFile(recordingId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} streamId 
         * @param {string} container 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveStreamFile(streamId: string, container: string, options?: any): AxiosPromise<void> {
            return LiveTvApiFp(configuration).getLiveStreamFile(streamId, container, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ChannelType} [type] 
         * @param {string} [userId] 
         * @param {number} [startIndex] 
         * @param {boolean} [isMovie] 
         * @param {boolean} [isSeries] 
         * @param {boolean} [isNews] 
         * @param {boolean} [isKids] 
         * @param {boolean} [isSports] 
         * @param {number} [limit] 
         * @param {boolean} [isFavorite] 
         * @param {boolean} [isLiked] 
         * @param {boolean} [isDisliked] 
         * @param {boolean} [enableImages] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {string} [fields] 
         * @param {boolean} [enableUserData] 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {boolean} [enableFavoriteSorting] 
         * @param {boolean} [addCurrentProgram] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveTvChannels(type?: ChannelType, userId?: string, startIndex?: number, isMovie?: boolean, isSeries?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, limit?: number, isFavorite?: boolean, isLiked?: boolean, isDisliked?: boolean, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: string, fields?: string, enableUserData?: boolean, sortBy?: string, sortOrder?: SortOrder, enableFavoriteSorting?: boolean, addCurrentProgram?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return LiveTvApiFp(configuration).getLiveTvChannels(type, userId, startIndex, isMovie, isSeries, isNews, isKids, isSports, limit, isFavorite, isLiked, isDisliked, enableImages, imageTypeLimit, enableImageTypes, fields, enableUserData, sortBy, sortOrder, enableFavoriteSorting, addCurrentProgram, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveTvInfo(options?: any): AxiosPromise<LiveTvInfo> {
            return LiveTvApiFp(configuration).getLiveTvInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [channelIds] 
         * @param {string} [userId] 
         * @param {string} [minStartDate] 
         * @param {boolean} [hasAired] 
         * @param {boolean} [isAiring] 
         * @param {string} [maxStartDate] 
         * @param {string} [minEndDate] 
         * @param {string} [maxEndDate] 
         * @param {boolean} [isMovie] 
         * @param {boolean} [isSeries] 
         * @param {boolean} [isNews] 
         * @param {boolean} [isKids] 
         * @param {boolean} [isSports] 
         * @param {number} [startIndex] 
         * @param {number} [limit] 
         * @param {string} [sortBy] 
         * @param {string} [sortOrder] 
         * @param {string} [genres] 
         * @param {string} [genreIds] 
         * @param {boolean} [enableImages] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {boolean} [enableUserData] 
         * @param {string} [seriesTimerId] 
         * @param {string} [librarySeriesId] 
         * @param {string} [fields] 
         * @param {boolean} [enableTotalRecordCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveTvPrograms(channelIds?: string, userId?: string, minStartDate?: string, hasAired?: boolean, isAiring?: boolean, maxStartDate?: string, minEndDate?: string, maxEndDate?: string, isMovie?: boolean, isSeries?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, startIndex?: number, limit?: number, sortBy?: string, sortOrder?: string, genres?: string, genreIds?: string, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: string, enableUserData?: boolean, seriesTimerId?: string, librarySeriesId?: string, fields?: string, enableTotalRecordCount?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return LiveTvApiFp(configuration).getLiveTvPrograms(channelIds, userId, minStartDate, hasAired, isAiring, maxStartDate, minEndDate, maxEndDate, isMovie, isSeries, isNews, isKids, isSports, startIndex, limit, sortBy, sortOrder, genres, genreIds, enableImages, imageTypeLimit, enableImageTypes, enableUserData, seriesTimerId, librarySeriesId, fields, enableTotalRecordCount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgram(programId: string, userId?: string, options?: any): AxiosPromise<BaseItemDto> {
            return LiveTvApiFp(configuration).getProgram(programId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GetProgramsDto} [getProgramsDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPrograms(getProgramsDto?: GetProgramsDto, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return LiveTvApiFp(configuration).getPrograms(getProgramsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [userId] 
         * @param {number} [limit] 
         * @param {boolean} [isAiring] 
         * @param {boolean} [hasAired] 
         * @param {boolean} [isSeries] 
         * @param {boolean} [isMovie] 
         * @param {boolean} [isNews] 
         * @param {boolean} [isKids] 
         * @param {boolean} [isSports] 
         * @param {boolean} [enableImages] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {string} [genreIds] 
         * @param {string} [fields] 
         * @param {boolean} [enableUserData] 
         * @param {boolean} [enableTotalRecordCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecommendedPrograms(userId?: string, limit?: number, isAiring?: boolean, hasAired?: boolean, isSeries?: boolean, isMovie?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: string, genreIds?: string, fields?: string, enableUserData?: boolean, enableTotalRecordCount?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return LiveTvApiFp(configuration).getRecommendedPrograms(userId, limit, isAiring, hasAired, isSeries, isMovie, isNews, isKids, isSports, enableImages, imageTypeLimit, enableImageTypes, genreIds, fields, enableUserData, enableTotalRecordCount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} recordingId 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecording(recordingId: string, userId?: string, options?: any): AxiosPromise<BaseItemDto> {
            return LiveTvApiFp(configuration).getRecording(recordingId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecordingFolders(userId?: string, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return LiveTvApiFp(configuration).getRecordingFolders(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecordingGroup(groupId: string, options?: any): AxiosPromise<void> {
            return LiveTvApiFp(configuration).getRecordingGroup(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecordingGroups(userId?: string, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return LiveTvApiFp(configuration).getRecordingGroups(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [channelId] 
         * @param {string} [userId] 
         * @param {number} [startIndex] 
         * @param {number} [limit] 
         * @param {RecordingStatus} [status] 
         * @param {boolean} [isInProgress] 
         * @param {string} [seriesTimerId] 
         * @param {boolean} [enableImages] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {string} [fields] 
         * @param {boolean} [enableUserData] 
         * @param {boolean} [isMovie] 
         * @param {boolean} [isSeries] 
         * @param {boolean} [isKids] 
         * @param {boolean} [isSports] 
         * @param {boolean} [isNews] 
         * @param {boolean} [isLibraryItem] 
         * @param {boolean} [enableTotalRecordCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecordings(channelId?: string, userId?: string, startIndex?: number, limit?: number, status?: RecordingStatus, isInProgress?: boolean, seriesTimerId?: string, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: string, fields?: string, enableUserData?: boolean, isMovie?: boolean, isSeries?: boolean, isKids?: boolean, isSports?: boolean, isNews?: boolean, isLibraryItem?: boolean, enableTotalRecordCount?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return LiveTvApiFp(configuration).getRecordings(channelId, userId, startIndex, limit, status, isInProgress, seriesTimerId, enableImages, imageTypeLimit, enableImageTypes, fields, enableUserData, isMovie, isSeries, isKids, isSports, isNews, isLibraryItem, enableTotalRecordCount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [channelId] 
         * @param {string} [userId] 
         * @param {string} [groupId] 
         * @param {number} [startIndex] 
         * @param {number} [limit] 
         * @param {RecordingStatus} [status] 
         * @param {boolean} [isInProgress] 
         * @param {string} [seriesTimerId] 
         * @param {boolean} [enableImages] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {string} [fields] 
         * @param {boolean} [enableUserData] 
         * @param {boolean} [enableTotalRecordCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecordingsSeries(channelId?: string, userId?: string, groupId?: string, startIndex?: number, limit?: number, status?: RecordingStatus, isInProgress?: boolean, seriesTimerId?: string, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: string, fields?: string, enableUserData?: boolean, enableTotalRecordCount?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return LiveTvApiFp(configuration).getRecordingsSeries(channelId, userId, groupId, startIndex, limit, status, isInProgress, seriesTimerId, enableImages, imageTypeLimit, enableImageTypes, fields, enableUserData, enableTotalRecordCount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchedulesDirectCountries(options?: any): AxiosPromise<void> {
            return LiveTvApiFp(configuration).getSchedulesDirectCountries(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} timerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSeriesTimer(timerId: string, options?: any): AxiosPromise<SeriesTimerInfoDto> {
            return LiveTvApiFp(configuration).getSeriesTimer(timerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [sortBy] 
         * @param {SortOrder} [sortOrder] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSeriesTimers(sortBy?: string, sortOrder?: SortOrder, options?: any): AxiosPromise<SeriesTimerInfoDtoQueryResult> {
            return LiveTvApiFp(configuration).getSeriesTimers(sortBy, sortOrder, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} timerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimer(timerId: string, options?: any): AxiosPromise<TimerInfoDto> {
            return LiveTvApiFp(configuration).getTimer(timerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [channelId] 
         * @param {string} [seriesTimerId] 
         * @param {boolean} [isActive] 
         * @param {boolean} [isScheduled] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimers(channelId?: string, seriesTimerId?: string, isActive?: boolean, isScheduled?: boolean, options?: any): AxiosPromise<TimerInfoDtoQueryResult> {
            return LiveTvApiFp(configuration).getTimers(channelId, seriesTimerId, isActive, isScheduled, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTunerHostTypes(options?: any): AxiosPromise<Array<NameIdPair>> {
            return LiveTvApiFp(configuration).getTunerHostTypes(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} tunerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetTuner(tunerId: string, options?: any): AxiosPromise<void> {
            return LiveTvApiFp(configuration).resetTuner(tunerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [providerId] 
         * @param {string} [tunerChannelId] 
         * @param {string} [providerChannelId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setChannelMapping(providerId?: string, tunerChannelId?: string, providerChannelId?: string, options?: any): AxiosPromise<TunerChannelMapping> {
            return LiveTvApiFp(configuration).setChannelMapping(providerId, tunerChannelId, providerChannelId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} timerId 
         * @param {SeriesTimerInfoDto} [seriesTimerInfoDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSeriesTimer(timerId: string, seriesTimerInfoDto?: SeriesTimerInfoDto, options?: any): AxiosPromise<void> {
            return LiveTvApiFp(configuration).updateSeriesTimer(timerId, seriesTimerInfoDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} timerId 
         * @param {TimerInfoDto} [timerInfoDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTimer(timerId: string, timerInfoDto?: TimerInfoDto, options?: any): AxiosPromise<void> {
            return LiveTvApiFp(configuration).updateTimer(timerId, timerInfoDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addListingProvider operation in LiveTvApi.
 * @export
 * @interface LiveTvApiAddListingProviderRequest
 */
export interface LiveTvApiAddListingProviderRequest {
    /**
     * 
     * @type {string}
     * @memberof LiveTvApiAddListingProvider
     */
    readonly pw?: string

    /**
     * 
     * @type {boolean}
     * @memberof LiveTvApiAddListingProvider
     */
    readonly validateListings?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof LiveTvApiAddListingProvider
     */
    readonly validateLogin?: boolean

    /**
     * 
     * @type {ListingsProviderInfo}
     * @memberof LiveTvApiAddListingProvider
     */
    readonly listingsProviderInfo?: ListingsProviderInfo
}

/**
 * Request parameters for addTunerHost operation in LiveTvApi.
 * @export
 * @interface LiveTvApiAddTunerHostRequest
 */
export interface LiveTvApiAddTunerHostRequest {
    /**
     * 
     * @type {TunerHostInfo}
     * @memberof LiveTvApiAddTunerHost
     */
    readonly tunerHostInfo?: TunerHostInfo
}

/**
 * Request parameters for cancelSeriesTimer operation in LiveTvApi.
 * @export
 * @interface LiveTvApiCancelSeriesTimerRequest
 */
export interface LiveTvApiCancelSeriesTimerRequest {
    /**
     * 
     * @type {string}
     * @memberof LiveTvApiCancelSeriesTimer
     */
    readonly timerId: string
}

/**
 * Request parameters for cancelTimer operation in LiveTvApi.
 * @export
 * @interface LiveTvApiCancelTimerRequest
 */
export interface LiveTvApiCancelTimerRequest {
    /**
     * 
     * @type {string}
     * @memberof LiveTvApiCancelTimer
     */
    readonly timerId: string
}

/**
 * Request parameters for createSeriesTimer operation in LiveTvApi.
 * @export
 * @interface LiveTvApiCreateSeriesTimerRequest
 */
export interface LiveTvApiCreateSeriesTimerRequest {
    /**
     * 
     * @type {SeriesTimerInfoDto}
     * @memberof LiveTvApiCreateSeriesTimer
     */
    readonly seriesTimerInfoDto?: SeriesTimerInfoDto
}

/**
 * Request parameters for createTimer operation in LiveTvApi.
 * @export
 * @interface LiveTvApiCreateTimerRequest
 */
export interface LiveTvApiCreateTimerRequest {
    /**
     * 
     * @type {TimerInfoDto}
     * @memberof LiveTvApiCreateTimer
     */
    readonly timerInfoDto?: TimerInfoDto
}

/**
 * Request parameters for deleteListingProvider operation in LiveTvApi.
 * @export
 * @interface LiveTvApiDeleteListingProviderRequest
 */
export interface LiveTvApiDeleteListingProviderRequest {
    /**
     * 
     * @type {string}
     * @memberof LiveTvApiDeleteListingProvider
     */
    readonly id?: string
}

/**
 * Request parameters for deleteRecording operation in LiveTvApi.
 * @export
 * @interface LiveTvApiDeleteRecordingRequest
 */
export interface LiveTvApiDeleteRecordingRequest {
    /**
     * 
     * @type {string}
     * @memberof LiveTvApiDeleteRecording
     */
    readonly recordingId: string
}

/**
 * Request parameters for deleteTunerHost operation in LiveTvApi.
 * @export
 * @interface LiveTvApiDeleteTunerHostRequest
 */
export interface LiveTvApiDeleteTunerHostRequest {
    /**
     * 
     * @type {string}
     * @memberof LiveTvApiDeleteTunerHost
     */
    readonly id?: string
}

/**
 * Request parameters for discoverTuners operation in LiveTvApi.
 * @export
 * @interface LiveTvApiDiscoverTunersRequest
 */
export interface LiveTvApiDiscoverTunersRequest {
    /**
     * 
     * @type {boolean}
     * @memberof LiveTvApiDiscoverTuners
     */
    readonly newDevicesOnly?: boolean
}

/**
 * Request parameters for getChannel operation in LiveTvApi.
 * @export
 * @interface LiveTvApiGetChannelRequest
 */
export interface LiveTvApiGetChannelRequest {
    /**
     * 
     * @type {string}
     * @memberof LiveTvApiGetChannel
     */
    readonly channelId: string

    /**
     * 
     * @type {string}
     * @memberof LiveTvApiGetChannel
     */
    readonly userId?: string
}

/**
 * Request parameters for getChannelMappingOptions operation in LiveTvApi.
 * @export
 * @interface LiveTvApiGetChannelMappingOptionsRequest
 */
export interface LiveTvApiGetChannelMappingOptionsRequest {
    /**
     * 
     * @type {string}
     * @memberof LiveTvApiGetChannelMappingOptions
     */
    readonly providerId?: string
}

/**
 * Request parameters for getDefaultTimer operation in LiveTvApi.
 * @export
 * @interface LiveTvApiGetDefaultTimerRequest
 */
export interface LiveTvApiGetDefaultTimerRequest {
    /**
     * 
     * @type {string}
     * @memberof LiveTvApiGetDefaultTimer
     */
    readonly programId?: string
}

/**
 * Request parameters for getLineups operation in LiveTvApi.
 * @export
 * @interface LiveTvApiGetLineupsRequest
 */
export interface LiveTvApiGetLineupsRequest {
    /**
     * 
     * @type {string}
     * @memberof LiveTvApiGetLineups
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof LiveTvApiGetLineups
     */
    readonly type?: string

    /**
     * 
     * @type {string}
     * @memberof LiveTvApiGetLineups
     */
    readonly location?: string

    /**
     * 
     * @type {string}
     * @memberof LiveTvApiGetLineups
     */
    readonly country?: string
}

/**
 * Request parameters for getLiveRecordingFile operation in LiveTvApi.
 * @export
 * @interface LiveTvApiGetLiveRecordingFileRequest
 */
export interface LiveTvApiGetLiveRecordingFileRequest {
    /**
     * 
     * @type {string}
     * @memberof LiveTvApiGetLiveRecordingFile
     */
    readonly recordingId: string
}

/**
 * Request parameters for getLiveStreamFile operation in LiveTvApi.
 * @export
 * @interface LiveTvApiGetLiveStreamFileRequest
 */
export interface LiveTvApiGetLiveStreamFileRequest {
    /**
     * 
     * @type {string}
     * @memberof LiveTvApiGetLiveStreamFile
     */
    readonly streamId: string

    /**
     * 
     * @type {string}
     * @memberof LiveTvApiGetLiveStreamFile
     */
    readonly container: string
}

/**
 * Request parameters for getLiveTvChannels operation in LiveTvApi.
 * @export
 * @interface LiveTvApiGetLiveTvChannelsRequest
 */
export interface LiveTvApiGetLiveTvChannelsRequest {
    /**
     * 
     * @type {ChannelType}
     * @memberof LiveTvApiGetLiveTvChannels
     */
    readonly type?: ChannelType

    /**
     * 
     * @type {string}
     * @memberof LiveTvApiGetLiveTvChannels
     */
    readonly userId?: string

    /**
     * 
     * @type {number}
     * @memberof LiveTvApiGetLiveTvChannels
     */
    readonly startIndex?: number

    /**
     * 
     * @type {boolean}
     * @memberof LiveTvApiGetLiveTvChannels
     */
    readonly isMovie?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof LiveTvApiGetLiveTvChannels
     */
    readonly isSeries?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof LiveTvApiGetLiveTvChannels
     */
    readonly isNews?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof LiveTvApiGetLiveTvChannels
     */
    readonly isKids?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof LiveTvApiGetLiveTvChannels
     */
    readonly isSports?: boolean

    /**
     * 
     * @type {number}
     * @memberof LiveTvApiGetLiveTvChannels
     */
    readonly limit?: number

    /**
     * 
     * @type {boolean}
     * @memberof LiveTvApiGetLiveTvChannels
     */
    readonly isFavorite?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof LiveTvApiGetLiveTvChannels
     */
    readonly isLiked?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof LiveTvApiGetLiveTvChannels
     */
    readonly isDisliked?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof LiveTvApiGetLiveTvChannels
     */
    readonly enableImages?: boolean

    /**
     * 
     * @type {number}
     * @memberof LiveTvApiGetLiveTvChannels
     */
    readonly imageTypeLimit?: number

    /**
     * 
     * @type {string}
     * @memberof LiveTvApiGetLiveTvChannels
     */
    readonly enableImageTypes?: string

    /**
     * 
     * @type {string}
     * @memberof LiveTvApiGetLiveTvChannels
     */
    readonly fields?: string

    /**
     * 
     * @type {boolean}
     * @memberof LiveTvApiGetLiveTvChannels
     */
    readonly enableUserData?: boolean

    /**
     * 
     * @type {string}
     * @memberof LiveTvApiGetLiveTvChannels
     */
    readonly sortBy?: string

    /**
     * 
     * @type {SortOrder}
     * @memberof LiveTvApiGetLiveTvChannels
     */
    readonly sortOrder?: SortOrder

    /**
     * 
     * @type {boolean}
     * @memberof LiveTvApiGetLiveTvChannels
     */
    readonly enableFavoriteSorting?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof LiveTvApiGetLiveTvChannels
     */
    readonly addCurrentProgram?: boolean
}

/**
 * Request parameters for getLiveTvPrograms operation in LiveTvApi.
 * @export
 * @interface LiveTvApiGetLiveTvProgramsRequest
 */
export interface LiveTvApiGetLiveTvProgramsRequest {
    /**
     * 
     * @type {string}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly channelIds?: string

    /**
     * 
     * @type {string}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly userId?: string

    /**
     * 
     * @type {string}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly minStartDate?: string

    /**
     * 
     * @type {boolean}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly hasAired?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly isAiring?: boolean

    /**
     * 
     * @type {string}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly maxStartDate?: string

    /**
     * 
     * @type {string}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly minEndDate?: string

    /**
     * 
     * @type {string}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly maxEndDate?: string

    /**
     * 
     * @type {boolean}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly isMovie?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly isSeries?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly isNews?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly isKids?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly isSports?: boolean

    /**
     * 
     * @type {number}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly startIndex?: number

    /**
     * 
     * @type {number}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly limit?: number

    /**
     * 
     * @type {string}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly sortBy?: string

    /**
     * 
     * @type {string}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly sortOrder?: string

    /**
     * 
     * @type {string}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly genres?: string

    /**
     * 
     * @type {string}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly genreIds?: string

    /**
     * 
     * @type {boolean}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly enableImages?: boolean

    /**
     * 
     * @type {number}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly imageTypeLimit?: number

    /**
     * 
     * @type {string}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly enableImageTypes?: string

    /**
     * 
     * @type {boolean}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly enableUserData?: boolean

    /**
     * 
     * @type {string}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly seriesTimerId?: string

    /**
     * 
     * @type {string}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly librarySeriesId?: string

    /**
     * 
     * @type {string}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly fields?: string

    /**
     * 
     * @type {boolean}
     * @memberof LiveTvApiGetLiveTvPrograms
     */
    readonly enableTotalRecordCount?: boolean
}

/**
 * Request parameters for getProgram operation in LiveTvApi.
 * @export
 * @interface LiveTvApiGetProgramRequest
 */
export interface LiveTvApiGetProgramRequest {
    /**
     * 
     * @type {string}
     * @memberof LiveTvApiGetProgram
     */
    readonly programId: string

    /**
     * 
     * @type {string}
     * @memberof LiveTvApiGetProgram
     */
    readonly userId?: string
}

/**
 * Request parameters for getPrograms operation in LiveTvApi.
 * @export
 * @interface LiveTvApiGetProgramsRequest
 */
export interface LiveTvApiGetProgramsRequest {
    /**
     * 
     * @type {GetProgramsDto}
     * @memberof LiveTvApiGetPrograms
     */
    readonly getProgramsDto?: GetProgramsDto
}

/**
 * Request parameters for getRecommendedPrograms operation in LiveTvApi.
 * @export
 * @interface LiveTvApiGetRecommendedProgramsRequest
 */
export interface LiveTvApiGetRecommendedProgramsRequest {
    /**
     * 
     * @type {string}
     * @memberof LiveTvApiGetRecommendedPrograms
     */
    readonly userId?: string

    /**
     * 
     * @type {number}
     * @memberof LiveTvApiGetRecommendedPrograms
     */
    readonly limit?: number

    /**
     * 
     * @type {boolean}
     * @memberof LiveTvApiGetRecommendedPrograms
     */
    readonly isAiring?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof LiveTvApiGetRecommendedPrograms
     */
    readonly hasAired?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof LiveTvApiGetRecommendedPrograms
     */
    readonly isSeries?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof LiveTvApiGetRecommendedPrograms
     */
    readonly isMovie?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof LiveTvApiGetRecommendedPrograms
     */
    readonly isNews?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof LiveTvApiGetRecommendedPrograms
     */
    readonly isKids?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof LiveTvApiGetRecommendedPrograms
     */
    readonly isSports?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof LiveTvApiGetRecommendedPrograms
     */
    readonly enableImages?: boolean

    /**
     * 
     * @type {number}
     * @memberof LiveTvApiGetRecommendedPrograms
     */
    readonly imageTypeLimit?: number

    /**
     * 
     * @type {string}
     * @memberof LiveTvApiGetRecommendedPrograms
     */
    readonly enableImageTypes?: string

    /**
     * 
     * @type {string}
     * @memberof LiveTvApiGetRecommendedPrograms
     */
    readonly genreIds?: string

    /**
     * 
     * @type {string}
     * @memberof LiveTvApiGetRecommendedPrograms
     */
    readonly fields?: string

    /**
     * 
     * @type {boolean}
     * @memberof LiveTvApiGetRecommendedPrograms
     */
    readonly enableUserData?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof LiveTvApiGetRecommendedPrograms
     */
    readonly enableTotalRecordCount?: boolean
}

/**
 * Request parameters for getRecording operation in LiveTvApi.
 * @export
 * @interface LiveTvApiGetRecordingRequest
 */
export interface LiveTvApiGetRecordingRequest {
    /**
     * 
     * @type {string}
     * @memberof LiveTvApiGetRecording
     */
    readonly recordingId: string

    /**
     * 
     * @type {string}
     * @memberof LiveTvApiGetRecording
     */
    readonly userId?: string
}

/**
 * Request parameters for getRecordingFolders operation in LiveTvApi.
 * @export
 * @interface LiveTvApiGetRecordingFoldersRequest
 */
export interface LiveTvApiGetRecordingFoldersRequest {
    /**
     * 
     * @type {string}
     * @memberof LiveTvApiGetRecordingFolders
     */
    readonly userId?: string
}

/**
 * Request parameters for getRecordingGroup operation in LiveTvApi.
 * @export
 * @interface LiveTvApiGetRecordingGroupRequest
 */
export interface LiveTvApiGetRecordingGroupRequest {
    /**
     * 
     * @type {string}
     * @memberof LiveTvApiGetRecordingGroup
     */
    readonly groupId: string
}

/**
 * Request parameters for getRecordingGroups operation in LiveTvApi.
 * @export
 * @interface LiveTvApiGetRecordingGroupsRequest
 */
export interface LiveTvApiGetRecordingGroupsRequest {
    /**
     * 
     * @type {string}
     * @memberof LiveTvApiGetRecordingGroups
     */
    readonly userId?: string
}

/**
 * Request parameters for getRecordings operation in LiveTvApi.
 * @export
 * @interface LiveTvApiGetRecordingsRequest
 */
export interface LiveTvApiGetRecordingsRequest {
    /**
     * 
     * @type {string}
     * @memberof LiveTvApiGetRecordings
     */
    readonly channelId?: string

    /**
     * 
     * @type {string}
     * @memberof LiveTvApiGetRecordings
     */
    readonly userId?: string

    /**
     * 
     * @type {number}
     * @memberof LiveTvApiGetRecordings
     */
    readonly startIndex?: number

    /**
     * 
     * @type {number}
     * @memberof LiveTvApiGetRecordings
     */
    readonly limit?: number

    /**
     * 
     * @type {RecordingStatus}
     * @memberof LiveTvApiGetRecordings
     */
    readonly status?: RecordingStatus

    /**
     * 
     * @type {boolean}
     * @memberof LiveTvApiGetRecordings
     */
    readonly isInProgress?: boolean

    /**
     * 
     * @type {string}
     * @memberof LiveTvApiGetRecordings
     */
    readonly seriesTimerId?: string

    /**
     * 
     * @type {boolean}
     * @memberof LiveTvApiGetRecordings
     */
    readonly enableImages?: boolean

    /**
     * 
     * @type {number}
     * @memberof LiveTvApiGetRecordings
     */
    readonly imageTypeLimit?: number

    /**
     * 
     * @type {string}
     * @memberof LiveTvApiGetRecordings
     */
    readonly enableImageTypes?: string

    /**
     * 
     * @type {string}
     * @memberof LiveTvApiGetRecordings
     */
    readonly fields?: string

    /**
     * 
     * @type {boolean}
     * @memberof LiveTvApiGetRecordings
     */
    readonly enableUserData?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof LiveTvApiGetRecordings
     */
    readonly isMovie?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof LiveTvApiGetRecordings
     */
    readonly isSeries?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof LiveTvApiGetRecordings
     */
    readonly isKids?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof LiveTvApiGetRecordings
     */
    readonly isSports?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof LiveTvApiGetRecordings
     */
    readonly isNews?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof LiveTvApiGetRecordings
     */
    readonly isLibraryItem?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof LiveTvApiGetRecordings
     */
    readonly enableTotalRecordCount?: boolean
}

/**
 * Request parameters for getRecordingsSeries operation in LiveTvApi.
 * @export
 * @interface LiveTvApiGetRecordingsSeriesRequest
 */
export interface LiveTvApiGetRecordingsSeriesRequest {
    /**
     * 
     * @type {string}
     * @memberof LiveTvApiGetRecordingsSeries
     */
    readonly channelId?: string

    /**
     * 
     * @type {string}
     * @memberof LiveTvApiGetRecordingsSeries
     */
    readonly userId?: string

    /**
     * 
     * @type {string}
     * @memberof LiveTvApiGetRecordingsSeries
     */
    readonly groupId?: string

    /**
     * 
     * @type {number}
     * @memberof LiveTvApiGetRecordingsSeries
     */
    readonly startIndex?: number

    /**
     * 
     * @type {number}
     * @memberof LiveTvApiGetRecordingsSeries
     */
    readonly limit?: number

    /**
     * 
     * @type {RecordingStatus}
     * @memberof LiveTvApiGetRecordingsSeries
     */
    readonly status?: RecordingStatus

    /**
     * 
     * @type {boolean}
     * @memberof LiveTvApiGetRecordingsSeries
     */
    readonly isInProgress?: boolean

    /**
     * 
     * @type {string}
     * @memberof LiveTvApiGetRecordingsSeries
     */
    readonly seriesTimerId?: string

    /**
     * 
     * @type {boolean}
     * @memberof LiveTvApiGetRecordingsSeries
     */
    readonly enableImages?: boolean

    /**
     * 
     * @type {number}
     * @memberof LiveTvApiGetRecordingsSeries
     */
    readonly imageTypeLimit?: number

    /**
     * 
     * @type {string}
     * @memberof LiveTvApiGetRecordingsSeries
     */
    readonly enableImageTypes?: string

    /**
     * 
     * @type {string}
     * @memberof LiveTvApiGetRecordingsSeries
     */
    readonly fields?: string

    /**
     * 
     * @type {boolean}
     * @memberof LiveTvApiGetRecordingsSeries
     */
    readonly enableUserData?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof LiveTvApiGetRecordingsSeries
     */
    readonly enableTotalRecordCount?: boolean
}

/**
 * Request parameters for getSeriesTimer operation in LiveTvApi.
 * @export
 * @interface LiveTvApiGetSeriesTimerRequest
 */
export interface LiveTvApiGetSeriesTimerRequest {
    /**
     * 
     * @type {string}
     * @memberof LiveTvApiGetSeriesTimer
     */
    readonly timerId: string
}

/**
 * Request parameters for getSeriesTimers operation in LiveTvApi.
 * @export
 * @interface LiveTvApiGetSeriesTimersRequest
 */
export interface LiveTvApiGetSeriesTimersRequest {
    /**
     * 
     * @type {string}
     * @memberof LiveTvApiGetSeriesTimers
     */
    readonly sortBy?: string

    /**
     * 
     * @type {SortOrder}
     * @memberof LiveTvApiGetSeriesTimers
     */
    readonly sortOrder?: SortOrder
}

/**
 * Request parameters for getTimer operation in LiveTvApi.
 * @export
 * @interface LiveTvApiGetTimerRequest
 */
export interface LiveTvApiGetTimerRequest {
    /**
     * 
     * @type {string}
     * @memberof LiveTvApiGetTimer
     */
    readonly timerId: string
}

/**
 * Request parameters for getTimers operation in LiveTvApi.
 * @export
 * @interface LiveTvApiGetTimersRequest
 */
export interface LiveTvApiGetTimersRequest {
    /**
     * 
     * @type {string}
     * @memberof LiveTvApiGetTimers
     */
    readonly channelId?: string

    /**
     * 
     * @type {string}
     * @memberof LiveTvApiGetTimers
     */
    readonly seriesTimerId?: string

    /**
     * 
     * @type {boolean}
     * @memberof LiveTvApiGetTimers
     */
    readonly isActive?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof LiveTvApiGetTimers
     */
    readonly isScheduled?: boolean
}

/**
 * Request parameters for resetTuner operation in LiveTvApi.
 * @export
 * @interface LiveTvApiResetTunerRequest
 */
export interface LiveTvApiResetTunerRequest {
    /**
     * 
     * @type {string}
     * @memberof LiveTvApiResetTuner
     */
    readonly tunerId: string
}

/**
 * Request parameters for setChannelMapping operation in LiveTvApi.
 * @export
 * @interface LiveTvApiSetChannelMappingRequest
 */
export interface LiveTvApiSetChannelMappingRequest {
    /**
     * 
     * @type {string}
     * @memberof LiveTvApiSetChannelMapping
     */
    readonly providerId?: string

    /**
     * 
     * @type {string}
     * @memberof LiveTvApiSetChannelMapping
     */
    readonly tunerChannelId?: string

    /**
     * 
     * @type {string}
     * @memberof LiveTvApiSetChannelMapping
     */
    readonly providerChannelId?: string
}

/**
 * Request parameters for updateSeriesTimer operation in LiveTvApi.
 * @export
 * @interface LiveTvApiUpdateSeriesTimerRequest
 */
export interface LiveTvApiUpdateSeriesTimerRequest {
    /**
     * 
     * @type {string}
     * @memberof LiveTvApiUpdateSeriesTimer
     */
    readonly timerId: string

    /**
     * 
     * @type {SeriesTimerInfoDto}
     * @memberof LiveTvApiUpdateSeriesTimer
     */
    readonly seriesTimerInfoDto?: SeriesTimerInfoDto
}

/**
 * Request parameters for updateTimer operation in LiveTvApi.
 * @export
 * @interface LiveTvApiUpdateTimerRequest
 */
export interface LiveTvApiUpdateTimerRequest {
    /**
     * 
     * @type {string}
     * @memberof LiveTvApiUpdateTimer
     */
    readonly timerId: string

    /**
     * 
     * @type {TimerInfoDto}
     * @memberof LiveTvApiUpdateTimer
     */
    readonly timerInfoDto?: TimerInfoDto
}

/**
 * LiveTvApi - object-oriented interface
 * @export
 * @class LiveTvApi
 * @extends {BaseAPI}
 */
export class LiveTvApi extends BaseAPI {
    /**
     * 
     * @param {LiveTvApiAddListingProviderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public addListingProvider(requestParameters: LiveTvApiAddListingProviderRequest = {}, options?: any) {
        return LiveTvApiFp(this.configuration).addListingProvider(requestParameters.pw, requestParameters.validateListings, requestParameters.validateLogin, requestParameters.listingsProviderInfo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LiveTvApiAddTunerHostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public addTunerHost(requestParameters: LiveTvApiAddTunerHostRequest = {}, options?: any) {
        return LiveTvApiFp(this.configuration).addTunerHost(requestParameters.tunerHostInfo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LiveTvApiCancelSeriesTimerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public cancelSeriesTimer(requestParameters: LiveTvApiCancelSeriesTimerRequest, options?: any) {
        return LiveTvApiFp(this.configuration).cancelSeriesTimer(requestParameters.timerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LiveTvApiCancelTimerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public cancelTimer(requestParameters: LiveTvApiCancelTimerRequest, options?: any) {
        return LiveTvApiFp(this.configuration).cancelTimer(requestParameters.timerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LiveTvApiCreateSeriesTimerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public createSeriesTimer(requestParameters: LiveTvApiCreateSeriesTimerRequest = {}, options?: any) {
        return LiveTvApiFp(this.configuration).createSeriesTimer(requestParameters.seriesTimerInfoDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LiveTvApiCreateTimerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public createTimer(requestParameters: LiveTvApiCreateTimerRequest = {}, options?: any) {
        return LiveTvApiFp(this.configuration).createTimer(requestParameters.timerInfoDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LiveTvApiDeleteListingProviderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public deleteListingProvider(requestParameters: LiveTvApiDeleteListingProviderRequest = {}, options?: any) {
        return LiveTvApiFp(this.configuration).deleteListingProvider(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LiveTvApiDeleteRecordingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public deleteRecording(requestParameters: LiveTvApiDeleteRecordingRequest, options?: any) {
        return LiveTvApiFp(this.configuration).deleteRecording(requestParameters.recordingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LiveTvApiDeleteTunerHostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public deleteTunerHost(requestParameters: LiveTvApiDeleteTunerHostRequest = {}, options?: any) {
        return LiveTvApiFp(this.configuration).deleteTunerHost(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LiveTvApiDiscoverTunersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public discoverTuners(requestParameters: LiveTvApiDiscoverTunersRequest = {}, options?: any) {
        return LiveTvApiFp(this.configuration).discoverTuners(requestParameters.newDevicesOnly, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LiveTvApiGetChannelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getChannel(requestParameters: LiveTvApiGetChannelRequest, options?: any) {
        return LiveTvApiFp(this.configuration).getChannel(requestParameters.channelId, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LiveTvApiGetChannelMappingOptionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getChannelMappingOptions(requestParameters: LiveTvApiGetChannelMappingOptionsRequest = {}, options?: any) {
        return LiveTvApiFp(this.configuration).getChannelMappingOptions(requestParameters.providerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getDefaultListingProvider(options?: any) {
        return LiveTvApiFp(this.configuration).getDefaultListingProvider(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LiveTvApiGetDefaultTimerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getDefaultTimer(requestParameters: LiveTvApiGetDefaultTimerRequest = {}, options?: any) {
        return LiveTvApiFp(this.configuration).getDefaultTimer(requestParameters.programId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getGuideInfo(options?: any) {
        return LiveTvApiFp(this.configuration).getGuideInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LiveTvApiGetLineupsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getLineups(requestParameters: LiveTvApiGetLineupsRequest = {}, options?: any) {
        return LiveTvApiFp(this.configuration).getLineups(requestParameters.id, requestParameters.type, requestParameters.location, requestParameters.country, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LiveTvApiGetLiveRecordingFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getLiveRecordingFile(requestParameters: LiveTvApiGetLiveRecordingFileRequest, options?: any) {
        return LiveTvApiFp(this.configuration).getLiveRecordingFile(requestParameters.recordingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LiveTvApiGetLiveStreamFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getLiveStreamFile(requestParameters: LiveTvApiGetLiveStreamFileRequest, options?: any) {
        return LiveTvApiFp(this.configuration).getLiveStreamFile(requestParameters.streamId, requestParameters.container, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LiveTvApiGetLiveTvChannelsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getLiveTvChannels(requestParameters: LiveTvApiGetLiveTvChannelsRequest = {}, options?: any) {
        return LiveTvApiFp(this.configuration).getLiveTvChannels(requestParameters.type, requestParameters.userId, requestParameters.startIndex, requestParameters.isMovie, requestParameters.isSeries, requestParameters.isNews, requestParameters.isKids, requestParameters.isSports, requestParameters.limit, requestParameters.isFavorite, requestParameters.isLiked, requestParameters.isDisliked, requestParameters.enableImages, requestParameters.imageTypeLimit, requestParameters.enableImageTypes, requestParameters.fields, requestParameters.enableUserData, requestParameters.sortBy, requestParameters.sortOrder, requestParameters.enableFavoriteSorting, requestParameters.addCurrentProgram, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getLiveTvInfo(options?: any) {
        return LiveTvApiFp(this.configuration).getLiveTvInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LiveTvApiGetLiveTvProgramsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getLiveTvPrograms(requestParameters: LiveTvApiGetLiveTvProgramsRequest = {}, options?: any) {
        return LiveTvApiFp(this.configuration).getLiveTvPrograms(requestParameters.channelIds, requestParameters.userId, requestParameters.minStartDate, requestParameters.hasAired, requestParameters.isAiring, requestParameters.maxStartDate, requestParameters.minEndDate, requestParameters.maxEndDate, requestParameters.isMovie, requestParameters.isSeries, requestParameters.isNews, requestParameters.isKids, requestParameters.isSports, requestParameters.startIndex, requestParameters.limit, requestParameters.sortBy, requestParameters.sortOrder, requestParameters.genres, requestParameters.genreIds, requestParameters.enableImages, requestParameters.imageTypeLimit, requestParameters.enableImageTypes, requestParameters.enableUserData, requestParameters.seriesTimerId, requestParameters.librarySeriesId, requestParameters.fields, requestParameters.enableTotalRecordCount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LiveTvApiGetProgramRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getProgram(requestParameters: LiveTvApiGetProgramRequest, options?: any) {
        return LiveTvApiFp(this.configuration).getProgram(requestParameters.programId, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LiveTvApiGetProgramsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getPrograms(requestParameters: LiveTvApiGetProgramsRequest = {}, options?: any) {
        return LiveTvApiFp(this.configuration).getPrograms(requestParameters.getProgramsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LiveTvApiGetRecommendedProgramsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getRecommendedPrograms(requestParameters: LiveTvApiGetRecommendedProgramsRequest = {}, options?: any) {
        return LiveTvApiFp(this.configuration).getRecommendedPrograms(requestParameters.userId, requestParameters.limit, requestParameters.isAiring, requestParameters.hasAired, requestParameters.isSeries, requestParameters.isMovie, requestParameters.isNews, requestParameters.isKids, requestParameters.isSports, requestParameters.enableImages, requestParameters.imageTypeLimit, requestParameters.enableImageTypes, requestParameters.genreIds, requestParameters.fields, requestParameters.enableUserData, requestParameters.enableTotalRecordCount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LiveTvApiGetRecordingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getRecording(requestParameters: LiveTvApiGetRecordingRequest, options?: any) {
        return LiveTvApiFp(this.configuration).getRecording(requestParameters.recordingId, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LiveTvApiGetRecordingFoldersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getRecordingFolders(requestParameters: LiveTvApiGetRecordingFoldersRequest = {}, options?: any) {
        return LiveTvApiFp(this.configuration).getRecordingFolders(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LiveTvApiGetRecordingGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getRecordingGroup(requestParameters: LiveTvApiGetRecordingGroupRequest, options?: any) {
        return LiveTvApiFp(this.configuration).getRecordingGroup(requestParameters.groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LiveTvApiGetRecordingGroupsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getRecordingGroups(requestParameters: LiveTvApiGetRecordingGroupsRequest = {}, options?: any) {
        return LiveTvApiFp(this.configuration).getRecordingGroups(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LiveTvApiGetRecordingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getRecordings(requestParameters: LiveTvApiGetRecordingsRequest = {}, options?: any) {
        return LiveTvApiFp(this.configuration).getRecordings(requestParameters.channelId, requestParameters.userId, requestParameters.startIndex, requestParameters.limit, requestParameters.status, requestParameters.isInProgress, requestParameters.seriesTimerId, requestParameters.enableImages, requestParameters.imageTypeLimit, requestParameters.enableImageTypes, requestParameters.fields, requestParameters.enableUserData, requestParameters.isMovie, requestParameters.isSeries, requestParameters.isKids, requestParameters.isSports, requestParameters.isNews, requestParameters.isLibraryItem, requestParameters.enableTotalRecordCount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LiveTvApiGetRecordingsSeriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getRecordingsSeries(requestParameters: LiveTvApiGetRecordingsSeriesRequest = {}, options?: any) {
        return LiveTvApiFp(this.configuration).getRecordingsSeries(requestParameters.channelId, requestParameters.userId, requestParameters.groupId, requestParameters.startIndex, requestParameters.limit, requestParameters.status, requestParameters.isInProgress, requestParameters.seriesTimerId, requestParameters.enableImages, requestParameters.imageTypeLimit, requestParameters.enableImageTypes, requestParameters.fields, requestParameters.enableUserData, requestParameters.enableTotalRecordCount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getSchedulesDirectCountries(options?: any) {
        return LiveTvApiFp(this.configuration).getSchedulesDirectCountries(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LiveTvApiGetSeriesTimerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getSeriesTimer(requestParameters: LiveTvApiGetSeriesTimerRequest, options?: any) {
        return LiveTvApiFp(this.configuration).getSeriesTimer(requestParameters.timerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LiveTvApiGetSeriesTimersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getSeriesTimers(requestParameters: LiveTvApiGetSeriesTimersRequest = {}, options?: any) {
        return LiveTvApiFp(this.configuration).getSeriesTimers(requestParameters.sortBy, requestParameters.sortOrder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LiveTvApiGetTimerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getTimer(requestParameters: LiveTvApiGetTimerRequest, options?: any) {
        return LiveTvApiFp(this.configuration).getTimer(requestParameters.timerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LiveTvApiGetTimersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getTimers(requestParameters: LiveTvApiGetTimersRequest = {}, options?: any) {
        return LiveTvApiFp(this.configuration).getTimers(requestParameters.channelId, requestParameters.seriesTimerId, requestParameters.isActive, requestParameters.isScheduled, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public getTunerHostTypes(options?: any) {
        return LiveTvApiFp(this.configuration).getTunerHostTypes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LiveTvApiResetTunerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public resetTuner(requestParameters: LiveTvApiResetTunerRequest, options?: any) {
        return LiveTvApiFp(this.configuration).resetTuner(requestParameters.tunerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LiveTvApiSetChannelMappingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public setChannelMapping(requestParameters: LiveTvApiSetChannelMappingRequest = {}, options?: any) {
        return LiveTvApiFp(this.configuration).setChannelMapping(requestParameters.providerId, requestParameters.tunerChannelId, requestParameters.providerChannelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LiveTvApiUpdateSeriesTimerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public updateSeriesTimer(requestParameters: LiveTvApiUpdateSeriesTimerRequest, options?: any) {
        return LiveTvApiFp(this.configuration).updateSeriesTimer(requestParameters.timerId, requestParameters.seriesTimerInfoDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LiveTvApiUpdateTimerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveTvApi
     */
    public updateTimer(requestParameters: LiveTvApiUpdateTimerRequest, options?: any) {
        return LiveTvApiFp(this.configuration).updateTimer(requestParameters.timerId, requestParameters.timerInfoDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LocalizationApi - axios parameter creator
 * @export
 */
export const LocalizationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCountries: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Localization/Countries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCultures: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Localization/Cultures`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLocalizationOptions: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Localization/Options`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParentalRatings: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Localization/ParentalRatings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LocalizationApi - functional programming interface
 * @export
 */
export const LocalizationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCountries(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CountryInfo>>> {
            const localVarAxiosArgs = await LocalizationApiAxiosParamCreator(configuration).getCountries(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCultures(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CultureDto>>> {
            const localVarAxiosArgs = await LocalizationApiAxiosParamCreator(configuration).getCultures(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLocalizationOptions(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LocalizationOption>>> {
            const localVarAxiosArgs = await LocalizationApiAxiosParamCreator(configuration).getLocalizationOptions(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getParentalRatings(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ParentalRating>>> {
            const localVarAxiosArgs = await LocalizationApiAxiosParamCreator(configuration).getParentalRatings(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * LocalizationApi - factory interface
 * @export
 */
export const LocalizationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCountries(options?: any): AxiosPromise<Array<CountryInfo>> {
            return LocalizationApiFp(configuration).getCountries(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCultures(options?: any): AxiosPromise<Array<CultureDto>> {
            return LocalizationApiFp(configuration).getCultures(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLocalizationOptions(options?: any): AxiosPromise<Array<LocalizationOption>> {
            return LocalizationApiFp(configuration).getLocalizationOptions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParentalRatings(options?: any): AxiosPromise<Array<ParentalRating>> {
            return LocalizationApiFp(configuration).getParentalRatings(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LocalizationApi - object-oriented interface
 * @export
 * @class LocalizationApi
 * @extends {BaseAPI}
 */
export class LocalizationApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocalizationApi
     */
    public getCountries(options?: any) {
        return LocalizationApiFp(this.configuration).getCountries(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocalizationApi
     */
    public getCultures(options?: any) {
        return LocalizationApiFp(this.configuration).getCultures(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocalizationApi
     */
    public getLocalizationOptions(options?: any) {
        return LocalizationApiFp(this.configuration).getLocalizationOptions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocalizationApi
     */
    public getParentalRatings(options?: any) {
        return LocalizationApiFp(this.configuration).getParentalRatings(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MediaInfoApi - axios parameter creator
 * @export
 */
export const MediaInfoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} liveStreamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        closeLiveStream: async (liveStreamId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'liveStreamId' is not null or undefined
            if (liveStreamId === null || liveStreamId === undefined) {
                throw new RequiredError('liveStreamId','Required parameter liveStreamId was null or undefined when calling closeLiveStream.');
            }
            const localVarPath = `/LiveStreams/Close`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (liveStreamId !== undefined) {
                localVarQueryParameter['liveStreamId'] = liveStreamId;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBitrateTestBytes: async (size?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Playback/BitrateTest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlaybackInfo: async (itemId: string, userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getPlaybackInfo.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getPlaybackInfo.');
            }
            const localVarPath = `/Items/{itemId}/PlaybackInfo`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} [userId] 
         * @param {number} [maxStreamingBitrate] 
         * @param {number} [startTimeTicks] 
         * @param {number} [audioStreamIndex] 
         * @param {number} [subtitleStreamIndex] 
         * @param {number} [maxAudioChannels] 
         * @param {string} [mediaSourceId] 
         * @param {string} [liveStreamId] 
         * @param {boolean} [autoOpenLiveStream] 
         * @param {boolean} [enableDirectPlay] 
         * @param {boolean} [enableDirectStream] 
         * @param {boolean} [enableTranscoding] 
         * @param {boolean} [allowVideoStreamCopy] 
         * @param {boolean} [allowAudioStreamCopy] 
         * @param {DeviceProfileDto} [deviceProfileDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPostedPlaybackInfo: async (itemId: string, userId?: string, maxStreamingBitrate?: number, startTimeTicks?: number, audioStreamIndex?: number, subtitleStreamIndex?: number, maxAudioChannels?: number, mediaSourceId?: string, liveStreamId?: string, autoOpenLiveStream?: boolean, enableDirectPlay?: boolean, enableDirectStream?: boolean, enableTranscoding?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, deviceProfileDto?: DeviceProfileDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getPostedPlaybackInfo.');
            }
            const localVarPath = `/Items/{itemId}/PlaybackInfo`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (maxStreamingBitrate !== undefined) {
                localVarQueryParameter['maxStreamingBitrate'] = maxStreamingBitrate;
            }

            if (startTimeTicks !== undefined) {
                localVarQueryParameter['startTimeTicks'] = startTimeTicks;
            }

            if (audioStreamIndex !== undefined) {
                localVarQueryParameter['audioStreamIndex'] = audioStreamIndex;
            }

            if (subtitleStreamIndex !== undefined) {
                localVarQueryParameter['subtitleStreamIndex'] = subtitleStreamIndex;
            }

            if (maxAudioChannels !== undefined) {
                localVarQueryParameter['maxAudioChannels'] = maxAudioChannels;
            }

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['mediaSourceId'] = mediaSourceId;
            }

            if (liveStreamId !== undefined) {
                localVarQueryParameter['liveStreamId'] = liveStreamId;
            }

            if (autoOpenLiveStream !== undefined) {
                localVarQueryParameter['autoOpenLiveStream'] = autoOpenLiveStream;
            }

            if (enableDirectPlay !== undefined) {
                localVarQueryParameter['enableDirectPlay'] = enableDirectPlay;
            }

            if (enableDirectStream !== undefined) {
                localVarQueryParameter['enableDirectStream'] = enableDirectStream;
            }

            if (enableTranscoding !== undefined) {
                localVarQueryParameter['enableTranscoding'] = enableTranscoding;
            }

            if (allowVideoStreamCopy !== undefined) {
                localVarQueryParameter['allowVideoStreamCopy'] = allowVideoStreamCopy;
            }

            if (allowAudioStreamCopy !== undefined) {
                localVarQueryParameter['allowAudioStreamCopy'] = allowAudioStreamCopy;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof deviceProfileDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(deviceProfileDto !== undefined ? deviceProfileDto : {}) : (deviceProfileDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [openToken] 
         * @param {string} [userId] 
         * @param {string} [playSessionId] 
         * @param {number} [maxStreamingBitrate] 
         * @param {number} [startTimeTicks] 
         * @param {number} [audioStreamIndex] 
         * @param {number} [subtitleStreamIndex] 
         * @param {number} [maxAudioChannels] 
         * @param {string} [itemId] 
         * @param {boolean} [enableDirectPlay] 
         * @param {boolean} [enableDirectStream] 
         * @param {OpenLiveStreamDto} [openLiveStreamDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openLiveStream: async (openToken?: string, userId?: string, playSessionId?: string, maxStreamingBitrate?: number, startTimeTicks?: number, audioStreamIndex?: number, subtitleStreamIndex?: number, maxAudioChannels?: number, itemId?: string, enableDirectPlay?: boolean, enableDirectStream?: boolean, openLiveStreamDto?: OpenLiveStreamDto, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/LiveStreams/Open`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (openToken !== undefined) {
                localVarQueryParameter['openToken'] = openToken;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (playSessionId !== undefined) {
                localVarQueryParameter['playSessionId'] = playSessionId;
            }

            if (maxStreamingBitrate !== undefined) {
                localVarQueryParameter['maxStreamingBitrate'] = maxStreamingBitrate;
            }

            if (startTimeTicks !== undefined) {
                localVarQueryParameter['startTimeTicks'] = startTimeTicks;
            }

            if (audioStreamIndex !== undefined) {
                localVarQueryParameter['audioStreamIndex'] = audioStreamIndex;
            }

            if (subtitleStreamIndex !== undefined) {
                localVarQueryParameter['subtitleStreamIndex'] = subtitleStreamIndex;
            }

            if (maxAudioChannels !== undefined) {
                localVarQueryParameter['maxAudioChannels'] = maxAudioChannels;
            }

            if (itemId !== undefined) {
                localVarQueryParameter['itemId'] = itemId;
            }

            if (enableDirectPlay !== undefined) {
                localVarQueryParameter['enableDirectPlay'] = enableDirectPlay;
            }

            if (enableDirectStream !== undefined) {
                localVarQueryParameter['enableDirectStream'] = enableDirectStream;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof openLiveStreamDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(openLiveStreamDto !== undefined ? openLiveStreamDto : {}) : (openLiveStreamDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MediaInfoApi - functional programming interface
 * @export
 */
export const MediaInfoApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} liveStreamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async closeLiveStream(liveStreamId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await MediaInfoApiAxiosParamCreator(configuration).closeLiveStream(liveStreamId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBitrateTestBytes(size?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await MediaInfoApiAxiosParamCreator(configuration).getBitrateTestBytes(size, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlaybackInfo(itemId: string, userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlaybackInfoResponse>> {
            const localVarAxiosArgs = await MediaInfoApiAxiosParamCreator(configuration).getPlaybackInfo(itemId, userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} [userId] 
         * @param {number} [maxStreamingBitrate] 
         * @param {number} [startTimeTicks] 
         * @param {number} [audioStreamIndex] 
         * @param {number} [subtitleStreamIndex] 
         * @param {number} [maxAudioChannels] 
         * @param {string} [mediaSourceId] 
         * @param {string} [liveStreamId] 
         * @param {boolean} [autoOpenLiveStream] 
         * @param {boolean} [enableDirectPlay] 
         * @param {boolean} [enableDirectStream] 
         * @param {boolean} [enableTranscoding] 
         * @param {boolean} [allowVideoStreamCopy] 
         * @param {boolean} [allowAudioStreamCopy] 
         * @param {DeviceProfileDto} [deviceProfileDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPostedPlaybackInfo(itemId: string, userId?: string, maxStreamingBitrate?: number, startTimeTicks?: number, audioStreamIndex?: number, subtitleStreamIndex?: number, maxAudioChannels?: number, mediaSourceId?: string, liveStreamId?: string, autoOpenLiveStream?: boolean, enableDirectPlay?: boolean, enableDirectStream?: boolean, enableTranscoding?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, deviceProfileDto?: DeviceProfileDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlaybackInfoResponse>> {
            const localVarAxiosArgs = await MediaInfoApiAxiosParamCreator(configuration).getPostedPlaybackInfo(itemId, userId, maxStreamingBitrate, startTimeTicks, audioStreamIndex, subtitleStreamIndex, maxAudioChannels, mediaSourceId, liveStreamId, autoOpenLiveStream, enableDirectPlay, enableDirectStream, enableTranscoding, allowVideoStreamCopy, allowAudioStreamCopy, deviceProfileDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [openToken] 
         * @param {string} [userId] 
         * @param {string} [playSessionId] 
         * @param {number} [maxStreamingBitrate] 
         * @param {number} [startTimeTicks] 
         * @param {number} [audioStreamIndex] 
         * @param {number} [subtitleStreamIndex] 
         * @param {number} [maxAudioChannels] 
         * @param {string} [itemId] 
         * @param {boolean} [enableDirectPlay] 
         * @param {boolean} [enableDirectStream] 
         * @param {OpenLiveStreamDto} [openLiveStreamDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async openLiveStream(openToken?: string, userId?: string, playSessionId?: string, maxStreamingBitrate?: number, startTimeTicks?: number, audioStreamIndex?: number, subtitleStreamIndex?: number, maxAudioChannels?: number, itemId?: string, enableDirectPlay?: boolean, enableDirectStream?: boolean, openLiveStreamDto?: OpenLiveStreamDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LiveStreamResponse>> {
            const localVarAxiosArgs = await MediaInfoApiAxiosParamCreator(configuration).openLiveStream(openToken, userId, playSessionId, maxStreamingBitrate, startTimeTicks, audioStreamIndex, subtitleStreamIndex, maxAudioChannels, itemId, enableDirectPlay, enableDirectStream, openLiveStreamDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * MediaInfoApi - factory interface
 * @export
 */
export const MediaInfoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} liveStreamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        closeLiveStream(liveStreamId: string, options?: any): AxiosPromise<void> {
            return MediaInfoApiFp(configuration).closeLiveStream(liveStreamId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBitrateTestBytes(size?: number, options?: any): AxiosPromise<void> {
            return MediaInfoApiFp(configuration).getBitrateTestBytes(size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlaybackInfo(itemId: string, userId: string, options?: any): AxiosPromise<PlaybackInfoResponse> {
            return MediaInfoApiFp(configuration).getPlaybackInfo(itemId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} [userId] 
         * @param {number} [maxStreamingBitrate] 
         * @param {number} [startTimeTicks] 
         * @param {number} [audioStreamIndex] 
         * @param {number} [subtitleStreamIndex] 
         * @param {number} [maxAudioChannels] 
         * @param {string} [mediaSourceId] 
         * @param {string} [liveStreamId] 
         * @param {boolean} [autoOpenLiveStream] 
         * @param {boolean} [enableDirectPlay] 
         * @param {boolean} [enableDirectStream] 
         * @param {boolean} [enableTranscoding] 
         * @param {boolean} [allowVideoStreamCopy] 
         * @param {boolean} [allowAudioStreamCopy] 
         * @param {DeviceProfileDto} [deviceProfileDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPostedPlaybackInfo(itemId: string, userId?: string, maxStreamingBitrate?: number, startTimeTicks?: number, audioStreamIndex?: number, subtitleStreamIndex?: number, maxAudioChannels?: number, mediaSourceId?: string, liveStreamId?: string, autoOpenLiveStream?: boolean, enableDirectPlay?: boolean, enableDirectStream?: boolean, enableTranscoding?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, deviceProfileDto?: DeviceProfileDto, options?: any): AxiosPromise<PlaybackInfoResponse> {
            return MediaInfoApiFp(configuration).getPostedPlaybackInfo(itemId, userId, maxStreamingBitrate, startTimeTicks, audioStreamIndex, subtitleStreamIndex, maxAudioChannels, mediaSourceId, liveStreamId, autoOpenLiveStream, enableDirectPlay, enableDirectStream, enableTranscoding, allowVideoStreamCopy, allowAudioStreamCopy, deviceProfileDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [openToken] 
         * @param {string} [userId] 
         * @param {string} [playSessionId] 
         * @param {number} [maxStreamingBitrate] 
         * @param {number} [startTimeTicks] 
         * @param {number} [audioStreamIndex] 
         * @param {number} [subtitleStreamIndex] 
         * @param {number} [maxAudioChannels] 
         * @param {string} [itemId] 
         * @param {boolean} [enableDirectPlay] 
         * @param {boolean} [enableDirectStream] 
         * @param {OpenLiveStreamDto} [openLiveStreamDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openLiveStream(openToken?: string, userId?: string, playSessionId?: string, maxStreamingBitrate?: number, startTimeTicks?: number, audioStreamIndex?: number, subtitleStreamIndex?: number, maxAudioChannels?: number, itemId?: string, enableDirectPlay?: boolean, enableDirectStream?: boolean, openLiveStreamDto?: OpenLiveStreamDto, options?: any): AxiosPromise<LiveStreamResponse> {
            return MediaInfoApiFp(configuration).openLiveStream(openToken, userId, playSessionId, maxStreamingBitrate, startTimeTicks, audioStreamIndex, subtitleStreamIndex, maxAudioChannels, itemId, enableDirectPlay, enableDirectStream, openLiveStreamDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for closeLiveStream operation in MediaInfoApi.
 * @export
 * @interface MediaInfoApiCloseLiveStreamRequest
 */
export interface MediaInfoApiCloseLiveStreamRequest {
    /**
     * 
     * @type {string}
     * @memberof MediaInfoApiCloseLiveStream
     */
    readonly liveStreamId: string
}

/**
 * Request parameters for getBitrateTestBytes operation in MediaInfoApi.
 * @export
 * @interface MediaInfoApiGetBitrateTestBytesRequest
 */
export interface MediaInfoApiGetBitrateTestBytesRequest {
    /**
     * 
     * @type {number}
     * @memberof MediaInfoApiGetBitrateTestBytes
     */
    readonly size?: number
}

/**
 * Request parameters for getPlaybackInfo operation in MediaInfoApi.
 * @export
 * @interface MediaInfoApiGetPlaybackInfoRequest
 */
export interface MediaInfoApiGetPlaybackInfoRequest {
    /**
     * 
     * @type {string}
     * @memberof MediaInfoApiGetPlaybackInfo
     */
    readonly itemId: string

    /**
     * 
     * @type {string}
     * @memberof MediaInfoApiGetPlaybackInfo
     */
    readonly userId: string
}

/**
 * Request parameters for getPostedPlaybackInfo operation in MediaInfoApi.
 * @export
 * @interface MediaInfoApiGetPostedPlaybackInfoRequest
 */
export interface MediaInfoApiGetPostedPlaybackInfoRequest {
    /**
     * 
     * @type {string}
     * @memberof MediaInfoApiGetPostedPlaybackInfo
     */
    readonly itemId: string

    /**
     * 
     * @type {string}
     * @memberof MediaInfoApiGetPostedPlaybackInfo
     */
    readonly userId?: string

    /**
     * 
     * @type {number}
     * @memberof MediaInfoApiGetPostedPlaybackInfo
     */
    readonly maxStreamingBitrate?: number

    /**
     * 
     * @type {number}
     * @memberof MediaInfoApiGetPostedPlaybackInfo
     */
    readonly startTimeTicks?: number

    /**
     * 
     * @type {number}
     * @memberof MediaInfoApiGetPostedPlaybackInfo
     */
    readonly audioStreamIndex?: number

    /**
     * 
     * @type {number}
     * @memberof MediaInfoApiGetPostedPlaybackInfo
     */
    readonly subtitleStreamIndex?: number

    /**
     * 
     * @type {number}
     * @memberof MediaInfoApiGetPostedPlaybackInfo
     */
    readonly maxAudioChannels?: number

    /**
     * 
     * @type {string}
     * @memberof MediaInfoApiGetPostedPlaybackInfo
     */
    readonly mediaSourceId?: string

    /**
     * 
     * @type {string}
     * @memberof MediaInfoApiGetPostedPlaybackInfo
     */
    readonly liveStreamId?: string

    /**
     * 
     * @type {boolean}
     * @memberof MediaInfoApiGetPostedPlaybackInfo
     */
    readonly autoOpenLiveStream?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof MediaInfoApiGetPostedPlaybackInfo
     */
    readonly enableDirectPlay?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof MediaInfoApiGetPostedPlaybackInfo
     */
    readonly enableDirectStream?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof MediaInfoApiGetPostedPlaybackInfo
     */
    readonly enableTranscoding?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof MediaInfoApiGetPostedPlaybackInfo
     */
    readonly allowVideoStreamCopy?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof MediaInfoApiGetPostedPlaybackInfo
     */
    readonly allowAudioStreamCopy?: boolean

    /**
     * 
     * @type {DeviceProfileDto}
     * @memberof MediaInfoApiGetPostedPlaybackInfo
     */
    readonly deviceProfileDto?: DeviceProfileDto
}

/**
 * Request parameters for openLiveStream operation in MediaInfoApi.
 * @export
 * @interface MediaInfoApiOpenLiveStreamRequest
 */
export interface MediaInfoApiOpenLiveStreamRequest {
    /**
     * 
     * @type {string}
     * @memberof MediaInfoApiOpenLiveStream
     */
    readonly openToken?: string

    /**
     * 
     * @type {string}
     * @memberof MediaInfoApiOpenLiveStream
     */
    readonly userId?: string

    /**
     * 
     * @type {string}
     * @memberof MediaInfoApiOpenLiveStream
     */
    readonly playSessionId?: string

    /**
     * 
     * @type {number}
     * @memberof MediaInfoApiOpenLiveStream
     */
    readonly maxStreamingBitrate?: number

    /**
     * 
     * @type {number}
     * @memberof MediaInfoApiOpenLiveStream
     */
    readonly startTimeTicks?: number

    /**
     * 
     * @type {number}
     * @memberof MediaInfoApiOpenLiveStream
     */
    readonly audioStreamIndex?: number

    /**
     * 
     * @type {number}
     * @memberof MediaInfoApiOpenLiveStream
     */
    readonly subtitleStreamIndex?: number

    /**
     * 
     * @type {number}
     * @memberof MediaInfoApiOpenLiveStream
     */
    readonly maxAudioChannels?: number

    /**
     * 
     * @type {string}
     * @memberof MediaInfoApiOpenLiveStream
     */
    readonly itemId?: string

    /**
     * 
     * @type {boolean}
     * @memberof MediaInfoApiOpenLiveStream
     */
    readonly enableDirectPlay?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof MediaInfoApiOpenLiveStream
     */
    readonly enableDirectStream?: boolean

    /**
     * 
     * @type {OpenLiveStreamDto}
     * @memberof MediaInfoApiOpenLiveStream
     */
    readonly openLiveStreamDto?: OpenLiveStreamDto
}

/**
 * MediaInfoApi - object-oriented interface
 * @export
 * @class MediaInfoApi
 * @extends {BaseAPI}
 */
export class MediaInfoApi extends BaseAPI {
    /**
     * 
     * @param {MediaInfoApiCloseLiveStreamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaInfoApi
     */
    public closeLiveStream(requestParameters: MediaInfoApiCloseLiveStreamRequest, options?: any) {
        return MediaInfoApiFp(this.configuration).closeLiveStream(requestParameters.liveStreamId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {MediaInfoApiGetBitrateTestBytesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaInfoApi
     */
    public getBitrateTestBytes(requestParameters: MediaInfoApiGetBitrateTestBytesRequest = {}, options?: any) {
        return MediaInfoApiFp(this.configuration).getBitrateTestBytes(requestParameters.size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {MediaInfoApiGetPlaybackInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaInfoApi
     */
    public getPlaybackInfo(requestParameters: MediaInfoApiGetPlaybackInfoRequest, options?: any) {
        return MediaInfoApiFp(this.configuration).getPlaybackInfo(requestParameters.itemId, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {MediaInfoApiGetPostedPlaybackInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaInfoApi
     */
    public getPostedPlaybackInfo(requestParameters: MediaInfoApiGetPostedPlaybackInfoRequest, options?: any) {
        return MediaInfoApiFp(this.configuration).getPostedPlaybackInfo(requestParameters.itemId, requestParameters.userId, requestParameters.maxStreamingBitrate, requestParameters.startTimeTicks, requestParameters.audioStreamIndex, requestParameters.subtitleStreamIndex, requestParameters.maxAudioChannels, requestParameters.mediaSourceId, requestParameters.liveStreamId, requestParameters.autoOpenLiveStream, requestParameters.enableDirectPlay, requestParameters.enableDirectStream, requestParameters.enableTranscoding, requestParameters.allowVideoStreamCopy, requestParameters.allowAudioStreamCopy, requestParameters.deviceProfileDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {MediaInfoApiOpenLiveStreamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaInfoApi
     */
    public openLiveStream(requestParameters: MediaInfoApiOpenLiveStreamRequest = {}, options?: any) {
        return MediaInfoApiFp(this.configuration).openLiveStream(requestParameters.openToken, requestParameters.userId, requestParameters.playSessionId, requestParameters.maxStreamingBitrate, requestParameters.startTimeTicks, requestParameters.audioStreamIndex, requestParameters.subtitleStreamIndex, requestParameters.maxAudioChannels, requestParameters.itemId, requestParameters.enableDirectPlay, requestParameters.enableDirectStream, requestParameters.openLiveStreamDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MoviesApi - axios parameter creator
 * @export
 */
export const MoviesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [userId] 
         * @param {string} [parentId] 
         * @param {string} [fields] 
         * @param {number} [categoryLimit] 
         * @param {number} [itemLimit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMovieRecommendations: async (userId?: string, parentId?: string, fields?: string, categoryLimit?: number, itemLimit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Movies/Recommendations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (parentId !== undefined) {
                localVarQueryParameter['parentId'] = parentId;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (categoryLimit !== undefined) {
                localVarQueryParameter['categoryLimit'] = categoryLimit;
            }

            if (itemLimit !== undefined) {
                localVarQueryParameter['itemLimit'] = itemLimit;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MoviesApi - functional programming interface
 * @export
 */
export const MoviesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [userId] 
         * @param {string} [parentId] 
         * @param {string} [fields] 
         * @param {number} [categoryLimit] 
         * @param {number} [itemLimit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMovieRecommendations(userId?: string, parentId?: string, fields?: string, categoryLimit?: number, itemLimit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RecommendationDto>>> {
            const localVarAxiosArgs = await MoviesApiAxiosParamCreator(configuration).getMovieRecommendations(userId, parentId, fields, categoryLimit, itemLimit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * MoviesApi - factory interface
 * @export
 */
export const MoviesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} [userId] 
         * @param {string} [parentId] 
         * @param {string} [fields] 
         * @param {number} [categoryLimit] 
         * @param {number} [itemLimit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMovieRecommendations(userId?: string, parentId?: string, fields?: string, categoryLimit?: number, itemLimit?: number, options?: any): AxiosPromise<Array<RecommendationDto>> {
            return MoviesApiFp(configuration).getMovieRecommendations(userId, parentId, fields, categoryLimit, itemLimit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getMovieRecommendations operation in MoviesApi.
 * @export
 * @interface MoviesApiGetMovieRecommendationsRequest
 */
export interface MoviesApiGetMovieRecommendationsRequest {
    /**
     * 
     * @type {string}
     * @memberof MoviesApiGetMovieRecommendations
     */
    readonly userId?: string

    /**
     * 
     * @type {string}
     * @memberof MoviesApiGetMovieRecommendations
     */
    readonly parentId?: string

    /**
     * 
     * @type {string}
     * @memberof MoviesApiGetMovieRecommendations
     */
    readonly fields?: string

    /**
     * 
     * @type {number}
     * @memberof MoviesApiGetMovieRecommendations
     */
    readonly categoryLimit?: number

    /**
     * 
     * @type {number}
     * @memberof MoviesApiGetMovieRecommendations
     */
    readonly itemLimit?: number
}

/**
 * MoviesApi - object-oriented interface
 * @export
 * @class MoviesApi
 * @extends {BaseAPI}
 */
export class MoviesApi extends BaseAPI {
    /**
     * 
     * @param {MoviesApiGetMovieRecommendationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MoviesApi
     */
    public getMovieRecommendations(requestParameters: MoviesApiGetMovieRecommendationsRequest = {}, options?: any) {
        return MoviesApiFp(this.configuration).getMovieRecommendations(requestParameters.userId, requestParameters.parentId, requestParameters.fields, requestParameters.categoryLimit, requestParameters.itemLimit, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MusicGenresApi - axios parameter creator
 * @export
 */
export const MusicGenresApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} genreName 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMusicGenre: async (genreName: string, userId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'genreName' is not null or undefined
            if (genreName === null || genreName === undefined) {
                throw new RequiredError('genreName','Required parameter genreName was null or undefined when calling getMusicGenre.');
            }
            const localVarPath = `/MusicGenres/{genreName}`
                .replace(`{${"genreName"}}`, encodeURIComponent(String(genreName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [minCommunityRating] 
         * @param {number} [startIndex] 
         * @param {number} [limit] 
         * @param {string} [searchTerm] 
         * @param {string} [parentId] 
         * @param {string} [fields] 
         * @param {string} [excludeItemTypes] 
         * @param {string} [includeItemTypes] 
         * @param {string} [filters] 
         * @param {boolean} [isFavorite] 
         * @param {string} [mediaTypes] 
         * @param {string} [genres] 
         * @param {string} [genreIds] 
         * @param {string} [officialRatings] 
         * @param {string} [tags] 
         * @param {string} [years] 
         * @param {boolean} [enableUserData] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {string} [person] 
         * @param {string} [personIds] 
         * @param {string} [personTypes] 
         * @param {string} [studios] 
         * @param {string} [studioIds] 
         * @param {string} [userId] 
         * @param {string} [nameStartsWithOrGreater] 
         * @param {string} [nameStartsWith] 
         * @param {string} [nameLessThan] 
         * @param {boolean} [enableImages] 
         * @param {boolean} [enableTotalRecordCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMusicGenres: async (minCommunityRating?: number, startIndex?: number, limit?: number, searchTerm?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, filters?: string, isFavorite?: boolean, mediaTypes?: string, genres?: string, genreIds?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, studioIds?: string, userId?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, enableImages?: boolean, enableTotalRecordCount?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/MusicGenres`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (minCommunityRating !== undefined) {
                localVarQueryParameter['minCommunityRating'] = minCommunityRating;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (searchTerm !== undefined) {
                localVarQueryParameter['searchTerm'] = searchTerm;
            }

            if (parentId !== undefined) {
                localVarQueryParameter['parentId'] = parentId;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeItemTypes !== undefined) {
                localVarQueryParameter['excludeItemTypes'] = excludeItemTypes;
            }

            if (includeItemTypes !== undefined) {
                localVarQueryParameter['includeItemTypes'] = includeItemTypes;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (isFavorite !== undefined) {
                localVarQueryParameter['isFavorite'] = isFavorite;
            }

            if (mediaTypes !== undefined) {
                localVarQueryParameter['mediaTypes'] = mediaTypes;
            }

            if (genres !== undefined) {
                localVarQueryParameter['genres'] = genres;
            }

            if (genreIds !== undefined) {
                localVarQueryParameter['genreIds'] = genreIds;
            }

            if (officialRatings !== undefined) {
                localVarQueryParameter['officialRatings'] = officialRatings;
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }

            if (years !== undefined) {
                localVarQueryParameter['years'] = years;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes !== undefined) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }

            if (person !== undefined) {
                localVarQueryParameter['person'] = person;
            }

            if (personIds !== undefined) {
                localVarQueryParameter['personIds'] = personIds;
            }

            if (personTypes !== undefined) {
                localVarQueryParameter['personTypes'] = personTypes;
            }

            if (studios !== undefined) {
                localVarQueryParameter['studios'] = studios;
            }

            if (studioIds !== undefined) {
                localVarQueryParameter['studioIds'] = studioIds;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (nameStartsWithOrGreater !== undefined) {
                localVarQueryParameter['nameStartsWithOrGreater'] = nameStartsWithOrGreater;
            }

            if (nameStartsWith !== undefined) {
                localVarQueryParameter['nameStartsWith'] = nameStartsWith;
            }

            if (nameLessThan !== undefined) {
                localVarQueryParameter['nameLessThan'] = nameLessThan;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }

            if (enableTotalRecordCount !== undefined) {
                localVarQueryParameter['enableTotalRecordCount'] = enableTotalRecordCount;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MusicGenresApi - functional programming interface
 * @export
 */
export const MusicGenresApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} genreName 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMusicGenre(genreName: string, userId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDto>> {
            const localVarAxiosArgs = await MusicGenresApiAxiosParamCreator(configuration).getMusicGenre(genreName, userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} [minCommunityRating] 
         * @param {number} [startIndex] 
         * @param {number} [limit] 
         * @param {string} [searchTerm] 
         * @param {string} [parentId] 
         * @param {string} [fields] 
         * @param {string} [excludeItemTypes] 
         * @param {string} [includeItemTypes] 
         * @param {string} [filters] 
         * @param {boolean} [isFavorite] 
         * @param {string} [mediaTypes] 
         * @param {string} [genres] 
         * @param {string} [genreIds] 
         * @param {string} [officialRatings] 
         * @param {string} [tags] 
         * @param {string} [years] 
         * @param {boolean} [enableUserData] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {string} [person] 
         * @param {string} [personIds] 
         * @param {string} [personTypes] 
         * @param {string} [studios] 
         * @param {string} [studioIds] 
         * @param {string} [userId] 
         * @param {string} [nameStartsWithOrGreater] 
         * @param {string} [nameStartsWith] 
         * @param {string} [nameLessThan] 
         * @param {boolean} [enableImages] 
         * @param {boolean} [enableTotalRecordCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMusicGenres(minCommunityRating?: number, startIndex?: number, limit?: number, searchTerm?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, filters?: string, isFavorite?: boolean, mediaTypes?: string, genres?: string, genreIds?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, studioIds?: string, userId?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, enableImages?: boolean, enableTotalRecordCount?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await MusicGenresApiAxiosParamCreator(configuration).getMusicGenres(minCommunityRating, startIndex, limit, searchTerm, parentId, fields, excludeItemTypes, includeItemTypes, filters, isFavorite, mediaTypes, genres, genreIds, officialRatings, tags, years, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, studioIds, userId, nameStartsWithOrGreater, nameStartsWith, nameLessThan, enableImages, enableTotalRecordCount, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * MusicGenresApi - factory interface
 * @export
 */
export const MusicGenresApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} genreName 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMusicGenre(genreName: string, userId?: string, options?: any): AxiosPromise<BaseItemDto> {
            return MusicGenresApiFp(configuration).getMusicGenre(genreName, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [minCommunityRating] 
         * @param {number} [startIndex] 
         * @param {number} [limit] 
         * @param {string} [searchTerm] 
         * @param {string} [parentId] 
         * @param {string} [fields] 
         * @param {string} [excludeItemTypes] 
         * @param {string} [includeItemTypes] 
         * @param {string} [filters] 
         * @param {boolean} [isFavorite] 
         * @param {string} [mediaTypes] 
         * @param {string} [genres] 
         * @param {string} [genreIds] 
         * @param {string} [officialRatings] 
         * @param {string} [tags] 
         * @param {string} [years] 
         * @param {boolean} [enableUserData] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {string} [person] 
         * @param {string} [personIds] 
         * @param {string} [personTypes] 
         * @param {string} [studios] 
         * @param {string} [studioIds] 
         * @param {string} [userId] 
         * @param {string} [nameStartsWithOrGreater] 
         * @param {string} [nameStartsWith] 
         * @param {string} [nameLessThan] 
         * @param {boolean} [enableImages] 
         * @param {boolean} [enableTotalRecordCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMusicGenres(minCommunityRating?: number, startIndex?: number, limit?: number, searchTerm?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, filters?: string, isFavorite?: boolean, mediaTypes?: string, genres?: string, genreIds?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, studioIds?: string, userId?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, enableImages?: boolean, enableTotalRecordCount?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return MusicGenresApiFp(configuration).getMusicGenres(minCommunityRating, startIndex, limit, searchTerm, parentId, fields, excludeItemTypes, includeItemTypes, filters, isFavorite, mediaTypes, genres, genreIds, officialRatings, tags, years, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, studioIds, userId, nameStartsWithOrGreater, nameStartsWith, nameLessThan, enableImages, enableTotalRecordCount, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getMusicGenre operation in MusicGenresApi.
 * @export
 * @interface MusicGenresApiGetMusicGenreRequest
 */
export interface MusicGenresApiGetMusicGenreRequest {
    /**
     * 
     * @type {string}
     * @memberof MusicGenresApiGetMusicGenre
     */
    readonly genreName: string

    /**
     * 
     * @type {string}
     * @memberof MusicGenresApiGetMusicGenre
     */
    readonly userId?: string
}

/**
 * Request parameters for getMusicGenres operation in MusicGenresApi.
 * @export
 * @interface MusicGenresApiGetMusicGenresRequest
 */
export interface MusicGenresApiGetMusicGenresRequest {
    /**
     * 
     * @type {number}
     * @memberof MusicGenresApiGetMusicGenres
     */
    readonly minCommunityRating?: number

    /**
     * 
     * @type {number}
     * @memberof MusicGenresApiGetMusicGenres
     */
    readonly startIndex?: number

    /**
     * 
     * @type {number}
     * @memberof MusicGenresApiGetMusicGenres
     */
    readonly limit?: number

    /**
     * 
     * @type {string}
     * @memberof MusicGenresApiGetMusicGenres
     */
    readonly searchTerm?: string

    /**
     * 
     * @type {string}
     * @memberof MusicGenresApiGetMusicGenres
     */
    readonly parentId?: string

    /**
     * 
     * @type {string}
     * @memberof MusicGenresApiGetMusicGenres
     */
    readonly fields?: string

    /**
     * 
     * @type {string}
     * @memberof MusicGenresApiGetMusicGenres
     */
    readonly excludeItemTypes?: string

    /**
     * 
     * @type {string}
     * @memberof MusicGenresApiGetMusicGenres
     */
    readonly includeItemTypes?: string

    /**
     * 
     * @type {string}
     * @memberof MusicGenresApiGetMusicGenres
     */
    readonly filters?: string

    /**
     * 
     * @type {boolean}
     * @memberof MusicGenresApiGetMusicGenres
     */
    readonly isFavorite?: boolean

    /**
     * 
     * @type {string}
     * @memberof MusicGenresApiGetMusicGenres
     */
    readonly mediaTypes?: string

    /**
     * 
     * @type {string}
     * @memberof MusicGenresApiGetMusicGenres
     */
    readonly genres?: string

    /**
     * 
     * @type {string}
     * @memberof MusicGenresApiGetMusicGenres
     */
    readonly genreIds?: string

    /**
     * 
     * @type {string}
     * @memberof MusicGenresApiGetMusicGenres
     */
    readonly officialRatings?: string

    /**
     * 
     * @type {string}
     * @memberof MusicGenresApiGetMusicGenres
     */
    readonly tags?: string

    /**
     * 
     * @type {string}
     * @memberof MusicGenresApiGetMusicGenres
     */
    readonly years?: string

    /**
     * 
     * @type {boolean}
     * @memberof MusicGenresApiGetMusicGenres
     */
    readonly enableUserData?: boolean

    /**
     * 
     * @type {number}
     * @memberof MusicGenresApiGetMusicGenres
     */
    readonly imageTypeLimit?: number

    /**
     * 
     * @type {string}
     * @memberof MusicGenresApiGetMusicGenres
     */
    readonly enableImageTypes?: string

    /**
     * 
     * @type {string}
     * @memberof MusicGenresApiGetMusicGenres
     */
    readonly person?: string

    /**
     * 
     * @type {string}
     * @memberof MusicGenresApiGetMusicGenres
     */
    readonly personIds?: string

    /**
     * 
     * @type {string}
     * @memberof MusicGenresApiGetMusicGenres
     */
    readonly personTypes?: string

    /**
     * 
     * @type {string}
     * @memberof MusicGenresApiGetMusicGenres
     */
    readonly studios?: string

    /**
     * 
     * @type {string}
     * @memberof MusicGenresApiGetMusicGenres
     */
    readonly studioIds?: string

    /**
     * 
     * @type {string}
     * @memberof MusicGenresApiGetMusicGenres
     */
    readonly userId?: string

    /**
     * 
     * @type {string}
     * @memberof MusicGenresApiGetMusicGenres
     */
    readonly nameStartsWithOrGreater?: string

    /**
     * 
     * @type {string}
     * @memberof MusicGenresApiGetMusicGenres
     */
    readonly nameStartsWith?: string

    /**
     * 
     * @type {string}
     * @memberof MusicGenresApiGetMusicGenres
     */
    readonly nameLessThan?: string

    /**
     * 
     * @type {boolean}
     * @memberof MusicGenresApiGetMusicGenres
     */
    readonly enableImages?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof MusicGenresApiGetMusicGenres
     */
    readonly enableTotalRecordCount?: boolean
}

/**
 * MusicGenresApi - object-oriented interface
 * @export
 * @class MusicGenresApi
 * @extends {BaseAPI}
 */
export class MusicGenresApi extends BaseAPI {
    /**
     * 
     * @param {MusicGenresApiGetMusicGenreRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MusicGenresApi
     */
    public getMusicGenre(requestParameters: MusicGenresApiGetMusicGenreRequest, options?: any) {
        return MusicGenresApiFp(this.configuration).getMusicGenre(requestParameters.genreName, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {MusicGenresApiGetMusicGenresRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MusicGenresApi
     */
    public getMusicGenres(requestParameters: MusicGenresApiGetMusicGenresRequest = {}, options?: any) {
        return MusicGenresApiFp(this.configuration).getMusicGenres(requestParameters.minCommunityRating, requestParameters.startIndex, requestParameters.limit, requestParameters.searchTerm, requestParameters.parentId, requestParameters.fields, requestParameters.excludeItemTypes, requestParameters.includeItemTypes, requestParameters.filters, requestParameters.isFavorite, requestParameters.mediaTypes, requestParameters.genres, requestParameters.genreIds, requestParameters.officialRatings, requestParameters.tags, requestParameters.years, requestParameters.enableUserData, requestParameters.imageTypeLimit, requestParameters.enableImageTypes, requestParameters.person, requestParameters.personIds, requestParameters.personTypes, requestParameters.studios, requestParameters.studioIds, requestParameters.userId, requestParameters.nameStartsWithOrGreater, requestParameters.nameStartsWith, requestParameters.nameLessThan, requestParameters.enableImages, requestParameters.enableTotalRecordCount, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NotificationsApi - axios parameter creator
 * @export
 */
export const NotificationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [url] 
         * @param {NotificationLevel} [level] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAdminNotification: async (url?: string, level?: NotificationLevel, name?: string, description?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Notifications/Admin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (url !== undefined) {
                localVarQueryParameter['url'] = url;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationServices: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Notifications/Services`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationTypes: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Notifications/Types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotifications: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getNotifications.');
            }
            const localVarPath = `/Notifications/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationsSummary: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getNotificationsSummary.');
            }
            const localVarPath = `/Notifications/{userId}/Summary`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRead: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling setRead.');
            }
            const localVarPath = `/Notifications/{userId}/Read`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUnread: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling setUnread.');
            }
            const localVarPath = `/Notifications/{userId}/Unread`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationsApi - functional programming interface
 * @export
 */
export const NotificationsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [url] 
         * @param {NotificationLevel} [level] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAdminNotification(url?: string, level?: NotificationLevel, name?: string, description?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await NotificationsApiAxiosParamCreator(configuration).createAdminNotification(url, level, name, description, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNotificationServices(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NameIdPair>>> {
            const localVarAxiosArgs = await NotificationsApiAxiosParamCreator(configuration).getNotificationServices(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNotificationTypes(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NotificationTypeInfo>>> {
            const localVarAxiosArgs = await NotificationsApiAxiosParamCreator(configuration).getNotificationTypes(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNotifications(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationResultDto>> {
            const localVarAxiosArgs = await NotificationsApiAxiosParamCreator(configuration).getNotifications(userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNotificationsSummary(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationsSummaryDto>> {
            const localVarAxiosArgs = await NotificationsApiAxiosParamCreator(configuration).getNotificationsSummary(userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setRead(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await NotificationsApiAxiosParamCreator(configuration).setRead(userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setUnread(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await NotificationsApiAxiosParamCreator(configuration).setUnread(userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * NotificationsApi - factory interface
 * @export
 */
export const NotificationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} [url] 
         * @param {NotificationLevel} [level] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAdminNotification(url?: string, level?: NotificationLevel, name?: string, description?: string, options?: any): AxiosPromise<void> {
            return NotificationsApiFp(configuration).createAdminNotification(url, level, name, description, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationServices(options?: any): AxiosPromise<Array<NameIdPair>> {
            return NotificationsApiFp(configuration).getNotificationServices(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationTypes(options?: any): AxiosPromise<Array<NotificationTypeInfo>> {
            return NotificationsApiFp(configuration).getNotificationTypes(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotifications(userId: string, options?: any): AxiosPromise<NotificationResultDto> {
            return NotificationsApiFp(configuration).getNotifications(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationsSummary(userId: string, options?: any): AxiosPromise<NotificationsSummaryDto> {
            return NotificationsApiFp(configuration).getNotificationsSummary(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRead(userId: string, options?: any): AxiosPromise<void> {
            return NotificationsApiFp(configuration).setRead(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUnread(userId: string, options?: any): AxiosPromise<void> {
            return NotificationsApiFp(configuration).setUnread(userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createAdminNotification operation in NotificationsApi.
 * @export
 * @interface NotificationsApiCreateAdminNotificationRequest
 */
export interface NotificationsApiCreateAdminNotificationRequest {
    /**
     * 
     * @type {string}
     * @memberof NotificationsApiCreateAdminNotification
     */
    readonly url?: string

    /**
     * 
     * @type {NotificationLevel}
     * @memberof NotificationsApiCreateAdminNotification
     */
    readonly level?: NotificationLevel

    /**
     * 
     * @type {string}
     * @memberof NotificationsApiCreateAdminNotification
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof NotificationsApiCreateAdminNotification
     */
    readonly description?: string
}

/**
 * Request parameters for getNotifications operation in NotificationsApi.
 * @export
 * @interface NotificationsApiGetNotificationsRequest
 */
export interface NotificationsApiGetNotificationsRequest {
    /**
     * 
     * @type {string}
     * @memberof NotificationsApiGetNotifications
     */
    readonly userId: string
}

/**
 * Request parameters for getNotificationsSummary operation in NotificationsApi.
 * @export
 * @interface NotificationsApiGetNotificationsSummaryRequest
 */
export interface NotificationsApiGetNotificationsSummaryRequest {
    /**
     * 
     * @type {string}
     * @memberof NotificationsApiGetNotificationsSummary
     */
    readonly userId: string
}

/**
 * Request parameters for setRead operation in NotificationsApi.
 * @export
 * @interface NotificationsApiSetReadRequest
 */
export interface NotificationsApiSetReadRequest {
    /**
     * 
     * @type {string}
     * @memberof NotificationsApiSetRead
     */
    readonly userId: string
}

/**
 * Request parameters for setUnread operation in NotificationsApi.
 * @export
 * @interface NotificationsApiSetUnreadRequest
 */
export interface NotificationsApiSetUnreadRequest {
    /**
     * 
     * @type {string}
     * @memberof NotificationsApiSetUnread
     */
    readonly userId: string
}

/**
 * NotificationsApi - object-oriented interface
 * @export
 * @class NotificationsApi
 * @extends {BaseAPI}
 */
export class NotificationsApi extends BaseAPI {
    /**
     * 
     * @param {NotificationsApiCreateAdminNotificationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public createAdminNotification(requestParameters: NotificationsApiCreateAdminNotificationRequest = {}, options?: any) {
        return NotificationsApiFp(this.configuration).createAdminNotification(requestParameters.url, requestParameters.level, requestParameters.name, requestParameters.description, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public getNotificationServices(options?: any) {
        return NotificationsApiFp(this.configuration).getNotificationServices(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public getNotificationTypes(options?: any) {
        return NotificationsApiFp(this.configuration).getNotificationTypes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {NotificationsApiGetNotificationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public getNotifications(requestParameters: NotificationsApiGetNotificationsRequest, options?: any) {
        return NotificationsApiFp(this.configuration).getNotifications(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {NotificationsApiGetNotificationsSummaryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public getNotificationsSummary(requestParameters: NotificationsApiGetNotificationsSummaryRequest, options?: any) {
        return NotificationsApiFp(this.configuration).getNotificationsSummary(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {NotificationsApiSetReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public setRead(requestParameters: NotificationsApiSetReadRequest, options?: any) {
        return NotificationsApiFp(this.configuration).setRead(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {NotificationsApiSetUnreadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public setUnread(requestParameters: NotificationsApiSetUnreadRequest, options?: any) {
        return NotificationsApiFp(this.configuration).setUnread(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PackageApi - axios parameter creator
 * @export
 */
export const PackageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} packageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPackageInstallation: async (packageId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'packageId' is not null or undefined
            if (packageId === null || packageId === undefined) {
                throw new RequiredError('packageId','Required parameter packageId was null or undefined when calling cancelPackageInstallation.');
            }
            const localVarPath = `/Packages/Installing/{packageId}`
                .replace(`{${"packageId"}}`, encodeURIComponent(String(packageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {string} [assemblyGuid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPackageInfo: async (name: string, assemblyGuid?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getPackageInfo.');
            }
            const localVarPath = `/Packages/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (assemblyGuid !== undefined) {
                localVarQueryParameter['assemblyGuid'] = assemblyGuid;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPackages: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Packages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositories: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Repositories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {string} [assemblyGuid] 
         * @param {string} [version] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        installPackage: async (name: string, assemblyGuid?: string, version?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling installPackage.');
            }
            const localVarPath = `/Packages/Installed/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (assemblyGuid !== undefined) {
                localVarQueryParameter['assemblyGuid'] = assemblyGuid;
            }

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<RepositoryInfo>} [repositoryInfo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRepositories: async (repositoryInfo?: Array<RepositoryInfo>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Repositories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'OPTIONS', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof repositoryInfo !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(repositoryInfo !== undefined ? repositoryInfo : {}) : (repositoryInfo || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PackageApi - functional programming interface
 * @export
 */
export const PackageApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} packageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelPackageInstallation(packageId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PackageApiAxiosParamCreator(configuration).cancelPackageInstallation(packageId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {string} [assemblyGuid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPackageInfo(name: string, assemblyGuid?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PackageInfo>> {
            const localVarAxiosArgs = await PackageApiAxiosParamCreator(configuration).getPackageInfo(name, assemblyGuid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPackages(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PackageInfo>>> {
            const localVarAxiosArgs = await PackageApiAxiosParamCreator(configuration).getPackages(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRepositories(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RepositoryInfo>>> {
            const localVarAxiosArgs = await PackageApiAxiosParamCreator(configuration).getRepositories(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {string} [assemblyGuid] 
         * @param {string} [version] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async installPackage(name: string, assemblyGuid?: string, version?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PackageApiAxiosParamCreator(configuration).installPackage(name, assemblyGuid, version, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Array<RepositoryInfo>} [repositoryInfo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setRepositories(repositoryInfo?: Array<RepositoryInfo>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PackageApiAxiosParamCreator(configuration).setRepositories(repositoryInfo, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * PackageApi - factory interface
 * @export
 */
export const PackageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} packageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPackageInstallation(packageId: string, options?: any): AxiosPromise<void> {
            return PackageApiFp(configuration).cancelPackageInstallation(packageId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} name 
         * @param {string} [assemblyGuid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPackageInfo(name: string, assemblyGuid?: string, options?: any): AxiosPromise<PackageInfo> {
            return PackageApiFp(configuration).getPackageInfo(name, assemblyGuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPackages(options?: any): AxiosPromise<Array<PackageInfo>> {
            return PackageApiFp(configuration).getPackages(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRepositories(options?: any): AxiosPromise<Array<RepositoryInfo>> {
            return PackageApiFp(configuration).getRepositories(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} name 
         * @param {string} [assemblyGuid] 
         * @param {string} [version] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        installPackage(name: string, assemblyGuid?: string, version?: string, options?: any): AxiosPromise<void> {
            return PackageApiFp(configuration).installPackage(name, assemblyGuid, version, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<RepositoryInfo>} [repositoryInfo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRepositories(repositoryInfo?: Array<RepositoryInfo>, options?: any): AxiosPromise<void> {
            return PackageApiFp(configuration).setRepositories(repositoryInfo, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for cancelPackageInstallation operation in PackageApi.
 * @export
 * @interface PackageApiCancelPackageInstallationRequest
 */
export interface PackageApiCancelPackageInstallationRequest {
    /**
     * 
     * @type {string}
     * @memberof PackageApiCancelPackageInstallation
     */
    readonly packageId: string
}

/**
 * Request parameters for getPackageInfo operation in PackageApi.
 * @export
 * @interface PackageApiGetPackageInfoRequest
 */
export interface PackageApiGetPackageInfoRequest {
    /**
     * 
     * @type {string}
     * @memberof PackageApiGetPackageInfo
     */
    readonly name: string

    /**
     * 
     * @type {string}
     * @memberof PackageApiGetPackageInfo
     */
    readonly assemblyGuid?: string
}

/**
 * Request parameters for installPackage operation in PackageApi.
 * @export
 * @interface PackageApiInstallPackageRequest
 */
export interface PackageApiInstallPackageRequest {
    /**
     * 
     * @type {string}
     * @memberof PackageApiInstallPackage
     */
    readonly name: string

    /**
     * 
     * @type {string}
     * @memberof PackageApiInstallPackage
     */
    readonly assemblyGuid?: string

    /**
     * 
     * @type {string}
     * @memberof PackageApiInstallPackage
     */
    readonly version?: string
}

/**
 * Request parameters for setRepositories operation in PackageApi.
 * @export
 * @interface PackageApiSetRepositoriesRequest
 */
export interface PackageApiSetRepositoriesRequest {
    /**
     * 
     * @type {Array<RepositoryInfo>}
     * @memberof PackageApiSetRepositories
     */
    readonly repositoryInfo?: Array<RepositoryInfo>
}

/**
 * PackageApi - object-oriented interface
 * @export
 * @class PackageApi
 * @extends {BaseAPI}
 */
export class PackageApi extends BaseAPI {
    /**
     * 
     * @param {PackageApiCancelPackageInstallationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackageApi
     */
    public cancelPackageInstallation(requestParameters: PackageApiCancelPackageInstallationRequest, options?: any) {
        return PackageApiFp(this.configuration).cancelPackageInstallation(requestParameters.packageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PackageApiGetPackageInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackageApi
     */
    public getPackageInfo(requestParameters: PackageApiGetPackageInfoRequest, options?: any) {
        return PackageApiFp(this.configuration).getPackageInfo(requestParameters.name, requestParameters.assemblyGuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackageApi
     */
    public getPackages(options?: any) {
        return PackageApiFp(this.configuration).getPackages(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackageApi
     */
    public getRepositories(options?: any) {
        return PackageApiFp(this.configuration).getRepositories(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PackageApiInstallPackageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackageApi
     */
    public installPackage(requestParameters: PackageApiInstallPackageRequest, options?: any) {
        return PackageApiFp(this.configuration).installPackage(requestParameters.name, requestParameters.assemblyGuid, requestParameters.version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PackageApiSetRepositoriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PackageApi
     */
    public setRepositories(requestParameters: PackageApiSetRepositoriesRequest = {}, options?: any) {
        return PackageApiFp(this.configuration).setRepositories(requestParameters.repositoryInfo, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PersonsApi - axios parameter creator
 * @export
 */
export const PersonsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} name 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPerson: async (name: string, userId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getPerson.');
            }
            const localVarPath = `/Persons/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [minCommunityRating] 
         * @param {number} [startIndex] 
         * @param {number} [limit] 
         * @param {string} [searchTerm] 
         * @param {string} [parentId] 
         * @param {string} [fields] 
         * @param {string} [excludeItemTypes] 
         * @param {string} [includeItemTypes] 
         * @param {string} [filters] 
         * @param {boolean} [isFavorite] 
         * @param {string} [mediaTypes] 
         * @param {string} [genres] 
         * @param {string} [genreIds] 
         * @param {string} [officialRatings] 
         * @param {string} [tags] 
         * @param {string} [years] 
         * @param {boolean} [enableUserData] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {string} [person] 
         * @param {string} [personIds] 
         * @param {string} [personTypes] 
         * @param {string} [studios] 
         * @param {string} [studioIds] 
         * @param {string} [userId] 
         * @param {string} [nameStartsWithOrGreater] 
         * @param {string} [nameStartsWith] 
         * @param {string} [nameLessThan] 
         * @param {boolean} [enableImages] 
         * @param {boolean} [enableTotalRecordCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersons: async (minCommunityRating?: number, startIndex?: number, limit?: number, searchTerm?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, filters?: string, isFavorite?: boolean, mediaTypes?: string, genres?: string, genreIds?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, studioIds?: string, userId?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, enableImages?: boolean, enableTotalRecordCount?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Persons`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (minCommunityRating !== undefined) {
                localVarQueryParameter['minCommunityRating'] = minCommunityRating;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (searchTerm !== undefined) {
                localVarQueryParameter['searchTerm'] = searchTerm;
            }

            if (parentId !== undefined) {
                localVarQueryParameter['parentId'] = parentId;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeItemTypes !== undefined) {
                localVarQueryParameter['excludeItemTypes'] = excludeItemTypes;
            }

            if (includeItemTypes !== undefined) {
                localVarQueryParameter['includeItemTypes'] = includeItemTypes;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (isFavorite !== undefined) {
                localVarQueryParameter['isFavorite'] = isFavorite;
            }

            if (mediaTypes !== undefined) {
                localVarQueryParameter['mediaTypes'] = mediaTypes;
            }

            if (genres !== undefined) {
                localVarQueryParameter['genres'] = genres;
            }

            if (genreIds !== undefined) {
                localVarQueryParameter['genreIds'] = genreIds;
            }

            if (officialRatings !== undefined) {
                localVarQueryParameter['officialRatings'] = officialRatings;
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }

            if (years !== undefined) {
                localVarQueryParameter['years'] = years;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes !== undefined) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }

            if (person !== undefined) {
                localVarQueryParameter['person'] = person;
            }

            if (personIds !== undefined) {
                localVarQueryParameter['personIds'] = personIds;
            }

            if (personTypes !== undefined) {
                localVarQueryParameter['personTypes'] = personTypes;
            }

            if (studios !== undefined) {
                localVarQueryParameter['studios'] = studios;
            }

            if (studioIds !== undefined) {
                localVarQueryParameter['studioIds'] = studioIds;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (nameStartsWithOrGreater !== undefined) {
                localVarQueryParameter['nameStartsWithOrGreater'] = nameStartsWithOrGreater;
            }

            if (nameStartsWith !== undefined) {
                localVarQueryParameter['nameStartsWith'] = nameStartsWith;
            }

            if (nameLessThan !== undefined) {
                localVarQueryParameter['nameLessThan'] = nameLessThan;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }

            if (enableTotalRecordCount !== undefined) {
                localVarQueryParameter['enableTotalRecordCount'] = enableTotalRecordCount;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PersonsApi - functional programming interface
 * @export
 */
export const PersonsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} name 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPerson(name: string, userId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDto>> {
            const localVarAxiosArgs = await PersonsApiAxiosParamCreator(configuration).getPerson(name, userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} [minCommunityRating] 
         * @param {number} [startIndex] 
         * @param {number} [limit] 
         * @param {string} [searchTerm] 
         * @param {string} [parentId] 
         * @param {string} [fields] 
         * @param {string} [excludeItemTypes] 
         * @param {string} [includeItemTypes] 
         * @param {string} [filters] 
         * @param {boolean} [isFavorite] 
         * @param {string} [mediaTypes] 
         * @param {string} [genres] 
         * @param {string} [genreIds] 
         * @param {string} [officialRatings] 
         * @param {string} [tags] 
         * @param {string} [years] 
         * @param {boolean} [enableUserData] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {string} [person] 
         * @param {string} [personIds] 
         * @param {string} [personTypes] 
         * @param {string} [studios] 
         * @param {string} [studioIds] 
         * @param {string} [userId] 
         * @param {string} [nameStartsWithOrGreater] 
         * @param {string} [nameStartsWith] 
         * @param {string} [nameLessThan] 
         * @param {boolean} [enableImages] 
         * @param {boolean} [enableTotalRecordCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPersons(minCommunityRating?: number, startIndex?: number, limit?: number, searchTerm?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, filters?: string, isFavorite?: boolean, mediaTypes?: string, genres?: string, genreIds?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, studioIds?: string, userId?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, enableImages?: boolean, enableTotalRecordCount?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await PersonsApiAxiosParamCreator(configuration).getPersons(minCommunityRating, startIndex, limit, searchTerm, parentId, fields, excludeItemTypes, includeItemTypes, filters, isFavorite, mediaTypes, genres, genreIds, officialRatings, tags, years, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, studioIds, userId, nameStartsWithOrGreater, nameStartsWith, nameLessThan, enableImages, enableTotalRecordCount, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * PersonsApi - factory interface
 * @export
 */
export const PersonsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} name 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPerson(name: string, userId?: string, options?: any): AxiosPromise<BaseItemDto> {
            return PersonsApiFp(configuration).getPerson(name, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [minCommunityRating] 
         * @param {number} [startIndex] 
         * @param {number} [limit] 
         * @param {string} [searchTerm] 
         * @param {string} [parentId] 
         * @param {string} [fields] 
         * @param {string} [excludeItemTypes] 
         * @param {string} [includeItemTypes] 
         * @param {string} [filters] 
         * @param {boolean} [isFavorite] 
         * @param {string} [mediaTypes] 
         * @param {string} [genres] 
         * @param {string} [genreIds] 
         * @param {string} [officialRatings] 
         * @param {string} [tags] 
         * @param {string} [years] 
         * @param {boolean} [enableUserData] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {string} [person] 
         * @param {string} [personIds] 
         * @param {string} [personTypes] 
         * @param {string} [studios] 
         * @param {string} [studioIds] 
         * @param {string} [userId] 
         * @param {string} [nameStartsWithOrGreater] 
         * @param {string} [nameStartsWith] 
         * @param {string} [nameLessThan] 
         * @param {boolean} [enableImages] 
         * @param {boolean} [enableTotalRecordCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersons(minCommunityRating?: number, startIndex?: number, limit?: number, searchTerm?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, filters?: string, isFavorite?: boolean, mediaTypes?: string, genres?: string, genreIds?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, studioIds?: string, userId?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, enableImages?: boolean, enableTotalRecordCount?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return PersonsApiFp(configuration).getPersons(minCommunityRating, startIndex, limit, searchTerm, parentId, fields, excludeItemTypes, includeItemTypes, filters, isFavorite, mediaTypes, genres, genreIds, officialRatings, tags, years, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, studioIds, userId, nameStartsWithOrGreater, nameStartsWith, nameLessThan, enableImages, enableTotalRecordCount, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getPerson operation in PersonsApi.
 * @export
 * @interface PersonsApiGetPersonRequest
 */
export interface PersonsApiGetPersonRequest {
    /**
     * 
     * @type {string}
     * @memberof PersonsApiGetPerson
     */
    readonly name: string

    /**
     * 
     * @type {string}
     * @memberof PersonsApiGetPerson
     */
    readonly userId?: string
}

/**
 * Request parameters for getPersons operation in PersonsApi.
 * @export
 * @interface PersonsApiGetPersonsRequest
 */
export interface PersonsApiGetPersonsRequest {
    /**
     * 
     * @type {number}
     * @memberof PersonsApiGetPersons
     */
    readonly minCommunityRating?: number

    /**
     * 
     * @type {number}
     * @memberof PersonsApiGetPersons
     */
    readonly startIndex?: number

    /**
     * 
     * @type {number}
     * @memberof PersonsApiGetPersons
     */
    readonly limit?: number

    /**
     * 
     * @type {string}
     * @memberof PersonsApiGetPersons
     */
    readonly searchTerm?: string

    /**
     * 
     * @type {string}
     * @memberof PersonsApiGetPersons
     */
    readonly parentId?: string

    /**
     * 
     * @type {string}
     * @memberof PersonsApiGetPersons
     */
    readonly fields?: string

    /**
     * 
     * @type {string}
     * @memberof PersonsApiGetPersons
     */
    readonly excludeItemTypes?: string

    /**
     * 
     * @type {string}
     * @memberof PersonsApiGetPersons
     */
    readonly includeItemTypes?: string

    /**
     * 
     * @type {string}
     * @memberof PersonsApiGetPersons
     */
    readonly filters?: string

    /**
     * 
     * @type {boolean}
     * @memberof PersonsApiGetPersons
     */
    readonly isFavorite?: boolean

    /**
     * 
     * @type {string}
     * @memberof PersonsApiGetPersons
     */
    readonly mediaTypes?: string

    /**
     * 
     * @type {string}
     * @memberof PersonsApiGetPersons
     */
    readonly genres?: string

    /**
     * 
     * @type {string}
     * @memberof PersonsApiGetPersons
     */
    readonly genreIds?: string

    /**
     * 
     * @type {string}
     * @memberof PersonsApiGetPersons
     */
    readonly officialRatings?: string

    /**
     * 
     * @type {string}
     * @memberof PersonsApiGetPersons
     */
    readonly tags?: string

    /**
     * 
     * @type {string}
     * @memberof PersonsApiGetPersons
     */
    readonly years?: string

    /**
     * 
     * @type {boolean}
     * @memberof PersonsApiGetPersons
     */
    readonly enableUserData?: boolean

    /**
     * 
     * @type {number}
     * @memberof PersonsApiGetPersons
     */
    readonly imageTypeLimit?: number

    /**
     * 
     * @type {string}
     * @memberof PersonsApiGetPersons
     */
    readonly enableImageTypes?: string

    /**
     * 
     * @type {string}
     * @memberof PersonsApiGetPersons
     */
    readonly person?: string

    /**
     * 
     * @type {string}
     * @memberof PersonsApiGetPersons
     */
    readonly personIds?: string

    /**
     * 
     * @type {string}
     * @memberof PersonsApiGetPersons
     */
    readonly personTypes?: string

    /**
     * 
     * @type {string}
     * @memberof PersonsApiGetPersons
     */
    readonly studios?: string

    /**
     * 
     * @type {string}
     * @memberof PersonsApiGetPersons
     */
    readonly studioIds?: string

    /**
     * 
     * @type {string}
     * @memberof PersonsApiGetPersons
     */
    readonly userId?: string

    /**
     * 
     * @type {string}
     * @memberof PersonsApiGetPersons
     */
    readonly nameStartsWithOrGreater?: string

    /**
     * 
     * @type {string}
     * @memberof PersonsApiGetPersons
     */
    readonly nameStartsWith?: string

    /**
     * 
     * @type {string}
     * @memberof PersonsApiGetPersons
     */
    readonly nameLessThan?: string

    /**
     * 
     * @type {boolean}
     * @memberof PersonsApiGetPersons
     */
    readonly enableImages?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof PersonsApiGetPersons
     */
    readonly enableTotalRecordCount?: boolean
}

/**
 * PersonsApi - object-oriented interface
 * @export
 * @class PersonsApi
 * @extends {BaseAPI}
 */
export class PersonsApi extends BaseAPI {
    /**
     * 
     * @param {PersonsApiGetPersonRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public getPerson(requestParameters: PersonsApiGetPersonRequest, options?: any) {
        return PersonsApiFp(this.configuration).getPerson(requestParameters.name, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PersonsApiGetPersonsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonsApi
     */
    public getPersons(requestParameters: PersonsApiGetPersonsRequest = {}, options?: any) {
        return PersonsApiFp(this.configuration).getPersons(requestParameters.minCommunityRating, requestParameters.startIndex, requestParameters.limit, requestParameters.searchTerm, requestParameters.parentId, requestParameters.fields, requestParameters.excludeItemTypes, requestParameters.includeItemTypes, requestParameters.filters, requestParameters.isFavorite, requestParameters.mediaTypes, requestParameters.genres, requestParameters.genreIds, requestParameters.officialRatings, requestParameters.tags, requestParameters.years, requestParameters.enableUserData, requestParameters.imageTypeLimit, requestParameters.enableImageTypes, requestParameters.person, requestParameters.personIds, requestParameters.personTypes, requestParameters.studios, requestParameters.studioIds, requestParameters.userId, requestParameters.nameStartsWithOrGreater, requestParameters.nameStartsWith, requestParameters.nameLessThan, requestParameters.enableImages, requestParameters.enableTotalRecordCount, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PlaylistsApi - axios parameter creator
 * @export
 */
export const PlaylistsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} playlistId 
         * @param {string} [ids] 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addToPlaylist: async (playlistId: string, ids?: string, userId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'playlistId' is not null or undefined
            if (playlistId === null || playlistId === undefined) {
                throw new RequiredError('playlistId','Required parameter playlistId was null or undefined when calling addToPlaylist.');
            }
            const localVarPath = `/Playlists/{playlistId}/Items`
                .replace(`{${"playlistId"}}`, encodeURIComponent(String(playlistId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreatePlaylistDto} createPlaylistDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPlaylist: async (createPlaylistDto: CreatePlaylistDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPlaylistDto' is not null or undefined
            if (createPlaylistDto === null || createPlaylistDto === undefined) {
                throw new RequiredError('createPlaylistDto','Required parameter createPlaylistDto was null or undefined when calling createPlaylist.');
            }
            const localVarPath = `/Playlists`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createPlaylistDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createPlaylistDto !== undefined ? createPlaylistDto : {}) : (createPlaylistDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} playlistId 
         * @param {string} userId 
         * @param {number} startIndex 
         * @param {number} limit 
         * @param {string} fields 
         * @param {boolean} enableImages 
         * @param {boolean} enableUserData 
         * @param {number} imageTypeLimit 
         * @param {string} enableImageTypes 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlaylistItems: async (playlistId: string, userId: string, startIndex: number, limit: number, fields: string, enableImages: boolean, enableUserData: boolean, imageTypeLimit: number, enableImageTypes: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'playlistId' is not null or undefined
            if (playlistId === null || playlistId === undefined) {
                throw new RequiredError('playlistId','Required parameter playlistId was null or undefined when calling getPlaylistItems.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getPlaylistItems.');
            }
            // verify required parameter 'startIndex' is not null or undefined
            if (startIndex === null || startIndex === undefined) {
                throw new RequiredError('startIndex','Required parameter startIndex was null or undefined when calling getPlaylistItems.');
            }
            // verify required parameter 'limit' is not null or undefined
            if (limit === null || limit === undefined) {
                throw new RequiredError('limit','Required parameter limit was null or undefined when calling getPlaylistItems.');
            }
            // verify required parameter 'fields' is not null or undefined
            if (fields === null || fields === undefined) {
                throw new RequiredError('fields','Required parameter fields was null or undefined when calling getPlaylistItems.');
            }
            // verify required parameter 'enableImages' is not null or undefined
            if (enableImages === null || enableImages === undefined) {
                throw new RequiredError('enableImages','Required parameter enableImages was null or undefined when calling getPlaylistItems.');
            }
            // verify required parameter 'enableUserData' is not null or undefined
            if (enableUserData === null || enableUserData === undefined) {
                throw new RequiredError('enableUserData','Required parameter enableUserData was null or undefined when calling getPlaylistItems.');
            }
            // verify required parameter 'imageTypeLimit' is not null or undefined
            if (imageTypeLimit === null || imageTypeLimit === undefined) {
                throw new RequiredError('imageTypeLimit','Required parameter imageTypeLimit was null or undefined when calling getPlaylistItems.');
            }
            // verify required parameter 'enableImageTypes' is not null or undefined
            if (enableImageTypes === null || enableImageTypes === undefined) {
                throw new RequiredError('enableImageTypes','Required parameter enableImageTypes was null or undefined when calling getPlaylistItems.');
            }
            const localVarPath = `/Playlists/{playlistId}/Items`
                .replace(`{${"playlistId"}}`, encodeURIComponent(String(playlistId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"startIndex"}}`, encodeURIComponent(String(startIndex)))
                .replace(`{${"limit"}}`, encodeURIComponent(String(limit)))
                .replace(`{${"fields"}}`, encodeURIComponent(String(fields)))
                .replace(`{${"enableImages"}}`, encodeURIComponent(String(enableImages)))
                .replace(`{${"enableUserData"}}`, encodeURIComponent(String(enableUserData)))
                .replace(`{${"imageTypeLimit"}}`, encodeURIComponent(String(imageTypeLimit)))
                .replace(`{${"enableImageTypes"}}`, encodeURIComponent(String(enableImageTypes)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} playlistId 
         * @param {string} itemId 
         * @param {number} newIndex 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveItem: async (playlistId: string, itemId: string, newIndex: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'playlistId' is not null or undefined
            if (playlistId === null || playlistId === undefined) {
                throw new RequiredError('playlistId','Required parameter playlistId was null or undefined when calling moveItem.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling moveItem.');
            }
            // verify required parameter 'newIndex' is not null or undefined
            if (newIndex === null || newIndex === undefined) {
                throw new RequiredError('newIndex','Required parameter newIndex was null or undefined when calling moveItem.');
            }
            const localVarPath = `/Playlists/{playlistId}/Items/{itemId}/Move/{newIndex}`
                .replace(`{${"playlistId"}}`, encodeURIComponent(String(playlistId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"newIndex"}}`, encodeURIComponent(String(newIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} playlistId 
         * @param {string} [entryIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeFromPlaylist: async (playlistId: string, entryIds?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'playlistId' is not null or undefined
            if (playlistId === null || playlistId === undefined) {
                throw new RequiredError('playlistId','Required parameter playlistId was null or undefined when calling removeFromPlaylist.');
            }
            const localVarPath = `/Playlists/{playlistId}/Items`
                .replace(`{${"playlistId"}}`, encodeURIComponent(String(playlistId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (entryIds !== undefined) {
                localVarQueryParameter['entryIds'] = entryIds;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlaylistsApi - functional programming interface
 * @export
 */
export const PlaylistsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} playlistId 
         * @param {string} [ids] 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addToPlaylist(playlistId: string, ids?: string, userId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PlaylistsApiAxiosParamCreator(configuration).addToPlaylist(playlistId, ids, userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CreatePlaylistDto} createPlaylistDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPlaylist(createPlaylistDto: CreatePlaylistDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlaylistCreationResult>> {
            const localVarAxiosArgs = await PlaylistsApiAxiosParamCreator(configuration).createPlaylist(createPlaylistDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} playlistId 
         * @param {string} userId 
         * @param {number} startIndex 
         * @param {number} limit 
         * @param {string} fields 
         * @param {boolean} enableImages 
         * @param {boolean} enableUserData 
         * @param {number} imageTypeLimit 
         * @param {string} enableImageTypes 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlaylistItems(playlistId: string, userId: string, startIndex: number, limit: number, fields: string, enableImages: boolean, enableUserData: boolean, imageTypeLimit: number, enableImageTypes: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await PlaylistsApiAxiosParamCreator(configuration).getPlaylistItems(playlistId, userId, startIndex, limit, fields, enableImages, enableUserData, imageTypeLimit, enableImageTypes, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} playlistId 
         * @param {string} itemId 
         * @param {number} newIndex 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moveItem(playlistId: string, itemId: string, newIndex: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PlaylistsApiAxiosParamCreator(configuration).moveItem(playlistId, itemId, newIndex, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} playlistId 
         * @param {string} [entryIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeFromPlaylist(playlistId: string, entryIds?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PlaylistsApiAxiosParamCreator(configuration).removeFromPlaylist(playlistId, entryIds, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * PlaylistsApi - factory interface
 * @export
 */
export const PlaylistsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} playlistId 
         * @param {string} [ids] 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addToPlaylist(playlistId: string, ids?: string, userId?: string, options?: any): AxiosPromise<void> {
            return PlaylistsApiFp(configuration).addToPlaylist(playlistId, ids, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreatePlaylistDto} createPlaylistDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPlaylist(createPlaylistDto: CreatePlaylistDto, options?: any): AxiosPromise<PlaylistCreationResult> {
            return PlaylistsApiFp(configuration).createPlaylist(createPlaylistDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} playlistId 
         * @param {string} userId 
         * @param {number} startIndex 
         * @param {number} limit 
         * @param {string} fields 
         * @param {boolean} enableImages 
         * @param {boolean} enableUserData 
         * @param {number} imageTypeLimit 
         * @param {string} enableImageTypes 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlaylistItems(playlistId: string, userId: string, startIndex: number, limit: number, fields: string, enableImages: boolean, enableUserData: boolean, imageTypeLimit: number, enableImageTypes: string, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return PlaylistsApiFp(configuration).getPlaylistItems(playlistId, userId, startIndex, limit, fields, enableImages, enableUserData, imageTypeLimit, enableImageTypes, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} playlistId 
         * @param {string} itemId 
         * @param {number} newIndex 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveItem(playlistId: string, itemId: string, newIndex: number, options?: any): AxiosPromise<void> {
            return PlaylistsApiFp(configuration).moveItem(playlistId, itemId, newIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} playlistId 
         * @param {string} [entryIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeFromPlaylist(playlistId: string, entryIds?: string, options?: any): AxiosPromise<void> {
            return PlaylistsApiFp(configuration).removeFromPlaylist(playlistId, entryIds, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addToPlaylist operation in PlaylistsApi.
 * @export
 * @interface PlaylistsApiAddToPlaylistRequest
 */
export interface PlaylistsApiAddToPlaylistRequest {
    /**
     * 
     * @type {string}
     * @memberof PlaylistsApiAddToPlaylist
     */
    readonly playlistId: string

    /**
     * 
     * @type {string}
     * @memberof PlaylistsApiAddToPlaylist
     */
    readonly ids?: string

    /**
     * 
     * @type {string}
     * @memberof PlaylistsApiAddToPlaylist
     */
    readonly userId?: string
}

/**
 * Request parameters for createPlaylist operation in PlaylistsApi.
 * @export
 * @interface PlaylistsApiCreatePlaylistRequest
 */
export interface PlaylistsApiCreatePlaylistRequest {
    /**
     * 
     * @type {CreatePlaylistDto}
     * @memberof PlaylistsApiCreatePlaylist
     */
    readonly createPlaylistDto: CreatePlaylistDto
}

/**
 * Request parameters for getPlaylistItems operation in PlaylistsApi.
 * @export
 * @interface PlaylistsApiGetPlaylistItemsRequest
 */
export interface PlaylistsApiGetPlaylistItemsRequest {
    /**
     * 
     * @type {string}
     * @memberof PlaylistsApiGetPlaylistItems
     */
    readonly playlistId: string

    /**
     * 
     * @type {string}
     * @memberof PlaylistsApiGetPlaylistItems
     */
    readonly userId: string

    /**
     * 
     * @type {number}
     * @memberof PlaylistsApiGetPlaylistItems
     */
    readonly startIndex: number

    /**
     * 
     * @type {number}
     * @memberof PlaylistsApiGetPlaylistItems
     */
    readonly limit: number

    /**
     * 
     * @type {string}
     * @memberof PlaylistsApiGetPlaylistItems
     */
    readonly fields: string

    /**
     * 
     * @type {boolean}
     * @memberof PlaylistsApiGetPlaylistItems
     */
    readonly enableImages: boolean

    /**
     * 
     * @type {boolean}
     * @memberof PlaylistsApiGetPlaylistItems
     */
    readonly enableUserData: boolean

    /**
     * 
     * @type {number}
     * @memberof PlaylistsApiGetPlaylistItems
     */
    readonly imageTypeLimit: number

    /**
     * 
     * @type {string}
     * @memberof PlaylistsApiGetPlaylistItems
     */
    readonly enableImageTypes: string
}

/**
 * Request parameters for moveItem operation in PlaylistsApi.
 * @export
 * @interface PlaylistsApiMoveItemRequest
 */
export interface PlaylistsApiMoveItemRequest {
    /**
     * 
     * @type {string}
     * @memberof PlaylistsApiMoveItem
     */
    readonly playlistId: string

    /**
     * 
     * @type {string}
     * @memberof PlaylistsApiMoveItem
     */
    readonly itemId: string

    /**
     * 
     * @type {number}
     * @memberof PlaylistsApiMoveItem
     */
    readonly newIndex: number
}

/**
 * Request parameters for removeFromPlaylist operation in PlaylistsApi.
 * @export
 * @interface PlaylistsApiRemoveFromPlaylistRequest
 */
export interface PlaylistsApiRemoveFromPlaylistRequest {
    /**
     * 
     * @type {string}
     * @memberof PlaylistsApiRemoveFromPlaylist
     */
    readonly playlistId: string

    /**
     * 
     * @type {string}
     * @memberof PlaylistsApiRemoveFromPlaylist
     */
    readonly entryIds?: string
}

/**
 * PlaylistsApi - object-oriented interface
 * @export
 * @class PlaylistsApi
 * @extends {BaseAPI}
 */
export class PlaylistsApi extends BaseAPI {
    /**
     * 
     * @param {PlaylistsApiAddToPlaylistRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistsApi
     */
    public addToPlaylist(requestParameters: PlaylistsApiAddToPlaylistRequest, options?: any) {
        return PlaylistsApiFp(this.configuration).addToPlaylist(requestParameters.playlistId, requestParameters.ids, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PlaylistsApiCreatePlaylistRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistsApi
     */
    public createPlaylist(requestParameters: PlaylistsApiCreatePlaylistRequest, options?: any) {
        return PlaylistsApiFp(this.configuration).createPlaylist(requestParameters.createPlaylistDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PlaylistsApiGetPlaylistItemsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistsApi
     */
    public getPlaylistItems(requestParameters: PlaylistsApiGetPlaylistItemsRequest, options?: any) {
        return PlaylistsApiFp(this.configuration).getPlaylistItems(requestParameters.playlistId, requestParameters.userId, requestParameters.startIndex, requestParameters.limit, requestParameters.fields, requestParameters.enableImages, requestParameters.enableUserData, requestParameters.imageTypeLimit, requestParameters.enableImageTypes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PlaylistsApiMoveItemRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistsApi
     */
    public moveItem(requestParameters: PlaylistsApiMoveItemRequest, options?: any) {
        return PlaylistsApiFp(this.configuration).moveItem(requestParameters.playlistId, requestParameters.itemId, requestParameters.newIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PlaylistsApiRemoveFromPlaylistRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistsApi
     */
    public removeFromPlaylist(requestParameters: PlaylistsApiRemoveFromPlaylistRequest, options?: any) {
        return PlaylistsApiFp(this.configuration).removeFromPlaylist(requestParameters.playlistId, requestParameters.entryIds, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PlaystateApi - axios parameter creator
 * @export
 */
export const PlaystateApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} userId 
         * @param {string} itemId 
         * @param {string} [datePlayed] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markPlayedItem: async (userId: string, itemId: string, datePlayed?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling markPlayedItem.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling markPlayedItem.');
            }
            const localVarPath = `/Users/{userId}/PlayedItems/{itemId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (datePlayed !== undefined) {
                localVarQueryParameter['datePlayed'] = (datePlayed as any instanceof Date) ?
                    (datePlayed as any).toISOString() :
                    datePlayed;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markUnplayedItem: async (userId: string, itemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling markUnplayedItem.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling markUnplayedItem.');
            }
            const localVarPath = `/Users/{userId}/PlayedItems/{itemId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} itemId 
         * @param {string} [mediaSourceId] 
         * @param {number} [positionTicks] 
         * @param {number} [audioStreamIndex] 
         * @param {number} [subtitleStreamIndex] 
         * @param {number} [volumeLevel] 
         * @param {PlayMethod} [playMethod] 
         * @param {string} [liveStreamId] 
         * @param {string} [playSessionId] 
         * @param {RepeatMode} [repeatMode] 
         * @param {boolean} [isPaused] 
         * @param {boolean} [isMuted] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        onPlaybackProgress: async (userId: string, itemId: string, mediaSourceId?: string, positionTicks?: number, audioStreamIndex?: number, subtitleStreamIndex?: number, volumeLevel?: number, playMethod?: PlayMethod, liveStreamId?: string, playSessionId?: string, repeatMode?: RepeatMode, isPaused?: boolean, isMuted?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling onPlaybackProgress.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling onPlaybackProgress.');
            }
            const localVarPath = `/Users/{userId}/PlayingItems/{itemId}/Progress`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['mediaSourceId'] = mediaSourceId;
            }

            if (positionTicks !== undefined) {
                localVarQueryParameter['positionTicks'] = positionTicks;
            }

            if (audioStreamIndex !== undefined) {
                localVarQueryParameter['audioStreamIndex'] = audioStreamIndex;
            }

            if (subtitleStreamIndex !== undefined) {
                localVarQueryParameter['subtitleStreamIndex'] = subtitleStreamIndex;
            }

            if (volumeLevel !== undefined) {
                localVarQueryParameter['volumeLevel'] = volumeLevel;
            }

            if (playMethod !== undefined) {
                localVarQueryParameter['playMethod'] = playMethod;
            }

            if (liveStreamId !== undefined) {
                localVarQueryParameter['liveStreamId'] = liveStreamId;
            }

            if (playSessionId !== undefined) {
                localVarQueryParameter['playSessionId'] = playSessionId;
            }

            if (repeatMode !== undefined) {
                localVarQueryParameter['repeatMode'] = repeatMode;
            }

            if (isPaused !== undefined) {
                localVarQueryParameter['isPaused'] = isPaused;
            }

            if (isMuted !== undefined) {
                localVarQueryParameter['isMuted'] = isMuted;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} itemId 
         * @param {string} [mediaSourceId] 
         * @param {number} [audioStreamIndex] 
         * @param {number} [subtitleStreamIndex] 
         * @param {PlayMethod} [playMethod] 
         * @param {string} [liveStreamId] 
         * @param {string} [playSessionId] 
         * @param {boolean} [canSeek] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        onPlaybackStart: async (userId: string, itemId: string, mediaSourceId?: string, audioStreamIndex?: number, subtitleStreamIndex?: number, playMethod?: PlayMethod, liveStreamId?: string, playSessionId?: string, canSeek?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling onPlaybackStart.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling onPlaybackStart.');
            }
            const localVarPath = `/Users/{userId}/PlayingItems/{itemId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['mediaSourceId'] = mediaSourceId;
            }

            if (audioStreamIndex !== undefined) {
                localVarQueryParameter['audioStreamIndex'] = audioStreamIndex;
            }

            if (subtitleStreamIndex !== undefined) {
                localVarQueryParameter['subtitleStreamIndex'] = subtitleStreamIndex;
            }

            if (playMethod !== undefined) {
                localVarQueryParameter['playMethod'] = playMethod;
            }

            if (liveStreamId !== undefined) {
                localVarQueryParameter['liveStreamId'] = liveStreamId;
            }

            if (playSessionId !== undefined) {
                localVarQueryParameter['playSessionId'] = playSessionId;
            }

            if (canSeek !== undefined) {
                localVarQueryParameter['canSeek'] = canSeek;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} itemId 
         * @param {string} [mediaSourceId] 
         * @param {string} [nextMediaType] 
         * @param {number} [positionTicks] 
         * @param {string} [liveStreamId] 
         * @param {string} [playSessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        onPlaybackStopped: async (userId: string, itemId: string, mediaSourceId?: string, nextMediaType?: string, positionTicks?: number, liveStreamId?: string, playSessionId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling onPlaybackStopped.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling onPlaybackStopped.');
            }
            const localVarPath = `/Users/{userId}/PlayingItems/{itemId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['mediaSourceId'] = mediaSourceId;
            }

            if (nextMediaType !== undefined) {
                localVarQueryParameter['nextMediaType'] = nextMediaType;
            }

            if (positionTicks !== undefined) {
                localVarQueryParameter['positionTicks'] = positionTicks;
            }

            if (liveStreamId !== undefined) {
                localVarQueryParameter['liveStreamId'] = liveStreamId;
            }

            if (playSessionId !== undefined) {
                localVarQueryParameter['playSessionId'] = playSessionId;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [playSessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pingPlaybackSession: async (playSessionId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Sessions/Playing/Ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (playSessionId !== undefined) {
                localVarQueryParameter['playSessionId'] = playSessionId;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PlaybackProgressInfo} [playbackProgressInfo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportPlaybackProgress: async (playbackProgressInfo?: PlaybackProgressInfo, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Sessions/Playing/Progress`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof playbackProgressInfo !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(playbackProgressInfo !== undefined ? playbackProgressInfo : {}) : (playbackProgressInfo || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PlaybackStartInfo} [playbackStartInfo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportPlaybackStart: async (playbackStartInfo?: PlaybackStartInfo, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Sessions/Playing`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof playbackStartInfo !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(playbackStartInfo !== undefined ? playbackStartInfo : {}) : (playbackStartInfo || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PlaybackStopInfo} [playbackStopInfo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportPlaybackStopped: async (playbackStopInfo?: PlaybackStopInfo, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Sessions/Playing/Stopped`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof playbackStopInfo !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(playbackStopInfo !== undefined ? playbackStopInfo : {}) : (playbackStopInfo || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlaystateApi - functional programming interface
 * @export
 */
export const PlaystateApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} userId 
         * @param {string} itemId 
         * @param {string} [datePlayed] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markPlayedItem(userId: string, itemId: string, datePlayed?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserItemDataDto>> {
            const localVarAxiosArgs = await PlaystateApiAxiosParamCreator(configuration).markPlayedItem(userId, itemId, datePlayed, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markUnplayedItem(userId: string, itemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserItemDataDto>> {
            const localVarAxiosArgs = await PlaystateApiAxiosParamCreator(configuration).markUnplayedItem(userId, itemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} itemId 
         * @param {string} [mediaSourceId] 
         * @param {number} [positionTicks] 
         * @param {number} [audioStreamIndex] 
         * @param {number} [subtitleStreamIndex] 
         * @param {number} [volumeLevel] 
         * @param {PlayMethod} [playMethod] 
         * @param {string} [liveStreamId] 
         * @param {string} [playSessionId] 
         * @param {RepeatMode} [repeatMode] 
         * @param {boolean} [isPaused] 
         * @param {boolean} [isMuted] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async onPlaybackProgress(userId: string, itemId: string, mediaSourceId?: string, positionTicks?: number, audioStreamIndex?: number, subtitleStreamIndex?: number, volumeLevel?: number, playMethod?: PlayMethod, liveStreamId?: string, playSessionId?: string, repeatMode?: RepeatMode, isPaused?: boolean, isMuted?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PlaystateApiAxiosParamCreator(configuration).onPlaybackProgress(userId, itemId, mediaSourceId, positionTicks, audioStreamIndex, subtitleStreamIndex, volumeLevel, playMethod, liveStreamId, playSessionId, repeatMode, isPaused, isMuted, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} itemId 
         * @param {string} [mediaSourceId] 
         * @param {number} [audioStreamIndex] 
         * @param {number} [subtitleStreamIndex] 
         * @param {PlayMethod} [playMethod] 
         * @param {string} [liveStreamId] 
         * @param {string} [playSessionId] 
         * @param {boolean} [canSeek] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async onPlaybackStart(userId: string, itemId: string, mediaSourceId?: string, audioStreamIndex?: number, subtitleStreamIndex?: number, playMethod?: PlayMethod, liveStreamId?: string, playSessionId?: string, canSeek?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PlaystateApiAxiosParamCreator(configuration).onPlaybackStart(userId, itemId, mediaSourceId, audioStreamIndex, subtitleStreamIndex, playMethod, liveStreamId, playSessionId, canSeek, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} itemId 
         * @param {string} [mediaSourceId] 
         * @param {string} [nextMediaType] 
         * @param {number} [positionTicks] 
         * @param {string} [liveStreamId] 
         * @param {string} [playSessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async onPlaybackStopped(userId: string, itemId: string, mediaSourceId?: string, nextMediaType?: string, positionTicks?: number, liveStreamId?: string, playSessionId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PlaystateApiAxiosParamCreator(configuration).onPlaybackStopped(userId, itemId, mediaSourceId, nextMediaType, positionTicks, liveStreamId, playSessionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [playSessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pingPlaybackSession(playSessionId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PlaystateApiAxiosParamCreator(configuration).pingPlaybackSession(playSessionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {PlaybackProgressInfo} [playbackProgressInfo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportPlaybackProgress(playbackProgressInfo?: PlaybackProgressInfo, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PlaystateApiAxiosParamCreator(configuration).reportPlaybackProgress(playbackProgressInfo, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {PlaybackStartInfo} [playbackStartInfo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportPlaybackStart(playbackStartInfo?: PlaybackStartInfo, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PlaystateApiAxiosParamCreator(configuration).reportPlaybackStart(playbackStartInfo, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {PlaybackStopInfo} [playbackStopInfo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportPlaybackStopped(playbackStopInfo?: PlaybackStopInfo, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PlaystateApiAxiosParamCreator(configuration).reportPlaybackStopped(playbackStopInfo, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * PlaystateApi - factory interface
 * @export
 */
export const PlaystateApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} userId 
         * @param {string} itemId 
         * @param {string} [datePlayed] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markPlayedItem(userId: string, itemId: string, datePlayed?: string, options?: any): AxiosPromise<UserItemDataDto> {
            return PlaystateApiFp(configuration).markPlayedItem(userId, itemId, datePlayed, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markUnplayedItem(userId: string, itemId: string, options?: any): AxiosPromise<UserItemDataDto> {
            return PlaystateApiFp(configuration).markUnplayedItem(userId, itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} itemId 
         * @param {string} [mediaSourceId] 
         * @param {number} [positionTicks] 
         * @param {number} [audioStreamIndex] 
         * @param {number} [subtitleStreamIndex] 
         * @param {number} [volumeLevel] 
         * @param {PlayMethod} [playMethod] 
         * @param {string} [liveStreamId] 
         * @param {string} [playSessionId] 
         * @param {RepeatMode} [repeatMode] 
         * @param {boolean} [isPaused] 
         * @param {boolean} [isMuted] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        onPlaybackProgress(userId: string, itemId: string, mediaSourceId?: string, positionTicks?: number, audioStreamIndex?: number, subtitleStreamIndex?: number, volumeLevel?: number, playMethod?: PlayMethod, liveStreamId?: string, playSessionId?: string, repeatMode?: RepeatMode, isPaused?: boolean, isMuted?: boolean, options?: any): AxiosPromise<void> {
            return PlaystateApiFp(configuration).onPlaybackProgress(userId, itemId, mediaSourceId, positionTicks, audioStreamIndex, subtitleStreamIndex, volumeLevel, playMethod, liveStreamId, playSessionId, repeatMode, isPaused, isMuted, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} itemId 
         * @param {string} [mediaSourceId] 
         * @param {number} [audioStreamIndex] 
         * @param {number} [subtitleStreamIndex] 
         * @param {PlayMethod} [playMethod] 
         * @param {string} [liveStreamId] 
         * @param {string} [playSessionId] 
         * @param {boolean} [canSeek] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        onPlaybackStart(userId: string, itemId: string, mediaSourceId?: string, audioStreamIndex?: number, subtitleStreamIndex?: number, playMethod?: PlayMethod, liveStreamId?: string, playSessionId?: string, canSeek?: boolean, options?: any): AxiosPromise<void> {
            return PlaystateApiFp(configuration).onPlaybackStart(userId, itemId, mediaSourceId, audioStreamIndex, subtitleStreamIndex, playMethod, liveStreamId, playSessionId, canSeek, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} itemId 
         * @param {string} [mediaSourceId] 
         * @param {string} [nextMediaType] 
         * @param {number} [positionTicks] 
         * @param {string} [liveStreamId] 
         * @param {string} [playSessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        onPlaybackStopped(userId: string, itemId: string, mediaSourceId?: string, nextMediaType?: string, positionTicks?: number, liveStreamId?: string, playSessionId?: string, options?: any): AxiosPromise<void> {
            return PlaystateApiFp(configuration).onPlaybackStopped(userId, itemId, mediaSourceId, nextMediaType, positionTicks, liveStreamId, playSessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [playSessionId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pingPlaybackSession(playSessionId?: string, options?: any): AxiosPromise<void> {
            return PlaystateApiFp(configuration).pingPlaybackSession(playSessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PlaybackProgressInfo} [playbackProgressInfo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportPlaybackProgress(playbackProgressInfo?: PlaybackProgressInfo, options?: any): AxiosPromise<void> {
            return PlaystateApiFp(configuration).reportPlaybackProgress(playbackProgressInfo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PlaybackStartInfo} [playbackStartInfo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportPlaybackStart(playbackStartInfo?: PlaybackStartInfo, options?: any): AxiosPromise<void> {
            return PlaystateApiFp(configuration).reportPlaybackStart(playbackStartInfo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PlaybackStopInfo} [playbackStopInfo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportPlaybackStopped(playbackStopInfo?: PlaybackStopInfo, options?: any): AxiosPromise<void> {
            return PlaystateApiFp(configuration).reportPlaybackStopped(playbackStopInfo, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for markPlayedItem operation in PlaystateApi.
 * @export
 * @interface PlaystateApiMarkPlayedItemRequest
 */
export interface PlaystateApiMarkPlayedItemRequest {
    /**
     * 
     * @type {string}
     * @memberof PlaystateApiMarkPlayedItem
     */
    readonly userId: string

    /**
     * 
     * @type {string}
     * @memberof PlaystateApiMarkPlayedItem
     */
    readonly itemId: string

    /**
     * 
     * @type {string}
     * @memberof PlaystateApiMarkPlayedItem
     */
    readonly datePlayed?: string
}

/**
 * Request parameters for markUnplayedItem operation in PlaystateApi.
 * @export
 * @interface PlaystateApiMarkUnplayedItemRequest
 */
export interface PlaystateApiMarkUnplayedItemRequest {
    /**
     * 
     * @type {string}
     * @memberof PlaystateApiMarkUnplayedItem
     */
    readonly userId: string

    /**
     * 
     * @type {string}
     * @memberof PlaystateApiMarkUnplayedItem
     */
    readonly itemId: string
}

/**
 * Request parameters for onPlaybackProgress operation in PlaystateApi.
 * @export
 * @interface PlaystateApiOnPlaybackProgressRequest
 */
export interface PlaystateApiOnPlaybackProgressRequest {
    /**
     * 
     * @type {string}
     * @memberof PlaystateApiOnPlaybackProgress
     */
    readonly userId: string

    /**
     * 
     * @type {string}
     * @memberof PlaystateApiOnPlaybackProgress
     */
    readonly itemId: string

    /**
     * 
     * @type {string}
     * @memberof PlaystateApiOnPlaybackProgress
     */
    readonly mediaSourceId?: string

    /**
     * 
     * @type {number}
     * @memberof PlaystateApiOnPlaybackProgress
     */
    readonly positionTicks?: number

    /**
     * 
     * @type {number}
     * @memberof PlaystateApiOnPlaybackProgress
     */
    readonly audioStreamIndex?: number

    /**
     * 
     * @type {number}
     * @memberof PlaystateApiOnPlaybackProgress
     */
    readonly subtitleStreamIndex?: number

    /**
     * 
     * @type {number}
     * @memberof PlaystateApiOnPlaybackProgress
     */
    readonly volumeLevel?: number

    /**
     * 
     * @type {PlayMethod}
     * @memberof PlaystateApiOnPlaybackProgress
     */
    readonly playMethod?: PlayMethod

    /**
     * 
     * @type {string}
     * @memberof PlaystateApiOnPlaybackProgress
     */
    readonly liveStreamId?: string

    /**
     * 
     * @type {string}
     * @memberof PlaystateApiOnPlaybackProgress
     */
    readonly playSessionId?: string

    /**
     * 
     * @type {RepeatMode}
     * @memberof PlaystateApiOnPlaybackProgress
     */
    readonly repeatMode?: RepeatMode

    /**
     * 
     * @type {boolean}
     * @memberof PlaystateApiOnPlaybackProgress
     */
    readonly isPaused?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof PlaystateApiOnPlaybackProgress
     */
    readonly isMuted?: boolean
}

/**
 * Request parameters for onPlaybackStart operation in PlaystateApi.
 * @export
 * @interface PlaystateApiOnPlaybackStartRequest
 */
export interface PlaystateApiOnPlaybackStartRequest {
    /**
     * 
     * @type {string}
     * @memberof PlaystateApiOnPlaybackStart
     */
    readonly userId: string

    /**
     * 
     * @type {string}
     * @memberof PlaystateApiOnPlaybackStart
     */
    readonly itemId: string

    /**
     * 
     * @type {string}
     * @memberof PlaystateApiOnPlaybackStart
     */
    readonly mediaSourceId?: string

    /**
     * 
     * @type {number}
     * @memberof PlaystateApiOnPlaybackStart
     */
    readonly audioStreamIndex?: number

    /**
     * 
     * @type {number}
     * @memberof PlaystateApiOnPlaybackStart
     */
    readonly subtitleStreamIndex?: number

    /**
     * 
     * @type {PlayMethod}
     * @memberof PlaystateApiOnPlaybackStart
     */
    readonly playMethod?: PlayMethod

    /**
     * 
     * @type {string}
     * @memberof PlaystateApiOnPlaybackStart
     */
    readonly liveStreamId?: string

    /**
     * 
     * @type {string}
     * @memberof PlaystateApiOnPlaybackStart
     */
    readonly playSessionId?: string

    /**
     * 
     * @type {boolean}
     * @memberof PlaystateApiOnPlaybackStart
     */
    readonly canSeek?: boolean
}

/**
 * Request parameters for onPlaybackStopped operation in PlaystateApi.
 * @export
 * @interface PlaystateApiOnPlaybackStoppedRequest
 */
export interface PlaystateApiOnPlaybackStoppedRequest {
    /**
     * 
     * @type {string}
     * @memberof PlaystateApiOnPlaybackStopped
     */
    readonly userId: string

    /**
     * 
     * @type {string}
     * @memberof PlaystateApiOnPlaybackStopped
     */
    readonly itemId: string

    /**
     * 
     * @type {string}
     * @memberof PlaystateApiOnPlaybackStopped
     */
    readonly mediaSourceId?: string

    /**
     * 
     * @type {string}
     * @memberof PlaystateApiOnPlaybackStopped
     */
    readonly nextMediaType?: string

    /**
     * 
     * @type {number}
     * @memberof PlaystateApiOnPlaybackStopped
     */
    readonly positionTicks?: number

    /**
     * 
     * @type {string}
     * @memberof PlaystateApiOnPlaybackStopped
     */
    readonly liveStreamId?: string

    /**
     * 
     * @type {string}
     * @memberof PlaystateApiOnPlaybackStopped
     */
    readonly playSessionId?: string
}

/**
 * Request parameters for pingPlaybackSession operation in PlaystateApi.
 * @export
 * @interface PlaystateApiPingPlaybackSessionRequest
 */
export interface PlaystateApiPingPlaybackSessionRequest {
    /**
     * 
     * @type {string}
     * @memberof PlaystateApiPingPlaybackSession
     */
    readonly playSessionId?: string
}

/**
 * Request parameters for reportPlaybackProgress operation in PlaystateApi.
 * @export
 * @interface PlaystateApiReportPlaybackProgressRequest
 */
export interface PlaystateApiReportPlaybackProgressRequest {
    /**
     * 
     * @type {PlaybackProgressInfo}
     * @memberof PlaystateApiReportPlaybackProgress
     */
    readonly playbackProgressInfo?: PlaybackProgressInfo
}

/**
 * Request parameters for reportPlaybackStart operation in PlaystateApi.
 * @export
 * @interface PlaystateApiReportPlaybackStartRequest
 */
export interface PlaystateApiReportPlaybackStartRequest {
    /**
     * 
     * @type {PlaybackStartInfo}
     * @memberof PlaystateApiReportPlaybackStart
     */
    readonly playbackStartInfo?: PlaybackStartInfo
}

/**
 * Request parameters for reportPlaybackStopped operation in PlaystateApi.
 * @export
 * @interface PlaystateApiReportPlaybackStoppedRequest
 */
export interface PlaystateApiReportPlaybackStoppedRequest {
    /**
     * 
     * @type {PlaybackStopInfo}
     * @memberof PlaystateApiReportPlaybackStopped
     */
    readonly playbackStopInfo?: PlaybackStopInfo
}

/**
 * PlaystateApi - object-oriented interface
 * @export
 * @class PlaystateApi
 * @extends {BaseAPI}
 */
export class PlaystateApi extends BaseAPI {
    /**
     * 
     * @param {PlaystateApiMarkPlayedItemRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaystateApi
     */
    public markPlayedItem(requestParameters: PlaystateApiMarkPlayedItemRequest, options?: any) {
        return PlaystateApiFp(this.configuration).markPlayedItem(requestParameters.userId, requestParameters.itemId, requestParameters.datePlayed, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PlaystateApiMarkUnplayedItemRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaystateApi
     */
    public markUnplayedItem(requestParameters: PlaystateApiMarkUnplayedItemRequest, options?: any) {
        return PlaystateApiFp(this.configuration).markUnplayedItem(requestParameters.userId, requestParameters.itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PlaystateApiOnPlaybackProgressRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaystateApi
     */
    public onPlaybackProgress(requestParameters: PlaystateApiOnPlaybackProgressRequest, options?: any) {
        return PlaystateApiFp(this.configuration).onPlaybackProgress(requestParameters.userId, requestParameters.itemId, requestParameters.mediaSourceId, requestParameters.positionTicks, requestParameters.audioStreamIndex, requestParameters.subtitleStreamIndex, requestParameters.volumeLevel, requestParameters.playMethod, requestParameters.liveStreamId, requestParameters.playSessionId, requestParameters.repeatMode, requestParameters.isPaused, requestParameters.isMuted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PlaystateApiOnPlaybackStartRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaystateApi
     */
    public onPlaybackStart(requestParameters: PlaystateApiOnPlaybackStartRequest, options?: any) {
        return PlaystateApiFp(this.configuration).onPlaybackStart(requestParameters.userId, requestParameters.itemId, requestParameters.mediaSourceId, requestParameters.audioStreamIndex, requestParameters.subtitleStreamIndex, requestParameters.playMethod, requestParameters.liveStreamId, requestParameters.playSessionId, requestParameters.canSeek, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PlaystateApiOnPlaybackStoppedRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaystateApi
     */
    public onPlaybackStopped(requestParameters: PlaystateApiOnPlaybackStoppedRequest, options?: any) {
        return PlaystateApiFp(this.configuration).onPlaybackStopped(requestParameters.userId, requestParameters.itemId, requestParameters.mediaSourceId, requestParameters.nextMediaType, requestParameters.positionTicks, requestParameters.liveStreamId, requestParameters.playSessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PlaystateApiPingPlaybackSessionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaystateApi
     */
    public pingPlaybackSession(requestParameters: PlaystateApiPingPlaybackSessionRequest = {}, options?: any) {
        return PlaystateApiFp(this.configuration).pingPlaybackSession(requestParameters.playSessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PlaystateApiReportPlaybackProgressRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaystateApi
     */
    public reportPlaybackProgress(requestParameters: PlaystateApiReportPlaybackProgressRequest = {}, options?: any) {
        return PlaystateApiFp(this.configuration).reportPlaybackProgress(requestParameters.playbackProgressInfo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PlaystateApiReportPlaybackStartRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaystateApi
     */
    public reportPlaybackStart(requestParameters: PlaystateApiReportPlaybackStartRequest = {}, options?: any) {
        return PlaystateApiFp(this.configuration).reportPlaybackStart(requestParameters.playbackStartInfo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PlaystateApiReportPlaybackStoppedRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaystateApi
     */
    public reportPlaybackStopped(requestParameters: PlaystateApiReportPlaybackStoppedRequest = {}, options?: any) {
        return PlaystateApiFp(this.configuration).reportPlaybackStopped(requestParameters.playbackStopInfo, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PluginsApi - axios parameter creator
 * @export
 */
export const PluginsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} pluginId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPluginConfiguration: async (pluginId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pluginId' is not null or undefined
            if (pluginId === null || pluginId === undefined) {
                throw new RequiredError('pluginId','Required parameter pluginId was null or undefined when calling getPluginConfiguration.');
            }
            const localVarPath = `/Plugins/{pluginId}/Configuration`
                .replace(`{${"pluginId"}}`, encodeURIComponent(String(pluginId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPluginSecurityInfo: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Plugins/SecurityInfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlugins: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Plugins`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegistration: async (name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getRegistration.');
            }
            const localVarPath = `/Plugins/Registrations/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegistrationStatus: async (name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getRegistrationStatus.');
            }
            const localVarPath = `/Plugins/RegistrationRecords/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} pluginId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uninstallPlugin: async (pluginId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pluginId' is not null or undefined
            if (pluginId === null || pluginId === undefined) {
                throw new RequiredError('pluginId','Required parameter pluginId was null or undefined when calling uninstallPlugin.');
            }
            const localVarPath = `/Plugins/{pluginId}`
                .replace(`{${"pluginId"}}`, encodeURIComponent(String(pluginId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} pluginId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePluginConfiguration: async (pluginId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pluginId' is not null or undefined
            if (pluginId === null || pluginId === undefined) {
                throw new RequiredError('pluginId','Required parameter pluginId was null or undefined when calling updatePluginConfiguration.');
            }
            const localVarPath = `/Plugins/{pluginId}/Configuration`
                .replace(`{${"pluginId"}}`, encodeURIComponent(String(pluginId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PluginSecurityInfo} pluginSecurityInfo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePluginSecurityInfo: async (pluginSecurityInfo: PluginSecurityInfo, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pluginSecurityInfo' is not null or undefined
            if (pluginSecurityInfo === null || pluginSecurityInfo === undefined) {
                throw new RequiredError('pluginSecurityInfo','Required parameter pluginSecurityInfo was null or undefined when calling updatePluginSecurityInfo.');
            }
            const localVarPath = `/Plugins/SecurityInfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof pluginSecurityInfo !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(pluginSecurityInfo !== undefined ? pluginSecurityInfo : {}) : (pluginSecurityInfo || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PluginsApi - functional programming interface
 * @export
 */
export const PluginsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} pluginId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPluginConfiguration(pluginId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await PluginsApiAxiosParamCreator(configuration).getPluginConfiguration(pluginId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPluginSecurityInfo(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PluginSecurityInfo>> {
            const localVarAxiosArgs = await PluginsApiAxiosParamCreator(configuration).getPluginSecurityInfo(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlugins(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PluginInfo>>> {
            const localVarAxiosArgs = await PluginsApiAxiosParamCreator(configuration).getPlugins(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRegistration(name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PluginsApiAxiosParamCreator(configuration).getRegistration(name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRegistrationStatus(name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MBRegistrationRecord>> {
            const localVarAxiosArgs = await PluginsApiAxiosParamCreator(configuration).getRegistrationStatus(name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} pluginId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uninstallPlugin(pluginId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PluginsApiAxiosParamCreator(configuration).uninstallPlugin(pluginId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} pluginId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePluginConfiguration(pluginId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PluginsApiAxiosParamCreator(configuration).updatePluginConfiguration(pluginId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {PluginSecurityInfo} pluginSecurityInfo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePluginSecurityInfo(pluginSecurityInfo: PluginSecurityInfo, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PluginsApiAxiosParamCreator(configuration).updatePluginSecurityInfo(pluginSecurityInfo, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * PluginsApi - factory interface
 * @export
 */
export const PluginsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} pluginId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPluginConfiguration(pluginId: string, options?: any): AxiosPromise<object> {
            return PluginsApiFp(configuration).getPluginConfiguration(pluginId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPluginSecurityInfo(options?: any): AxiosPromise<PluginSecurityInfo> {
            return PluginsApiFp(configuration).getPluginSecurityInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlugins(options?: any): AxiosPromise<Array<PluginInfo>> {
            return PluginsApiFp(configuration).getPlugins(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegistration(name: string, options?: any): AxiosPromise<void> {
            return PluginsApiFp(configuration).getRegistration(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegistrationStatus(name: string, options?: any): AxiosPromise<MBRegistrationRecord> {
            return PluginsApiFp(configuration).getRegistrationStatus(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} pluginId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uninstallPlugin(pluginId: string, options?: any): AxiosPromise<void> {
            return PluginsApiFp(configuration).uninstallPlugin(pluginId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} pluginId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePluginConfiguration(pluginId: string, options?: any): AxiosPromise<void> {
            return PluginsApiFp(configuration).updatePluginConfiguration(pluginId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PluginSecurityInfo} pluginSecurityInfo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePluginSecurityInfo(pluginSecurityInfo: PluginSecurityInfo, options?: any): AxiosPromise<void> {
            return PluginsApiFp(configuration).updatePluginSecurityInfo(pluginSecurityInfo, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getPluginConfiguration operation in PluginsApi.
 * @export
 * @interface PluginsApiGetPluginConfigurationRequest
 */
export interface PluginsApiGetPluginConfigurationRequest {
    /**
     * 
     * @type {string}
     * @memberof PluginsApiGetPluginConfiguration
     */
    readonly pluginId: string
}

/**
 * Request parameters for getRegistration operation in PluginsApi.
 * @export
 * @interface PluginsApiGetRegistrationRequest
 */
export interface PluginsApiGetRegistrationRequest {
    /**
     * 
     * @type {string}
     * @memberof PluginsApiGetRegistration
     */
    readonly name: string
}

/**
 * Request parameters for getRegistrationStatus operation in PluginsApi.
 * @export
 * @interface PluginsApiGetRegistrationStatusRequest
 */
export interface PluginsApiGetRegistrationStatusRequest {
    /**
     * 
     * @type {string}
     * @memberof PluginsApiGetRegistrationStatus
     */
    readonly name: string
}

/**
 * Request parameters for uninstallPlugin operation in PluginsApi.
 * @export
 * @interface PluginsApiUninstallPluginRequest
 */
export interface PluginsApiUninstallPluginRequest {
    /**
     * 
     * @type {string}
     * @memberof PluginsApiUninstallPlugin
     */
    readonly pluginId: string
}

/**
 * Request parameters for updatePluginConfiguration operation in PluginsApi.
 * @export
 * @interface PluginsApiUpdatePluginConfigurationRequest
 */
export interface PluginsApiUpdatePluginConfigurationRequest {
    /**
     * 
     * @type {string}
     * @memberof PluginsApiUpdatePluginConfiguration
     */
    readonly pluginId: string
}

/**
 * Request parameters for updatePluginSecurityInfo operation in PluginsApi.
 * @export
 * @interface PluginsApiUpdatePluginSecurityInfoRequest
 */
export interface PluginsApiUpdatePluginSecurityInfoRequest {
    /**
     * 
     * @type {PluginSecurityInfo}
     * @memberof PluginsApiUpdatePluginSecurityInfo
     */
    readonly pluginSecurityInfo: PluginSecurityInfo
}

/**
 * PluginsApi - object-oriented interface
 * @export
 * @class PluginsApi
 * @extends {BaseAPI}
 */
export class PluginsApi extends BaseAPI {
    /**
     * 
     * @param {PluginsApiGetPluginConfigurationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginsApi
     */
    public getPluginConfiguration(requestParameters: PluginsApiGetPluginConfigurationRequest, options?: any) {
        return PluginsApiFp(this.configuration).getPluginConfiguration(requestParameters.pluginId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginsApi
     */
    public getPluginSecurityInfo(options?: any) {
        return PluginsApiFp(this.configuration).getPluginSecurityInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginsApi
     */
    public getPlugins(options?: any) {
        return PluginsApiFp(this.configuration).getPlugins(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PluginsApiGetRegistrationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginsApi
     */
    public getRegistration(requestParameters: PluginsApiGetRegistrationRequest, options?: any) {
        return PluginsApiFp(this.configuration).getRegistration(requestParameters.name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PluginsApiGetRegistrationStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginsApi
     */
    public getRegistrationStatus(requestParameters: PluginsApiGetRegistrationStatusRequest, options?: any) {
        return PluginsApiFp(this.configuration).getRegistrationStatus(requestParameters.name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PluginsApiUninstallPluginRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginsApi
     */
    public uninstallPlugin(requestParameters: PluginsApiUninstallPluginRequest, options?: any) {
        return PluginsApiFp(this.configuration).uninstallPlugin(requestParameters.pluginId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PluginsApiUpdatePluginConfigurationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginsApi
     */
    public updatePluginConfiguration(requestParameters: PluginsApiUpdatePluginConfigurationRequest, options?: any) {
        return PluginsApiFp(this.configuration).updatePluginConfiguration(requestParameters.pluginId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PluginsApiUpdatePluginSecurityInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginsApi
     */
    public updatePluginSecurityInfo(requestParameters: PluginsApiUpdatePluginSecurityInfoRequest, options?: any) {
        return PluginsApiFp(this.configuration).updatePluginSecurityInfo(requestParameters.pluginSecurityInfo, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * QuickConnectApi - axios parameter creator
 * @export
 */
export const QuickConnectApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activate: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/QuickConnect/Activate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorize: async (code: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            if (code === null || code === undefined) {
                throw new RequiredError('code','Required parameter code was null or undefined when calling authorize.');
            }
            const localVarPath = `/QuickConnect/Authorize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {QuickConnectState} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        available: async (status?: QuickConnectState, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/QuickConnect/Available`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} secret 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connect: async (secret: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'secret' is not null or undefined
            if (secret === null || secret === undefined) {
                throw new RequiredError('secret','Required parameter secret was null or undefined when calling connect.');
            }
            const localVarPath = `/QuickConnect/Connect`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (secret !== undefined) {
                localVarQueryParameter['secret'] = secret;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deauthorize: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/QuickConnect/Deauthorize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/QuickConnect/Status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiate: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/QuickConnect/Initiate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QuickConnectApi - functional programming interface
 * @export
 */
export const QuickConnectApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activate(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await QuickConnectApiAxiosParamCreator(configuration).activate(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authorize(code: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await QuickConnectApiAxiosParamCreator(configuration).authorize(code, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {QuickConnectState} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async available(status?: QuickConnectState, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await QuickConnectApiAxiosParamCreator(configuration).available(status, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} secret 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connect(secret: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuickConnectResult>> {
            const localVarAxiosArgs = await QuickConnectApiAxiosParamCreator(configuration).connect(secret, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deauthorize(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await QuickConnectApiAxiosParamCreator(configuration).deauthorize(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatus(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuickConnectState>> {
            const localVarAxiosArgs = await QuickConnectApiAxiosParamCreator(configuration).getStatus(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async initiate(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuickConnectResult>> {
            const localVarAxiosArgs = await QuickConnectApiAxiosParamCreator(configuration).initiate(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * QuickConnectApi - factory interface
 * @export
 */
export const QuickConnectApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activate(options?: any): AxiosPromise<void> {
            return QuickConnectApiFp(configuration).activate(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorize(code: string, options?: any): AxiosPromise<boolean> {
            return QuickConnectApiFp(configuration).authorize(code, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {QuickConnectState} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        available(status?: QuickConnectState, options?: any): AxiosPromise<void> {
            return QuickConnectApiFp(configuration).available(status, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} secret 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connect(secret: string, options?: any): AxiosPromise<QuickConnectResult> {
            return QuickConnectApiFp(configuration).connect(secret, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deauthorize(options?: any): AxiosPromise<number> {
            return QuickConnectApiFp(configuration).deauthorize(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus(options?: any): AxiosPromise<QuickConnectState> {
            return QuickConnectApiFp(configuration).getStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiate(options?: any): AxiosPromise<QuickConnectResult> {
            return QuickConnectApiFp(configuration).initiate(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for authorize operation in QuickConnectApi.
 * @export
 * @interface QuickConnectApiAuthorizeRequest
 */
export interface QuickConnectApiAuthorizeRequest {
    /**
     * 
     * @type {string}
     * @memberof QuickConnectApiAuthorize
     */
    readonly code: string
}

/**
 * Request parameters for available operation in QuickConnectApi.
 * @export
 * @interface QuickConnectApiAvailableRequest
 */
export interface QuickConnectApiAvailableRequest {
    /**
     * 
     * @type {QuickConnectState}
     * @memberof QuickConnectApiAvailable
     */
    readonly status?: QuickConnectState
}

/**
 * Request parameters for connect operation in QuickConnectApi.
 * @export
 * @interface QuickConnectApiConnectRequest
 */
export interface QuickConnectApiConnectRequest {
    /**
     * 
     * @type {string}
     * @memberof QuickConnectApiConnect
     */
    readonly secret: string
}

/**
 * QuickConnectApi - object-oriented interface
 * @export
 * @class QuickConnectApi
 * @extends {BaseAPI}
 */
export class QuickConnectApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuickConnectApi
     */
    public activate(options?: any) {
        return QuickConnectApiFp(this.configuration).activate(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {QuickConnectApiAuthorizeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuickConnectApi
     */
    public authorize(requestParameters: QuickConnectApiAuthorizeRequest, options?: any) {
        return QuickConnectApiFp(this.configuration).authorize(requestParameters.code, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {QuickConnectApiAvailableRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuickConnectApi
     */
    public available(requestParameters: QuickConnectApiAvailableRequest = {}, options?: any) {
        return QuickConnectApiFp(this.configuration).available(requestParameters.status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {QuickConnectApiConnectRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuickConnectApi
     */
    public connect(requestParameters: QuickConnectApiConnectRequest, options?: any) {
        return QuickConnectApiFp(this.configuration).connect(requestParameters.secret, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuickConnectApi
     */
    public deauthorize(options?: any) {
        return QuickConnectApiFp(this.configuration).deauthorize(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuickConnectApi
     */
    public getStatus(options?: any) {
        return QuickConnectApiFp(this.configuration).getStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuickConnectApi
     */
    public initiate(options?: any) {
        return QuickConnectApiFp(this.configuration).initiate(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RemoteImageApi - axios parameter creator
 * @export
 */
export const RemoteImageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} itemId 
         * @param {ImageType} type 
         * @param {string} [imageUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadRemoteImage: async (itemId: string, type: ImageType, imageUrl?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling downloadRemoteImage.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling downloadRemoteImage.');
            }
            const localVarPath = `/Items/{itemId}/RemoteImages/Download`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (imageUrl !== undefined) {
                localVarQueryParameter['imageUrl'] = imageUrl;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} imageUrl 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRemoteImage: async (imageUrl: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'imageUrl' is not null or undefined
            if (imageUrl === null || imageUrl === undefined) {
                throw new RequiredError('imageUrl','Required parameter imageUrl was null or undefined when calling getRemoteImage.');
            }
            const localVarPath = `/Images/Remote`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (imageUrl !== undefined) {
                localVarQueryParameter['imageUrl'] = imageUrl;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRemoteImageProviders: async (itemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getRemoteImageProviders.');
            }
            const localVarPath = `/Items/{itemId}/RemoteImages/Providers`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {ImageType} [type] 
         * @param {number} [startIndex] 
         * @param {number} [limit] 
         * @param {string} [providerName] 
         * @param {boolean} [includeAllLanguages] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRemoteImages: async (itemId: string, type?: ImageType, startIndex?: number, limit?: number, providerName?: string, includeAllLanguages?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getRemoteImages.');
            }
            const localVarPath = `/Items/{itemId}/RemoteImages`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (providerName !== undefined) {
                localVarQueryParameter['providerName'] = providerName;
            }

            if (includeAllLanguages !== undefined) {
                localVarQueryParameter['includeAllLanguages'] = includeAllLanguages;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RemoteImageApi - functional programming interface
 * @export
 */
export const RemoteImageApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} itemId 
         * @param {ImageType} type 
         * @param {string} [imageUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadRemoteImage(itemId: string, type: ImageType, imageUrl?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await RemoteImageApiAxiosParamCreator(configuration).downloadRemoteImage(itemId, type, imageUrl, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} imageUrl 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRemoteImage(imageUrl: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await RemoteImageApiAxiosParamCreator(configuration).getRemoteImage(imageUrl, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRemoteImageProviders(itemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ImageProviderInfo>>> {
            const localVarAxiosArgs = await RemoteImageApiAxiosParamCreator(configuration).getRemoteImageProviders(itemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {ImageType} [type] 
         * @param {number} [startIndex] 
         * @param {number} [limit] 
         * @param {string} [providerName] 
         * @param {boolean} [includeAllLanguages] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRemoteImages(itemId: string, type?: ImageType, startIndex?: number, limit?: number, providerName?: string, includeAllLanguages?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RemoteImageResult>> {
            const localVarAxiosArgs = await RemoteImageApiAxiosParamCreator(configuration).getRemoteImages(itemId, type, startIndex, limit, providerName, includeAllLanguages, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * RemoteImageApi - factory interface
 * @export
 */
export const RemoteImageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} itemId 
         * @param {ImageType} type 
         * @param {string} [imageUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadRemoteImage(itemId: string, type: ImageType, imageUrl?: string, options?: any): AxiosPromise<void> {
            return RemoteImageApiFp(configuration).downloadRemoteImage(itemId, type, imageUrl, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} imageUrl 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRemoteImage(imageUrl: string, options?: any): AxiosPromise<void> {
            return RemoteImageApiFp(configuration).getRemoteImage(imageUrl, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRemoteImageProviders(itemId: string, options?: any): AxiosPromise<Array<ImageProviderInfo>> {
            return RemoteImageApiFp(configuration).getRemoteImageProviders(itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} itemId 
         * @param {ImageType} [type] 
         * @param {number} [startIndex] 
         * @param {number} [limit] 
         * @param {string} [providerName] 
         * @param {boolean} [includeAllLanguages] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRemoteImages(itemId: string, type?: ImageType, startIndex?: number, limit?: number, providerName?: string, includeAllLanguages?: boolean, options?: any): AxiosPromise<RemoteImageResult> {
            return RemoteImageApiFp(configuration).getRemoteImages(itemId, type, startIndex, limit, providerName, includeAllLanguages, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for downloadRemoteImage operation in RemoteImageApi.
 * @export
 * @interface RemoteImageApiDownloadRemoteImageRequest
 */
export interface RemoteImageApiDownloadRemoteImageRequest {
    /**
     * 
     * @type {string}
     * @memberof RemoteImageApiDownloadRemoteImage
     */
    readonly itemId: string

    /**
     * 
     * @type {ImageType}
     * @memberof RemoteImageApiDownloadRemoteImage
     */
    readonly type: ImageType

    /**
     * 
     * @type {string}
     * @memberof RemoteImageApiDownloadRemoteImage
     */
    readonly imageUrl?: string
}

/**
 * Request parameters for getRemoteImage operation in RemoteImageApi.
 * @export
 * @interface RemoteImageApiGetRemoteImageRequest
 */
export interface RemoteImageApiGetRemoteImageRequest {
    /**
     * 
     * @type {string}
     * @memberof RemoteImageApiGetRemoteImage
     */
    readonly imageUrl: string
}

/**
 * Request parameters for getRemoteImageProviders operation in RemoteImageApi.
 * @export
 * @interface RemoteImageApiGetRemoteImageProvidersRequest
 */
export interface RemoteImageApiGetRemoteImageProvidersRequest {
    /**
     * 
     * @type {string}
     * @memberof RemoteImageApiGetRemoteImageProviders
     */
    readonly itemId: string
}

/**
 * Request parameters for getRemoteImages operation in RemoteImageApi.
 * @export
 * @interface RemoteImageApiGetRemoteImagesRequest
 */
export interface RemoteImageApiGetRemoteImagesRequest {
    /**
     * 
     * @type {string}
     * @memberof RemoteImageApiGetRemoteImages
     */
    readonly itemId: string

    /**
     * 
     * @type {ImageType}
     * @memberof RemoteImageApiGetRemoteImages
     */
    readonly type?: ImageType

    /**
     * 
     * @type {number}
     * @memberof RemoteImageApiGetRemoteImages
     */
    readonly startIndex?: number

    /**
     * 
     * @type {number}
     * @memberof RemoteImageApiGetRemoteImages
     */
    readonly limit?: number

    /**
     * 
     * @type {string}
     * @memberof RemoteImageApiGetRemoteImages
     */
    readonly providerName?: string

    /**
     * 
     * @type {boolean}
     * @memberof RemoteImageApiGetRemoteImages
     */
    readonly includeAllLanguages?: boolean
}

/**
 * RemoteImageApi - object-oriented interface
 * @export
 * @class RemoteImageApi
 * @extends {BaseAPI}
 */
export class RemoteImageApi extends BaseAPI {
    /**
     * 
     * @param {RemoteImageApiDownloadRemoteImageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteImageApi
     */
    public downloadRemoteImage(requestParameters: RemoteImageApiDownloadRemoteImageRequest, options?: any) {
        return RemoteImageApiFp(this.configuration).downloadRemoteImage(requestParameters.itemId, requestParameters.type, requestParameters.imageUrl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RemoteImageApiGetRemoteImageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteImageApi
     */
    public getRemoteImage(requestParameters: RemoteImageApiGetRemoteImageRequest, options?: any) {
        return RemoteImageApiFp(this.configuration).getRemoteImage(requestParameters.imageUrl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RemoteImageApiGetRemoteImageProvidersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteImageApi
     */
    public getRemoteImageProviders(requestParameters: RemoteImageApiGetRemoteImageProvidersRequest, options?: any) {
        return RemoteImageApiFp(this.configuration).getRemoteImageProviders(requestParameters.itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RemoteImageApiGetRemoteImagesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemoteImageApi
     */
    public getRemoteImages(requestParameters: RemoteImageApiGetRemoteImagesRequest, options?: any) {
        return RemoteImageApiFp(this.configuration).getRemoteImages(requestParameters.itemId, requestParameters.type, requestParameters.startIndex, requestParameters.limit, requestParameters.providerName, requestParameters.includeAllLanguages, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ScheduledTasksApi - axios parameter creator
 * @export
 */
export const ScheduledTasksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTask: async (taskId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            if (taskId === null || taskId === undefined) {
                throw new RequiredError('taskId','Required parameter taskId was null or undefined when calling getTask.');
            }
            const localVarPath = `/ScheduledTasks/{taskId}`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {boolean} [isHidden] 
         * @param {boolean} [isEnabled] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasks: async (isHidden?: boolean, isEnabled?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/ScheduledTasks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (isHidden !== undefined) {
                localVarQueryParameter['isHidden'] = isHidden;
            }

            if (isEnabled !== undefined) {
                localVarQueryParameter['isEnabled'] = isEnabled;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startTask: async (taskId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            if (taskId === null || taskId === undefined) {
                throw new RequiredError('taskId','Required parameter taskId was null or undefined when calling startTask.');
            }
            const localVarPath = `/ScheduledTasks/Running/{taskId}`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopTask: async (taskId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            if (taskId === null || taskId === undefined) {
                throw new RequiredError('taskId','Required parameter taskId was null or undefined when calling stopTask.');
            }
            const localVarPath = `/ScheduledTasks/Running/{taskId}`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} taskId 
         * @param {Array<TaskTriggerInfo>} taskTriggerInfo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTask: async (taskId: string, taskTriggerInfo: Array<TaskTriggerInfo>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            if (taskId === null || taskId === undefined) {
                throw new RequiredError('taskId','Required parameter taskId was null or undefined when calling updateTask.');
            }
            // verify required parameter 'taskTriggerInfo' is not null or undefined
            if (taskTriggerInfo === null || taskTriggerInfo === undefined) {
                throw new RequiredError('taskTriggerInfo','Required parameter taskTriggerInfo was null or undefined when calling updateTask.');
            }
            const localVarPath = `/ScheduledTasks/{taskId}/Triggers`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof taskTriggerInfo !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(taskTriggerInfo !== undefined ? taskTriggerInfo : {}) : (taskTriggerInfo || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ScheduledTasksApi - functional programming interface
 * @export
 */
export const ScheduledTasksApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTask(taskId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskInfo>> {
            const localVarAxiosArgs = await ScheduledTasksApiAxiosParamCreator(configuration).getTask(taskId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {boolean} [isHidden] 
         * @param {boolean} [isEnabled] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTasks(isHidden?: boolean, isEnabled?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IScheduledTaskWorker>>> {
            const localVarAxiosArgs = await ScheduledTasksApiAxiosParamCreator(configuration).getTasks(isHidden, isEnabled, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startTask(taskId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ScheduledTasksApiAxiosParamCreator(configuration).startTask(taskId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopTask(taskId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ScheduledTasksApiAxiosParamCreator(configuration).stopTask(taskId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} taskId 
         * @param {Array<TaskTriggerInfo>} taskTriggerInfo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTask(taskId: string, taskTriggerInfo: Array<TaskTriggerInfo>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ScheduledTasksApiAxiosParamCreator(configuration).updateTask(taskId, taskTriggerInfo, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ScheduledTasksApi - factory interface
 * @export
 */
export const ScheduledTasksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTask(taskId: string, options?: any): AxiosPromise<TaskInfo> {
            return ScheduledTasksApiFp(configuration).getTask(taskId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {boolean} [isHidden] 
         * @param {boolean} [isEnabled] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasks(isHidden?: boolean, isEnabled?: boolean, options?: any): AxiosPromise<Array<IScheduledTaskWorker>> {
            return ScheduledTasksApiFp(configuration).getTasks(isHidden, isEnabled, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startTask(taskId: string, options?: any): AxiosPromise<void> {
            return ScheduledTasksApiFp(configuration).startTask(taskId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopTask(taskId: string, options?: any): AxiosPromise<void> {
            return ScheduledTasksApiFp(configuration).stopTask(taskId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} taskId 
         * @param {Array<TaskTriggerInfo>} taskTriggerInfo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTask(taskId: string, taskTriggerInfo: Array<TaskTriggerInfo>, options?: any): AxiosPromise<void> {
            return ScheduledTasksApiFp(configuration).updateTask(taskId, taskTriggerInfo, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getTask operation in ScheduledTasksApi.
 * @export
 * @interface ScheduledTasksApiGetTaskRequest
 */
export interface ScheduledTasksApiGetTaskRequest {
    /**
     * 
     * @type {string}
     * @memberof ScheduledTasksApiGetTask
     */
    readonly taskId: string
}

/**
 * Request parameters for getTasks operation in ScheduledTasksApi.
 * @export
 * @interface ScheduledTasksApiGetTasksRequest
 */
export interface ScheduledTasksApiGetTasksRequest {
    /**
     * 
     * @type {boolean}
     * @memberof ScheduledTasksApiGetTasks
     */
    readonly isHidden?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ScheduledTasksApiGetTasks
     */
    readonly isEnabled?: boolean
}

/**
 * Request parameters for startTask operation in ScheduledTasksApi.
 * @export
 * @interface ScheduledTasksApiStartTaskRequest
 */
export interface ScheduledTasksApiStartTaskRequest {
    /**
     * 
     * @type {string}
     * @memberof ScheduledTasksApiStartTask
     */
    readonly taskId: string
}

/**
 * Request parameters for stopTask operation in ScheduledTasksApi.
 * @export
 * @interface ScheduledTasksApiStopTaskRequest
 */
export interface ScheduledTasksApiStopTaskRequest {
    /**
     * 
     * @type {string}
     * @memberof ScheduledTasksApiStopTask
     */
    readonly taskId: string
}

/**
 * Request parameters for updateTask operation in ScheduledTasksApi.
 * @export
 * @interface ScheduledTasksApiUpdateTaskRequest
 */
export interface ScheduledTasksApiUpdateTaskRequest {
    /**
     * 
     * @type {string}
     * @memberof ScheduledTasksApiUpdateTask
     */
    readonly taskId: string

    /**
     * 
     * @type {Array<TaskTriggerInfo>}
     * @memberof ScheduledTasksApiUpdateTask
     */
    readonly taskTriggerInfo: Array<TaskTriggerInfo>
}

/**
 * ScheduledTasksApi - object-oriented interface
 * @export
 * @class ScheduledTasksApi
 * @extends {BaseAPI}
 */
export class ScheduledTasksApi extends BaseAPI {
    /**
     * 
     * @param {ScheduledTasksApiGetTaskRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduledTasksApi
     */
    public getTask(requestParameters: ScheduledTasksApiGetTaskRequest, options?: any) {
        return ScheduledTasksApiFp(this.configuration).getTask(requestParameters.taskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ScheduledTasksApiGetTasksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduledTasksApi
     */
    public getTasks(requestParameters: ScheduledTasksApiGetTasksRequest = {}, options?: any) {
        return ScheduledTasksApiFp(this.configuration).getTasks(requestParameters.isHidden, requestParameters.isEnabled, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ScheduledTasksApiStartTaskRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduledTasksApi
     */
    public startTask(requestParameters: ScheduledTasksApiStartTaskRequest, options?: any) {
        return ScheduledTasksApiFp(this.configuration).startTask(requestParameters.taskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ScheduledTasksApiStopTaskRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduledTasksApi
     */
    public stopTask(requestParameters: ScheduledTasksApiStopTaskRequest, options?: any) {
        return ScheduledTasksApiFp(this.configuration).stopTask(requestParameters.taskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ScheduledTasksApiUpdateTaskRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduledTasksApi
     */
    public updateTask(requestParameters: ScheduledTasksApiUpdateTaskRequest, options?: any) {
        return ScheduledTasksApiFp(this.configuration).updateTask(requestParameters.taskId, requestParameters.taskTriggerInfo, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SearchApi - axios parameter creator
 * @export
 */
export const SearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} searchTerm 
         * @param {number} [startIndex] 
         * @param {number} [limit] 
         * @param {string} [userId] 
         * @param {string} [includeItemTypes] 
         * @param {string} [excludeItemTypes] 
         * @param {string} [mediaTypes] 
         * @param {string} [parentId] 
         * @param {boolean} [isMovie] 
         * @param {boolean} [isSeries] 
         * @param {boolean} [isNews] 
         * @param {boolean} [isKids] 
         * @param {boolean} [isSports] 
         * @param {boolean} [includePeople] 
         * @param {boolean} [includeMedia] 
         * @param {boolean} [includeGenres] 
         * @param {boolean} [includeStudios] 
         * @param {boolean} [includeArtists] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: async (searchTerm: string, startIndex?: number, limit?: number, userId?: string, includeItemTypes?: string, excludeItemTypes?: string, mediaTypes?: string, parentId?: string, isMovie?: boolean, isSeries?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, includePeople?: boolean, includeMedia?: boolean, includeGenres?: boolean, includeStudios?: boolean, includeArtists?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchTerm' is not null or undefined
            if (searchTerm === null || searchTerm === undefined) {
                throw new RequiredError('searchTerm','Required parameter searchTerm was null or undefined when calling get.');
            }
            const localVarPath = `/Search/Hints`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (searchTerm !== undefined) {
                localVarQueryParameter['searchTerm'] = searchTerm;
            }

            if (includeItemTypes !== undefined) {
                localVarQueryParameter['includeItemTypes'] = includeItemTypes;
            }

            if (excludeItemTypes !== undefined) {
                localVarQueryParameter['excludeItemTypes'] = excludeItemTypes;
            }

            if (mediaTypes !== undefined) {
                localVarQueryParameter['mediaTypes'] = mediaTypes;
            }

            if (parentId !== undefined) {
                localVarQueryParameter['parentId'] = parentId;
            }

            if (isMovie !== undefined) {
                localVarQueryParameter['isMovie'] = isMovie;
            }

            if (isSeries !== undefined) {
                localVarQueryParameter['isSeries'] = isSeries;
            }

            if (isNews !== undefined) {
                localVarQueryParameter['isNews'] = isNews;
            }

            if (isKids !== undefined) {
                localVarQueryParameter['isKids'] = isKids;
            }

            if (isSports !== undefined) {
                localVarQueryParameter['isSports'] = isSports;
            }

            if (includePeople !== undefined) {
                localVarQueryParameter['includePeople'] = includePeople;
            }

            if (includeMedia !== undefined) {
                localVarQueryParameter['includeMedia'] = includeMedia;
            }

            if (includeGenres !== undefined) {
                localVarQueryParameter['includeGenres'] = includeGenres;
            }

            if (includeStudios !== undefined) {
                localVarQueryParameter['includeStudios'] = includeStudios;
            }

            if (includeArtists !== undefined) {
                localVarQueryParameter['includeArtists'] = includeArtists;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SearchApi - functional programming interface
 * @export
 */
export const SearchApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} searchTerm 
         * @param {number} [startIndex] 
         * @param {number} [limit] 
         * @param {string} [userId] 
         * @param {string} [includeItemTypes] 
         * @param {string} [excludeItemTypes] 
         * @param {string} [mediaTypes] 
         * @param {string} [parentId] 
         * @param {boolean} [isMovie] 
         * @param {boolean} [isSeries] 
         * @param {boolean} [isNews] 
         * @param {boolean} [isKids] 
         * @param {boolean} [isSports] 
         * @param {boolean} [includePeople] 
         * @param {boolean} [includeMedia] 
         * @param {boolean} [includeGenres] 
         * @param {boolean} [includeStudios] 
         * @param {boolean} [includeArtists] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get(searchTerm: string, startIndex?: number, limit?: number, userId?: string, includeItemTypes?: string, excludeItemTypes?: string, mediaTypes?: string, parentId?: string, isMovie?: boolean, isSeries?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, includePeople?: boolean, includeMedia?: boolean, includeGenres?: boolean, includeStudios?: boolean, includeArtists?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchHintResult>> {
            const localVarAxiosArgs = await SearchApiAxiosParamCreator(configuration).get(searchTerm, startIndex, limit, userId, includeItemTypes, excludeItemTypes, mediaTypes, parentId, isMovie, isSeries, isNews, isKids, isSports, includePeople, includeMedia, includeGenres, includeStudios, includeArtists, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SearchApi - factory interface
 * @export
 */
export const SearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} searchTerm 
         * @param {number} [startIndex] 
         * @param {number} [limit] 
         * @param {string} [userId] 
         * @param {string} [includeItemTypes] 
         * @param {string} [excludeItemTypes] 
         * @param {string} [mediaTypes] 
         * @param {string} [parentId] 
         * @param {boolean} [isMovie] 
         * @param {boolean} [isSeries] 
         * @param {boolean} [isNews] 
         * @param {boolean} [isKids] 
         * @param {boolean} [isSports] 
         * @param {boolean} [includePeople] 
         * @param {boolean} [includeMedia] 
         * @param {boolean} [includeGenres] 
         * @param {boolean} [includeStudios] 
         * @param {boolean} [includeArtists] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(searchTerm: string, startIndex?: number, limit?: number, userId?: string, includeItemTypes?: string, excludeItemTypes?: string, mediaTypes?: string, parentId?: string, isMovie?: boolean, isSeries?: boolean, isNews?: boolean, isKids?: boolean, isSports?: boolean, includePeople?: boolean, includeMedia?: boolean, includeGenres?: boolean, includeStudios?: boolean, includeArtists?: boolean, options?: any): AxiosPromise<SearchHintResult> {
            return SearchApiFp(configuration).get(searchTerm, startIndex, limit, userId, includeItemTypes, excludeItemTypes, mediaTypes, parentId, isMovie, isSeries, isNews, isKids, isSports, includePeople, includeMedia, includeGenres, includeStudios, includeArtists, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for get operation in SearchApi.
 * @export
 * @interface SearchApiGetRequest
 */
export interface SearchApiGetRequest {
    /**
     * 
     * @type {string}
     * @memberof SearchApiGet
     */
    readonly searchTerm: string

    /**
     * 
     * @type {number}
     * @memberof SearchApiGet
     */
    readonly startIndex?: number

    /**
     * 
     * @type {number}
     * @memberof SearchApiGet
     */
    readonly limit?: number

    /**
     * 
     * @type {string}
     * @memberof SearchApiGet
     */
    readonly userId?: string

    /**
     * 
     * @type {string}
     * @memberof SearchApiGet
     */
    readonly includeItemTypes?: string

    /**
     * 
     * @type {string}
     * @memberof SearchApiGet
     */
    readonly excludeItemTypes?: string

    /**
     * 
     * @type {string}
     * @memberof SearchApiGet
     */
    readonly mediaTypes?: string

    /**
     * 
     * @type {string}
     * @memberof SearchApiGet
     */
    readonly parentId?: string

    /**
     * 
     * @type {boolean}
     * @memberof SearchApiGet
     */
    readonly isMovie?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof SearchApiGet
     */
    readonly isSeries?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof SearchApiGet
     */
    readonly isNews?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof SearchApiGet
     */
    readonly isKids?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof SearchApiGet
     */
    readonly isSports?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof SearchApiGet
     */
    readonly includePeople?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof SearchApiGet
     */
    readonly includeMedia?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof SearchApiGet
     */
    readonly includeGenres?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof SearchApiGet
     */
    readonly includeStudios?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof SearchApiGet
     */
    readonly includeArtists?: boolean
}

/**
 * SearchApi - object-oriented interface
 * @export
 * @class SearchApi
 * @extends {BaseAPI}
 */
export class SearchApi extends BaseAPI {
    /**
     * 
     * @param {SearchApiGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public get(requestParameters: SearchApiGetRequest, options?: any) {
        return SearchApiFp(this.configuration).get(requestParameters.searchTerm, requestParameters.startIndex, requestParameters.limit, requestParameters.userId, requestParameters.includeItemTypes, requestParameters.excludeItemTypes, requestParameters.mediaTypes, requestParameters.parentId, requestParameters.isMovie, requestParameters.isSeries, requestParameters.isNews, requestParameters.isKids, requestParameters.isSports, requestParameters.includePeople, requestParameters.includeMedia, requestParameters.includeGenres, requestParameters.includeStudios, requestParameters.includeArtists, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SessionApi - axios parameter creator
 * @export
 */
export const SessionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} sessionId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserToSession: async (sessionId: string, userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            if (sessionId === null || sessionId === undefined) {
                throw new RequiredError('sessionId','Required parameter sessionId was null or undefined when calling addUserToSession.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling addUserToSession.');
            }
            const localVarPath = `/Sessions/{sessionId}/User/{userId}`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sessionId 
         * @param {string} itemType 
         * @param {string} itemId 
         * @param {string} itemName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayContent: async (sessionId: string, itemType: string, itemId: string, itemName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            if (sessionId === null || sessionId === undefined) {
                throw new RequiredError('sessionId','Required parameter sessionId was null or undefined when calling displayContent.');
            }
            // verify required parameter 'itemType' is not null or undefined
            if (itemType === null || itemType === undefined) {
                throw new RequiredError('itemType','Required parameter itemType was null or undefined when calling displayContent.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling displayContent.');
            }
            // verify required parameter 'itemName' is not null or undefined
            if (itemName === null || itemName === undefined) {
                throw new RequiredError('itemName','Required parameter itemName was null or undefined when calling displayContent.');
            }
            const localVarPath = `/Sessions/{sessionId}/Viewing`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (itemType !== undefined) {
                localVarQueryParameter['itemType'] = itemType;
            }

            if (itemId !== undefined) {
                localVarQueryParameter['itemId'] = itemId;
            }

            if (itemName !== undefined) {
                localVarQueryParameter['itemName'] = itemName;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthProviders: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Auth/Providers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordResetProviders: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Auth/PasswordResetProviders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [controllableByUserId] 
         * @param {string} [deviceId] 
         * @param {number} [activeWithinSeconds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessions: async (controllableByUserId?: string, deviceId?: string, activeWithinSeconds?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (controllableByUserId !== undefined) {
                localVarQueryParameter['controllableByUserId'] = controllableByUserId;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (activeWithinSeconds !== undefined) {
                localVarQueryParameter['activeWithinSeconds'] = activeWithinSeconds;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sessionId 
         * @param {Array<string>} [itemIds] 
         * @param {number} [startPositionTicks] 
         * @param {PlayCommand} [playCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        play: async (sessionId: string, itemIds?: Array<string>, startPositionTicks?: number, playCommand?: PlayCommand, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            if (sessionId === null || sessionId === undefined) {
                throw new RequiredError('sessionId','Required parameter sessionId was null or undefined when calling play.');
            }
            const localVarPath = `/Sessions/{sessionId}/Playing`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (itemIds) {
                localVarQueryParameter['itemIds'] = itemIds;
            }

            if (startPositionTicks !== undefined) {
                localVarQueryParameter['startPositionTicks'] = startPositionTicks;
            }

            if (playCommand !== undefined) {
                localVarQueryParameter['playCommand'] = playCommand;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [playableMediaTypes] 
         * @param {string} [supportedCommands] 
         * @param {boolean} [supportsMediaControl] 
         * @param {boolean} [supportsSync] 
         * @param {boolean} [supportsPersistentIdentifier] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCapabilities: async (id: string, playableMediaTypes?: string, supportedCommands?: string, supportsMediaControl?: boolean, supportsSync?: boolean, supportsPersistentIdentifier?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling postCapabilities.');
            }
            const localVarPath = `/Sessions/Capabilities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (playableMediaTypes !== undefined) {
                localVarQueryParameter['playableMediaTypes'] = playableMediaTypes;
            }

            if (supportedCommands !== undefined) {
                localVarQueryParameter['supportedCommands'] = supportedCommands;
            }

            if (supportsMediaControl !== undefined) {
                localVarQueryParameter['supportsMediaControl'] = supportsMediaControl;
            }

            if (supportsSync !== undefined) {
                localVarQueryParameter['supportsSync'] = supportsSync;
            }

            if (supportsPersistentIdentifier !== undefined) {
                localVarQueryParameter['supportsPersistentIdentifier'] = supportsPersistentIdentifier;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ClientCapabilities} clientCapabilities 
         * @param {string} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFullCapabilities: async (clientCapabilities: ClientCapabilities, id?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientCapabilities' is not null or undefined
            if (clientCapabilities === null || clientCapabilities === undefined) {
                throw new RequiredError('clientCapabilities','Required parameter clientCapabilities was null or undefined when calling postFullCapabilities.');
            }
            const localVarPath = `/Sessions/Capabilities/Full`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof clientCapabilities !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(clientCapabilities !== undefined ? clientCapabilities : {}) : (clientCapabilities || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sessionId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserFromSession: async (sessionId: string, userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            if (sessionId === null || sessionId === undefined) {
                throw new RequiredError('sessionId','Required parameter sessionId was null or undefined when calling removeUserFromSession.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling removeUserFromSession.');
            }
            const localVarPath = `/Sessions/{sessionId}/User/{userId}`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportSessionEnded: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Sessions/Logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [sessionId] 
         * @param {string} [itemId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportViewing: async (sessionId?: string, itemId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Sessions/Viewing`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (sessionId !== undefined) {
                localVarQueryParameter['sessionId'] = sessionId;
            }

            if (itemId !== undefined) {
                localVarQueryParameter['itemId'] = itemId;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sessionId 
         * @param {GeneralCommand} generalCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendFullGeneralCommand: async (sessionId: string, generalCommand: GeneralCommand, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            if (sessionId === null || sessionId === undefined) {
                throw new RequiredError('sessionId','Required parameter sessionId was null or undefined when calling sendFullGeneralCommand.');
            }
            // verify required parameter 'generalCommand' is not null or undefined
            if (generalCommand === null || generalCommand === undefined) {
                throw new RequiredError('generalCommand','Required parameter generalCommand was null or undefined when calling sendFullGeneralCommand.');
            }
            const localVarPath = `/Sessions/{sessionId}/Command`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof generalCommand !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(generalCommand !== undefined ? generalCommand : {}) : (generalCommand || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sessionId 
         * @param {string} command 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendGeneralCommand: async (sessionId: string, command: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            if (sessionId === null || sessionId === undefined) {
                throw new RequiredError('sessionId','Required parameter sessionId was null or undefined when calling sendGeneralCommand.');
            }
            // verify required parameter 'command' is not null or undefined
            if (command === null || command === undefined) {
                throw new RequiredError('command','Required parameter command was null or undefined when calling sendGeneralCommand.');
            }
            const localVarPath = `/Sessions/{sessionId}/Command/{command}`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
                .replace(`{${"command"}}`, encodeURIComponent(String(command)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sessionId 
         * @param {string} text 
         * @param {string} header 
         * @param {number} [timeoutMs] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendMessageCommand: async (sessionId: string, text: string, header: string, timeoutMs?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            if (sessionId === null || sessionId === undefined) {
                throw new RequiredError('sessionId','Required parameter sessionId was null or undefined when calling sendMessageCommand.');
            }
            // verify required parameter 'text' is not null or undefined
            if (text === null || text === undefined) {
                throw new RequiredError('text','Required parameter text was null or undefined when calling sendMessageCommand.');
            }
            // verify required parameter 'header' is not null or undefined
            if (header === null || header === undefined) {
                throw new RequiredError('header','Required parameter header was null or undefined when calling sendMessageCommand.');
            }
            const localVarPath = `/Sessions/{sessionId}/Message`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (text !== undefined) {
                localVarQueryParameter['text'] = text;
            }

            if (header !== undefined) {
                localVarQueryParameter['header'] = header;
            }

            if (timeoutMs !== undefined) {
                localVarQueryParameter['timeoutMs'] = timeoutMs;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sessionId 
         * @param {string} command 
         * @param {PlaystateRequest} [playstateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendPlaystateCommand: async (sessionId: string, command: string, playstateRequest?: PlaystateRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            if (sessionId === null || sessionId === undefined) {
                throw new RequiredError('sessionId','Required parameter sessionId was null or undefined when calling sendPlaystateCommand.');
            }
            // verify required parameter 'command' is not null or undefined
            if (command === null || command === undefined) {
                throw new RequiredError('command','Required parameter command was null or undefined when calling sendPlaystateCommand.');
            }
            const localVarPath = `/Sessions/{sessionId}/Playing/{command}`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
                .replace(`{${"command"}}`, encodeURIComponent(String(command)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof playstateRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(playstateRequest !== undefined ? playstateRequest : {}) : (playstateRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sessionId 
         * @param {string} command 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendSystemCommand: async (sessionId: string, command: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            if (sessionId === null || sessionId === undefined) {
                throw new RequiredError('sessionId','Required parameter sessionId was null or undefined when calling sendSystemCommand.');
            }
            // verify required parameter 'command' is not null or undefined
            if (command === null || command === undefined) {
                throw new RequiredError('command','Required parameter command was null or undefined when calling sendSystemCommand.');
            }
            const localVarPath = `/Sessions/{sessionId}/System/{command}`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)))
                .replace(`{${"command"}}`, encodeURIComponent(String(command)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SessionApi - functional programming interface
 * @export
 */
export const SessionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} sessionId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addUserToSession(sessionId: string, userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SessionApiAxiosParamCreator(configuration).addUserToSession(sessionId, userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} sessionId 
         * @param {string} itemType 
         * @param {string} itemId 
         * @param {string} itemName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async displayContent(sessionId: string, itemType: string, itemId: string, itemName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SessionApiAxiosParamCreator(configuration).displayContent(sessionId, itemType, itemId, itemName, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthProviders(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NameIdPair>>> {
            const localVarAxiosArgs = await SessionApiAxiosParamCreator(configuration).getAuthProviders(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPasswordResetProviders(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NameIdPair>>> {
            const localVarAxiosArgs = await SessionApiAxiosParamCreator(configuration).getPasswordResetProviders(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [controllableByUserId] 
         * @param {string} [deviceId] 
         * @param {number} [activeWithinSeconds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSessions(controllableByUserId?: string, deviceId?: string, activeWithinSeconds?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SessionInfo>>> {
            const localVarAxiosArgs = await SessionApiAxiosParamCreator(configuration).getSessions(controllableByUserId, deviceId, activeWithinSeconds, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} sessionId 
         * @param {Array<string>} [itemIds] 
         * @param {number} [startPositionTicks] 
         * @param {PlayCommand} [playCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async play(sessionId: string, itemIds?: Array<string>, startPositionTicks?: number, playCommand?: PlayCommand, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SessionApiAxiosParamCreator(configuration).play(sessionId, itemIds, startPositionTicks, playCommand, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [playableMediaTypes] 
         * @param {string} [supportedCommands] 
         * @param {boolean} [supportsMediaControl] 
         * @param {boolean} [supportsSync] 
         * @param {boolean} [supportsPersistentIdentifier] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCapabilities(id: string, playableMediaTypes?: string, supportedCommands?: string, supportsMediaControl?: boolean, supportsSync?: boolean, supportsPersistentIdentifier?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SessionApiAxiosParamCreator(configuration).postCapabilities(id, playableMediaTypes, supportedCommands, supportsMediaControl, supportsSync, supportsPersistentIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {ClientCapabilities} clientCapabilities 
         * @param {string} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postFullCapabilities(clientCapabilities: ClientCapabilities, id?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SessionApiAxiosParamCreator(configuration).postFullCapabilities(clientCapabilities, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} sessionId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeUserFromSession(sessionId: string, userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SessionApiAxiosParamCreator(configuration).removeUserFromSession(sessionId, userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportSessionEnded(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SessionApiAxiosParamCreator(configuration).reportSessionEnded(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [sessionId] 
         * @param {string} [itemId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportViewing(sessionId?: string, itemId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SessionApiAxiosParamCreator(configuration).reportViewing(sessionId, itemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} sessionId 
         * @param {GeneralCommand} generalCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendFullGeneralCommand(sessionId: string, generalCommand: GeneralCommand, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SessionApiAxiosParamCreator(configuration).sendFullGeneralCommand(sessionId, generalCommand, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} sessionId 
         * @param {string} command 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendGeneralCommand(sessionId: string, command: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SessionApiAxiosParamCreator(configuration).sendGeneralCommand(sessionId, command, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} sessionId 
         * @param {string} text 
         * @param {string} header 
         * @param {number} [timeoutMs] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendMessageCommand(sessionId: string, text: string, header: string, timeoutMs?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SessionApiAxiosParamCreator(configuration).sendMessageCommand(sessionId, text, header, timeoutMs, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} sessionId 
         * @param {string} command 
         * @param {PlaystateRequest} [playstateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendPlaystateCommand(sessionId: string, command: string, playstateRequest?: PlaystateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SessionApiAxiosParamCreator(configuration).sendPlaystateCommand(sessionId, command, playstateRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} sessionId 
         * @param {string} command 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendSystemCommand(sessionId: string, command: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SessionApiAxiosParamCreator(configuration).sendSystemCommand(sessionId, command, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SessionApi - factory interface
 * @export
 */
export const SessionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} sessionId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserToSession(sessionId: string, userId: string, options?: any): AxiosPromise<void> {
            return SessionApiFp(configuration).addUserToSession(sessionId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} sessionId 
         * @param {string} itemType 
         * @param {string} itemId 
         * @param {string} itemName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayContent(sessionId: string, itemType: string, itemId: string, itemName: string, options?: any): AxiosPromise<void> {
            return SessionApiFp(configuration).displayContent(sessionId, itemType, itemId, itemName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthProviders(options?: any): AxiosPromise<Array<NameIdPair>> {
            return SessionApiFp(configuration).getAuthProviders(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPasswordResetProviders(options?: any): AxiosPromise<Array<NameIdPair>> {
            return SessionApiFp(configuration).getPasswordResetProviders(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [controllableByUserId] 
         * @param {string} [deviceId] 
         * @param {number} [activeWithinSeconds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessions(controllableByUserId?: string, deviceId?: string, activeWithinSeconds?: number, options?: any): AxiosPromise<Array<SessionInfo>> {
            return SessionApiFp(configuration).getSessions(controllableByUserId, deviceId, activeWithinSeconds, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} sessionId 
         * @param {Array<string>} [itemIds] 
         * @param {number} [startPositionTicks] 
         * @param {PlayCommand} [playCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        play(sessionId: string, itemIds?: Array<string>, startPositionTicks?: number, playCommand?: PlayCommand, options?: any): AxiosPromise<void> {
            return SessionApiFp(configuration).play(sessionId, itemIds, startPositionTicks, playCommand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [playableMediaTypes] 
         * @param {string} [supportedCommands] 
         * @param {boolean} [supportsMediaControl] 
         * @param {boolean} [supportsSync] 
         * @param {boolean} [supportsPersistentIdentifier] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCapabilities(id: string, playableMediaTypes?: string, supportedCommands?: string, supportsMediaControl?: boolean, supportsSync?: boolean, supportsPersistentIdentifier?: boolean, options?: any): AxiosPromise<void> {
            return SessionApiFp(configuration).postCapabilities(id, playableMediaTypes, supportedCommands, supportsMediaControl, supportsSync, supportsPersistentIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ClientCapabilities} clientCapabilities 
         * @param {string} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFullCapabilities(clientCapabilities: ClientCapabilities, id?: string, options?: any): AxiosPromise<void> {
            return SessionApiFp(configuration).postFullCapabilities(clientCapabilities, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} sessionId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserFromSession(sessionId: string, userId: string, options?: any): AxiosPromise<void> {
            return SessionApiFp(configuration).removeUserFromSession(sessionId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportSessionEnded(options?: any): AxiosPromise<void> {
            return SessionApiFp(configuration).reportSessionEnded(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [sessionId] 
         * @param {string} [itemId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportViewing(sessionId?: string, itemId?: string, options?: any): AxiosPromise<void> {
            return SessionApiFp(configuration).reportViewing(sessionId, itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} sessionId 
         * @param {GeneralCommand} generalCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendFullGeneralCommand(sessionId: string, generalCommand: GeneralCommand, options?: any): AxiosPromise<void> {
            return SessionApiFp(configuration).sendFullGeneralCommand(sessionId, generalCommand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} sessionId 
         * @param {string} command 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendGeneralCommand(sessionId: string, command: string, options?: any): AxiosPromise<void> {
            return SessionApiFp(configuration).sendGeneralCommand(sessionId, command, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} sessionId 
         * @param {string} text 
         * @param {string} header 
         * @param {number} [timeoutMs] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendMessageCommand(sessionId: string, text: string, header: string, timeoutMs?: number, options?: any): AxiosPromise<void> {
            return SessionApiFp(configuration).sendMessageCommand(sessionId, text, header, timeoutMs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} sessionId 
         * @param {string} command 
         * @param {PlaystateRequest} [playstateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendPlaystateCommand(sessionId: string, command: string, playstateRequest?: PlaystateRequest, options?: any): AxiosPromise<void> {
            return SessionApiFp(configuration).sendPlaystateCommand(sessionId, command, playstateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} sessionId 
         * @param {string} command 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendSystemCommand(sessionId: string, command: string, options?: any): AxiosPromise<void> {
            return SessionApiFp(configuration).sendSystemCommand(sessionId, command, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addUserToSession operation in SessionApi.
 * @export
 * @interface SessionApiAddUserToSessionRequest
 */
export interface SessionApiAddUserToSessionRequest {
    /**
     * 
     * @type {string}
     * @memberof SessionApiAddUserToSession
     */
    readonly sessionId: string

    /**
     * 
     * @type {string}
     * @memberof SessionApiAddUserToSession
     */
    readonly userId: string
}

/**
 * Request parameters for displayContent operation in SessionApi.
 * @export
 * @interface SessionApiDisplayContentRequest
 */
export interface SessionApiDisplayContentRequest {
    /**
     * 
     * @type {string}
     * @memberof SessionApiDisplayContent
     */
    readonly sessionId: string

    /**
     * 
     * @type {string}
     * @memberof SessionApiDisplayContent
     */
    readonly itemType: string

    /**
     * 
     * @type {string}
     * @memberof SessionApiDisplayContent
     */
    readonly itemId: string

    /**
     * 
     * @type {string}
     * @memberof SessionApiDisplayContent
     */
    readonly itemName: string
}

/**
 * Request parameters for getSessions operation in SessionApi.
 * @export
 * @interface SessionApiGetSessionsRequest
 */
export interface SessionApiGetSessionsRequest {
    /**
     * 
     * @type {string}
     * @memberof SessionApiGetSessions
     */
    readonly controllableByUserId?: string

    /**
     * 
     * @type {string}
     * @memberof SessionApiGetSessions
     */
    readonly deviceId?: string

    /**
     * 
     * @type {number}
     * @memberof SessionApiGetSessions
     */
    readonly activeWithinSeconds?: number
}

/**
 * Request parameters for play operation in SessionApi.
 * @export
 * @interface SessionApiPlayRequest
 */
export interface SessionApiPlayRequest {
    /**
     * 
     * @type {string}
     * @memberof SessionApiPlay
     */
    readonly sessionId: string

    /**
     * 
     * @type {Array<string>}
     * @memberof SessionApiPlay
     */
    readonly itemIds?: Array<string>

    /**
     * 
     * @type {number}
     * @memberof SessionApiPlay
     */
    readonly startPositionTicks?: number

    /**
     * 
     * @type {PlayCommand}
     * @memberof SessionApiPlay
     */
    readonly playCommand?: PlayCommand
}

/**
 * Request parameters for postCapabilities operation in SessionApi.
 * @export
 * @interface SessionApiPostCapabilitiesRequest
 */
export interface SessionApiPostCapabilitiesRequest {
    /**
     * 
     * @type {string}
     * @memberof SessionApiPostCapabilities
     */
    readonly id: string

    /**
     * 
     * @type {string}
     * @memberof SessionApiPostCapabilities
     */
    readonly playableMediaTypes?: string

    /**
     * 
     * @type {string}
     * @memberof SessionApiPostCapabilities
     */
    readonly supportedCommands?: string

    /**
     * 
     * @type {boolean}
     * @memberof SessionApiPostCapabilities
     */
    readonly supportsMediaControl?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof SessionApiPostCapabilities
     */
    readonly supportsSync?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof SessionApiPostCapabilities
     */
    readonly supportsPersistentIdentifier?: boolean
}

/**
 * Request parameters for postFullCapabilities operation in SessionApi.
 * @export
 * @interface SessionApiPostFullCapabilitiesRequest
 */
export interface SessionApiPostFullCapabilitiesRequest {
    /**
     * 
     * @type {ClientCapabilities}
     * @memberof SessionApiPostFullCapabilities
     */
    readonly clientCapabilities: ClientCapabilities

    /**
     * 
     * @type {string}
     * @memberof SessionApiPostFullCapabilities
     */
    readonly id?: string
}

/**
 * Request parameters for removeUserFromSession operation in SessionApi.
 * @export
 * @interface SessionApiRemoveUserFromSessionRequest
 */
export interface SessionApiRemoveUserFromSessionRequest {
    /**
     * 
     * @type {string}
     * @memberof SessionApiRemoveUserFromSession
     */
    readonly sessionId: string

    /**
     * 
     * @type {string}
     * @memberof SessionApiRemoveUserFromSession
     */
    readonly userId: string
}

/**
 * Request parameters for reportViewing operation in SessionApi.
 * @export
 * @interface SessionApiReportViewingRequest
 */
export interface SessionApiReportViewingRequest {
    /**
     * 
     * @type {string}
     * @memberof SessionApiReportViewing
     */
    readonly sessionId?: string

    /**
     * 
     * @type {string}
     * @memberof SessionApiReportViewing
     */
    readonly itemId?: string
}

/**
 * Request parameters for sendFullGeneralCommand operation in SessionApi.
 * @export
 * @interface SessionApiSendFullGeneralCommandRequest
 */
export interface SessionApiSendFullGeneralCommandRequest {
    /**
     * 
     * @type {string}
     * @memberof SessionApiSendFullGeneralCommand
     */
    readonly sessionId: string

    /**
     * 
     * @type {GeneralCommand}
     * @memberof SessionApiSendFullGeneralCommand
     */
    readonly generalCommand: GeneralCommand
}

/**
 * Request parameters for sendGeneralCommand operation in SessionApi.
 * @export
 * @interface SessionApiSendGeneralCommandRequest
 */
export interface SessionApiSendGeneralCommandRequest {
    /**
     * 
     * @type {string}
     * @memberof SessionApiSendGeneralCommand
     */
    readonly sessionId: string

    /**
     * 
     * @type {string}
     * @memberof SessionApiSendGeneralCommand
     */
    readonly command: string
}

/**
 * Request parameters for sendMessageCommand operation in SessionApi.
 * @export
 * @interface SessionApiSendMessageCommandRequest
 */
export interface SessionApiSendMessageCommandRequest {
    /**
     * 
     * @type {string}
     * @memberof SessionApiSendMessageCommand
     */
    readonly sessionId: string

    /**
     * 
     * @type {string}
     * @memberof SessionApiSendMessageCommand
     */
    readonly text: string

    /**
     * 
     * @type {string}
     * @memberof SessionApiSendMessageCommand
     */
    readonly header: string

    /**
     * 
     * @type {number}
     * @memberof SessionApiSendMessageCommand
     */
    readonly timeoutMs?: number
}

/**
 * Request parameters for sendPlaystateCommand operation in SessionApi.
 * @export
 * @interface SessionApiSendPlaystateCommandRequest
 */
export interface SessionApiSendPlaystateCommandRequest {
    /**
     * 
     * @type {string}
     * @memberof SessionApiSendPlaystateCommand
     */
    readonly sessionId: string

    /**
     * 
     * @type {string}
     * @memberof SessionApiSendPlaystateCommand
     */
    readonly command: string

    /**
     * 
     * @type {PlaystateRequest}
     * @memberof SessionApiSendPlaystateCommand
     */
    readonly playstateRequest?: PlaystateRequest
}

/**
 * Request parameters for sendSystemCommand operation in SessionApi.
 * @export
 * @interface SessionApiSendSystemCommandRequest
 */
export interface SessionApiSendSystemCommandRequest {
    /**
     * 
     * @type {string}
     * @memberof SessionApiSendSystemCommand
     */
    readonly sessionId: string

    /**
     * 
     * @type {string}
     * @memberof SessionApiSendSystemCommand
     */
    readonly command: string
}

/**
 * SessionApi - object-oriented interface
 * @export
 * @class SessionApi
 * @extends {BaseAPI}
 */
export class SessionApi extends BaseAPI {
    /**
     * 
     * @param {SessionApiAddUserToSessionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public addUserToSession(requestParameters: SessionApiAddUserToSessionRequest, options?: any) {
        return SessionApiFp(this.configuration).addUserToSession(requestParameters.sessionId, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SessionApiDisplayContentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public displayContent(requestParameters: SessionApiDisplayContentRequest, options?: any) {
        return SessionApiFp(this.configuration).displayContent(requestParameters.sessionId, requestParameters.itemType, requestParameters.itemId, requestParameters.itemName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public getAuthProviders(options?: any) {
        return SessionApiFp(this.configuration).getAuthProviders(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public getPasswordResetProviders(options?: any) {
        return SessionApiFp(this.configuration).getPasswordResetProviders(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SessionApiGetSessionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public getSessions(requestParameters: SessionApiGetSessionsRequest = {}, options?: any) {
        return SessionApiFp(this.configuration).getSessions(requestParameters.controllableByUserId, requestParameters.deviceId, requestParameters.activeWithinSeconds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SessionApiPlayRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public play(requestParameters: SessionApiPlayRequest, options?: any) {
        return SessionApiFp(this.configuration).play(requestParameters.sessionId, requestParameters.itemIds, requestParameters.startPositionTicks, requestParameters.playCommand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SessionApiPostCapabilitiesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public postCapabilities(requestParameters: SessionApiPostCapabilitiesRequest, options?: any) {
        return SessionApiFp(this.configuration).postCapabilities(requestParameters.id, requestParameters.playableMediaTypes, requestParameters.supportedCommands, requestParameters.supportsMediaControl, requestParameters.supportsSync, requestParameters.supportsPersistentIdentifier, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SessionApiPostFullCapabilitiesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public postFullCapabilities(requestParameters: SessionApiPostFullCapabilitiesRequest, options?: any) {
        return SessionApiFp(this.configuration).postFullCapabilities(requestParameters.clientCapabilities, requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SessionApiRemoveUserFromSessionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public removeUserFromSession(requestParameters: SessionApiRemoveUserFromSessionRequest, options?: any) {
        return SessionApiFp(this.configuration).removeUserFromSession(requestParameters.sessionId, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public reportSessionEnded(options?: any) {
        return SessionApiFp(this.configuration).reportSessionEnded(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SessionApiReportViewingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public reportViewing(requestParameters: SessionApiReportViewingRequest = {}, options?: any) {
        return SessionApiFp(this.configuration).reportViewing(requestParameters.sessionId, requestParameters.itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SessionApiSendFullGeneralCommandRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sendFullGeneralCommand(requestParameters: SessionApiSendFullGeneralCommandRequest, options?: any) {
        return SessionApiFp(this.configuration).sendFullGeneralCommand(requestParameters.sessionId, requestParameters.generalCommand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SessionApiSendGeneralCommandRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sendGeneralCommand(requestParameters: SessionApiSendGeneralCommandRequest, options?: any) {
        return SessionApiFp(this.configuration).sendGeneralCommand(requestParameters.sessionId, requestParameters.command, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SessionApiSendMessageCommandRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sendMessageCommand(requestParameters: SessionApiSendMessageCommandRequest, options?: any) {
        return SessionApiFp(this.configuration).sendMessageCommand(requestParameters.sessionId, requestParameters.text, requestParameters.header, requestParameters.timeoutMs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SessionApiSendPlaystateCommandRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sendPlaystateCommand(requestParameters: SessionApiSendPlaystateCommandRequest, options?: any) {
        return SessionApiFp(this.configuration).sendPlaystateCommand(requestParameters.sessionId, requestParameters.command, requestParameters.playstateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SessionApiSendSystemCommandRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    public sendSystemCommand(requestParameters: SessionApiSendSystemCommandRequest, options?: any) {
        return SessionApiFp(this.configuration).sendSystemCommand(requestParameters.sessionId, requestParameters.command, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StartupApi - axios parameter creator
 * @export
 */
export const StartupApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeWizard: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Startup/Complete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirstUser: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Startup/User`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirstUser2: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Startup/FirstUser`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStartupConfiguration: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Startup/Configuration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {StartupRemoteAccessDto} startupRemoteAccessDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRemoteAccess: async (startupRemoteAccessDto: StartupRemoteAccessDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'startupRemoteAccessDto' is not null or undefined
            if (startupRemoteAccessDto === null || startupRemoteAccessDto === undefined) {
                throw new RequiredError('startupRemoteAccessDto','Required parameter startupRemoteAccessDto was null or undefined when calling setRemoteAccess.');
            }
            const localVarPath = `/Startup/RemoteAccess`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof startupRemoteAccessDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(startupRemoteAccessDto !== undefined ? startupRemoteAccessDto : {}) : (startupRemoteAccessDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {StartupConfigurationDto} startupConfigurationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInitialConfiguration: async (startupConfigurationDto: StartupConfigurationDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'startupConfigurationDto' is not null or undefined
            if (startupConfigurationDto === null || startupConfigurationDto === undefined) {
                throw new RequiredError('startupConfigurationDto','Required parameter startupConfigurationDto was null or undefined when calling updateInitialConfiguration.');
            }
            const localVarPath = `/Startup/Configuration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof startupConfigurationDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(startupConfigurationDto !== undefined ? startupConfigurationDto : {}) : (startupConfigurationDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {StartupUserDto} [startupUserDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStartupUser: async (startupUserDto?: StartupUserDto, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Startup/User`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof startupUserDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(startupUserDto !== undefined ? startupUserDto : {}) : (startupUserDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StartupApi - functional programming interface
 * @export
 */
export const StartupApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async completeWizard(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await StartupApiAxiosParamCreator(configuration).completeWizard(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFirstUser(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StartupUserDto>> {
            const localVarAxiosArgs = await StartupApiAxiosParamCreator(configuration).getFirstUser(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFirstUser2(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StartupUserDto>> {
            const localVarAxiosArgs = await StartupApiAxiosParamCreator(configuration).getFirstUser2(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStartupConfiguration(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StartupConfigurationDto>> {
            const localVarAxiosArgs = await StartupApiAxiosParamCreator(configuration).getStartupConfiguration(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {StartupRemoteAccessDto} startupRemoteAccessDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setRemoteAccess(startupRemoteAccessDto: StartupRemoteAccessDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await StartupApiAxiosParamCreator(configuration).setRemoteAccess(startupRemoteAccessDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {StartupConfigurationDto} startupConfigurationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateInitialConfiguration(startupConfigurationDto: StartupConfigurationDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await StartupApiAxiosParamCreator(configuration).updateInitialConfiguration(startupConfigurationDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {StartupUserDto} [startupUserDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateStartupUser(startupUserDto?: StartupUserDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await StartupApiAxiosParamCreator(configuration).updateStartupUser(startupUserDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * StartupApi - factory interface
 * @export
 */
export const StartupApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeWizard(options?: any): AxiosPromise<void> {
            return StartupApiFp(configuration).completeWizard(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirstUser(options?: any): AxiosPromise<StartupUserDto> {
            return StartupApiFp(configuration).getFirstUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFirstUser2(options?: any): AxiosPromise<StartupUserDto> {
            return StartupApiFp(configuration).getFirstUser2(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStartupConfiguration(options?: any): AxiosPromise<StartupConfigurationDto> {
            return StartupApiFp(configuration).getStartupConfiguration(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {StartupRemoteAccessDto} startupRemoteAccessDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRemoteAccess(startupRemoteAccessDto: StartupRemoteAccessDto, options?: any): AxiosPromise<void> {
            return StartupApiFp(configuration).setRemoteAccess(startupRemoteAccessDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {StartupConfigurationDto} startupConfigurationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInitialConfiguration(startupConfigurationDto: StartupConfigurationDto, options?: any): AxiosPromise<void> {
            return StartupApiFp(configuration).updateInitialConfiguration(startupConfigurationDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {StartupUserDto} [startupUserDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStartupUser(startupUserDto?: StartupUserDto, options?: any): AxiosPromise<void> {
            return StartupApiFp(configuration).updateStartupUser(startupUserDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for setRemoteAccess operation in StartupApi.
 * @export
 * @interface StartupApiSetRemoteAccessRequest
 */
export interface StartupApiSetRemoteAccessRequest {
    /**
     * 
     * @type {StartupRemoteAccessDto}
     * @memberof StartupApiSetRemoteAccess
     */
    readonly startupRemoteAccessDto: StartupRemoteAccessDto
}

/**
 * Request parameters for updateInitialConfiguration operation in StartupApi.
 * @export
 * @interface StartupApiUpdateInitialConfigurationRequest
 */
export interface StartupApiUpdateInitialConfigurationRequest {
    /**
     * 
     * @type {StartupConfigurationDto}
     * @memberof StartupApiUpdateInitialConfiguration
     */
    readonly startupConfigurationDto: StartupConfigurationDto
}

/**
 * Request parameters for updateStartupUser operation in StartupApi.
 * @export
 * @interface StartupApiUpdateStartupUserRequest
 */
export interface StartupApiUpdateStartupUserRequest {
    /**
     * 
     * @type {StartupUserDto}
     * @memberof StartupApiUpdateStartupUser
     */
    readonly startupUserDto?: StartupUserDto
}

/**
 * StartupApi - object-oriented interface
 * @export
 * @class StartupApi
 * @extends {BaseAPI}
 */
export class StartupApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StartupApi
     */
    public completeWizard(options?: any) {
        return StartupApiFp(this.configuration).completeWizard(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StartupApi
     */
    public getFirstUser(options?: any) {
        return StartupApiFp(this.configuration).getFirstUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StartupApi
     */
    public getFirstUser2(options?: any) {
        return StartupApiFp(this.configuration).getFirstUser2(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StartupApi
     */
    public getStartupConfiguration(options?: any) {
        return StartupApiFp(this.configuration).getStartupConfiguration(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {StartupApiSetRemoteAccessRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StartupApi
     */
    public setRemoteAccess(requestParameters: StartupApiSetRemoteAccessRequest, options?: any) {
        return StartupApiFp(this.configuration).setRemoteAccess(requestParameters.startupRemoteAccessDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {StartupApiUpdateInitialConfigurationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StartupApi
     */
    public updateInitialConfiguration(requestParameters: StartupApiUpdateInitialConfigurationRequest, options?: any) {
        return StartupApiFp(this.configuration).updateInitialConfiguration(requestParameters.startupConfigurationDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {StartupApiUpdateStartupUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StartupApi
     */
    public updateStartupUser(requestParameters: StartupApiUpdateStartupUserRequest = {}, options?: any) {
        return StartupApiFp(this.configuration).updateStartupUser(requestParameters.startupUserDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StudiosApi - axios parameter creator
 * @export
 */
export const StudiosApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} name 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudio: async (name: string, userId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getStudio.');
            }
            const localVarPath = `/Studios/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [minCommunityRating] 
         * @param {number} [startIndex] 
         * @param {number} [limit] 
         * @param {string} [searchTerm] 
         * @param {string} [parentId] 
         * @param {string} [fields] 
         * @param {string} [excludeItemTypes] 
         * @param {string} [includeItemTypes] 
         * @param {string} [filters] 
         * @param {boolean} [isFavorite] 
         * @param {string} [mediaTypes] 
         * @param {string} [genres] 
         * @param {string} [genreIds] 
         * @param {string} [officialRatings] 
         * @param {string} [tags] 
         * @param {string} [years] 
         * @param {boolean} [enableUserData] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {string} [person] 
         * @param {string} [personIds] 
         * @param {string} [personTypes] 
         * @param {string} [studios] 
         * @param {string} [studioIds] 
         * @param {string} [userId] 
         * @param {string} [nameStartsWithOrGreater] 
         * @param {string} [nameStartsWith] 
         * @param {string} [nameLessThan] 
         * @param {boolean} [enableImages] 
         * @param {boolean} [enableTotalRecordCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudios: async (minCommunityRating?: number, startIndex?: number, limit?: number, searchTerm?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, filters?: string, isFavorite?: boolean, mediaTypes?: string, genres?: string, genreIds?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, studioIds?: string, userId?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, enableImages?: boolean, enableTotalRecordCount?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Studios`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (minCommunityRating !== undefined) {
                localVarQueryParameter['minCommunityRating'] = minCommunityRating;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (searchTerm !== undefined) {
                localVarQueryParameter['searchTerm'] = searchTerm;
            }

            if (parentId !== undefined) {
                localVarQueryParameter['parentId'] = parentId;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeItemTypes !== undefined) {
                localVarQueryParameter['excludeItemTypes'] = excludeItemTypes;
            }

            if (includeItemTypes !== undefined) {
                localVarQueryParameter['includeItemTypes'] = includeItemTypes;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (isFavorite !== undefined) {
                localVarQueryParameter['isFavorite'] = isFavorite;
            }

            if (mediaTypes !== undefined) {
                localVarQueryParameter['mediaTypes'] = mediaTypes;
            }

            if (genres !== undefined) {
                localVarQueryParameter['genres'] = genres;
            }

            if (genreIds !== undefined) {
                localVarQueryParameter['genreIds'] = genreIds;
            }

            if (officialRatings !== undefined) {
                localVarQueryParameter['officialRatings'] = officialRatings;
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }

            if (years !== undefined) {
                localVarQueryParameter['years'] = years;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes !== undefined) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }

            if (person !== undefined) {
                localVarQueryParameter['person'] = person;
            }

            if (personIds !== undefined) {
                localVarQueryParameter['personIds'] = personIds;
            }

            if (personTypes !== undefined) {
                localVarQueryParameter['personTypes'] = personTypes;
            }

            if (studios !== undefined) {
                localVarQueryParameter['studios'] = studios;
            }

            if (studioIds !== undefined) {
                localVarQueryParameter['studioIds'] = studioIds;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (nameStartsWithOrGreater !== undefined) {
                localVarQueryParameter['nameStartsWithOrGreater'] = nameStartsWithOrGreater;
            }

            if (nameStartsWith !== undefined) {
                localVarQueryParameter['nameStartsWith'] = nameStartsWith;
            }

            if (nameLessThan !== undefined) {
                localVarQueryParameter['nameLessThan'] = nameLessThan;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }

            if (enableTotalRecordCount !== undefined) {
                localVarQueryParameter['enableTotalRecordCount'] = enableTotalRecordCount;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StudiosApi - functional programming interface
 * @export
 */
export const StudiosApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} name 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStudio(name: string, userId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDto>> {
            const localVarAxiosArgs = await StudiosApiAxiosParamCreator(configuration).getStudio(name, userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} [minCommunityRating] 
         * @param {number} [startIndex] 
         * @param {number} [limit] 
         * @param {string} [searchTerm] 
         * @param {string} [parentId] 
         * @param {string} [fields] 
         * @param {string} [excludeItemTypes] 
         * @param {string} [includeItemTypes] 
         * @param {string} [filters] 
         * @param {boolean} [isFavorite] 
         * @param {string} [mediaTypes] 
         * @param {string} [genres] 
         * @param {string} [genreIds] 
         * @param {string} [officialRatings] 
         * @param {string} [tags] 
         * @param {string} [years] 
         * @param {boolean} [enableUserData] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {string} [person] 
         * @param {string} [personIds] 
         * @param {string} [personTypes] 
         * @param {string} [studios] 
         * @param {string} [studioIds] 
         * @param {string} [userId] 
         * @param {string} [nameStartsWithOrGreater] 
         * @param {string} [nameStartsWith] 
         * @param {string} [nameLessThan] 
         * @param {boolean} [enableImages] 
         * @param {boolean} [enableTotalRecordCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStudios(minCommunityRating?: number, startIndex?: number, limit?: number, searchTerm?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, filters?: string, isFavorite?: boolean, mediaTypes?: string, genres?: string, genreIds?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, studioIds?: string, userId?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, enableImages?: boolean, enableTotalRecordCount?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await StudiosApiAxiosParamCreator(configuration).getStudios(minCommunityRating, startIndex, limit, searchTerm, parentId, fields, excludeItemTypes, includeItemTypes, filters, isFavorite, mediaTypes, genres, genreIds, officialRatings, tags, years, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, studioIds, userId, nameStartsWithOrGreater, nameStartsWith, nameLessThan, enableImages, enableTotalRecordCount, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * StudiosApi - factory interface
 * @export
 */
export const StudiosApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} name 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudio(name: string, userId?: string, options?: any): AxiosPromise<BaseItemDto> {
            return StudiosApiFp(configuration).getStudio(name, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [minCommunityRating] 
         * @param {number} [startIndex] 
         * @param {number} [limit] 
         * @param {string} [searchTerm] 
         * @param {string} [parentId] 
         * @param {string} [fields] 
         * @param {string} [excludeItemTypes] 
         * @param {string} [includeItemTypes] 
         * @param {string} [filters] 
         * @param {boolean} [isFavorite] 
         * @param {string} [mediaTypes] 
         * @param {string} [genres] 
         * @param {string} [genreIds] 
         * @param {string} [officialRatings] 
         * @param {string} [tags] 
         * @param {string} [years] 
         * @param {boolean} [enableUserData] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {string} [person] 
         * @param {string} [personIds] 
         * @param {string} [personTypes] 
         * @param {string} [studios] 
         * @param {string} [studioIds] 
         * @param {string} [userId] 
         * @param {string} [nameStartsWithOrGreater] 
         * @param {string} [nameStartsWith] 
         * @param {string} [nameLessThan] 
         * @param {boolean} [enableImages] 
         * @param {boolean} [enableTotalRecordCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudios(minCommunityRating?: number, startIndex?: number, limit?: number, searchTerm?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, filters?: string, isFavorite?: boolean, mediaTypes?: string, genres?: string, genreIds?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, studioIds?: string, userId?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, enableImages?: boolean, enableTotalRecordCount?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return StudiosApiFp(configuration).getStudios(minCommunityRating, startIndex, limit, searchTerm, parentId, fields, excludeItemTypes, includeItemTypes, filters, isFavorite, mediaTypes, genres, genreIds, officialRatings, tags, years, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, studioIds, userId, nameStartsWithOrGreater, nameStartsWith, nameLessThan, enableImages, enableTotalRecordCount, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getStudio operation in StudiosApi.
 * @export
 * @interface StudiosApiGetStudioRequest
 */
export interface StudiosApiGetStudioRequest {
    /**
     * 
     * @type {string}
     * @memberof StudiosApiGetStudio
     */
    readonly name: string

    /**
     * 
     * @type {string}
     * @memberof StudiosApiGetStudio
     */
    readonly userId?: string
}

/**
 * Request parameters for getStudios operation in StudiosApi.
 * @export
 * @interface StudiosApiGetStudiosRequest
 */
export interface StudiosApiGetStudiosRequest {
    /**
     * 
     * @type {number}
     * @memberof StudiosApiGetStudios
     */
    readonly minCommunityRating?: number

    /**
     * 
     * @type {number}
     * @memberof StudiosApiGetStudios
     */
    readonly startIndex?: number

    /**
     * 
     * @type {number}
     * @memberof StudiosApiGetStudios
     */
    readonly limit?: number

    /**
     * 
     * @type {string}
     * @memberof StudiosApiGetStudios
     */
    readonly searchTerm?: string

    /**
     * 
     * @type {string}
     * @memberof StudiosApiGetStudios
     */
    readonly parentId?: string

    /**
     * 
     * @type {string}
     * @memberof StudiosApiGetStudios
     */
    readonly fields?: string

    /**
     * 
     * @type {string}
     * @memberof StudiosApiGetStudios
     */
    readonly excludeItemTypes?: string

    /**
     * 
     * @type {string}
     * @memberof StudiosApiGetStudios
     */
    readonly includeItemTypes?: string

    /**
     * 
     * @type {string}
     * @memberof StudiosApiGetStudios
     */
    readonly filters?: string

    /**
     * 
     * @type {boolean}
     * @memberof StudiosApiGetStudios
     */
    readonly isFavorite?: boolean

    /**
     * 
     * @type {string}
     * @memberof StudiosApiGetStudios
     */
    readonly mediaTypes?: string

    /**
     * 
     * @type {string}
     * @memberof StudiosApiGetStudios
     */
    readonly genres?: string

    /**
     * 
     * @type {string}
     * @memberof StudiosApiGetStudios
     */
    readonly genreIds?: string

    /**
     * 
     * @type {string}
     * @memberof StudiosApiGetStudios
     */
    readonly officialRatings?: string

    /**
     * 
     * @type {string}
     * @memberof StudiosApiGetStudios
     */
    readonly tags?: string

    /**
     * 
     * @type {string}
     * @memberof StudiosApiGetStudios
     */
    readonly years?: string

    /**
     * 
     * @type {boolean}
     * @memberof StudiosApiGetStudios
     */
    readonly enableUserData?: boolean

    /**
     * 
     * @type {number}
     * @memberof StudiosApiGetStudios
     */
    readonly imageTypeLimit?: number

    /**
     * 
     * @type {string}
     * @memberof StudiosApiGetStudios
     */
    readonly enableImageTypes?: string

    /**
     * 
     * @type {string}
     * @memberof StudiosApiGetStudios
     */
    readonly person?: string

    /**
     * 
     * @type {string}
     * @memberof StudiosApiGetStudios
     */
    readonly personIds?: string

    /**
     * 
     * @type {string}
     * @memberof StudiosApiGetStudios
     */
    readonly personTypes?: string

    /**
     * 
     * @type {string}
     * @memberof StudiosApiGetStudios
     */
    readonly studios?: string

    /**
     * 
     * @type {string}
     * @memberof StudiosApiGetStudios
     */
    readonly studioIds?: string

    /**
     * 
     * @type {string}
     * @memberof StudiosApiGetStudios
     */
    readonly userId?: string

    /**
     * 
     * @type {string}
     * @memberof StudiosApiGetStudios
     */
    readonly nameStartsWithOrGreater?: string

    /**
     * 
     * @type {string}
     * @memberof StudiosApiGetStudios
     */
    readonly nameStartsWith?: string

    /**
     * 
     * @type {string}
     * @memberof StudiosApiGetStudios
     */
    readonly nameLessThan?: string

    /**
     * 
     * @type {boolean}
     * @memberof StudiosApiGetStudios
     */
    readonly enableImages?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof StudiosApiGetStudios
     */
    readonly enableTotalRecordCount?: boolean
}

/**
 * StudiosApi - object-oriented interface
 * @export
 * @class StudiosApi
 * @extends {BaseAPI}
 */
export class StudiosApi extends BaseAPI {
    /**
     * 
     * @param {StudiosApiGetStudioRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiosApi
     */
    public getStudio(requestParameters: StudiosApiGetStudioRequest, options?: any) {
        return StudiosApiFp(this.configuration).getStudio(requestParameters.name, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {StudiosApiGetStudiosRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiosApi
     */
    public getStudios(requestParameters: StudiosApiGetStudiosRequest = {}, options?: any) {
        return StudiosApiFp(this.configuration).getStudios(requestParameters.minCommunityRating, requestParameters.startIndex, requestParameters.limit, requestParameters.searchTerm, requestParameters.parentId, requestParameters.fields, requestParameters.excludeItemTypes, requestParameters.includeItemTypes, requestParameters.filters, requestParameters.isFavorite, requestParameters.mediaTypes, requestParameters.genres, requestParameters.genreIds, requestParameters.officialRatings, requestParameters.tags, requestParameters.years, requestParameters.enableUserData, requestParameters.imageTypeLimit, requestParameters.enableImageTypes, requestParameters.person, requestParameters.personIds, requestParameters.personTypes, requestParameters.studios, requestParameters.studioIds, requestParameters.userId, requestParameters.nameStartsWithOrGreater, requestParameters.nameStartsWith, requestParameters.nameLessThan, requestParameters.enableImages, requestParameters.enableTotalRecordCount, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SubtitleApi - axios parameter creator
 * @export
 */
export const SubtitleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} itemId 
         * @param {number} index 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubtitle: async (itemId: string, index: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling deleteSubtitle.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling deleteSubtitle.');
            }
            const localVarPath = `/Videos/{itemId}/Subtitles/{index}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} subtitleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadRemoteSubtitles: async (itemId: string, subtitleId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling downloadRemoteSubtitles.');
            }
            // verify required parameter 'subtitleId' is not null or undefined
            if (subtitleId === null || subtitleId === undefined) {
                throw new RequiredError('subtitleId','Required parameter subtitleId was null or undefined when calling downloadRemoteSubtitles.');
            }
            const localVarPath = `/Items/{itemId}/RemoteSearch/Subtitles/{subtitleId}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"subtitleId"}}`, encodeURIComponent(String(subtitleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRemoteSubtitles: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getRemoteSubtitles.');
            }
            const localVarPath = `/Providers/Subtitles/Subtitles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} mediaSourceId 
         * @param {number} index 
         * @param {string} format 
         * @param {number} startPositionTicks 
         * @param {number} [endPositionTicks] 
         * @param {boolean} [copyTimestamps] 
         * @param {boolean} [addVttTimeMap] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubtitle: async (itemId: string, mediaSourceId: string, index: number, format: string, startPositionTicks: number, endPositionTicks?: number, copyTimestamps?: boolean, addVttTimeMap?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getSubtitle.');
            }
            // verify required parameter 'mediaSourceId' is not null or undefined
            if (mediaSourceId === null || mediaSourceId === undefined) {
                throw new RequiredError('mediaSourceId','Required parameter mediaSourceId was null or undefined when calling getSubtitle.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling getSubtitle.');
            }
            // verify required parameter 'format' is not null or undefined
            if (format === null || format === undefined) {
                throw new RequiredError('format','Required parameter format was null or undefined when calling getSubtitle.');
            }
            // verify required parameter 'startPositionTicks' is not null or undefined
            if (startPositionTicks === null || startPositionTicks === undefined) {
                throw new RequiredError('startPositionTicks','Required parameter startPositionTicks was null or undefined when calling getSubtitle.');
            }
            const localVarPath = `/Videos/{itemId}/{mediaSourceId}/Subtitles/{index}/Stream.{format}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"mediaSourceId"}}`, encodeURIComponent(String(mediaSourceId)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"format"}}`, encodeURIComponent(String(format)))
                .replace(`{${"startPositionTicks"}}`, encodeURIComponent(String(startPositionTicks)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (endPositionTicks !== undefined) {
                localVarQueryParameter['endPositionTicks'] = endPositionTicks;
            }

            if (copyTimestamps !== undefined) {
                localVarQueryParameter['copyTimestamps'] = copyTimestamps;
            }

            if (addVttTimeMap !== undefined) {
                localVarQueryParameter['addVttTimeMap'] = addVttTimeMap;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} mediaSourceId 
         * @param {number} index 
         * @param {string} format 
         * @param {number} startPositionTicks 
         * @param {number} [endPositionTicks] 
         * @param {boolean} [copyTimestamps] 
         * @param {boolean} [addVttTimeMap] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubtitle2: async (itemId: string, mediaSourceId: string, index: number, format: string, startPositionTicks: number, endPositionTicks?: number, copyTimestamps?: boolean, addVttTimeMap?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getSubtitle2.');
            }
            // verify required parameter 'mediaSourceId' is not null or undefined
            if (mediaSourceId === null || mediaSourceId === undefined) {
                throw new RequiredError('mediaSourceId','Required parameter mediaSourceId was null or undefined when calling getSubtitle2.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling getSubtitle2.');
            }
            // verify required parameter 'format' is not null or undefined
            if (format === null || format === undefined) {
                throw new RequiredError('format','Required parameter format was null or undefined when calling getSubtitle2.');
            }
            // verify required parameter 'startPositionTicks' is not null or undefined
            if (startPositionTicks === null || startPositionTicks === undefined) {
                throw new RequiredError('startPositionTicks','Required parameter startPositionTicks was null or undefined when calling getSubtitle2.');
            }
            const localVarPath = `/Videos/{itemId}/{mediaSourceId}/Subtitles/{index}/{startPositionTicks}/Stream.{format}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"mediaSourceId"}}`, encodeURIComponent(String(mediaSourceId)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"format"}}`, encodeURIComponent(String(format)))
                .replace(`{${"startPositionTicks"}}`, encodeURIComponent(String(startPositionTicks)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (endPositionTicks !== undefined) {
                localVarQueryParameter['endPositionTicks'] = endPositionTicks;
            }

            if (copyTimestamps !== undefined) {
                localVarQueryParameter['copyTimestamps'] = copyTimestamps;
            }

            if (addVttTimeMap !== undefined) {
                localVarQueryParameter['addVttTimeMap'] = addVttTimeMap;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {number} index 
         * @param {string} mediaSourceId 
         * @param {number} segmentLength 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubtitlePlaylist: async (itemId: string, index: number, mediaSourceId: string, segmentLength: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getSubtitlePlaylist.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling getSubtitlePlaylist.');
            }
            // verify required parameter 'mediaSourceId' is not null or undefined
            if (mediaSourceId === null || mediaSourceId === undefined) {
                throw new RequiredError('mediaSourceId','Required parameter mediaSourceId was null or undefined when calling getSubtitlePlaylist.');
            }
            // verify required parameter 'segmentLength' is not null or undefined
            if (segmentLength === null || segmentLength === undefined) {
                throw new RequiredError('segmentLength','Required parameter segmentLength was null or undefined when calling getSubtitlePlaylist.');
            }
            const localVarPath = `/Videos/{itemId}/{mediaSourceId}/Subtitles/{index}/subtitles.m3u8`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"mediaSourceId"}}`, encodeURIComponent(String(mediaSourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (segmentLength !== undefined) {
                localVarQueryParameter['segmentLength'] = segmentLength;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} language 
         * @param {boolean} [isPerfectMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchRemoteSubtitles: async (itemId: string, language: string, isPerfectMatch?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling searchRemoteSubtitles.');
            }
            // verify required parameter 'language' is not null or undefined
            if (language === null || language === undefined) {
                throw new RequiredError('language','Required parameter language was null or undefined when calling searchRemoteSubtitles.');
            }
            const localVarPath = `/Items/{itemId}/RemoteSearch/Subtitles/{language}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"language"}}`, encodeURIComponent(String(language)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (isPerfectMatch !== undefined) {
                localVarQueryParameter['isPerfectMatch'] = isPerfectMatch;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubtitleApi - functional programming interface
 * @export
 */
export const SubtitleApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} itemId 
         * @param {number} index 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSubtitle(itemId: string, index: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SubtitleApiAxiosParamCreator(configuration).deleteSubtitle(itemId, index, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} subtitleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadRemoteSubtitles(itemId: string, subtitleId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SubtitleApiAxiosParamCreator(configuration).downloadRemoteSubtitles(itemId, subtitleId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRemoteSubtitles(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SubtitleApiAxiosParamCreator(configuration).getRemoteSubtitles(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} mediaSourceId 
         * @param {number} index 
         * @param {string} format 
         * @param {number} startPositionTicks 
         * @param {number} [endPositionTicks] 
         * @param {boolean} [copyTimestamps] 
         * @param {boolean} [addVttTimeMap] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubtitle(itemId: string, mediaSourceId: string, index: number, format: string, startPositionTicks: number, endPositionTicks?: number, copyTimestamps?: boolean, addVttTimeMap?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SubtitleApiAxiosParamCreator(configuration).getSubtitle(itemId, mediaSourceId, index, format, startPositionTicks, endPositionTicks, copyTimestamps, addVttTimeMap, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} mediaSourceId 
         * @param {number} index 
         * @param {string} format 
         * @param {number} startPositionTicks 
         * @param {number} [endPositionTicks] 
         * @param {boolean} [copyTimestamps] 
         * @param {boolean} [addVttTimeMap] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubtitle2(itemId: string, mediaSourceId: string, index: number, format: string, startPositionTicks: number, endPositionTicks?: number, copyTimestamps?: boolean, addVttTimeMap?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SubtitleApiAxiosParamCreator(configuration).getSubtitle2(itemId, mediaSourceId, index, format, startPositionTicks, endPositionTicks, copyTimestamps, addVttTimeMap, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {number} index 
         * @param {string} mediaSourceId 
         * @param {number} segmentLength 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubtitlePlaylist(itemId: string, index: number, mediaSourceId: string, segmentLength: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SubtitleApiAxiosParamCreator(configuration).getSubtitlePlaylist(itemId, index, mediaSourceId, segmentLength, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} language 
         * @param {boolean} [isPerfectMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchRemoteSubtitles(itemId: string, language: string, isPerfectMatch?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RemoteSubtitleInfo>>> {
            const localVarAxiosArgs = await SubtitleApiAxiosParamCreator(configuration).searchRemoteSubtitles(itemId, language, isPerfectMatch, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SubtitleApi - factory interface
 * @export
 */
export const SubtitleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} itemId 
         * @param {number} index 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubtitle(itemId: string, index: number, options?: any): AxiosPromise<void> {
            return SubtitleApiFp(configuration).deleteSubtitle(itemId, index, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} subtitleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadRemoteSubtitles(itemId: string, subtitleId: string, options?: any): AxiosPromise<void> {
            return SubtitleApiFp(configuration).downloadRemoteSubtitles(itemId, subtitleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRemoteSubtitles(id: string, options?: any): AxiosPromise<void> {
            return SubtitleApiFp(configuration).getRemoteSubtitles(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} mediaSourceId 
         * @param {number} index 
         * @param {string} format 
         * @param {number} startPositionTicks 
         * @param {number} [endPositionTicks] 
         * @param {boolean} [copyTimestamps] 
         * @param {boolean} [addVttTimeMap] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubtitle(itemId: string, mediaSourceId: string, index: number, format: string, startPositionTicks: number, endPositionTicks?: number, copyTimestamps?: boolean, addVttTimeMap?: boolean, options?: any): AxiosPromise<void> {
            return SubtitleApiFp(configuration).getSubtitle(itemId, mediaSourceId, index, format, startPositionTicks, endPositionTicks, copyTimestamps, addVttTimeMap, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} mediaSourceId 
         * @param {number} index 
         * @param {string} format 
         * @param {number} startPositionTicks 
         * @param {number} [endPositionTicks] 
         * @param {boolean} [copyTimestamps] 
         * @param {boolean} [addVttTimeMap] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubtitle2(itemId: string, mediaSourceId: string, index: number, format: string, startPositionTicks: number, endPositionTicks?: number, copyTimestamps?: boolean, addVttTimeMap?: boolean, options?: any): AxiosPromise<void> {
            return SubtitleApiFp(configuration).getSubtitle2(itemId, mediaSourceId, index, format, startPositionTicks, endPositionTicks, copyTimestamps, addVttTimeMap, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} itemId 
         * @param {number} index 
         * @param {string} mediaSourceId 
         * @param {number} segmentLength 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubtitlePlaylist(itemId: string, index: number, mediaSourceId: string, segmentLength: number, options?: any): AxiosPromise<void> {
            return SubtitleApiFp(configuration).getSubtitlePlaylist(itemId, index, mediaSourceId, segmentLength, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} language 
         * @param {boolean} [isPerfectMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchRemoteSubtitles(itemId: string, language: string, isPerfectMatch?: boolean, options?: any): AxiosPromise<Array<RemoteSubtitleInfo>> {
            return SubtitleApiFp(configuration).searchRemoteSubtitles(itemId, language, isPerfectMatch, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deleteSubtitle operation in SubtitleApi.
 * @export
 * @interface SubtitleApiDeleteSubtitleRequest
 */
export interface SubtitleApiDeleteSubtitleRequest {
    /**
     * 
     * @type {string}
     * @memberof SubtitleApiDeleteSubtitle
     */
    readonly itemId: string

    /**
     * 
     * @type {number}
     * @memberof SubtitleApiDeleteSubtitle
     */
    readonly index: number
}

/**
 * Request parameters for downloadRemoteSubtitles operation in SubtitleApi.
 * @export
 * @interface SubtitleApiDownloadRemoteSubtitlesRequest
 */
export interface SubtitleApiDownloadRemoteSubtitlesRequest {
    /**
     * 
     * @type {string}
     * @memberof SubtitleApiDownloadRemoteSubtitles
     */
    readonly itemId: string

    /**
     * 
     * @type {string}
     * @memberof SubtitleApiDownloadRemoteSubtitles
     */
    readonly subtitleId: string
}

/**
 * Request parameters for getRemoteSubtitles operation in SubtitleApi.
 * @export
 * @interface SubtitleApiGetRemoteSubtitlesRequest
 */
export interface SubtitleApiGetRemoteSubtitlesRequest {
    /**
     * 
     * @type {string}
     * @memberof SubtitleApiGetRemoteSubtitles
     */
    readonly id: string
}

/**
 * Request parameters for getSubtitle operation in SubtitleApi.
 * @export
 * @interface SubtitleApiGetSubtitleRequest
 */
export interface SubtitleApiGetSubtitleRequest {
    /**
     * 
     * @type {string}
     * @memberof SubtitleApiGetSubtitle
     */
    readonly itemId: string

    /**
     * 
     * @type {string}
     * @memberof SubtitleApiGetSubtitle
     */
    readonly mediaSourceId: string

    /**
     * 
     * @type {number}
     * @memberof SubtitleApiGetSubtitle
     */
    readonly index: number

    /**
     * 
     * @type {string}
     * @memberof SubtitleApiGetSubtitle
     */
    readonly format: string

    /**
     * 
     * @type {number}
     * @memberof SubtitleApiGetSubtitle
     */
    readonly startPositionTicks: number

    /**
     * 
     * @type {number}
     * @memberof SubtitleApiGetSubtitle
     */
    readonly endPositionTicks?: number

    /**
     * 
     * @type {boolean}
     * @memberof SubtitleApiGetSubtitle
     */
    readonly copyTimestamps?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof SubtitleApiGetSubtitle
     */
    readonly addVttTimeMap?: boolean
}

/**
 * Request parameters for getSubtitle2 operation in SubtitleApi.
 * @export
 * @interface SubtitleApiGetSubtitle2Request
 */
export interface SubtitleApiGetSubtitle2Request {
    /**
     * 
     * @type {string}
     * @memberof SubtitleApiGetSubtitle2
     */
    readonly itemId: string

    /**
     * 
     * @type {string}
     * @memberof SubtitleApiGetSubtitle2
     */
    readonly mediaSourceId: string

    /**
     * 
     * @type {number}
     * @memberof SubtitleApiGetSubtitle2
     */
    readonly index: number

    /**
     * 
     * @type {string}
     * @memberof SubtitleApiGetSubtitle2
     */
    readonly format: string

    /**
     * 
     * @type {number}
     * @memberof SubtitleApiGetSubtitle2
     */
    readonly startPositionTicks: number

    /**
     * 
     * @type {number}
     * @memberof SubtitleApiGetSubtitle2
     */
    readonly endPositionTicks?: number

    /**
     * 
     * @type {boolean}
     * @memberof SubtitleApiGetSubtitle2
     */
    readonly copyTimestamps?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof SubtitleApiGetSubtitle2
     */
    readonly addVttTimeMap?: boolean
}

/**
 * Request parameters for getSubtitlePlaylist operation in SubtitleApi.
 * @export
 * @interface SubtitleApiGetSubtitlePlaylistRequest
 */
export interface SubtitleApiGetSubtitlePlaylistRequest {
    /**
     * 
     * @type {string}
     * @memberof SubtitleApiGetSubtitlePlaylist
     */
    readonly itemId: string

    /**
     * 
     * @type {number}
     * @memberof SubtitleApiGetSubtitlePlaylist
     */
    readonly index: number

    /**
     * 
     * @type {string}
     * @memberof SubtitleApiGetSubtitlePlaylist
     */
    readonly mediaSourceId: string

    /**
     * 
     * @type {number}
     * @memberof SubtitleApiGetSubtitlePlaylist
     */
    readonly segmentLength: number
}

/**
 * Request parameters for searchRemoteSubtitles operation in SubtitleApi.
 * @export
 * @interface SubtitleApiSearchRemoteSubtitlesRequest
 */
export interface SubtitleApiSearchRemoteSubtitlesRequest {
    /**
     * 
     * @type {string}
     * @memberof SubtitleApiSearchRemoteSubtitles
     */
    readonly itemId: string

    /**
     * 
     * @type {string}
     * @memberof SubtitleApiSearchRemoteSubtitles
     */
    readonly language: string

    /**
     * 
     * @type {boolean}
     * @memberof SubtitleApiSearchRemoteSubtitles
     */
    readonly isPerfectMatch?: boolean
}

/**
 * SubtitleApi - object-oriented interface
 * @export
 * @class SubtitleApi
 * @extends {BaseAPI}
 */
export class SubtitleApi extends BaseAPI {
    /**
     * 
     * @param {SubtitleApiDeleteSubtitleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubtitleApi
     */
    public deleteSubtitle(requestParameters: SubtitleApiDeleteSubtitleRequest, options?: any) {
        return SubtitleApiFp(this.configuration).deleteSubtitle(requestParameters.itemId, requestParameters.index, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SubtitleApiDownloadRemoteSubtitlesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubtitleApi
     */
    public downloadRemoteSubtitles(requestParameters: SubtitleApiDownloadRemoteSubtitlesRequest, options?: any) {
        return SubtitleApiFp(this.configuration).downloadRemoteSubtitles(requestParameters.itemId, requestParameters.subtitleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SubtitleApiGetRemoteSubtitlesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubtitleApi
     */
    public getRemoteSubtitles(requestParameters: SubtitleApiGetRemoteSubtitlesRequest, options?: any) {
        return SubtitleApiFp(this.configuration).getRemoteSubtitles(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SubtitleApiGetSubtitleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubtitleApi
     */
    public getSubtitle(requestParameters: SubtitleApiGetSubtitleRequest, options?: any) {
        return SubtitleApiFp(this.configuration).getSubtitle(requestParameters.itemId, requestParameters.mediaSourceId, requestParameters.index, requestParameters.format, requestParameters.startPositionTicks, requestParameters.endPositionTicks, requestParameters.copyTimestamps, requestParameters.addVttTimeMap, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SubtitleApiGetSubtitle2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubtitleApi
     */
    public getSubtitle2(requestParameters: SubtitleApiGetSubtitle2Request, options?: any) {
        return SubtitleApiFp(this.configuration).getSubtitle2(requestParameters.itemId, requestParameters.mediaSourceId, requestParameters.index, requestParameters.format, requestParameters.startPositionTicks, requestParameters.endPositionTicks, requestParameters.copyTimestamps, requestParameters.addVttTimeMap, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SubtitleApiGetSubtitlePlaylistRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubtitleApi
     */
    public getSubtitlePlaylist(requestParameters: SubtitleApiGetSubtitlePlaylistRequest, options?: any) {
        return SubtitleApiFp(this.configuration).getSubtitlePlaylist(requestParameters.itemId, requestParameters.index, requestParameters.mediaSourceId, requestParameters.segmentLength, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SubtitleApiSearchRemoteSubtitlesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubtitleApi
     */
    public searchRemoteSubtitles(requestParameters: SubtitleApiSearchRemoteSubtitlesRequest, options?: any) {
        return SubtitleApiFp(this.configuration).searchRemoteSubtitles(requestParameters.itemId, requestParameters.language, requestParameters.isPerfectMatch, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SuggestionsApi - axios parameter creator
 * @export
 */
export const SuggestionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} userId 
         * @param {string} [mediaType] 
         * @param {string} [type] 
         * @param {number} [startIndex] 
         * @param {number} [limit] 
         * @param {boolean} [enableTotalRecordCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSuggestions: async (userId: string, mediaType?: string, type?: string, startIndex?: number, limit?: number, enableTotalRecordCount?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getSuggestions.');
            }
            const localVarPath = `/Users/{userId}/Suggestions`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (mediaType !== undefined) {
                localVarQueryParameter['mediaType'] = mediaType;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (enableTotalRecordCount !== undefined) {
                localVarQueryParameter['enableTotalRecordCount'] = enableTotalRecordCount;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SuggestionsApi - functional programming interface
 * @export
 */
export const SuggestionsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} userId 
         * @param {string} [mediaType] 
         * @param {string} [type] 
         * @param {number} [startIndex] 
         * @param {number} [limit] 
         * @param {boolean} [enableTotalRecordCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSuggestions(userId: string, mediaType?: string, type?: string, startIndex?: number, limit?: number, enableTotalRecordCount?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await SuggestionsApiAxiosParamCreator(configuration).getSuggestions(userId, mediaType, type, startIndex, limit, enableTotalRecordCount, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SuggestionsApi - factory interface
 * @export
 */
export const SuggestionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} userId 
         * @param {string} [mediaType] 
         * @param {string} [type] 
         * @param {number} [startIndex] 
         * @param {number} [limit] 
         * @param {boolean} [enableTotalRecordCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSuggestions(userId: string, mediaType?: string, type?: string, startIndex?: number, limit?: number, enableTotalRecordCount?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return SuggestionsApiFp(configuration).getSuggestions(userId, mediaType, type, startIndex, limit, enableTotalRecordCount, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getSuggestions operation in SuggestionsApi.
 * @export
 * @interface SuggestionsApiGetSuggestionsRequest
 */
export interface SuggestionsApiGetSuggestionsRequest {
    /**
     * 
     * @type {string}
     * @memberof SuggestionsApiGetSuggestions
     */
    readonly userId: string

    /**
     * 
     * @type {string}
     * @memberof SuggestionsApiGetSuggestions
     */
    readonly mediaType?: string

    /**
     * 
     * @type {string}
     * @memberof SuggestionsApiGetSuggestions
     */
    readonly type?: string

    /**
     * 
     * @type {number}
     * @memberof SuggestionsApiGetSuggestions
     */
    readonly startIndex?: number

    /**
     * 
     * @type {number}
     * @memberof SuggestionsApiGetSuggestions
     */
    readonly limit?: number

    /**
     * 
     * @type {boolean}
     * @memberof SuggestionsApiGetSuggestions
     */
    readonly enableTotalRecordCount?: boolean
}

/**
 * SuggestionsApi - object-oriented interface
 * @export
 * @class SuggestionsApi
 * @extends {BaseAPI}
 */
export class SuggestionsApi extends BaseAPI {
    /**
     * 
     * @param {SuggestionsApiGetSuggestionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SuggestionsApi
     */
    public getSuggestions(requestParameters: SuggestionsApiGetSuggestionsRequest, options?: any) {
        return SuggestionsApiFp(this.configuration).getSuggestions(requestParameters.userId, requestParameters.mediaType, requestParameters.type, requestParameters.startIndex, requestParameters.limit, requestParameters.enableTotalRecordCount, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SyncPlayApi - axios parameter creator
 * @export
 */
export const SyncPlayApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [when] 
         * @param {number} [positionTicks] 
         * @param {boolean} [bufferingDone] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncPlayBuffering: async (when?: string, positionTicks?: number, bufferingDone?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/SyncPlay/Buffering`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (when !== undefined) {
                localVarQueryParameter['when'] = (when as any instanceof Date) ?
                    (when as any).toISOString() :
                    when;
            }

            if (positionTicks !== undefined) {
                localVarQueryParameter['positionTicks'] = positionTicks;
            }

            if (bufferingDone !== undefined) {
                localVarQueryParameter['bufferingDone'] = bufferingDone;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncPlayCreateGroup: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/SyncPlay/New`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [filterItemId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncPlayGetGroups: async (filterItemId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/SyncPlay/List`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (filterItemId !== undefined) {
                localVarQueryParameter['filterItemId'] = filterItemId;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncPlayJoinGroup: async (groupId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            if (groupId === null || groupId === undefined) {
                throw new RequiredError('groupId','Required parameter groupId was null or undefined when calling syncPlayJoinGroup.');
            }
            const localVarPath = `/SyncPlay/Join`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (groupId !== undefined) {
                localVarQueryParameter['groupId'] = groupId;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncPlayLeaveGroup: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/SyncPlay/Leave`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncPlayPause: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/SyncPlay/Pause`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [ping] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncPlayPing: async (ping?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/SyncPlay/Ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (ping !== undefined) {
                localVarQueryParameter['ping'] = ping;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncPlayPlay: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/SyncPlay/Play`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [positionTicks] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncPlaySeek: async (positionTicks?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/SyncPlay/Seek`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (positionTicks !== undefined) {
                localVarQueryParameter['positionTicks'] = positionTicks;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SyncPlayApi - functional programming interface
 * @export
 */
export const SyncPlayApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [when] 
         * @param {number} [positionTicks] 
         * @param {boolean} [bufferingDone] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async syncPlayBuffering(when?: string, positionTicks?: number, bufferingDone?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SyncPlayApiAxiosParamCreator(configuration).syncPlayBuffering(when, positionTicks, bufferingDone, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async syncPlayCreateGroup(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SyncPlayApiAxiosParamCreator(configuration).syncPlayCreateGroup(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [filterItemId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async syncPlayGetGroups(filterItemId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GroupInfoView>>> {
            const localVarAxiosArgs = await SyncPlayApiAxiosParamCreator(configuration).syncPlayGetGroups(filterItemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async syncPlayJoinGroup(groupId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SyncPlayApiAxiosParamCreator(configuration).syncPlayJoinGroup(groupId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async syncPlayLeaveGroup(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SyncPlayApiAxiosParamCreator(configuration).syncPlayLeaveGroup(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async syncPlayPause(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SyncPlayApiAxiosParamCreator(configuration).syncPlayPause(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} [ping] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async syncPlayPing(ping?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SyncPlayApiAxiosParamCreator(configuration).syncPlayPing(ping, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async syncPlayPlay(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SyncPlayApiAxiosParamCreator(configuration).syncPlayPlay(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} [positionTicks] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async syncPlaySeek(positionTicks?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SyncPlayApiAxiosParamCreator(configuration).syncPlaySeek(positionTicks, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SyncPlayApi - factory interface
 * @export
 */
export const SyncPlayApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} [when] 
         * @param {number} [positionTicks] 
         * @param {boolean} [bufferingDone] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncPlayBuffering(when?: string, positionTicks?: number, bufferingDone?: boolean, options?: any): AxiosPromise<void> {
            return SyncPlayApiFp(configuration).syncPlayBuffering(when, positionTicks, bufferingDone, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncPlayCreateGroup(options?: any): AxiosPromise<void> {
            return SyncPlayApiFp(configuration).syncPlayCreateGroup(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [filterItemId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncPlayGetGroups(filterItemId?: string, options?: any): AxiosPromise<Array<GroupInfoView>> {
            return SyncPlayApiFp(configuration).syncPlayGetGroups(filterItemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncPlayJoinGroup(groupId: string, options?: any): AxiosPromise<void> {
            return SyncPlayApiFp(configuration).syncPlayJoinGroup(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncPlayLeaveGroup(options?: any): AxiosPromise<void> {
            return SyncPlayApiFp(configuration).syncPlayLeaveGroup(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncPlayPause(options?: any): AxiosPromise<void> {
            return SyncPlayApiFp(configuration).syncPlayPause(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [ping] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncPlayPing(ping?: number, options?: any): AxiosPromise<void> {
            return SyncPlayApiFp(configuration).syncPlayPing(ping, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncPlayPlay(options?: any): AxiosPromise<void> {
            return SyncPlayApiFp(configuration).syncPlayPlay(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [positionTicks] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncPlaySeek(positionTicks?: number, options?: any): AxiosPromise<void> {
            return SyncPlayApiFp(configuration).syncPlaySeek(positionTicks, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for syncPlayBuffering operation in SyncPlayApi.
 * @export
 * @interface SyncPlayApiSyncPlayBufferingRequest
 */
export interface SyncPlayApiSyncPlayBufferingRequest {
    /**
     * 
     * @type {string}
     * @memberof SyncPlayApiSyncPlayBuffering
     */
    readonly when?: string

    /**
     * 
     * @type {number}
     * @memberof SyncPlayApiSyncPlayBuffering
     */
    readonly positionTicks?: number

    /**
     * 
     * @type {boolean}
     * @memberof SyncPlayApiSyncPlayBuffering
     */
    readonly bufferingDone?: boolean
}

/**
 * Request parameters for syncPlayGetGroups operation in SyncPlayApi.
 * @export
 * @interface SyncPlayApiSyncPlayGetGroupsRequest
 */
export interface SyncPlayApiSyncPlayGetGroupsRequest {
    /**
     * 
     * @type {string}
     * @memberof SyncPlayApiSyncPlayGetGroups
     */
    readonly filterItemId?: string
}

/**
 * Request parameters for syncPlayJoinGroup operation in SyncPlayApi.
 * @export
 * @interface SyncPlayApiSyncPlayJoinGroupRequest
 */
export interface SyncPlayApiSyncPlayJoinGroupRequest {
    /**
     * 
     * @type {string}
     * @memberof SyncPlayApiSyncPlayJoinGroup
     */
    readonly groupId: string
}

/**
 * Request parameters for syncPlayPing operation in SyncPlayApi.
 * @export
 * @interface SyncPlayApiSyncPlayPingRequest
 */
export interface SyncPlayApiSyncPlayPingRequest {
    /**
     * 
     * @type {number}
     * @memberof SyncPlayApiSyncPlayPing
     */
    readonly ping?: number
}

/**
 * Request parameters for syncPlaySeek operation in SyncPlayApi.
 * @export
 * @interface SyncPlayApiSyncPlaySeekRequest
 */
export interface SyncPlayApiSyncPlaySeekRequest {
    /**
     * 
     * @type {number}
     * @memberof SyncPlayApiSyncPlaySeek
     */
    readonly positionTicks?: number
}

/**
 * SyncPlayApi - object-oriented interface
 * @export
 * @class SyncPlayApi
 * @extends {BaseAPI}
 */
export class SyncPlayApi extends BaseAPI {
    /**
     * 
     * @param {SyncPlayApiSyncPlayBufferingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SyncPlayApi
     */
    public syncPlayBuffering(requestParameters: SyncPlayApiSyncPlayBufferingRequest = {}, options?: any) {
        return SyncPlayApiFp(this.configuration).syncPlayBuffering(requestParameters.when, requestParameters.positionTicks, requestParameters.bufferingDone, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SyncPlayApi
     */
    public syncPlayCreateGroup(options?: any) {
        return SyncPlayApiFp(this.configuration).syncPlayCreateGroup(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SyncPlayApiSyncPlayGetGroupsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SyncPlayApi
     */
    public syncPlayGetGroups(requestParameters: SyncPlayApiSyncPlayGetGroupsRequest = {}, options?: any) {
        return SyncPlayApiFp(this.configuration).syncPlayGetGroups(requestParameters.filterItemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SyncPlayApiSyncPlayJoinGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SyncPlayApi
     */
    public syncPlayJoinGroup(requestParameters: SyncPlayApiSyncPlayJoinGroupRequest, options?: any) {
        return SyncPlayApiFp(this.configuration).syncPlayJoinGroup(requestParameters.groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SyncPlayApi
     */
    public syncPlayLeaveGroup(options?: any) {
        return SyncPlayApiFp(this.configuration).syncPlayLeaveGroup(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SyncPlayApi
     */
    public syncPlayPause(options?: any) {
        return SyncPlayApiFp(this.configuration).syncPlayPause(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SyncPlayApiSyncPlayPingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SyncPlayApi
     */
    public syncPlayPing(requestParameters: SyncPlayApiSyncPlayPingRequest = {}, options?: any) {
        return SyncPlayApiFp(this.configuration).syncPlayPing(requestParameters.ping, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SyncPlayApi
     */
    public syncPlayPlay(options?: any) {
        return SyncPlayApiFp(this.configuration).syncPlayPlay(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SyncPlayApiSyncPlaySeekRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SyncPlayApi
     */
    public syncPlaySeek(requestParameters: SyncPlayApiSyncPlaySeekRequest = {}, options?: any) {
        return SyncPlayApiFp(this.configuration).syncPlaySeek(requestParameters.positionTicks, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SystemApi - axios parameter creator
 * @export
 */
export const SystemApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEndpointInfo: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/System/Endpoint`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogFile: async (name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getLogFile.');
            }
            const localVarPath = `/System/Logs/Log`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPingSystem: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/System/Ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicSystemInfo: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/System/Info/Public`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerLogs: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/System/Logs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemInfo: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/System/Info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWakeOnLanInfo: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/System/WakeOnLanInfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPingSystem: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/System/Ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartApplication: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/System/Restart`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shutdownApplication: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/System/Shutdown`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SystemApi - functional programming interface
 * @export
 */
export const SystemApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEndpointInfo(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EndPointInfo>> {
            const localVarAxiosArgs = await SystemApiAxiosParamCreator(configuration).getEndpointInfo(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLogFile(name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SystemApiAxiosParamCreator(configuration).getLogFile(name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPingSystem(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await SystemApiAxiosParamCreator(configuration).getPingSystem(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicSystemInfo(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicSystemInfo>> {
            const localVarAxiosArgs = await SystemApiAxiosParamCreator(configuration).getPublicSystemInfo(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServerLogs(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LogFile>>> {
            const localVarAxiosArgs = await SystemApiAxiosParamCreator(configuration).getServerLogs(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSystemInfo(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemInfo>> {
            const localVarAxiosArgs = await SystemApiAxiosParamCreator(configuration).getSystemInfo(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWakeOnLanInfo(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WakeOnLanInfo>>> {
            const localVarAxiosArgs = await SystemApiAxiosParamCreator(configuration).getWakeOnLanInfo(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postPingSystem(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await SystemApiAxiosParamCreator(configuration).postPingSystem(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restartApplication(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SystemApiAxiosParamCreator(configuration).restartApplication(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shutdownApplication(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SystemApiAxiosParamCreator(configuration).shutdownApplication(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SystemApi - factory interface
 * @export
 */
export const SystemApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEndpointInfo(options?: any): AxiosPromise<EndPointInfo> {
            return SystemApiFp(configuration).getEndpointInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogFile(name: string, options?: any): AxiosPromise<void> {
            return SystemApiFp(configuration).getLogFile(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPingSystem(options?: any): AxiosPromise<string> {
            return SystemApiFp(configuration).getPingSystem(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicSystemInfo(options?: any): AxiosPromise<PublicSystemInfo> {
            return SystemApiFp(configuration).getPublicSystemInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerLogs(options?: any): AxiosPromise<Array<LogFile>> {
            return SystemApiFp(configuration).getServerLogs(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemInfo(options?: any): AxiosPromise<SystemInfo> {
            return SystemApiFp(configuration).getSystemInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWakeOnLanInfo(options?: any): AxiosPromise<Array<WakeOnLanInfo>> {
            return SystemApiFp(configuration).getWakeOnLanInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPingSystem(options?: any): AxiosPromise<string> {
            return SystemApiFp(configuration).postPingSystem(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartApplication(options?: any): AxiosPromise<void> {
            return SystemApiFp(configuration).restartApplication(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shutdownApplication(options?: any): AxiosPromise<void> {
            return SystemApiFp(configuration).shutdownApplication(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getLogFile operation in SystemApi.
 * @export
 * @interface SystemApiGetLogFileRequest
 */
export interface SystemApiGetLogFileRequest {
    /**
     * 
     * @type {string}
     * @memberof SystemApiGetLogFile
     */
    readonly name: string
}

/**
 * SystemApi - object-oriented interface
 * @export
 * @class SystemApi
 * @extends {BaseAPI}
 */
export class SystemApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public getEndpointInfo(options?: any) {
        return SystemApiFp(this.configuration).getEndpointInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SystemApiGetLogFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public getLogFile(requestParameters: SystemApiGetLogFileRequest, options?: any) {
        return SystemApiFp(this.configuration).getLogFile(requestParameters.name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public getPingSystem(options?: any) {
        return SystemApiFp(this.configuration).getPingSystem(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public getPublicSystemInfo(options?: any) {
        return SystemApiFp(this.configuration).getPublicSystemInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public getServerLogs(options?: any) {
        return SystemApiFp(this.configuration).getServerLogs(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public getSystemInfo(options?: any) {
        return SystemApiFp(this.configuration).getSystemInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public getWakeOnLanInfo(options?: any) {
        return SystemApiFp(this.configuration).getWakeOnLanInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public postPingSystem(options?: any) {
        return SystemApiFp(this.configuration).postPingSystem(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public restartApplication(options?: any) {
        return SystemApiFp(this.configuration).restartApplication(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public shutdownApplication(options?: any) {
        return SystemApiFp(this.configuration).shutdownApplication(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TimeSyncApi - axios parameter creator
 * @export
 */
export const TimeSyncApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUtcTime: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/GetUtcTime`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TimeSyncApi - functional programming interface
 * @export
 */
export const TimeSyncApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUtcTime(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UtcTimeResponse>> {
            const localVarAxiosArgs = await TimeSyncApiAxiosParamCreator(configuration).getUtcTime(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TimeSyncApi - factory interface
 * @export
 */
export const TimeSyncApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUtcTime(options?: any): AxiosPromise<UtcTimeResponse> {
            return TimeSyncApiFp(configuration).getUtcTime(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TimeSyncApi - object-oriented interface
 * @export
 * @class TimeSyncApi
 * @extends {BaseAPI}
 */
export class TimeSyncApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimeSyncApi
     */
    public getUtcTime(options?: any) {
        return TimeSyncApiFp(this.configuration).getUtcTime(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TrailersApi - axios parameter creator
 * @export
 */
export const TrailersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [userId] 
         * @param {string} [maxOfficialRating] 
         * @param {boolean} [hasThemeSong] 
         * @param {boolean} [hasThemeVideo] 
         * @param {boolean} [hasSubtitles] 
         * @param {boolean} [hasSpecialFeature] 
         * @param {boolean} [hasTrailer] 
         * @param {string} [adjacentTo] 
         * @param {number} [parentIndexNumber] 
         * @param {boolean} [hasParentalRating] 
         * @param {boolean} [isHd] 
         * @param {boolean} [is4K] 
         * @param {string} [locationTypes] 
         * @param {string} [excludeLocationTypes] 
         * @param {boolean} [isMissing] 
         * @param {boolean} [isUnaired] 
         * @param {number} [minCommunityRating] 
         * @param {number} [minCriticRating] 
         * @param {string} [minPremiereDate] 
         * @param {string} [minDateLastSaved] 
         * @param {string} [minDateLastSavedForUser] 
         * @param {string} [maxPremiereDate] 
         * @param {boolean} [hasOverview] 
         * @param {boolean} [hasImdbId] 
         * @param {boolean} [hasTmdbId] 
         * @param {boolean} [hasTvdbId] 
         * @param {string} [excludeItemIds] 
         * @param {number} [startIndex] 
         * @param {number} [limit] 
         * @param {boolean} [recursive] 
         * @param {string} [searchTerm] 
         * @param {string} [sortOrder] 
         * @param {string} [parentId] 
         * @param {string} [fields] 
         * @param {string} [excludeItemTypes] 
         * @param {string} [filters] 
         * @param {boolean} [isFavorite] 
         * @param {string} [mediaTypes] 
         * @param {string} [imageTypes] 
         * @param {string} [sortBy] 
         * @param {boolean} [isPlayed] 
         * @param {string} [genres] 
         * @param {string} [officialRatings] 
         * @param {string} [tags] 
         * @param {string} [years] 
         * @param {boolean} [enableUserData] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {string} [person] 
         * @param {string} [personIds] 
         * @param {string} [personTypes] 
         * @param {string} [studios] 
         * @param {string} [artists] 
         * @param {string} [excludeArtistIds] 
         * @param {string} [artistIds] 
         * @param {string} [albumArtistIds] 
         * @param {string} [contributingArtistIds] 
         * @param {string} [albums] 
         * @param {string} [albumIds] 
         * @param {string} [ids] 
         * @param {string} [videoTypes] 
         * @param {string} [minOfficialRating] 
         * @param {boolean} [isLocked] 
         * @param {boolean} [isPlaceHolder] 
         * @param {boolean} [hasOfficialRating] 
         * @param {boolean} [collapseBoxSetItems] 
         * @param {number} [minWidth] 
         * @param {number} [minHeight] 
         * @param {number} [maxWidth] 
         * @param {number} [maxHeight] 
         * @param {boolean} [is3D] 
         * @param {string} [seriesStatus] 
         * @param {string} [nameStartsWithOrGreater] 
         * @param {string} [nameStartsWith] 
         * @param {string} [nameLessThan] 
         * @param {string} [studioIds] 
         * @param {string} [genreIds] 
         * @param {boolean} [enableTotalRecordCount] 
         * @param {boolean} [enableImages] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrailers: async (userId?: string, maxOfficialRating?: string, hasThemeSong?: boolean, hasThemeVideo?: boolean, hasSubtitles?: boolean, hasSpecialFeature?: boolean, hasTrailer?: boolean, adjacentTo?: string, parentIndexNumber?: number, hasParentalRating?: boolean, isHd?: boolean, is4K?: boolean, locationTypes?: string, excludeLocationTypes?: string, isMissing?: boolean, isUnaired?: boolean, minCommunityRating?: number, minCriticRating?: number, minPremiereDate?: string, minDateLastSaved?: string, minDateLastSavedForUser?: string, maxPremiereDate?: string, hasOverview?: boolean, hasImdbId?: boolean, hasTmdbId?: boolean, hasTvdbId?: boolean, excludeItemIds?: string, startIndex?: number, limit?: number, recursive?: boolean, searchTerm?: string, sortOrder?: string, parentId?: string, fields?: string, excludeItemTypes?: string, filters?: string, isFavorite?: boolean, mediaTypes?: string, imageTypes?: string, sortBy?: string, isPlayed?: boolean, genres?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, artists?: string, excludeArtistIds?: string, artistIds?: string, albumArtistIds?: string, contributingArtistIds?: string, albums?: string, albumIds?: string, ids?: string, videoTypes?: string, minOfficialRating?: string, isLocked?: boolean, isPlaceHolder?: boolean, hasOfficialRating?: boolean, collapseBoxSetItems?: boolean, minWidth?: number, minHeight?: number, maxWidth?: number, maxHeight?: number, is3D?: boolean, seriesStatus?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, studioIds?: string, genreIds?: string, enableTotalRecordCount?: boolean, enableImages?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Trailers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (maxOfficialRating !== undefined) {
                localVarQueryParameter['maxOfficialRating'] = maxOfficialRating;
            }

            if (hasThemeSong !== undefined) {
                localVarQueryParameter['hasThemeSong'] = hasThemeSong;
            }

            if (hasThemeVideo !== undefined) {
                localVarQueryParameter['hasThemeVideo'] = hasThemeVideo;
            }

            if (hasSubtitles !== undefined) {
                localVarQueryParameter['hasSubtitles'] = hasSubtitles;
            }

            if (hasSpecialFeature !== undefined) {
                localVarQueryParameter['hasSpecialFeature'] = hasSpecialFeature;
            }

            if (hasTrailer !== undefined) {
                localVarQueryParameter['hasTrailer'] = hasTrailer;
            }

            if (adjacentTo !== undefined) {
                localVarQueryParameter['adjacentTo'] = adjacentTo;
            }

            if (parentIndexNumber !== undefined) {
                localVarQueryParameter['parentIndexNumber'] = parentIndexNumber;
            }

            if (hasParentalRating !== undefined) {
                localVarQueryParameter['hasParentalRating'] = hasParentalRating;
            }

            if (isHd !== undefined) {
                localVarQueryParameter['isHd'] = isHd;
            }

            if (is4K !== undefined) {
                localVarQueryParameter['is4K'] = is4K;
            }

            if (locationTypes !== undefined) {
                localVarQueryParameter['locationTypes'] = locationTypes;
            }

            if (excludeLocationTypes !== undefined) {
                localVarQueryParameter['excludeLocationTypes'] = excludeLocationTypes;
            }

            if (isMissing !== undefined) {
                localVarQueryParameter['isMissing'] = isMissing;
            }

            if (isUnaired !== undefined) {
                localVarQueryParameter['isUnaired'] = isUnaired;
            }

            if (minCommunityRating !== undefined) {
                localVarQueryParameter['minCommunityRating'] = minCommunityRating;
            }

            if (minCriticRating !== undefined) {
                localVarQueryParameter['minCriticRating'] = minCriticRating;
            }

            if (minPremiereDate !== undefined) {
                localVarQueryParameter['minPremiereDate'] = (minPremiereDate as any instanceof Date) ?
                    (minPremiereDate as any).toISOString() :
                    minPremiereDate;
            }

            if (minDateLastSaved !== undefined) {
                localVarQueryParameter['minDateLastSaved'] = (minDateLastSaved as any instanceof Date) ?
                    (minDateLastSaved as any).toISOString() :
                    minDateLastSaved;
            }

            if (minDateLastSavedForUser !== undefined) {
                localVarQueryParameter['minDateLastSavedForUser'] = (minDateLastSavedForUser as any instanceof Date) ?
                    (minDateLastSavedForUser as any).toISOString() :
                    minDateLastSavedForUser;
            }

            if (maxPremiereDate !== undefined) {
                localVarQueryParameter['maxPremiereDate'] = (maxPremiereDate as any instanceof Date) ?
                    (maxPremiereDate as any).toISOString() :
                    maxPremiereDate;
            }

            if (hasOverview !== undefined) {
                localVarQueryParameter['hasOverview'] = hasOverview;
            }

            if (hasImdbId !== undefined) {
                localVarQueryParameter['hasImdbId'] = hasImdbId;
            }

            if (hasTmdbId !== undefined) {
                localVarQueryParameter['hasTmdbId'] = hasTmdbId;
            }

            if (hasTvdbId !== undefined) {
                localVarQueryParameter['hasTvdbId'] = hasTvdbId;
            }

            if (excludeItemIds !== undefined) {
                localVarQueryParameter['excludeItemIds'] = excludeItemIds;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (recursive !== undefined) {
                localVarQueryParameter['recursive'] = recursive;
            }

            if (searchTerm !== undefined) {
                localVarQueryParameter['searchTerm'] = searchTerm;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (parentId !== undefined) {
                localVarQueryParameter['parentId'] = parentId;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeItemTypes !== undefined) {
                localVarQueryParameter['excludeItemTypes'] = excludeItemTypes;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }

            if (isFavorite !== undefined) {
                localVarQueryParameter['isFavorite'] = isFavorite;
            }

            if (mediaTypes !== undefined) {
                localVarQueryParameter['mediaTypes'] = mediaTypes;
            }

            if (imageTypes !== undefined) {
                localVarQueryParameter['imageTypes'] = imageTypes;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (isPlayed !== undefined) {
                localVarQueryParameter['isPlayed'] = isPlayed;
            }

            if (genres !== undefined) {
                localVarQueryParameter['genres'] = genres;
            }

            if (officialRatings !== undefined) {
                localVarQueryParameter['officialRatings'] = officialRatings;
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }

            if (years !== undefined) {
                localVarQueryParameter['years'] = years;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes !== undefined) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }

            if (person !== undefined) {
                localVarQueryParameter['person'] = person;
            }

            if (personIds !== undefined) {
                localVarQueryParameter['personIds'] = personIds;
            }

            if (personTypes !== undefined) {
                localVarQueryParameter['personTypes'] = personTypes;
            }

            if (studios !== undefined) {
                localVarQueryParameter['studios'] = studios;
            }

            if (artists !== undefined) {
                localVarQueryParameter['artists'] = artists;
            }

            if (excludeArtistIds !== undefined) {
                localVarQueryParameter['excludeArtistIds'] = excludeArtistIds;
            }

            if (artistIds !== undefined) {
                localVarQueryParameter['artistIds'] = artistIds;
            }

            if (albumArtistIds !== undefined) {
                localVarQueryParameter['albumArtistIds'] = albumArtistIds;
            }

            if (contributingArtistIds !== undefined) {
                localVarQueryParameter['contributingArtistIds'] = contributingArtistIds;
            }

            if (albums !== undefined) {
                localVarQueryParameter['albums'] = albums;
            }

            if (albumIds !== undefined) {
                localVarQueryParameter['albumIds'] = albumIds;
            }

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }

            if (videoTypes !== undefined) {
                localVarQueryParameter['videoTypes'] = videoTypes;
            }

            if (minOfficialRating !== undefined) {
                localVarQueryParameter['minOfficialRating'] = minOfficialRating;
            }

            if (isLocked !== undefined) {
                localVarQueryParameter['isLocked'] = isLocked;
            }

            if (isPlaceHolder !== undefined) {
                localVarQueryParameter['isPlaceHolder'] = isPlaceHolder;
            }

            if (hasOfficialRating !== undefined) {
                localVarQueryParameter['hasOfficialRating'] = hasOfficialRating;
            }

            if (collapseBoxSetItems !== undefined) {
                localVarQueryParameter['collapseBoxSetItems'] = collapseBoxSetItems;
            }

            if (minWidth !== undefined) {
                localVarQueryParameter['minWidth'] = minWidth;
            }

            if (minHeight !== undefined) {
                localVarQueryParameter['minHeight'] = minHeight;
            }

            if (maxWidth !== undefined) {
                localVarQueryParameter['maxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['maxHeight'] = maxHeight;
            }

            if (is3D !== undefined) {
                localVarQueryParameter['is3D'] = is3D;
            }

            if (seriesStatus !== undefined) {
                localVarQueryParameter['seriesStatus'] = seriesStatus;
            }

            if (nameStartsWithOrGreater !== undefined) {
                localVarQueryParameter['nameStartsWithOrGreater'] = nameStartsWithOrGreater;
            }

            if (nameStartsWith !== undefined) {
                localVarQueryParameter['nameStartsWith'] = nameStartsWith;
            }

            if (nameLessThan !== undefined) {
                localVarQueryParameter['nameLessThan'] = nameLessThan;
            }

            if (studioIds !== undefined) {
                localVarQueryParameter['studioIds'] = studioIds;
            }

            if (genreIds !== undefined) {
                localVarQueryParameter['genreIds'] = genreIds;
            }

            if (enableTotalRecordCount !== undefined) {
                localVarQueryParameter['enableTotalRecordCount'] = enableTotalRecordCount;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TrailersApi - functional programming interface
 * @export
 */
export const TrailersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [userId] 
         * @param {string} [maxOfficialRating] 
         * @param {boolean} [hasThemeSong] 
         * @param {boolean} [hasThemeVideo] 
         * @param {boolean} [hasSubtitles] 
         * @param {boolean} [hasSpecialFeature] 
         * @param {boolean} [hasTrailer] 
         * @param {string} [adjacentTo] 
         * @param {number} [parentIndexNumber] 
         * @param {boolean} [hasParentalRating] 
         * @param {boolean} [isHd] 
         * @param {boolean} [is4K] 
         * @param {string} [locationTypes] 
         * @param {string} [excludeLocationTypes] 
         * @param {boolean} [isMissing] 
         * @param {boolean} [isUnaired] 
         * @param {number} [minCommunityRating] 
         * @param {number} [minCriticRating] 
         * @param {string} [minPremiereDate] 
         * @param {string} [minDateLastSaved] 
         * @param {string} [minDateLastSavedForUser] 
         * @param {string} [maxPremiereDate] 
         * @param {boolean} [hasOverview] 
         * @param {boolean} [hasImdbId] 
         * @param {boolean} [hasTmdbId] 
         * @param {boolean} [hasTvdbId] 
         * @param {string} [excludeItemIds] 
         * @param {number} [startIndex] 
         * @param {number} [limit] 
         * @param {boolean} [recursive] 
         * @param {string} [searchTerm] 
         * @param {string} [sortOrder] 
         * @param {string} [parentId] 
         * @param {string} [fields] 
         * @param {string} [excludeItemTypes] 
         * @param {string} [filters] 
         * @param {boolean} [isFavorite] 
         * @param {string} [mediaTypes] 
         * @param {string} [imageTypes] 
         * @param {string} [sortBy] 
         * @param {boolean} [isPlayed] 
         * @param {string} [genres] 
         * @param {string} [officialRatings] 
         * @param {string} [tags] 
         * @param {string} [years] 
         * @param {boolean} [enableUserData] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {string} [person] 
         * @param {string} [personIds] 
         * @param {string} [personTypes] 
         * @param {string} [studios] 
         * @param {string} [artists] 
         * @param {string} [excludeArtistIds] 
         * @param {string} [artistIds] 
         * @param {string} [albumArtistIds] 
         * @param {string} [contributingArtistIds] 
         * @param {string} [albums] 
         * @param {string} [albumIds] 
         * @param {string} [ids] 
         * @param {string} [videoTypes] 
         * @param {string} [minOfficialRating] 
         * @param {boolean} [isLocked] 
         * @param {boolean} [isPlaceHolder] 
         * @param {boolean} [hasOfficialRating] 
         * @param {boolean} [collapseBoxSetItems] 
         * @param {number} [minWidth] 
         * @param {number} [minHeight] 
         * @param {number} [maxWidth] 
         * @param {number} [maxHeight] 
         * @param {boolean} [is3D] 
         * @param {string} [seriesStatus] 
         * @param {string} [nameStartsWithOrGreater] 
         * @param {string} [nameStartsWith] 
         * @param {string} [nameLessThan] 
         * @param {string} [studioIds] 
         * @param {string} [genreIds] 
         * @param {boolean} [enableTotalRecordCount] 
         * @param {boolean} [enableImages] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTrailers(userId?: string, maxOfficialRating?: string, hasThemeSong?: boolean, hasThemeVideo?: boolean, hasSubtitles?: boolean, hasSpecialFeature?: boolean, hasTrailer?: boolean, adjacentTo?: string, parentIndexNumber?: number, hasParentalRating?: boolean, isHd?: boolean, is4K?: boolean, locationTypes?: string, excludeLocationTypes?: string, isMissing?: boolean, isUnaired?: boolean, minCommunityRating?: number, minCriticRating?: number, minPremiereDate?: string, minDateLastSaved?: string, minDateLastSavedForUser?: string, maxPremiereDate?: string, hasOverview?: boolean, hasImdbId?: boolean, hasTmdbId?: boolean, hasTvdbId?: boolean, excludeItemIds?: string, startIndex?: number, limit?: number, recursive?: boolean, searchTerm?: string, sortOrder?: string, parentId?: string, fields?: string, excludeItemTypes?: string, filters?: string, isFavorite?: boolean, mediaTypes?: string, imageTypes?: string, sortBy?: string, isPlayed?: boolean, genres?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, artists?: string, excludeArtistIds?: string, artistIds?: string, albumArtistIds?: string, contributingArtistIds?: string, albums?: string, albumIds?: string, ids?: string, videoTypes?: string, minOfficialRating?: string, isLocked?: boolean, isPlaceHolder?: boolean, hasOfficialRating?: boolean, collapseBoxSetItems?: boolean, minWidth?: number, minHeight?: number, maxWidth?: number, maxHeight?: number, is3D?: boolean, seriesStatus?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, studioIds?: string, genreIds?: string, enableTotalRecordCount?: boolean, enableImages?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await TrailersApiAxiosParamCreator(configuration).getTrailers(userId, maxOfficialRating, hasThemeSong, hasThemeVideo, hasSubtitles, hasSpecialFeature, hasTrailer, adjacentTo, parentIndexNumber, hasParentalRating, isHd, is4K, locationTypes, excludeLocationTypes, isMissing, isUnaired, minCommunityRating, minCriticRating, minPremiereDate, minDateLastSaved, minDateLastSavedForUser, maxPremiereDate, hasOverview, hasImdbId, hasTmdbId, hasTvdbId, excludeItemIds, startIndex, limit, recursive, searchTerm, sortOrder, parentId, fields, excludeItemTypes, filters, isFavorite, mediaTypes, imageTypes, sortBy, isPlayed, genres, officialRatings, tags, years, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, artists, excludeArtistIds, artistIds, albumArtistIds, contributingArtistIds, albums, albumIds, ids, videoTypes, minOfficialRating, isLocked, isPlaceHolder, hasOfficialRating, collapseBoxSetItems, minWidth, minHeight, maxWidth, maxHeight, is3D, seriesStatus, nameStartsWithOrGreater, nameStartsWith, nameLessThan, studioIds, genreIds, enableTotalRecordCount, enableImages, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TrailersApi - factory interface
 * @export
 */
export const TrailersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} [userId] 
         * @param {string} [maxOfficialRating] 
         * @param {boolean} [hasThemeSong] 
         * @param {boolean} [hasThemeVideo] 
         * @param {boolean} [hasSubtitles] 
         * @param {boolean} [hasSpecialFeature] 
         * @param {boolean} [hasTrailer] 
         * @param {string} [adjacentTo] 
         * @param {number} [parentIndexNumber] 
         * @param {boolean} [hasParentalRating] 
         * @param {boolean} [isHd] 
         * @param {boolean} [is4K] 
         * @param {string} [locationTypes] 
         * @param {string} [excludeLocationTypes] 
         * @param {boolean} [isMissing] 
         * @param {boolean} [isUnaired] 
         * @param {number} [minCommunityRating] 
         * @param {number} [minCriticRating] 
         * @param {string} [minPremiereDate] 
         * @param {string} [minDateLastSaved] 
         * @param {string} [minDateLastSavedForUser] 
         * @param {string} [maxPremiereDate] 
         * @param {boolean} [hasOverview] 
         * @param {boolean} [hasImdbId] 
         * @param {boolean} [hasTmdbId] 
         * @param {boolean} [hasTvdbId] 
         * @param {string} [excludeItemIds] 
         * @param {number} [startIndex] 
         * @param {number} [limit] 
         * @param {boolean} [recursive] 
         * @param {string} [searchTerm] 
         * @param {string} [sortOrder] 
         * @param {string} [parentId] 
         * @param {string} [fields] 
         * @param {string} [excludeItemTypes] 
         * @param {string} [filters] 
         * @param {boolean} [isFavorite] 
         * @param {string} [mediaTypes] 
         * @param {string} [imageTypes] 
         * @param {string} [sortBy] 
         * @param {boolean} [isPlayed] 
         * @param {string} [genres] 
         * @param {string} [officialRatings] 
         * @param {string} [tags] 
         * @param {string} [years] 
         * @param {boolean} [enableUserData] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {string} [person] 
         * @param {string} [personIds] 
         * @param {string} [personTypes] 
         * @param {string} [studios] 
         * @param {string} [artists] 
         * @param {string} [excludeArtistIds] 
         * @param {string} [artistIds] 
         * @param {string} [albumArtistIds] 
         * @param {string} [contributingArtistIds] 
         * @param {string} [albums] 
         * @param {string} [albumIds] 
         * @param {string} [ids] 
         * @param {string} [videoTypes] 
         * @param {string} [minOfficialRating] 
         * @param {boolean} [isLocked] 
         * @param {boolean} [isPlaceHolder] 
         * @param {boolean} [hasOfficialRating] 
         * @param {boolean} [collapseBoxSetItems] 
         * @param {number} [minWidth] 
         * @param {number} [minHeight] 
         * @param {number} [maxWidth] 
         * @param {number} [maxHeight] 
         * @param {boolean} [is3D] 
         * @param {string} [seriesStatus] 
         * @param {string} [nameStartsWithOrGreater] 
         * @param {string} [nameStartsWith] 
         * @param {string} [nameLessThan] 
         * @param {string} [studioIds] 
         * @param {string} [genreIds] 
         * @param {boolean} [enableTotalRecordCount] 
         * @param {boolean} [enableImages] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrailers(userId?: string, maxOfficialRating?: string, hasThemeSong?: boolean, hasThemeVideo?: boolean, hasSubtitles?: boolean, hasSpecialFeature?: boolean, hasTrailer?: boolean, adjacentTo?: string, parentIndexNumber?: number, hasParentalRating?: boolean, isHd?: boolean, is4K?: boolean, locationTypes?: string, excludeLocationTypes?: string, isMissing?: boolean, isUnaired?: boolean, minCommunityRating?: number, minCriticRating?: number, minPremiereDate?: string, minDateLastSaved?: string, minDateLastSavedForUser?: string, maxPremiereDate?: string, hasOverview?: boolean, hasImdbId?: boolean, hasTmdbId?: boolean, hasTvdbId?: boolean, excludeItemIds?: string, startIndex?: number, limit?: number, recursive?: boolean, searchTerm?: string, sortOrder?: string, parentId?: string, fields?: string, excludeItemTypes?: string, filters?: string, isFavorite?: boolean, mediaTypes?: string, imageTypes?: string, sortBy?: string, isPlayed?: boolean, genres?: string, officialRatings?: string, tags?: string, years?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, person?: string, personIds?: string, personTypes?: string, studios?: string, artists?: string, excludeArtistIds?: string, artistIds?: string, albumArtistIds?: string, contributingArtistIds?: string, albums?: string, albumIds?: string, ids?: string, videoTypes?: string, minOfficialRating?: string, isLocked?: boolean, isPlaceHolder?: boolean, hasOfficialRating?: boolean, collapseBoxSetItems?: boolean, minWidth?: number, minHeight?: number, maxWidth?: number, maxHeight?: number, is3D?: boolean, seriesStatus?: string, nameStartsWithOrGreater?: string, nameStartsWith?: string, nameLessThan?: string, studioIds?: string, genreIds?: string, enableTotalRecordCount?: boolean, enableImages?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return TrailersApiFp(configuration).getTrailers(userId, maxOfficialRating, hasThemeSong, hasThemeVideo, hasSubtitles, hasSpecialFeature, hasTrailer, adjacentTo, parentIndexNumber, hasParentalRating, isHd, is4K, locationTypes, excludeLocationTypes, isMissing, isUnaired, minCommunityRating, minCriticRating, minPremiereDate, minDateLastSaved, minDateLastSavedForUser, maxPremiereDate, hasOverview, hasImdbId, hasTmdbId, hasTvdbId, excludeItemIds, startIndex, limit, recursive, searchTerm, sortOrder, parentId, fields, excludeItemTypes, filters, isFavorite, mediaTypes, imageTypes, sortBy, isPlayed, genres, officialRatings, tags, years, enableUserData, imageTypeLimit, enableImageTypes, person, personIds, personTypes, studios, artists, excludeArtistIds, artistIds, albumArtistIds, contributingArtistIds, albums, albumIds, ids, videoTypes, minOfficialRating, isLocked, isPlaceHolder, hasOfficialRating, collapseBoxSetItems, minWidth, minHeight, maxWidth, maxHeight, is3D, seriesStatus, nameStartsWithOrGreater, nameStartsWith, nameLessThan, studioIds, genreIds, enableTotalRecordCount, enableImages, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getTrailers operation in TrailersApi.
 * @export
 * @interface TrailersApiGetTrailersRequest
 */
export interface TrailersApiGetTrailersRequest {
    /**
     * 
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly userId?: string

    /**
     * 
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly maxOfficialRating?: string

    /**
     * 
     * @type {boolean}
     * @memberof TrailersApiGetTrailers
     */
    readonly hasThemeSong?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof TrailersApiGetTrailers
     */
    readonly hasThemeVideo?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof TrailersApiGetTrailers
     */
    readonly hasSubtitles?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof TrailersApiGetTrailers
     */
    readonly hasSpecialFeature?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof TrailersApiGetTrailers
     */
    readonly hasTrailer?: boolean

    /**
     * 
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly adjacentTo?: string

    /**
     * 
     * @type {number}
     * @memberof TrailersApiGetTrailers
     */
    readonly parentIndexNumber?: number

    /**
     * 
     * @type {boolean}
     * @memberof TrailersApiGetTrailers
     */
    readonly hasParentalRating?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof TrailersApiGetTrailers
     */
    readonly isHd?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof TrailersApiGetTrailers
     */
    readonly is4K?: boolean

    /**
     * 
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly locationTypes?: string

    /**
     * 
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly excludeLocationTypes?: string

    /**
     * 
     * @type {boolean}
     * @memberof TrailersApiGetTrailers
     */
    readonly isMissing?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof TrailersApiGetTrailers
     */
    readonly isUnaired?: boolean

    /**
     * 
     * @type {number}
     * @memberof TrailersApiGetTrailers
     */
    readonly minCommunityRating?: number

    /**
     * 
     * @type {number}
     * @memberof TrailersApiGetTrailers
     */
    readonly minCriticRating?: number

    /**
     * 
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly minPremiereDate?: string

    /**
     * 
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly minDateLastSaved?: string

    /**
     * 
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly minDateLastSavedForUser?: string

    /**
     * 
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly maxPremiereDate?: string

    /**
     * 
     * @type {boolean}
     * @memberof TrailersApiGetTrailers
     */
    readonly hasOverview?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof TrailersApiGetTrailers
     */
    readonly hasImdbId?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof TrailersApiGetTrailers
     */
    readonly hasTmdbId?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof TrailersApiGetTrailers
     */
    readonly hasTvdbId?: boolean

    /**
     * 
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly excludeItemIds?: string

    /**
     * 
     * @type {number}
     * @memberof TrailersApiGetTrailers
     */
    readonly startIndex?: number

    /**
     * 
     * @type {number}
     * @memberof TrailersApiGetTrailers
     */
    readonly limit?: number

    /**
     * 
     * @type {boolean}
     * @memberof TrailersApiGetTrailers
     */
    readonly recursive?: boolean

    /**
     * 
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly searchTerm?: string

    /**
     * 
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly sortOrder?: string

    /**
     * 
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly parentId?: string

    /**
     * 
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly fields?: string

    /**
     * 
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly excludeItemTypes?: string

    /**
     * 
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly filters?: string

    /**
     * 
     * @type {boolean}
     * @memberof TrailersApiGetTrailers
     */
    readonly isFavorite?: boolean

    /**
     * 
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly mediaTypes?: string

    /**
     * 
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly imageTypes?: string

    /**
     * 
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly sortBy?: string

    /**
     * 
     * @type {boolean}
     * @memberof TrailersApiGetTrailers
     */
    readonly isPlayed?: boolean

    /**
     * 
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly genres?: string

    /**
     * 
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly officialRatings?: string

    /**
     * 
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly tags?: string

    /**
     * 
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly years?: string

    /**
     * 
     * @type {boolean}
     * @memberof TrailersApiGetTrailers
     */
    readonly enableUserData?: boolean

    /**
     * 
     * @type {number}
     * @memberof TrailersApiGetTrailers
     */
    readonly imageTypeLimit?: number

    /**
     * 
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly enableImageTypes?: string

    /**
     * 
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly person?: string

    /**
     * 
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly personIds?: string

    /**
     * 
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly personTypes?: string

    /**
     * 
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly studios?: string

    /**
     * 
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly artists?: string

    /**
     * 
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly excludeArtistIds?: string

    /**
     * 
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly artistIds?: string

    /**
     * 
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly albumArtistIds?: string

    /**
     * 
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly contributingArtistIds?: string

    /**
     * 
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly albums?: string

    /**
     * 
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly albumIds?: string

    /**
     * 
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly ids?: string

    /**
     * 
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly videoTypes?: string

    /**
     * 
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly minOfficialRating?: string

    /**
     * 
     * @type {boolean}
     * @memberof TrailersApiGetTrailers
     */
    readonly isLocked?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof TrailersApiGetTrailers
     */
    readonly isPlaceHolder?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof TrailersApiGetTrailers
     */
    readonly hasOfficialRating?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof TrailersApiGetTrailers
     */
    readonly collapseBoxSetItems?: boolean

    /**
     * 
     * @type {number}
     * @memberof TrailersApiGetTrailers
     */
    readonly minWidth?: number

    /**
     * 
     * @type {number}
     * @memberof TrailersApiGetTrailers
     */
    readonly minHeight?: number

    /**
     * 
     * @type {number}
     * @memberof TrailersApiGetTrailers
     */
    readonly maxWidth?: number

    /**
     * 
     * @type {number}
     * @memberof TrailersApiGetTrailers
     */
    readonly maxHeight?: number

    /**
     * 
     * @type {boolean}
     * @memberof TrailersApiGetTrailers
     */
    readonly is3D?: boolean

    /**
     * 
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly seriesStatus?: string

    /**
     * 
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly nameStartsWithOrGreater?: string

    /**
     * 
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly nameStartsWith?: string

    /**
     * 
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly nameLessThan?: string

    /**
     * 
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly studioIds?: string

    /**
     * 
     * @type {string}
     * @memberof TrailersApiGetTrailers
     */
    readonly genreIds?: string

    /**
     * 
     * @type {boolean}
     * @memberof TrailersApiGetTrailers
     */
    readonly enableTotalRecordCount?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof TrailersApiGetTrailers
     */
    readonly enableImages?: boolean
}

/**
 * TrailersApi - object-oriented interface
 * @export
 * @class TrailersApi
 * @extends {BaseAPI}
 */
export class TrailersApi extends BaseAPI {
    /**
     * 
     * @param {TrailersApiGetTrailersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrailersApi
     */
    public getTrailers(requestParameters: TrailersApiGetTrailersRequest = {}, options?: any) {
        return TrailersApiFp(this.configuration).getTrailers(requestParameters.userId, requestParameters.maxOfficialRating, requestParameters.hasThemeSong, requestParameters.hasThemeVideo, requestParameters.hasSubtitles, requestParameters.hasSpecialFeature, requestParameters.hasTrailer, requestParameters.adjacentTo, requestParameters.parentIndexNumber, requestParameters.hasParentalRating, requestParameters.isHd, requestParameters.is4K, requestParameters.locationTypes, requestParameters.excludeLocationTypes, requestParameters.isMissing, requestParameters.isUnaired, requestParameters.minCommunityRating, requestParameters.minCriticRating, requestParameters.minPremiereDate, requestParameters.minDateLastSaved, requestParameters.minDateLastSavedForUser, requestParameters.maxPremiereDate, requestParameters.hasOverview, requestParameters.hasImdbId, requestParameters.hasTmdbId, requestParameters.hasTvdbId, requestParameters.excludeItemIds, requestParameters.startIndex, requestParameters.limit, requestParameters.recursive, requestParameters.searchTerm, requestParameters.sortOrder, requestParameters.parentId, requestParameters.fields, requestParameters.excludeItemTypes, requestParameters.filters, requestParameters.isFavorite, requestParameters.mediaTypes, requestParameters.imageTypes, requestParameters.sortBy, requestParameters.isPlayed, requestParameters.genres, requestParameters.officialRatings, requestParameters.tags, requestParameters.years, requestParameters.enableUserData, requestParameters.imageTypeLimit, requestParameters.enableImageTypes, requestParameters.person, requestParameters.personIds, requestParameters.personTypes, requestParameters.studios, requestParameters.artists, requestParameters.excludeArtistIds, requestParameters.artistIds, requestParameters.albumArtistIds, requestParameters.contributingArtistIds, requestParameters.albums, requestParameters.albumIds, requestParameters.ids, requestParameters.videoTypes, requestParameters.minOfficialRating, requestParameters.isLocked, requestParameters.isPlaceHolder, requestParameters.hasOfficialRating, requestParameters.collapseBoxSetItems, requestParameters.minWidth, requestParameters.minHeight, requestParameters.maxWidth, requestParameters.maxHeight, requestParameters.is3D, requestParameters.seriesStatus, requestParameters.nameStartsWithOrGreater, requestParameters.nameStartsWith, requestParameters.nameLessThan, requestParameters.studioIds, requestParameters.genreIds, requestParameters.enableTotalRecordCount, requestParameters.enableImages, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TvShowsApi - axios parameter creator
 * @export
 */
export const TvShowsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} seriesId 
         * @param {string} userId 
         * @param {string} [fields] 
         * @param {number} [season] 
         * @param {string} [seasonId] 
         * @param {boolean} [isMissing] 
         * @param {string} [adjacentTo] 
         * @param {string} [startItemId] 
         * @param {number} [startIndex] 
         * @param {number} [limit] 
         * @param {boolean} [enableImages] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {boolean} [enableUserData] 
         * @param {string} [sortBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEpisodes: async (seriesId: string, userId: string, fields?: string, season?: number, seasonId?: string, isMissing?: boolean, adjacentTo?: string, startItemId?: string, startIndex?: number, limit?: number, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: string, enableUserData?: boolean, sortBy?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'seriesId' is not null or undefined
            if (seriesId === null || seriesId === undefined) {
                throw new RequiredError('seriesId','Required parameter seriesId was null or undefined when calling getEpisodes.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getEpisodes.');
            }
            const localVarPath = `/Shows/{seriesId}/Episodes`
                .replace(`{${"seriesId"}}`, encodeURIComponent(String(seriesId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (season !== undefined) {
                localVarQueryParameter['season'] = season;
            }

            if (seasonId !== undefined) {
                localVarQueryParameter['seasonId'] = seasonId;
            }

            if (isMissing !== undefined) {
                localVarQueryParameter['isMissing'] = isMissing;
            }

            if (adjacentTo !== undefined) {
                localVarQueryParameter['adjacentTo'] = adjacentTo;
            }

            if (startItemId !== undefined) {
                localVarQueryParameter['startItemId'] = startItemId;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes !== undefined) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {number} [startIndex] 
         * @param {number} [limit] 
         * @param {string} [fields] 
         * @param {string} [seriesId] 
         * @param {string} [parentId] 
         * @param {boolean} [enableImges] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {boolean} [enableUserData] 
         * @param {boolean} [enableTotalRecordCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNextUp: async (userId: string, startIndex?: number, limit?: number, fields?: string, seriesId?: string, parentId?: string, enableImges?: boolean, imageTypeLimit?: number, enableImageTypes?: string, enableUserData?: boolean, enableTotalRecordCount?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getNextUp.');
            }
            const localVarPath = `/Shows/NextUp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (seriesId !== undefined) {
                localVarQueryParameter['seriesId'] = seriesId;
            }

            if (parentId !== undefined) {
                localVarQueryParameter['parentId'] = parentId;
            }

            if (enableImges !== undefined) {
                localVarQueryParameter['enableImges'] = enableImges;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes !== undefined) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (enableTotalRecordCount !== undefined) {
                localVarQueryParameter['enableTotalRecordCount'] = enableTotalRecordCount;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} seriesId 
         * @param {string} userId 
         * @param {string} [fields] 
         * @param {boolean} [isSpecialSeason] 
         * @param {boolean} [isMissing] 
         * @param {string} [adjacentTo] 
         * @param {boolean} [enableImages] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {boolean} [enableUserData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSeasons: async (seriesId: string, userId: string, fields?: string, isSpecialSeason?: boolean, isMissing?: boolean, adjacentTo?: string, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: string, enableUserData?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'seriesId' is not null or undefined
            if (seriesId === null || seriesId === undefined) {
                throw new RequiredError('seriesId','Required parameter seriesId was null or undefined when calling getSeasons.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getSeasons.');
            }
            const localVarPath = `/Shows/{seriesId}/Seasons`
                .replace(`{${"seriesId"}}`, encodeURIComponent(String(seriesId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (isSpecialSeason !== undefined) {
                localVarQueryParameter['isSpecialSeason'] = isSpecialSeason;
            }

            if (isMissing !== undefined) {
                localVarQueryParameter['isMissing'] = isMissing;
            }

            if (adjacentTo !== undefined) {
                localVarQueryParameter['adjacentTo'] = adjacentTo;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes !== undefined) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {number} [startIndex] 
         * @param {number} [limit] 
         * @param {string} [fields] 
         * @param {string} [parentId] 
         * @param {boolean} [enableImges] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {boolean} [enableUserData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUpcomingEpisodes: async (userId: string, startIndex?: number, limit?: number, fields?: string, parentId?: string, enableImges?: boolean, imageTypeLimit?: number, enableImageTypes?: string, enableUserData?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getUpcomingEpisodes.');
            }
            const localVarPath = `/Shows/Upcoming`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (parentId !== undefined) {
                localVarQueryParameter['parentId'] = parentId;
            }

            if (enableImges !== undefined) {
                localVarQueryParameter['enableImges'] = enableImges;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes !== undefined) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TvShowsApi - functional programming interface
 * @export
 */
export const TvShowsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} seriesId 
         * @param {string} userId 
         * @param {string} [fields] 
         * @param {number} [season] 
         * @param {string} [seasonId] 
         * @param {boolean} [isMissing] 
         * @param {string} [adjacentTo] 
         * @param {string} [startItemId] 
         * @param {number} [startIndex] 
         * @param {number} [limit] 
         * @param {boolean} [enableImages] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {boolean} [enableUserData] 
         * @param {string} [sortBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEpisodes(seriesId: string, userId: string, fields?: string, season?: number, seasonId?: string, isMissing?: boolean, adjacentTo?: string, startItemId?: string, startIndex?: number, limit?: number, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: string, enableUserData?: boolean, sortBy?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await TvShowsApiAxiosParamCreator(configuration).getEpisodes(seriesId, userId, fields, season, seasonId, isMissing, adjacentTo, startItemId, startIndex, limit, enableImages, imageTypeLimit, enableImageTypes, enableUserData, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {number} [startIndex] 
         * @param {number} [limit] 
         * @param {string} [fields] 
         * @param {string} [seriesId] 
         * @param {string} [parentId] 
         * @param {boolean} [enableImges] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {boolean} [enableUserData] 
         * @param {boolean} [enableTotalRecordCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNextUp(userId: string, startIndex?: number, limit?: number, fields?: string, seriesId?: string, parentId?: string, enableImges?: boolean, imageTypeLimit?: number, enableImageTypes?: string, enableUserData?: boolean, enableTotalRecordCount?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await TvShowsApiAxiosParamCreator(configuration).getNextUp(userId, startIndex, limit, fields, seriesId, parentId, enableImges, imageTypeLimit, enableImageTypes, enableUserData, enableTotalRecordCount, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} seriesId 
         * @param {string} userId 
         * @param {string} [fields] 
         * @param {boolean} [isSpecialSeason] 
         * @param {boolean} [isMissing] 
         * @param {string} [adjacentTo] 
         * @param {boolean} [enableImages] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {boolean} [enableUserData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSeasons(seriesId: string, userId: string, fields?: string, isSpecialSeason?: boolean, isMissing?: boolean, adjacentTo?: string, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: string, enableUserData?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await TvShowsApiAxiosParamCreator(configuration).getSeasons(seriesId, userId, fields, isSpecialSeason, isMissing, adjacentTo, enableImages, imageTypeLimit, enableImageTypes, enableUserData, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {number} [startIndex] 
         * @param {number} [limit] 
         * @param {string} [fields] 
         * @param {string} [parentId] 
         * @param {boolean} [enableImges] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {boolean} [enableUserData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUpcomingEpisodes(userId: string, startIndex?: number, limit?: number, fields?: string, parentId?: string, enableImges?: boolean, imageTypeLimit?: number, enableImageTypes?: string, enableUserData?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await TvShowsApiAxiosParamCreator(configuration).getUpcomingEpisodes(userId, startIndex, limit, fields, parentId, enableImges, imageTypeLimit, enableImageTypes, enableUserData, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TvShowsApi - factory interface
 * @export
 */
export const TvShowsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} seriesId 
         * @param {string} userId 
         * @param {string} [fields] 
         * @param {number} [season] 
         * @param {string} [seasonId] 
         * @param {boolean} [isMissing] 
         * @param {string} [adjacentTo] 
         * @param {string} [startItemId] 
         * @param {number} [startIndex] 
         * @param {number} [limit] 
         * @param {boolean} [enableImages] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {boolean} [enableUserData] 
         * @param {string} [sortBy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEpisodes(seriesId: string, userId: string, fields?: string, season?: number, seasonId?: string, isMissing?: boolean, adjacentTo?: string, startItemId?: string, startIndex?: number, limit?: number, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: string, enableUserData?: boolean, sortBy?: string, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return TvShowsApiFp(configuration).getEpisodes(seriesId, userId, fields, season, seasonId, isMissing, adjacentTo, startItemId, startIndex, limit, enableImages, imageTypeLimit, enableImageTypes, enableUserData, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {number} [startIndex] 
         * @param {number} [limit] 
         * @param {string} [fields] 
         * @param {string} [seriesId] 
         * @param {string} [parentId] 
         * @param {boolean} [enableImges] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {boolean} [enableUserData] 
         * @param {boolean} [enableTotalRecordCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNextUp(userId: string, startIndex?: number, limit?: number, fields?: string, seriesId?: string, parentId?: string, enableImges?: boolean, imageTypeLimit?: number, enableImageTypes?: string, enableUserData?: boolean, enableTotalRecordCount?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return TvShowsApiFp(configuration).getNextUp(userId, startIndex, limit, fields, seriesId, parentId, enableImges, imageTypeLimit, enableImageTypes, enableUserData, enableTotalRecordCount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} seriesId 
         * @param {string} userId 
         * @param {string} [fields] 
         * @param {boolean} [isSpecialSeason] 
         * @param {boolean} [isMissing] 
         * @param {string} [adjacentTo] 
         * @param {boolean} [enableImages] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {boolean} [enableUserData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSeasons(seriesId: string, userId: string, fields?: string, isSpecialSeason?: boolean, isMissing?: boolean, adjacentTo?: string, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: string, enableUserData?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return TvShowsApiFp(configuration).getSeasons(seriesId, userId, fields, isSpecialSeason, isMissing, adjacentTo, enableImages, imageTypeLimit, enableImageTypes, enableUserData, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {number} [startIndex] 
         * @param {number} [limit] 
         * @param {string} [fields] 
         * @param {string} [parentId] 
         * @param {boolean} [enableImges] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {boolean} [enableUserData] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUpcomingEpisodes(userId: string, startIndex?: number, limit?: number, fields?: string, parentId?: string, enableImges?: boolean, imageTypeLimit?: number, enableImageTypes?: string, enableUserData?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return TvShowsApiFp(configuration).getUpcomingEpisodes(userId, startIndex, limit, fields, parentId, enableImges, imageTypeLimit, enableImageTypes, enableUserData, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getEpisodes operation in TvShowsApi.
 * @export
 * @interface TvShowsApiGetEpisodesRequest
 */
export interface TvShowsApiGetEpisodesRequest {
    /**
     * 
     * @type {string}
     * @memberof TvShowsApiGetEpisodes
     */
    readonly seriesId: string

    /**
     * 
     * @type {string}
     * @memberof TvShowsApiGetEpisodes
     */
    readonly userId: string

    /**
     * 
     * @type {string}
     * @memberof TvShowsApiGetEpisodes
     */
    readonly fields?: string

    /**
     * 
     * @type {number}
     * @memberof TvShowsApiGetEpisodes
     */
    readonly season?: number

    /**
     * 
     * @type {string}
     * @memberof TvShowsApiGetEpisodes
     */
    readonly seasonId?: string

    /**
     * 
     * @type {boolean}
     * @memberof TvShowsApiGetEpisodes
     */
    readonly isMissing?: boolean

    /**
     * 
     * @type {string}
     * @memberof TvShowsApiGetEpisodes
     */
    readonly adjacentTo?: string

    /**
     * 
     * @type {string}
     * @memberof TvShowsApiGetEpisodes
     */
    readonly startItemId?: string

    /**
     * 
     * @type {number}
     * @memberof TvShowsApiGetEpisodes
     */
    readonly startIndex?: number

    /**
     * 
     * @type {number}
     * @memberof TvShowsApiGetEpisodes
     */
    readonly limit?: number

    /**
     * 
     * @type {boolean}
     * @memberof TvShowsApiGetEpisodes
     */
    readonly enableImages?: boolean

    /**
     * 
     * @type {number}
     * @memberof TvShowsApiGetEpisodes
     */
    readonly imageTypeLimit?: number

    /**
     * 
     * @type {string}
     * @memberof TvShowsApiGetEpisodes
     */
    readonly enableImageTypes?: string

    /**
     * 
     * @type {boolean}
     * @memberof TvShowsApiGetEpisodes
     */
    readonly enableUserData?: boolean

    /**
     * 
     * @type {string}
     * @memberof TvShowsApiGetEpisodes
     */
    readonly sortBy?: string
}

/**
 * Request parameters for getNextUp operation in TvShowsApi.
 * @export
 * @interface TvShowsApiGetNextUpRequest
 */
export interface TvShowsApiGetNextUpRequest {
    /**
     * 
     * @type {string}
     * @memberof TvShowsApiGetNextUp
     */
    readonly userId: string

    /**
     * 
     * @type {number}
     * @memberof TvShowsApiGetNextUp
     */
    readonly startIndex?: number

    /**
     * 
     * @type {number}
     * @memberof TvShowsApiGetNextUp
     */
    readonly limit?: number

    /**
     * 
     * @type {string}
     * @memberof TvShowsApiGetNextUp
     */
    readonly fields?: string

    /**
     * 
     * @type {string}
     * @memberof TvShowsApiGetNextUp
     */
    readonly seriesId?: string

    /**
     * 
     * @type {string}
     * @memberof TvShowsApiGetNextUp
     */
    readonly parentId?: string

    /**
     * 
     * @type {boolean}
     * @memberof TvShowsApiGetNextUp
     */
    readonly enableImges?: boolean

    /**
     * 
     * @type {number}
     * @memberof TvShowsApiGetNextUp
     */
    readonly imageTypeLimit?: number

    /**
     * 
     * @type {string}
     * @memberof TvShowsApiGetNextUp
     */
    readonly enableImageTypes?: string

    /**
     * 
     * @type {boolean}
     * @memberof TvShowsApiGetNextUp
     */
    readonly enableUserData?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof TvShowsApiGetNextUp
     */
    readonly enableTotalRecordCount?: boolean
}

/**
 * Request parameters for getSeasons operation in TvShowsApi.
 * @export
 * @interface TvShowsApiGetSeasonsRequest
 */
export interface TvShowsApiGetSeasonsRequest {
    /**
     * 
     * @type {string}
     * @memberof TvShowsApiGetSeasons
     */
    readonly seriesId: string

    /**
     * 
     * @type {string}
     * @memberof TvShowsApiGetSeasons
     */
    readonly userId: string

    /**
     * 
     * @type {string}
     * @memberof TvShowsApiGetSeasons
     */
    readonly fields?: string

    /**
     * 
     * @type {boolean}
     * @memberof TvShowsApiGetSeasons
     */
    readonly isSpecialSeason?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof TvShowsApiGetSeasons
     */
    readonly isMissing?: boolean

    /**
     * 
     * @type {string}
     * @memberof TvShowsApiGetSeasons
     */
    readonly adjacentTo?: string

    /**
     * 
     * @type {boolean}
     * @memberof TvShowsApiGetSeasons
     */
    readonly enableImages?: boolean

    /**
     * 
     * @type {number}
     * @memberof TvShowsApiGetSeasons
     */
    readonly imageTypeLimit?: number

    /**
     * 
     * @type {string}
     * @memberof TvShowsApiGetSeasons
     */
    readonly enableImageTypes?: string

    /**
     * 
     * @type {boolean}
     * @memberof TvShowsApiGetSeasons
     */
    readonly enableUserData?: boolean
}

/**
 * Request parameters for getUpcomingEpisodes operation in TvShowsApi.
 * @export
 * @interface TvShowsApiGetUpcomingEpisodesRequest
 */
export interface TvShowsApiGetUpcomingEpisodesRequest {
    /**
     * 
     * @type {string}
     * @memberof TvShowsApiGetUpcomingEpisodes
     */
    readonly userId: string

    /**
     * 
     * @type {number}
     * @memberof TvShowsApiGetUpcomingEpisodes
     */
    readonly startIndex?: number

    /**
     * 
     * @type {number}
     * @memberof TvShowsApiGetUpcomingEpisodes
     */
    readonly limit?: number

    /**
     * 
     * @type {string}
     * @memberof TvShowsApiGetUpcomingEpisodes
     */
    readonly fields?: string

    /**
     * 
     * @type {string}
     * @memberof TvShowsApiGetUpcomingEpisodes
     */
    readonly parentId?: string

    /**
     * 
     * @type {boolean}
     * @memberof TvShowsApiGetUpcomingEpisodes
     */
    readonly enableImges?: boolean

    /**
     * 
     * @type {number}
     * @memberof TvShowsApiGetUpcomingEpisodes
     */
    readonly imageTypeLimit?: number

    /**
     * 
     * @type {string}
     * @memberof TvShowsApiGetUpcomingEpisodes
     */
    readonly enableImageTypes?: string

    /**
     * 
     * @type {boolean}
     * @memberof TvShowsApiGetUpcomingEpisodes
     */
    readonly enableUserData?: boolean
}

/**
 * TvShowsApi - object-oriented interface
 * @export
 * @class TvShowsApi
 * @extends {BaseAPI}
 */
export class TvShowsApi extends BaseAPI {
    /**
     * 
     * @param {TvShowsApiGetEpisodesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TvShowsApi
     */
    public getEpisodes(requestParameters: TvShowsApiGetEpisodesRequest, options?: any) {
        return TvShowsApiFp(this.configuration).getEpisodes(requestParameters.seriesId, requestParameters.userId, requestParameters.fields, requestParameters.season, requestParameters.seasonId, requestParameters.isMissing, requestParameters.adjacentTo, requestParameters.startItemId, requestParameters.startIndex, requestParameters.limit, requestParameters.enableImages, requestParameters.imageTypeLimit, requestParameters.enableImageTypes, requestParameters.enableUserData, requestParameters.sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TvShowsApiGetNextUpRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TvShowsApi
     */
    public getNextUp(requestParameters: TvShowsApiGetNextUpRequest, options?: any) {
        return TvShowsApiFp(this.configuration).getNextUp(requestParameters.userId, requestParameters.startIndex, requestParameters.limit, requestParameters.fields, requestParameters.seriesId, requestParameters.parentId, requestParameters.enableImges, requestParameters.imageTypeLimit, requestParameters.enableImageTypes, requestParameters.enableUserData, requestParameters.enableTotalRecordCount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TvShowsApiGetSeasonsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TvShowsApi
     */
    public getSeasons(requestParameters: TvShowsApiGetSeasonsRequest, options?: any) {
        return TvShowsApiFp(this.configuration).getSeasons(requestParameters.seriesId, requestParameters.userId, requestParameters.fields, requestParameters.isSpecialSeason, requestParameters.isMissing, requestParameters.adjacentTo, requestParameters.enableImages, requestParameters.imageTypeLimit, requestParameters.enableImageTypes, requestParameters.enableUserData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TvShowsApiGetUpcomingEpisodesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TvShowsApi
     */
    public getUpcomingEpisodes(requestParameters: TvShowsApiGetUpcomingEpisodesRequest, options?: any) {
        return TvShowsApiFp(this.configuration).getUpcomingEpisodes(requestParameters.userId, requestParameters.startIndex, requestParameters.limit, requestParameters.fields, requestParameters.parentId, requestParameters.enableImges, requestParameters.imageTypeLimit, requestParameters.enableImageTypes, requestParameters.enableUserData, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UniversalAudioApi - axios parameter creator
 * @export
 */
export const UniversalAudioApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} itemId 
         * @param {string} container 
         * @param {string} [mediaSourceId] 
         * @param {string} [deviceId] 
         * @param {string} [userId] 
         * @param {string} [audioCodec] 
         * @param {number} [maxAudioChannels] 
         * @param {number} [transcodingAudioChannels] 
         * @param {number} [maxStreamingBitrate] 
         * @param {number} [startTimeTicks] 
         * @param {string} [transcodingContainer] 
         * @param {string} [transcodingProtocol] 
         * @param {number} [maxAudioSampleRate] 
         * @param {number} [maxAudioBitDepth] 
         * @param {boolean} [enableRemoteMedia] 
         * @param {boolean} [breakOnNonKeyFrames] 
         * @param {boolean} [enableRedirection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniversalAudioStream: async (itemId: string, container: string, mediaSourceId?: string, deviceId?: string, userId?: string, audioCodec?: string, maxAudioChannels?: number, transcodingAudioChannels?: number, maxStreamingBitrate?: number, startTimeTicks?: number, transcodingContainer?: string, transcodingProtocol?: string, maxAudioSampleRate?: number, maxAudioBitDepth?: number, enableRemoteMedia?: boolean, breakOnNonKeyFrames?: boolean, enableRedirection?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getUniversalAudioStream.');
            }
            // verify required parameter 'container' is not null or undefined
            if (container === null || container === undefined) {
                throw new RequiredError('container','Required parameter container was null or undefined when calling getUniversalAudioStream.');
            }
            const localVarPath = `/Audio/{itemId}/universal`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"container"}}`, encodeURIComponent(String(container)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['mediaSourceId'] = mediaSourceId;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (audioCodec !== undefined) {
                localVarQueryParameter['audioCodec'] = audioCodec;
            }

            if (maxAudioChannels !== undefined) {
                localVarQueryParameter['maxAudioChannels'] = maxAudioChannels;
            }

            if (transcodingAudioChannels !== undefined) {
                localVarQueryParameter['transcodingAudioChannels'] = transcodingAudioChannels;
            }

            if (maxStreamingBitrate !== undefined) {
                localVarQueryParameter['maxStreamingBitrate'] = maxStreamingBitrate;
            }

            if (startTimeTicks !== undefined) {
                localVarQueryParameter['startTimeTicks'] = startTimeTicks;
            }

            if (transcodingContainer !== undefined) {
                localVarQueryParameter['transcodingContainer'] = transcodingContainer;
            }

            if (transcodingProtocol !== undefined) {
                localVarQueryParameter['transcodingProtocol'] = transcodingProtocol;
            }

            if (maxAudioSampleRate !== undefined) {
                localVarQueryParameter['maxAudioSampleRate'] = maxAudioSampleRate;
            }

            if (maxAudioBitDepth !== undefined) {
                localVarQueryParameter['maxAudioBitDepth'] = maxAudioBitDepth;
            }

            if (enableRemoteMedia !== undefined) {
                localVarQueryParameter['enableRemoteMedia'] = enableRemoteMedia;
            }

            if (breakOnNonKeyFrames !== undefined) {
                localVarQueryParameter['breakOnNonKeyFrames'] = breakOnNonKeyFrames;
            }

            if (enableRedirection !== undefined) {
                localVarQueryParameter['enableRedirection'] = enableRedirection;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} container 
         * @param {string} [mediaSourceId] 
         * @param {string} [deviceId] 
         * @param {string} [userId] 
         * @param {string} [audioCodec] 
         * @param {number} [maxAudioChannels] 
         * @param {number} [transcodingAudioChannels] 
         * @param {number} [maxStreamingBitrate] 
         * @param {number} [startTimeTicks] 
         * @param {string} [transcodingContainer] 
         * @param {string} [transcodingProtocol] 
         * @param {number} [maxAudioSampleRate] 
         * @param {number} [maxAudioBitDepth] 
         * @param {boolean} [enableRemoteMedia] 
         * @param {boolean} [breakOnNonKeyFrames] 
         * @param {boolean} [enableRedirection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniversalAudioStream2: async (itemId: string, container: string, mediaSourceId?: string, deviceId?: string, userId?: string, audioCodec?: string, maxAudioChannels?: number, transcodingAudioChannels?: number, maxStreamingBitrate?: number, startTimeTicks?: number, transcodingContainer?: string, transcodingProtocol?: string, maxAudioSampleRate?: number, maxAudioBitDepth?: number, enableRemoteMedia?: boolean, breakOnNonKeyFrames?: boolean, enableRedirection?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getUniversalAudioStream2.');
            }
            // verify required parameter 'container' is not null or undefined
            if (container === null || container === undefined) {
                throw new RequiredError('container','Required parameter container was null or undefined when calling getUniversalAudioStream2.');
            }
            const localVarPath = `/Audio/{itemId}/universal.{container}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"container"}}`, encodeURIComponent(String(container)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['mediaSourceId'] = mediaSourceId;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (audioCodec !== undefined) {
                localVarQueryParameter['audioCodec'] = audioCodec;
            }

            if (maxAudioChannels !== undefined) {
                localVarQueryParameter['maxAudioChannels'] = maxAudioChannels;
            }

            if (transcodingAudioChannels !== undefined) {
                localVarQueryParameter['transcodingAudioChannels'] = transcodingAudioChannels;
            }

            if (maxStreamingBitrate !== undefined) {
                localVarQueryParameter['maxStreamingBitrate'] = maxStreamingBitrate;
            }

            if (startTimeTicks !== undefined) {
                localVarQueryParameter['startTimeTicks'] = startTimeTicks;
            }

            if (transcodingContainer !== undefined) {
                localVarQueryParameter['transcodingContainer'] = transcodingContainer;
            }

            if (transcodingProtocol !== undefined) {
                localVarQueryParameter['transcodingProtocol'] = transcodingProtocol;
            }

            if (maxAudioSampleRate !== undefined) {
                localVarQueryParameter['maxAudioSampleRate'] = maxAudioSampleRate;
            }

            if (maxAudioBitDepth !== undefined) {
                localVarQueryParameter['maxAudioBitDepth'] = maxAudioBitDepth;
            }

            if (enableRemoteMedia !== undefined) {
                localVarQueryParameter['enableRemoteMedia'] = enableRemoteMedia;
            }

            if (breakOnNonKeyFrames !== undefined) {
                localVarQueryParameter['breakOnNonKeyFrames'] = breakOnNonKeyFrames;
            }

            if (enableRedirection !== undefined) {
                localVarQueryParameter['enableRedirection'] = enableRedirection;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} container 
         * @param {string} [mediaSourceId] 
         * @param {string} [deviceId] 
         * @param {string} [userId] 
         * @param {string} [audioCodec] 
         * @param {number} [maxAudioChannels] 
         * @param {number} [transcodingAudioChannels] 
         * @param {number} [maxStreamingBitrate] 
         * @param {number} [startTimeTicks] 
         * @param {string} [transcodingContainer] 
         * @param {string} [transcodingProtocol] 
         * @param {number} [maxAudioSampleRate] 
         * @param {number} [maxAudioBitDepth] 
         * @param {boolean} [enableRemoteMedia] 
         * @param {boolean} [breakOnNonKeyFrames] 
         * @param {boolean} [enableRedirection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headUniversalAudioStream: async (itemId: string, container: string, mediaSourceId?: string, deviceId?: string, userId?: string, audioCodec?: string, maxAudioChannels?: number, transcodingAudioChannels?: number, maxStreamingBitrate?: number, startTimeTicks?: number, transcodingContainer?: string, transcodingProtocol?: string, maxAudioSampleRate?: number, maxAudioBitDepth?: number, enableRemoteMedia?: boolean, breakOnNonKeyFrames?: boolean, enableRedirection?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling headUniversalAudioStream.');
            }
            // verify required parameter 'container' is not null or undefined
            if (container === null || container === undefined) {
                throw new RequiredError('container','Required parameter container was null or undefined when calling headUniversalAudioStream.');
            }
            const localVarPath = `/Audio/{itemId}/universal`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"container"}}`, encodeURIComponent(String(container)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['mediaSourceId'] = mediaSourceId;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (audioCodec !== undefined) {
                localVarQueryParameter['audioCodec'] = audioCodec;
            }

            if (maxAudioChannels !== undefined) {
                localVarQueryParameter['maxAudioChannels'] = maxAudioChannels;
            }

            if (transcodingAudioChannels !== undefined) {
                localVarQueryParameter['transcodingAudioChannels'] = transcodingAudioChannels;
            }

            if (maxStreamingBitrate !== undefined) {
                localVarQueryParameter['maxStreamingBitrate'] = maxStreamingBitrate;
            }

            if (startTimeTicks !== undefined) {
                localVarQueryParameter['startTimeTicks'] = startTimeTicks;
            }

            if (transcodingContainer !== undefined) {
                localVarQueryParameter['transcodingContainer'] = transcodingContainer;
            }

            if (transcodingProtocol !== undefined) {
                localVarQueryParameter['transcodingProtocol'] = transcodingProtocol;
            }

            if (maxAudioSampleRate !== undefined) {
                localVarQueryParameter['maxAudioSampleRate'] = maxAudioSampleRate;
            }

            if (maxAudioBitDepth !== undefined) {
                localVarQueryParameter['maxAudioBitDepth'] = maxAudioBitDepth;
            }

            if (enableRemoteMedia !== undefined) {
                localVarQueryParameter['enableRemoteMedia'] = enableRemoteMedia;
            }

            if (breakOnNonKeyFrames !== undefined) {
                localVarQueryParameter['breakOnNonKeyFrames'] = breakOnNonKeyFrames;
            }

            if (enableRedirection !== undefined) {
                localVarQueryParameter['enableRedirection'] = enableRedirection;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} container 
         * @param {string} [mediaSourceId] 
         * @param {string} [deviceId] 
         * @param {string} [userId] 
         * @param {string} [audioCodec] 
         * @param {number} [maxAudioChannels] 
         * @param {number} [transcodingAudioChannels] 
         * @param {number} [maxStreamingBitrate] 
         * @param {number} [startTimeTicks] 
         * @param {string} [transcodingContainer] 
         * @param {string} [transcodingProtocol] 
         * @param {number} [maxAudioSampleRate] 
         * @param {number} [maxAudioBitDepth] 
         * @param {boolean} [enableRemoteMedia] 
         * @param {boolean} [breakOnNonKeyFrames] 
         * @param {boolean} [enableRedirection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headUniversalAudioStream2: async (itemId: string, container: string, mediaSourceId?: string, deviceId?: string, userId?: string, audioCodec?: string, maxAudioChannels?: number, transcodingAudioChannels?: number, maxStreamingBitrate?: number, startTimeTicks?: number, transcodingContainer?: string, transcodingProtocol?: string, maxAudioSampleRate?: number, maxAudioBitDepth?: number, enableRemoteMedia?: boolean, breakOnNonKeyFrames?: boolean, enableRedirection?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling headUniversalAudioStream2.');
            }
            // verify required parameter 'container' is not null or undefined
            if (container === null || container === undefined) {
                throw new RequiredError('container','Required parameter container was null or undefined when calling headUniversalAudioStream2.');
            }
            const localVarPath = `/Audio/{itemId}/universal.{container}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"container"}}`, encodeURIComponent(String(container)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['mediaSourceId'] = mediaSourceId;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (audioCodec !== undefined) {
                localVarQueryParameter['audioCodec'] = audioCodec;
            }

            if (maxAudioChannels !== undefined) {
                localVarQueryParameter['maxAudioChannels'] = maxAudioChannels;
            }

            if (transcodingAudioChannels !== undefined) {
                localVarQueryParameter['transcodingAudioChannels'] = transcodingAudioChannels;
            }

            if (maxStreamingBitrate !== undefined) {
                localVarQueryParameter['maxStreamingBitrate'] = maxStreamingBitrate;
            }

            if (startTimeTicks !== undefined) {
                localVarQueryParameter['startTimeTicks'] = startTimeTicks;
            }

            if (transcodingContainer !== undefined) {
                localVarQueryParameter['transcodingContainer'] = transcodingContainer;
            }

            if (transcodingProtocol !== undefined) {
                localVarQueryParameter['transcodingProtocol'] = transcodingProtocol;
            }

            if (maxAudioSampleRate !== undefined) {
                localVarQueryParameter['maxAudioSampleRate'] = maxAudioSampleRate;
            }

            if (maxAudioBitDepth !== undefined) {
                localVarQueryParameter['maxAudioBitDepth'] = maxAudioBitDepth;
            }

            if (enableRemoteMedia !== undefined) {
                localVarQueryParameter['enableRemoteMedia'] = enableRemoteMedia;
            }

            if (breakOnNonKeyFrames !== undefined) {
                localVarQueryParameter['breakOnNonKeyFrames'] = breakOnNonKeyFrames;
            }

            if (enableRedirection !== undefined) {
                localVarQueryParameter['enableRedirection'] = enableRedirection;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UniversalAudioApi - functional programming interface
 * @export
 */
export const UniversalAudioApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} itemId 
         * @param {string} container 
         * @param {string} [mediaSourceId] 
         * @param {string} [deviceId] 
         * @param {string} [userId] 
         * @param {string} [audioCodec] 
         * @param {number} [maxAudioChannels] 
         * @param {number} [transcodingAudioChannels] 
         * @param {number} [maxStreamingBitrate] 
         * @param {number} [startTimeTicks] 
         * @param {string} [transcodingContainer] 
         * @param {string} [transcodingProtocol] 
         * @param {number} [maxAudioSampleRate] 
         * @param {number} [maxAudioBitDepth] 
         * @param {boolean} [enableRemoteMedia] 
         * @param {boolean} [breakOnNonKeyFrames] 
         * @param {boolean} [enableRedirection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUniversalAudioStream(itemId: string, container: string, mediaSourceId?: string, deviceId?: string, userId?: string, audioCodec?: string, maxAudioChannels?: number, transcodingAudioChannels?: number, maxStreamingBitrate?: number, startTimeTicks?: number, transcodingContainer?: string, transcodingProtocol?: string, maxAudioSampleRate?: number, maxAudioBitDepth?: number, enableRemoteMedia?: boolean, breakOnNonKeyFrames?: boolean, enableRedirection?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UniversalAudioApiAxiosParamCreator(configuration).getUniversalAudioStream(itemId, container, mediaSourceId, deviceId, userId, audioCodec, maxAudioChannels, transcodingAudioChannels, maxStreamingBitrate, startTimeTicks, transcodingContainer, transcodingProtocol, maxAudioSampleRate, maxAudioBitDepth, enableRemoteMedia, breakOnNonKeyFrames, enableRedirection, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} container 
         * @param {string} [mediaSourceId] 
         * @param {string} [deviceId] 
         * @param {string} [userId] 
         * @param {string} [audioCodec] 
         * @param {number} [maxAudioChannels] 
         * @param {number} [transcodingAudioChannels] 
         * @param {number} [maxStreamingBitrate] 
         * @param {number} [startTimeTicks] 
         * @param {string} [transcodingContainer] 
         * @param {string} [transcodingProtocol] 
         * @param {number} [maxAudioSampleRate] 
         * @param {number} [maxAudioBitDepth] 
         * @param {boolean} [enableRemoteMedia] 
         * @param {boolean} [breakOnNonKeyFrames] 
         * @param {boolean} [enableRedirection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUniversalAudioStream2(itemId: string, container: string, mediaSourceId?: string, deviceId?: string, userId?: string, audioCodec?: string, maxAudioChannels?: number, transcodingAudioChannels?: number, maxStreamingBitrate?: number, startTimeTicks?: number, transcodingContainer?: string, transcodingProtocol?: string, maxAudioSampleRate?: number, maxAudioBitDepth?: number, enableRemoteMedia?: boolean, breakOnNonKeyFrames?: boolean, enableRedirection?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UniversalAudioApiAxiosParamCreator(configuration).getUniversalAudioStream2(itemId, container, mediaSourceId, deviceId, userId, audioCodec, maxAudioChannels, transcodingAudioChannels, maxStreamingBitrate, startTimeTicks, transcodingContainer, transcodingProtocol, maxAudioSampleRate, maxAudioBitDepth, enableRemoteMedia, breakOnNonKeyFrames, enableRedirection, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} container 
         * @param {string} [mediaSourceId] 
         * @param {string} [deviceId] 
         * @param {string} [userId] 
         * @param {string} [audioCodec] 
         * @param {number} [maxAudioChannels] 
         * @param {number} [transcodingAudioChannels] 
         * @param {number} [maxStreamingBitrate] 
         * @param {number} [startTimeTicks] 
         * @param {string} [transcodingContainer] 
         * @param {string} [transcodingProtocol] 
         * @param {number} [maxAudioSampleRate] 
         * @param {number} [maxAudioBitDepth] 
         * @param {boolean} [enableRemoteMedia] 
         * @param {boolean} [breakOnNonKeyFrames] 
         * @param {boolean} [enableRedirection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headUniversalAudioStream(itemId: string, container: string, mediaSourceId?: string, deviceId?: string, userId?: string, audioCodec?: string, maxAudioChannels?: number, transcodingAudioChannels?: number, maxStreamingBitrate?: number, startTimeTicks?: number, transcodingContainer?: string, transcodingProtocol?: string, maxAudioSampleRate?: number, maxAudioBitDepth?: number, enableRemoteMedia?: boolean, breakOnNonKeyFrames?: boolean, enableRedirection?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UniversalAudioApiAxiosParamCreator(configuration).headUniversalAudioStream(itemId, container, mediaSourceId, deviceId, userId, audioCodec, maxAudioChannels, transcodingAudioChannels, maxStreamingBitrate, startTimeTicks, transcodingContainer, transcodingProtocol, maxAudioSampleRate, maxAudioBitDepth, enableRemoteMedia, breakOnNonKeyFrames, enableRedirection, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} container 
         * @param {string} [mediaSourceId] 
         * @param {string} [deviceId] 
         * @param {string} [userId] 
         * @param {string} [audioCodec] 
         * @param {number} [maxAudioChannels] 
         * @param {number} [transcodingAudioChannels] 
         * @param {number} [maxStreamingBitrate] 
         * @param {number} [startTimeTicks] 
         * @param {string} [transcodingContainer] 
         * @param {string} [transcodingProtocol] 
         * @param {number} [maxAudioSampleRate] 
         * @param {number} [maxAudioBitDepth] 
         * @param {boolean} [enableRemoteMedia] 
         * @param {boolean} [breakOnNonKeyFrames] 
         * @param {boolean} [enableRedirection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headUniversalAudioStream2(itemId: string, container: string, mediaSourceId?: string, deviceId?: string, userId?: string, audioCodec?: string, maxAudioChannels?: number, transcodingAudioChannels?: number, maxStreamingBitrate?: number, startTimeTicks?: number, transcodingContainer?: string, transcodingProtocol?: string, maxAudioSampleRate?: number, maxAudioBitDepth?: number, enableRemoteMedia?: boolean, breakOnNonKeyFrames?: boolean, enableRedirection?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UniversalAudioApiAxiosParamCreator(configuration).headUniversalAudioStream2(itemId, container, mediaSourceId, deviceId, userId, audioCodec, maxAudioChannels, transcodingAudioChannels, maxStreamingBitrate, startTimeTicks, transcodingContainer, transcodingProtocol, maxAudioSampleRate, maxAudioBitDepth, enableRemoteMedia, breakOnNonKeyFrames, enableRedirection, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UniversalAudioApi - factory interface
 * @export
 */
export const UniversalAudioApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} itemId 
         * @param {string} container 
         * @param {string} [mediaSourceId] 
         * @param {string} [deviceId] 
         * @param {string} [userId] 
         * @param {string} [audioCodec] 
         * @param {number} [maxAudioChannels] 
         * @param {number} [transcodingAudioChannels] 
         * @param {number} [maxStreamingBitrate] 
         * @param {number} [startTimeTicks] 
         * @param {string} [transcodingContainer] 
         * @param {string} [transcodingProtocol] 
         * @param {number} [maxAudioSampleRate] 
         * @param {number} [maxAudioBitDepth] 
         * @param {boolean} [enableRemoteMedia] 
         * @param {boolean} [breakOnNonKeyFrames] 
         * @param {boolean} [enableRedirection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniversalAudioStream(itemId: string, container: string, mediaSourceId?: string, deviceId?: string, userId?: string, audioCodec?: string, maxAudioChannels?: number, transcodingAudioChannels?: number, maxStreamingBitrate?: number, startTimeTicks?: number, transcodingContainer?: string, transcodingProtocol?: string, maxAudioSampleRate?: number, maxAudioBitDepth?: number, enableRemoteMedia?: boolean, breakOnNonKeyFrames?: boolean, enableRedirection?: boolean, options?: any): AxiosPromise<void> {
            return UniversalAudioApiFp(configuration).getUniversalAudioStream(itemId, container, mediaSourceId, deviceId, userId, audioCodec, maxAudioChannels, transcodingAudioChannels, maxStreamingBitrate, startTimeTicks, transcodingContainer, transcodingProtocol, maxAudioSampleRate, maxAudioBitDepth, enableRemoteMedia, breakOnNonKeyFrames, enableRedirection, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} container 
         * @param {string} [mediaSourceId] 
         * @param {string} [deviceId] 
         * @param {string} [userId] 
         * @param {string} [audioCodec] 
         * @param {number} [maxAudioChannels] 
         * @param {number} [transcodingAudioChannels] 
         * @param {number} [maxStreamingBitrate] 
         * @param {number} [startTimeTicks] 
         * @param {string} [transcodingContainer] 
         * @param {string} [transcodingProtocol] 
         * @param {number} [maxAudioSampleRate] 
         * @param {number} [maxAudioBitDepth] 
         * @param {boolean} [enableRemoteMedia] 
         * @param {boolean} [breakOnNonKeyFrames] 
         * @param {boolean} [enableRedirection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniversalAudioStream2(itemId: string, container: string, mediaSourceId?: string, deviceId?: string, userId?: string, audioCodec?: string, maxAudioChannels?: number, transcodingAudioChannels?: number, maxStreamingBitrate?: number, startTimeTicks?: number, transcodingContainer?: string, transcodingProtocol?: string, maxAudioSampleRate?: number, maxAudioBitDepth?: number, enableRemoteMedia?: boolean, breakOnNonKeyFrames?: boolean, enableRedirection?: boolean, options?: any): AxiosPromise<void> {
            return UniversalAudioApiFp(configuration).getUniversalAudioStream2(itemId, container, mediaSourceId, deviceId, userId, audioCodec, maxAudioChannels, transcodingAudioChannels, maxStreamingBitrate, startTimeTicks, transcodingContainer, transcodingProtocol, maxAudioSampleRate, maxAudioBitDepth, enableRemoteMedia, breakOnNonKeyFrames, enableRedirection, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} container 
         * @param {string} [mediaSourceId] 
         * @param {string} [deviceId] 
         * @param {string} [userId] 
         * @param {string} [audioCodec] 
         * @param {number} [maxAudioChannels] 
         * @param {number} [transcodingAudioChannels] 
         * @param {number} [maxStreamingBitrate] 
         * @param {number} [startTimeTicks] 
         * @param {string} [transcodingContainer] 
         * @param {string} [transcodingProtocol] 
         * @param {number} [maxAudioSampleRate] 
         * @param {number} [maxAudioBitDepth] 
         * @param {boolean} [enableRemoteMedia] 
         * @param {boolean} [breakOnNonKeyFrames] 
         * @param {boolean} [enableRedirection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headUniversalAudioStream(itemId: string, container: string, mediaSourceId?: string, deviceId?: string, userId?: string, audioCodec?: string, maxAudioChannels?: number, transcodingAudioChannels?: number, maxStreamingBitrate?: number, startTimeTicks?: number, transcodingContainer?: string, transcodingProtocol?: string, maxAudioSampleRate?: number, maxAudioBitDepth?: number, enableRemoteMedia?: boolean, breakOnNonKeyFrames?: boolean, enableRedirection?: boolean, options?: any): AxiosPromise<void> {
            return UniversalAudioApiFp(configuration).headUniversalAudioStream(itemId, container, mediaSourceId, deviceId, userId, audioCodec, maxAudioChannels, transcodingAudioChannels, maxStreamingBitrate, startTimeTicks, transcodingContainer, transcodingProtocol, maxAudioSampleRate, maxAudioBitDepth, enableRemoteMedia, breakOnNonKeyFrames, enableRedirection, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} container 
         * @param {string} [mediaSourceId] 
         * @param {string} [deviceId] 
         * @param {string} [userId] 
         * @param {string} [audioCodec] 
         * @param {number} [maxAudioChannels] 
         * @param {number} [transcodingAudioChannels] 
         * @param {number} [maxStreamingBitrate] 
         * @param {number} [startTimeTicks] 
         * @param {string} [transcodingContainer] 
         * @param {string} [transcodingProtocol] 
         * @param {number} [maxAudioSampleRate] 
         * @param {number} [maxAudioBitDepth] 
         * @param {boolean} [enableRemoteMedia] 
         * @param {boolean} [breakOnNonKeyFrames] 
         * @param {boolean} [enableRedirection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headUniversalAudioStream2(itemId: string, container: string, mediaSourceId?: string, deviceId?: string, userId?: string, audioCodec?: string, maxAudioChannels?: number, transcodingAudioChannels?: number, maxStreamingBitrate?: number, startTimeTicks?: number, transcodingContainer?: string, transcodingProtocol?: string, maxAudioSampleRate?: number, maxAudioBitDepth?: number, enableRemoteMedia?: boolean, breakOnNonKeyFrames?: boolean, enableRedirection?: boolean, options?: any): AxiosPromise<void> {
            return UniversalAudioApiFp(configuration).headUniversalAudioStream2(itemId, container, mediaSourceId, deviceId, userId, audioCodec, maxAudioChannels, transcodingAudioChannels, maxStreamingBitrate, startTimeTicks, transcodingContainer, transcodingProtocol, maxAudioSampleRate, maxAudioBitDepth, enableRemoteMedia, breakOnNonKeyFrames, enableRedirection, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getUniversalAudioStream operation in UniversalAudioApi.
 * @export
 * @interface UniversalAudioApiGetUniversalAudioStreamRequest
 */
export interface UniversalAudioApiGetUniversalAudioStreamRequest {
    /**
     * 
     * @type {string}
     * @memberof UniversalAudioApiGetUniversalAudioStream
     */
    readonly itemId: string

    /**
     * 
     * @type {string}
     * @memberof UniversalAudioApiGetUniversalAudioStream
     */
    readonly container: string

    /**
     * 
     * @type {string}
     * @memberof UniversalAudioApiGetUniversalAudioStream
     */
    readonly mediaSourceId?: string

    /**
     * 
     * @type {string}
     * @memberof UniversalAudioApiGetUniversalAudioStream
     */
    readonly deviceId?: string

    /**
     * 
     * @type {string}
     * @memberof UniversalAudioApiGetUniversalAudioStream
     */
    readonly userId?: string

    /**
     * 
     * @type {string}
     * @memberof UniversalAudioApiGetUniversalAudioStream
     */
    readonly audioCodec?: string

    /**
     * 
     * @type {number}
     * @memberof UniversalAudioApiGetUniversalAudioStream
     */
    readonly maxAudioChannels?: number

    /**
     * 
     * @type {number}
     * @memberof UniversalAudioApiGetUniversalAudioStream
     */
    readonly transcodingAudioChannels?: number

    /**
     * 
     * @type {number}
     * @memberof UniversalAudioApiGetUniversalAudioStream
     */
    readonly maxStreamingBitrate?: number

    /**
     * 
     * @type {number}
     * @memberof UniversalAudioApiGetUniversalAudioStream
     */
    readonly startTimeTicks?: number

    /**
     * 
     * @type {string}
     * @memberof UniversalAudioApiGetUniversalAudioStream
     */
    readonly transcodingContainer?: string

    /**
     * 
     * @type {string}
     * @memberof UniversalAudioApiGetUniversalAudioStream
     */
    readonly transcodingProtocol?: string

    /**
     * 
     * @type {number}
     * @memberof UniversalAudioApiGetUniversalAudioStream
     */
    readonly maxAudioSampleRate?: number

    /**
     * 
     * @type {number}
     * @memberof UniversalAudioApiGetUniversalAudioStream
     */
    readonly maxAudioBitDepth?: number

    /**
     * 
     * @type {boolean}
     * @memberof UniversalAudioApiGetUniversalAudioStream
     */
    readonly enableRemoteMedia?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof UniversalAudioApiGetUniversalAudioStream
     */
    readonly breakOnNonKeyFrames?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof UniversalAudioApiGetUniversalAudioStream
     */
    readonly enableRedirection?: boolean
}

/**
 * Request parameters for getUniversalAudioStream2 operation in UniversalAudioApi.
 * @export
 * @interface UniversalAudioApiGetUniversalAudioStream2Request
 */
export interface UniversalAudioApiGetUniversalAudioStream2Request {
    /**
     * 
     * @type {string}
     * @memberof UniversalAudioApiGetUniversalAudioStream2
     */
    readonly itemId: string

    /**
     * 
     * @type {string}
     * @memberof UniversalAudioApiGetUniversalAudioStream2
     */
    readonly container: string

    /**
     * 
     * @type {string}
     * @memberof UniversalAudioApiGetUniversalAudioStream2
     */
    readonly mediaSourceId?: string

    /**
     * 
     * @type {string}
     * @memberof UniversalAudioApiGetUniversalAudioStream2
     */
    readonly deviceId?: string

    /**
     * 
     * @type {string}
     * @memberof UniversalAudioApiGetUniversalAudioStream2
     */
    readonly userId?: string

    /**
     * 
     * @type {string}
     * @memberof UniversalAudioApiGetUniversalAudioStream2
     */
    readonly audioCodec?: string

    /**
     * 
     * @type {number}
     * @memberof UniversalAudioApiGetUniversalAudioStream2
     */
    readonly maxAudioChannels?: number

    /**
     * 
     * @type {number}
     * @memberof UniversalAudioApiGetUniversalAudioStream2
     */
    readonly transcodingAudioChannels?: number

    /**
     * 
     * @type {number}
     * @memberof UniversalAudioApiGetUniversalAudioStream2
     */
    readonly maxStreamingBitrate?: number

    /**
     * 
     * @type {number}
     * @memberof UniversalAudioApiGetUniversalAudioStream2
     */
    readonly startTimeTicks?: number

    /**
     * 
     * @type {string}
     * @memberof UniversalAudioApiGetUniversalAudioStream2
     */
    readonly transcodingContainer?: string

    /**
     * 
     * @type {string}
     * @memberof UniversalAudioApiGetUniversalAudioStream2
     */
    readonly transcodingProtocol?: string

    /**
     * 
     * @type {number}
     * @memberof UniversalAudioApiGetUniversalAudioStream2
     */
    readonly maxAudioSampleRate?: number

    /**
     * 
     * @type {number}
     * @memberof UniversalAudioApiGetUniversalAudioStream2
     */
    readonly maxAudioBitDepth?: number

    /**
     * 
     * @type {boolean}
     * @memberof UniversalAudioApiGetUniversalAudioStream2
     */
    readonly enableRemoteMedia?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof UniversalAudioApiGetUniversalAudioStream2
     */
    readonly breakOnNonKeyFrames?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof UniversalAudioApiGetUniversalAudioStream2
     */
    readonly enableRedirection?: boolean
}

/**
 * Request parameters for headUniversalAudioStream operation in UniversalAudioApi.
 * @export
 * @interface UniversalAudioApiHeadUniversalAudioStreamRequest
 */
export interface UniversalAudioApiHeadUniversalAudioStreamRequest {
    /**
     * 
     * @type {string}
     * @memberof UniversalAudioApiHeadUniversalAudioStream
     */
    readonly itemId: string

    /**
     * 
     * @type {string}
     * @memberof UniversalAudioApiHeadUniversalAudioStream
     */
    readonly container: string

    /**
     * 
     * @type {string}
     * @memberof UniversalAudioApiHeadUniversalAudioStream
     */
    readonly mediaSourceId?: string

    /**
     * 
     * @type {string}
     * @memberof UniversalAudioApiHeadUniversalAudioStream
     */
    readonly deviceId?: string

    /**
     * 
     * @type {string}
     * @memberof UniversalAudioApiHeadUniversalAudioStream
     */
    readonly userId?: string

    /**
     * 
     * @type {string}
     * @memberof UniversalAudioApiHeadUniversalAudioStream
     */
    readonly audioCodec?: string

    /**
     * 
     * @type {number}
     * @memberof UniversalAudioApiHeadUniversalAudioStream
     */
    readonly maxAudioChannels?: number

    /**
     * 
     * @type {number}
     * @memberof UniversalAudioApiHeadUniversalAudioStream
     */
    readonly transcodingAudioChannels?: number

    /**
     * 
     * @type {number}
     * @memberof UniversalAudioApiHeadUniversalAudioStream
     */
    readonly maxStreamingBitrate?: number

    /**
     * 
     * @type {number}
     * @memberof UniversalAudioApiHeadUniversalAudioStream
     */
    readonly startTimeTicks?: number

    /**
     * 
     * @type {string}
     * @memberof UniversalAudioApiHeadUniversalAudioStream
     */
    readonly transcodingContainer?: string

    /**
     * 
     * @type {string}
     * @memberof UniversalAudioApiHeadUniversalAudioStream
     */
    readonly transcodingProtocol?: string

    /**
     * 
     * @type {number}
     * @memberof UniversalAudioApiHeadUniversalAudioStream
     */
    readonly maxAudioSampleRate?: number

    /**
     * 
     * @type {number}
     * @memberof UniversalAudioApiHeadUniversalAudioStream
     */
    readonly maxAudioBitDepth?: number

    /**
     * 
     * @type {boolean}
     * @memberof UniversalAudioApiHeadUniversalAudioStream
     */
    readonly enableRemoteMedia?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof UniversalAudioApiHeadUniversalAudioStream
     */
    readonly breakOnNonKeyFrames?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof UniversalAudioApiHeadUniversalAudioStream
     */
    readonly enableRedirection?: boolean
}

/**
 * Request parameters for headUniversalAudioStream2 operation in UniversalAudioApi.
 * @export
 * @interface UniversalAudioApiHeadUniversalAudioStream2Request
 */
export interface UniversalAudioApiHeadUniversalAudioStream2Request {
    /**
     * 
     * @type {string}
     * @memberof UniversalAudioApiHeadUniversalAudioStream2
     */
    readonly itemId: string

    /**
     * 
     * @type {string}
     * @memberof UniversalAudioApiHeadUniversalAudioStream2
     */
    readonly container: string

    /**
     * 
     * @type {string}
     * @memberof UniversalAudioApiHeadUniversalAudioStream2
     */
    readonly mediaSourceId?: string

    /**
     * 
     * @type {string}
     * @memberof UniversalAudioApiHeadUniversalAudioStream2
     */
    readonly deviceId?: string

    /**
     * 
     * @type {string}
     * @memberof UniversalAudioApiHeadUniversalAudioStream2
     */
    readonly userId?: string

    /**
     * 
     * @type {string}
     * @memberof UniversalAudioApiHeadUniversalAudioStream2
     */
    readonly audioCodec?: string

    /**
     * 
     * @type {number}
     * @memberof UniversalAudioApiHeadUniversalAudioStream2
     */
    readonly maxAudioChannels?: number

    /**
     * 
     * @type {number}
     * @memberof UniversalAudioApiHeadUniversalAudioStream2
     */
    readonly transcodingAudioChannels?: number

    /**
     * 
     * @type {number}
     * @memberof UniversalAudioApiHeadUniversalAudioStream2
     */
    readonly maxStreamingBitrate?: number

    /**
     * 
     * @type {number}
     * @memberof UniversalAudioApiHeadUniversalAudioStream2
     */
    readonly startTimeTicks?: number

    /**
     * 
     * @type {string}
     * @memberof UniversalAudioApiHeadUniversalAudioStream2
     */
    readonly transcodingContainer?: string

    /**
     * 
     * @type {string}
     * @memberof UniversalAudioApiHeadUniversalAudioStream2
     */
    readonly transcodingProtocol?: string

    /**
     * 
     * @type {number}
     * @memberof UniversalAudioApiHeadUniversalAudioStream2
     */
    readonly maxAudioSampleRate?: number

    /**
     * 
     * @type {number}
     * @memberof UniversalAudioApiHeadUniversalAudioStream2
     */
    readonly maxAudioBitDepth?: number

    /**
     * 
     * @type {boolean}
     * @memberof UniversalAudioApiHeadUniversalAudioStream2
     */
    readonly enableRemoteMedia?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof UniversalAudioApiHeadUniversalAudioStream2
     */
    readonly breakOnNonKeyFrames?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof UniversalAudioApiHeadUniversalAudioStream2
     */
    readonly enableRedirection?: boolean
}

/**
 * UniversalAudioApi - object-oriented interface
 * @export
 * @class UniversalAudioApi
 * @extends {BaseAPI}
 */
export class UniversalAudioApi extends BaseAPI {
    /**
     * 
     * @param {UniversalAudioApiGetUniversalAudioStreamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UniversalAudioApi
     */
    public getUniversalAudioStream(requestParameters: UniversalAudioApiGetUniversalAudioStreamRequest, options?: any) {
        return UniversalAudioApiFp(this.configuration).getUniversalAudioStream(requestParameters.itemId, requestParameters.container, requestParameters.mediaSourceId, requestParameters.deviceId, requestParameters.userId, requestParameters.audioCodec, requestParameters.maxAudioChannels, requestParameters.transcodingAudioChannels, requestParameters.maxStreamingBitrate, requestParameters.startTimeTicks, requestParameters.transcodingContainer, requestParameters.transcodingProtocol, requestParameters.maxAudioSampleRate, requestParameters.maxAudioBitDepth, requestParameters.enableRemoteMedia, requestParameters.breakOnNonKeyFrames, requestParameters.enableRedirection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UniversalAudioApiGetUniversalAudioStream2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UniversalAudioApi
     */
    public getUniversalAudioStream2(requestParameters: UniversalAudioApiGetUniversalAudioStream2Request, options?: any) {
        return UniversalAudioApiFp(this.configuration).getUniversalAudioStream2(requestParameters.itemId, requestParameters.container, requestParameters.mediaSourceId, requestParameters.deviceId, requestParameters.userId, requestParameters.audioCodec, requestParameters.maxAudioChannels, requestParameters.transcodingAudioChannels, requestParameters.maxStreamingBitrate, requestParameters.startTimeTicks, requestParameters.transcodingContainer, requestParameters.transcodingProtocol, requestParameters.maxAudioSampleRate, requestParameters.maxAudioBitDepth, requestParameters.enableRemoteMedia, requestParameters.breakOnNonKeyFrames, requestParameters.enableRedirection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UniversalAudioApiHeadUniversalAudioStreamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UniversalAudioApi
     */
    public headUniversalAudioStream(requestParameters: UniversalAudioApiHeadUniversalAudioStreamRequest, options?: any) {
        return UniversalAudioApiFp(this.configuration).headUniversalAudioStream(requestParameters.itemId, requestParameters.container, requestParameters.mediaSourceId, requestParameters.deviceId, requestParameters.userId, requestParameters.audioCodec, requestParameters.maxAudioChannels, requestParameters.transcodingAudioChannels, requestParameters.maxStreamingBitrate, requestParameters.startTimeTicks, requestParameters.transcodingContainer, requestParameters.transcodingProtocol, requestParameters.maxAudioSampleRate, requestParameters.maxAudioBitDepth, requestParameters.enableRemoteMedia, requestParameters.breakOnNonKeyFrames, requestParameters.enableRedirection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UniversalAudioApiHeadUniversalAudioStream2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UniversalAudioApi
     */
    public headUniversalAudioStream2(requestParameters: UniversalAudioApiHeadUniversalAudioStream2Request, options?: any) {
        return UniversalAudioApiFp(this.configuration).headUniversalAudioStream2(requestParameters.itemId, requestParameters.container, requestParameters.mediaSourceId, requestParameters.deviceId, requestParameters.userId, requestParameters.audioCodec, requestParameters.maxAudioChannels, requestParameters.transcodingAudioChannels, requestParameters.maxStreamingBitrate, requestParameters.startTimeTicks, requestParameters.transcodingContainer, requestParameters.transcodingProtocol, requestParameters.maxAudioSampleRate, requestParameters.maxAudioBitDepth, requestParameters.enableRemoteMedia, requestParameters.breakOnNonKeyFrames, requestParameters.enableRedirection, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} userId 
         * @param {string} pw 
         * @param {string} [password] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticateUser: async (userId: string, pw: string, password?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling authenticateUser.');
            }
            // verify required parameter 'pw' is not null or undefined
            if (pw === null || pw === undefined) {
                throw new RequiredError('pw','Required parameter pw was null or undefined when calling authenticateUser.');
            }
            const localVarPath = `/Users/{userId}/Authenticate`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (pw !== undefined) {
                localVarQueryParameter['pw'] = pw;
            }

            if (password !== undefined) {
                localVarQueryParameter['password'] = password;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AuthenticateUserByName} authenticateUserByName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticateUserByName: async (authenticateUserByName: AuthenticateUserByName, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authenticateUserByName' is not null or undefined
            if (authenticateUserByName === null || authenticateUserByName === undefined) {
                throw new RequiredError('authenticateUserByName','Required parameter authenticateUserByName was null or undefined when calling authenticateUserByName.');
            }
            const localVarPath = `/Users/AuthenticateByName`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof authenticateUserByName !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(authenticateUserByName !== undefined ? authenticateUserByName : {}) : (authenticateUserByName || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {QuickConnectDto} quickConnectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticateWithQuickConnect: async (quickConnectDto: QuickConnectDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'quickConnectDto' is not null or undefined
            if (quickConnectDto === null || quickConnectDto === undefined) {
                throw new RequiredError('quickConnectDto','Required parameter quickConnectDto was null or undefined when calling authenticateWithQuickConnect.');
            }
            const localVarPath = `/Users/AuthenticateWithQuickConnect`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof quickConnectDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(quickConnectDto !== undefined ? quickConnectDto : {}) : (quickConnectDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateUserByName} [createUserByName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserByName: async (createUserByName?: CreateUserByName, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Users/New`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createUserByName !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createUserByName !== undefined ? createUserByName : {}) : (createUserByName || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling deleteUser.');
            }
            const localVarPath = `/Users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forgotPassword: async (body?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Users/ForgotPassword`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forgotPasswordPin: async (body?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Users/ForgotPassword/Pin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicUsers: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Users/Public`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getUserById.');
            }
            const localVarPath = `/Users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {boolean} [isHidden] 
         * @param {boolean} [isDisabled] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (isHidden?: boolean, isDisabled?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (isHidden !== undefined) {
                localVarQueryParameter['isHidden'] = isHidden;
            }

            if (isDisabled !== undefined) {
                localVarQueryParameter['isDisabled'] = isDisabled;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {UserDto} [userDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (userId: string, userDto?: UserDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling updateUser.');
            }
            const localVarPath = `/Users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof userDto !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(userDto !== undefined ? userDto : {}) : (userDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {UserConfiguration} [userConfiguration] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserConfiguration: async (userId: string, userConfiguration?: UserConfiguration, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling updateUserConfiguration.');
            }
            const localVarPath = `/Users/{userId}/Configuration`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof userConfiguration !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(userConfiguration !== undefined ? userConfiguration : {}) : (userConfiguration || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {UpdateUserEasyPassword} [updateUserEasyPassword] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserEasyPassword: async (userId: string, updateUserEasyPassword?: UpdateUserEasyPassword, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling updateUserEasyPassword.');
            }
            const localVarPath = `/Users/{userId}/EasyPassword`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof updateUserEasyPassword !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(updateUserEasyPassword !== undefined ? updateUserEasyPassword : {}) : (updateUserEasyPassword || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {UpdateUserPassword} [updateUserPassword] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPassword: async (userId: string, updateUserPassword?: UpdateUserPassword, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling updateUserPassword.');
            }
            const localVarPath = `/Users/{userId}/Password`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof updateUserPassword !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(updateUserPassword !== undefined ? updateUserPassword : {}) : (updateUserPassword || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {UserPolicy} [userPolicy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPolicy: async (userId: string, userPolicy?: UserPolicy, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling updateUserPolicy.');
            }
            const localVarPath = `/Users/{userId}/Policy`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof userPolicy !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(userPolicy !== undefined ? userPolicy : {}) : (userPolicy || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} userId 
         * @param {string} pw 
         * @param {string} [password] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticateUser(userId: string, pw: string, password?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResult>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).authenticateUser(userId, pw, password, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {AuthenticateUserByName} authenticateUserByName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticateUserByName(authenticateUserByName: AuthenticateUserByName, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResult>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).authenticateUserByName(authenticateUserByName, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {QuickConnectDto} quickConnectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticateWithQuickConnect(quickConnectDto: QuickConnectDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResult>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).authenticateWithQuickConnect(quickConnectDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CreateUserByName} [createUserByName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserByName(createUserByName?: CreateUserByName, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDto>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).createUserByName(createUserByName, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).deleteUser(userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async forgotPassword(body?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ForgotPasswordResult>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).forgotPassword(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async forgotPasswordPin(body?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PinRedeemResult>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).forgotPasswordPin(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicUsers(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserDto>>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).getPublicUsers(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserById(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDto>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).getUserById(userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {boolean} [isHidden] 
         * @param {boolean} [isDisabled] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(isHidden?: boolean, isDisabled?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserDto>>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).getUsers(isHidden, isDisabled, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {UserDto} [userDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(userId: string, userDto?: UserDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).updateUser(userId, userDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {UserConfiguration} [userConfiguration] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserConfiguration(userId: string, userConfiguration?: UserConfiguration, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).updateUserConfiguration(userId, userConfiguration, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {UpdateUserEasyPassword} [updateUserEasyPassword] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserEasyPassword(userId: string, updateUserEasyPassword?: UpdateUserEasyPassword, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).updateUserEasyPassword(userId, updateUserEasyPassword, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {UpdateUserPassword} [updateUserPassword] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserPassword(userId: string, updateUserPassword?: UpdateUserPassword, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).updateUserPassword(userId, updateUserPassword, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {UserPolicy} [userPolicy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserPolicy(userId: string, userPolicy?: UserPolicy, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).updateUserPolicy(userId, userPolicy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} userId 
         * @param {string} pw 
         * @param {string} [password] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticateUser(userId: string, pw: string, password?: string, options?: any): AxiosPromise<AuthenticationResult> {
            return UserApiFp(configuration).authenticateUser(userId, pw, password, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AuthenticateUserByName} authenticateUserByName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticateUserByName(authenticateUserByName: AuthenticateUserByName, options?: any): AxiosPromise<AuthenticationResult> {
            return UserApiFp(configuration).authenticateUserByName(authenticateUserByName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {QuickConnectDto} quickConnectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticateWithQuickConnect(quickConnectDto: QuickConnectDto, options?: any): AxiosPromise<AuthenticationResult> {
            return UserApiFp(configuration).authenticateWithQuickConnect(quickConnectDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateUserByName} [createUserByName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserByName(createUserByName?: CreateUserByName, options?: any): AxiosPromise<UserDto> {
            return UserApiFp(configuration).createUserByName(createUserByName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(userId: string, options?: any): AxiosPromise<void> {
            return UserApiFp(configuration).deleteUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forgotPassword(body?: string, options?: any): AxiosPromise<ForgotPasswordResult> {
            return UserApiFp(configuration).forgotPassword(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forgotPasswordPin(body?: string, options?: any): AxiosPromise<PinRedeemResult> {
            return UserApiFp(configuration).forgotPasswordPin(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicUsers(options?: any): AxiosPromise<Array<UserDto>> {
            return UserApiFp(configuration).getPublicUsers(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById(userId: string, options?: any): AxiosPromise<UserDto> {
            return UserApiFp(configuration).getUserById(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {boolean} [isHidden] 
         * @param {boolean} [isDisabled] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(isHidden?: boolean, isDisabled?: boolean, options?: any): AxiosPromise<Array<UserDto>> {
            return UserApiFp(configuration).getUsers(isHidden, isDisabled, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {UserDto} [userDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(userId: string, userDto?: UserDto, options?: any): AxiosPromise<void> {
            return UserApiFp(configuration).updateUser(userId, userDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {UserConfiguration} [userConfiguration] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserConfiguration(userId: string, userConfiguration?: UserConfiguration, options?: any): AxiosPromise<void> {
            return UserApiFp(configuration).updateUserConfiguration(userId, userConfiguration, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {UpdateUserEasyPassword} [updateUserEasyPassword] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserEasyPassword(userId: string, updateUserEasyPassword?: UpdateUserEasyPassword, options?: any): AxiosPromise<void> {
            return UserApiFp(configuration).updateUserEasyPassword(userId, updateUserEasyPassword, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {UpdateUserPassword} [updateUserPassword] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPassword(userId: string, updateUserPassword?: UpdateUserPassword, options?: any): AxiosPromise<void> {
            return UserApiFp(configuration).updateUserPassword(userId, updateUserPassword, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {UserPolicy} [userPolicy] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPolicy(userId: string, userPolicy?: UserPolicy, options?: any): AxiosPromise<void> {
            return UserApiFp(configuration).updateUserPolicy(userId, userPolicy, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for authenticateUser operation in UserApi.
 * @export
 * @interface UserApiAuthenticateUserRequest
 */
export interface UserApiAuthenticateUserRequest {
    /**
     * 
     * @type {string}
     * @memberof UserApiAuthenticateUser
     */
    readonly userId: string

    /**
     * 
     * @type {string}
     * @memberof UserApiAuthenticateUser
     */
    readonly pw: string

    /**
     * 
     * @type {string}
     * @memberof UserApiAuthenticateUser
     */
    readonly password?: string
}

/**
 * Request parameters for authenticateUserByName operation in UserApi.
 * @export
 * @interface UserApiAuthenticateUserByNameRequest
 */
export interface UserApiAuthenticateUserByNameRequest {
    /**
     * 
     * @type {AuthenticateUserByName}
     * @memberof UserApiAuthenticateUserByName
     */
    readonly authenticateUserByName: AuthenticateUserByName
}

/**
 * Request parameters for authenticateWithQuickConnect operation in UserApi.
 * @export
 * @interface UserApiAuthenticateWithQuickConnectRequest
 */
export interface UserApiAuthenticateWithQuickConnectRequest {
    /**
     * 
     * @type {QuickConnectDto}
     * @memberof UserApiAuthenticateWithQuickConnect
     */
    readonly quickConnectDto: QuickConnectDto
}

/**
 * Request parameters for createUserByName operation in UserApi.
 * @export
 * @interface UserApiCreateUserByNameRequest
 */
export interface UserApiCreateUserByNameRequest {
    /**
     * 
     * @type {CreateUserByName}
     * @memberof UserApiCreateUserByName
     */
    readonly createUserByName?: CreateUserByName
}

/**
 * Request parameters for deleteUser operation in UserApi.
 * @export
 * @interface UserApiDeleteUserRequest
 */
export interface UserApiDeleteUserRequest {
    /**
     * 
     * @type {string}
     * @memberof UserApiDeleteUser
     */
    readonly userId: string
}

/**
 * Request parameters for forgotPassword operation in UserApi.
 * @export
 * @interface UserApiForgotPasswordRequest
 */
export interface UserApiForgotPasswordRequest {
    /**
     * 
     * @type {string}
     * @memberof UserApiForgotPassword
     */
    readonly body?: string
}

/**
 * Request parameters for forgotPasswordPin operation in UserApi.
 * @export
 * @interface UserApiForgotPasswordPinRequest
 */
export interface UserApiForgotPasswordPinRequest {
    /**
     * 
     * @type {string}
     * @memberof UserApiForgotPasswordPin
     */
    readonly body?: string
}

/**
 * Request parameters for getUserById operation in UserApi.
 * @export
 * @interface UserApiGetUserByIdRequest
 */
export interface UserApiGetUserByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof UserApiGetUserById
     */
    readonly userId: string
}

/**
 * Request parameters for getUsers operation in UserApi.
 * @export
 * @interface UserApiGetUsersRequest
 */
export interface UserApiGetUsersRequest {
    /**
     * 
     * @type {boolean}
     * @memberof UserApiGetUsers
     */
    readonly isHidden?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof UserApiGetUsers
     */
    readonly isDisabled?: boolean
}

/**
 * Request parameters for updateUser operation in UserApi.
 * @export
 * @interface UserApiUpdateUserRequest
 */
export interface UserApiUpdateUserRequest {
    /**
     * 
     * @type {string}
     * @memberof UserApiUpdateUser
     */
    readonly userId: string

    /**
     * 
     * @type {UserDto}
     * @memberof UserApiUpdateUser
     */
    readonly userDto?: UserDto
}

/**
 * Request parameters for updateUserConfiguration operation in UserApi.
 * @export
 * @interface UserApiUpdateUserConfigurationRequest
 */
export interface UserApiUpdateUserConfigurationRequest {
    /**
     * 
     * @type {string}
     * @memberof UserApiUpdateUserConfiguration
     */
    readonly userId: string

    /**
     * 
     * @type {UserConfiguration}
     * @memberof UserApiUpdateUserConfiguration
     */
    readonly userConfiguration?: UserConfiguration
}

/**
 * Request parameters for updateUserEasyPassword operation in UserApi.
 * @export
 * @interface UserApiUpdateUserEasyPasswordRequest
 */
export interface UserApiUpdateUserEasyPasswordRequest {
    /**
     * 
     * @type {string}
     * @memberof UserApiUpdateUserEasyPassword
     */
    readonly userId: string

    /**
     * 
     * @type {UpdateUserEasyPassword}
     * @memberof UserApiUpdateUserEasyPassword
     */
    readonly updateUserEasyPassword?: UpdateUserEasyPassword
}

/**
 * Request parameters for updateUserPassword operation in UserApi.
 * @export
 * @interface UserApiUpdateUserPasswordRequest
 */
export interface UserApiUpdateUserPasswordRequest {
    /**
     * 
     * @type {string}
     * @memberof UserApiUpdateUserPassword
     */
    readonly userId: string

    /**
     * 
     * @type {UpdateUserPassword}
     * @memberof UserApiUpdateUserPassword
     */
    readonly updateUserPassword?: UpdateUserPassword
}

/**
 * Request parameters for updateUserPolicy operation in UserApi.
 * @export
 * @interface UserApiUpdateUserPolicyRequest
 */
export interface UserApiUpdateUserPolicyRequest {
    /**
     * 
     * @type {string}
     * @memberof UserApiUpdateUserPolicy
     */
    readonly userId: string

    /**
     * 
     * @type {UserPolicy}
     * @memberof UserApiUpdateUserPolicy
     */
    readonly userPolicy?: UserPolicy
}

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @param {UserApiAuthenticateUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public authenticateUser(requestParameters: UserApiAuthenticateUserRequest, options?: any) {
        return UserApiFp(this.configuration).authenticateUser(requestParameters.userId, requestParameters.pw, requestParameters.password, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserApiAuthenticateUserByNameRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public authenticateUserByName(requestParameters: UserApiAuthenticateUserByNameRequest, options?: any) {
        return UserApiFp(this.configuration).authenticateUserByName(requestParameters.authenticateUserByName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserApiAuthenticateWithQuickConnectRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public authenticateWithQuickConnect(requestParameters: UserApiAuthenticateWithQuickConnectRequest, options?: any) {
        return UserApiFp(this.configuration).authenticateWithQuickConnect(requestParameters.quickConnectDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserApiCreateUserByNameRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public createUserByName(requestParameters: UserApiCreateUserByNameRequest = {}, options?: any) {
        return UserApiFp(this.configuration).createUserByName(requestParameters.createUserByName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserApiDeleteUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public deleteUser(requestParameters: UserApiDeleteUserRequest, options?: any) {
        return UserApiFp(this.configuration).deleteUser(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserApiForgotPasswordRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public forgotPassword(requestParameters: UserApiForgotPasswordRequest = {}, options?: any) {
        return UserApiFp(this.configuration).forgotPassword(requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserApiForgotPasswordPinRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public forgotPasswordPin(requestParameters: UserApiForgotPasswordPinRequest = {}, options?: any) {
        return UserApiFp(this.configuration).forgotPasswordPin(requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getPublicUsers(options?: any) {
        return UserApiFp(this.configuration).getPublicUsers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserApiGetUserByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserById(requestParameters: UserApiGetUserByIdRequest, options?: any) {
        return UserApiFp(this.configuration).getUserById(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserApiGetUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUsers(requestParameters: UserApiGetUsersRequest = {}, options?: any) {
        return UserApiFp(this.configuration).getUsers(requestParameters.isHidden, requestParameters.isDisabled, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserApiUpdateUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateUser(requestParameters: UserApiUpdateUserRequest, options?: any) {
        return UserApiFp(this.configuration).updateUser(requestParameters.userId, requestParameters.userDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserApiUpdateUserConfigurationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateUserConfiguration(requestParameters: UserApiUpdateUserConfigurationRequest, options?: any) {
        return UserApiFp(this.configuration).updateUserConfiguration(requestParameters.userId, requestParameters.userConfiguration, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserApiUpdateUserEasyPasswordRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateUserEasyPassword(requestParameters: UserApiUpdateUserEasyPasswordRequest, options?: any) {
        return UserApiFp(this.configuration).updateUserEasyPassword(requestParameters.userId, requestParameters.updateUserEasyPassword, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserApiUpdateUserPasswordRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateUserPassword(requestParameters: UserApiUpdateUserPasswordRequest, options?: any) {
        return UserApiFp(this.configuration).updateUserPassword(requestParameters.userId, requestParameters.updateUserPassword, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserApiUpdateUserPolicyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateUserPolicy(requestParameters: UserApiUpdateUserPolicyRequest, options?: any) {
        return UserApiFp(this.configuration).updateUserPolicy(requestParameters.userId, requestParameters.userPolicy, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserLibraryApi - axios parameter creator
 * @export
 */
export const UserLibraryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} userId 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserItemRating: async (userId: string, itemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling deleteUserItemRating.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling deleteUserItemRating.');
            }
            const localVarPath = `/Users/{userId}/Items/{itemId}/Rating`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntros: async (userId: string, itemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getIntros.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getIntros.');
            }
            const localVarPath = `/Users/{userId}/Items/{itemId}/Intros`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItem: async (userId: string, itemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getItem.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getItem.');
            }
            const localVarPath = `/Users/{userId}/Items/{itemId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} [parentId] 
         * @param {string} [fields] 
         * @param {string} [includeItemTypes] 
         * @param {boolean} [isPlayed] 
         * @param {boolean} [enableImages] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {boolean} [enableUserData] 
         * @param {number} [limit] 
         * @param {boolean} [groupItems] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestMedia: async (userId: string, parentId?: string, fields?: string, includeItemTypes?: string, isPlayed?: boolean, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: string, enableUserData?: boolean, limit?: number, groupItems?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getLatestMedia.');
            }
            const localVarPath = `/Users/{userId}/Items/Latest`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (parentId !== undefined) {
                localVarQueryParameter['parentId'] = parentId;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (includeItemTypes !== undefined) {
                localVarQueryParameter['includeItemTypes'] = includeItemTypes;
            }

            if (isPlayed !== undefined) {
                localVarQueryParameter['isPlayed'] = isPlayed;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes !== undefined) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (groupItems !== undefined) {
                localVarQueryParameter['groupItems'] = groupItems;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLocalTrailers: async (userId: string, itemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getLocalTrailers.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getLocalTrailers.');
            }
            const localVarPath = `/Users/{userId}/Items/{itemId}/LocalTrailers`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRootFolder: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getRootFolder.');
            }
            const localVarPath = `/Users/{userId}/Items/Root`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpecialFeatures: async (userId: string, itemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getSpecialFeatures.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getSpecialFeatures.');
            }
            const localVarPath = `/Users/{userId}/Items/{itemId}/SpecialFeatures`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markFavoriteItem: async (userId: string, itemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling markFavoriteItem.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling markFavoriteItem.');
            }
            const localVarPath = `/Users/{userId}/FavoriteItems/{itemId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unmarkFavoriteItem: async (userId: string, itemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling unmarkFavoriteItem.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling unmarkFavoriteItem.');
            }
            const localVarPath = `/Users/{userId}/FavoriteItems/{itemId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} itemId 
         * @param {boolean} [likes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserItemRating: async (userId: string, itemId: string, likes?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling updateUserItemRating.');
            }
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling updateUserItemRating.');
            }
            const localVarPath = `/Users/{userId}/Items/{itemId}/Rating`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (likes !== undefined) {
                localVarQueryParameter['likes'] = likes;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserLibraryApi - functional programming interface
 * @export
 */
export const UserLibraryApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} userId 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserItemRating(userId: string, itemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserItemDataDto>> {
            const localVarAxiosArgs = await UserLibraryApiAxiosParamCreator(configuration).deleteUserItemRating(userId, itemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIntros(userId: string, itemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await UserLibraryApiAxiosParamCreator(configuration).getIntros(userId, itemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItem(userId: string, itemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDto>> {
            const localVarAxiosArgs = await UserLibraryApiAxiosParamCreator(configuration).getItem(userId, itemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} [parentId] 
         * @param {string} [fields] 
         * @param {string} [includeItemTypes] 
         * @param {boolean} [isPlayed] 
         * @param {boolean} [enableImages] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {boolean} [enableUserData] 
         * @param {number} [limit] 
         * @param {boolean} [groupItems] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLatestMedia(userId: string, parentId?: string, fields?: string, includeItemTypes?: string, isPlayed?: boolean, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: string, enableUserData?: boolean, limit?: number, groupItems?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BaseItemDto>>> {
            const localVarAxiosArgs = await UserLibraryApiAxiosParamCreator(configuration).getLatestMedia(userId, parentId, fields, includeItemTypes, isPlayed, enableImages, imageTypeLimit, enableImageTypes, enableUserData, limit, groupItems, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLocalTrailers(userId: string, itemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BaseItemDto>>> {
            const localVarAxiosArgs = await UserLibraryApiAxiosParamCreator(configuration).getLocalTrailers(userId, itemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRootFolder(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDto>> {
            const localVarAxiosArgs = await UserLibraryApiAxiosParamCreator(configuration).getRootFolder(userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSpecialFeatures(userId: string, itemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BaseItemDto>>> {
            const localVarAxiosArgs = await UserLibraryApiAxiosParamCreator(configuration).getSpecialFeatures(userId, itemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markFavoriteItem(userId: string, itemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserItemDataDto>> {
            const localVarAxiosArgs = await UserLibraryApiAxiosParamCreator(configuration).markFavoriteItem(userId, itemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unmarkFavoriteItem(userId: string, itemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserItemDataDto>> {
            const localVarAxiosArgs = await UserLibraryApiAxiosParamCreator(configuration).unmarkFavoriteItem(userId, itemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} itemId 
         * @param {boolean} [likes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserItemRating(userId: string, itemId: string, likes?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserItemDataDto>> {
            const localVarAxiosArgs = await UserLibraryApiAxiosParamCreator(configuration).updateUserItemRating(userId, itemId, likes, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UserLibraryApi - factory interface
 * @export
 */
export const UserLibraryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} userId 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserItemRating(userId: string, itemId: string, options?: any): AxiosPromise<UserItemDataDto> {
            return UserLibraryApiFp(configuration).deleteUserItemRating(userId, itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntros(userId: string, itemId: string, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return UserLibraryApiFp(configuration).getIntros(userId, itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItem(userId: string, itemId: string, options?: any): AxiosPromise<BaseItemDto> {
            return UserLibraryApiFp(configuration).getItem(userId, itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} [parentId] 
         * @param {string} [fields] 
         * @param {string} [includeItemTypes] 
         * @param {boolean} [isPlayed] 
         * @param {boolean} [enableImages] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {boolean} [enableUserData] 
         * @param {number} [limit] 
         * @param {boolean} [groupItems] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestMedia(userId: string, parentId?: string, fields?: string, includeItemTypes?: string, isPlayed?: boolean, enableImages?: boolean, imageTypeLimit?: number, enableImageTypes?: string, enableUserData?: boolean, limit?: number, groupItems?: boolean, options?: any): AxiosPromise<Array<BaseItemDto>> {
            return UserLibraryApiFp(configuration).getLatestMedia(userId, parentId, fields, includeItemTypes, isPlayed, enableImages, imageTypeLimit, enableImageTypes, enableUserData, limit, groupItems, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLocalTrailers(userId: string, itemId: string, options?: any): AxiosPromise<Array<BaseItemDto>> {
            return UserLibraryApiFp(configuration).getLocalTrailers(userId, itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRootFolder(userId: string, options?: any): AxiosPromise<BaseItemDto> {
            return UserLibraryApiFp(configuration).getRootFolder(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpecialFeatures(userId: string, itemId: string, options?: any): AxiosPromise<Array<BaseItemDto>> {
            return UserLibraryApiFp(configuration).getSpecialFeatures(userId, itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markFavoriteItem(userId: string, itemId: string, options?: any): AxiosPromise<UserItemDataDto> {
            return UserLibraryApiFp(configuration).markFavoriteItem(userId, itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unmarkFavoriteItem(userId: string, itemId: string, options?: any): AxiosPromise<UserItemDataDto> {
            return UserLibraryApiFp(configuration).unmarkFavoriteItem(userId, itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} itemId 
         * @param {boolean} [likes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserItemRating(userId: string, itemId: string, likes?: boolean, options?: any): AxiosPromise<UserItemDataDto> {
            return UserLibraryApiFp(configuration).updateUserItemRating(userId, itemId, likes, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deleteUserItemRating operation in UserLibraryApi.
 * @export
 * @interface UserLibraryApiDeleteUserItemRatingRequest
 */
export interface UserLibraryApiDeleteUserItemRatingRequest {
    /**
     * 
     * @type {string}
     * @memberof UserLibraryApiDeleteUserItemRating
     */
    readonly userId: string

    /**
     * 
     * @type {string}
     * @memberof UserLibraryApiDeleteUserItemRating
     */
    readonly itemId: string
}

/**
 * Request parameters for getIntros operation in UserLibraryApi.
 * @export
 * @interface UserLibraryApiGetIntrosRequest
 */
export interface UserLibraryApiGetIntrosRequest {
    /**
     * 
     * @type {string}
     * @memberof UserLibraryApiGetIntros
     */
    readonly userId: string

    /**
     * 
     * @type {string}
     * @memberof UserLibraryApiGetIntros
     */
    readonly itemId: string
}

/**
 * Request parameters for getItem operation in UserLibraryApi.
 * @export
 * @interface UserLibraryApiGetItemRequest
 */
export interface UserLibraryApiGetItemRequest {
    /**
     * 
     * @type {string}
     * @memberof UserLibraryApiGetItem
     */
    readonly userId: string

    /**
     * 
     * @type {string}
     * @memberof UserLibraryApiGetItem
     */
    readonly itemId: string
}

/**
 * Request parameters for getLatestMedia operation in UserLibraryApi.
 * @export
 * @interface UserLibraryApiGetLatestMediaRequest
 */
export interface UserLibraryApiGetLatestMediaRequest {
    /**
     * 
     * @type {string}
     * @memberof UserLibraryApiGetLatestMedia
     */
    readonly userId: string

    /**
     * 
     * @type {string}
     * @memberof UserLibraryApiGetLatestMedia
     */
    readonly parentId?: string

    /**
     * 
     * @type {string}
     * @memberof UserLibraryApiGetLatestMedia
     */
    readonly fields?: string

    /**
     * 
     * @type {string}
     * @memberof UserLibraryApiGetLatestMedia
     */
    readonly includeItemTypes?: string

    /**
     * 
     * @type {boolean}
     * @memberof UserLibraryApiGetLatestMedia
     */
    readonly isPlayed?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof UserLibraryApiGetLatestMedia
     */
    readonly enableImages?: boolean

    /**
     * 
     * @type {number}
     * @memberof UserLibraryApiGetLatestMedia
     */
    readonly imageTypeLimit?: number

    /**
     * 
     * @type {string}
     * @memberof UserLibraryApiGetLatestMedia
     */
    readonly enableImageTypes?: string

    /**
     * 
     * @type {boolean}
     * @memberof UserLibraryApiGetLatestMedia
     */
    readonly enableUserData?: boolean

    /**
     * 
     * @type {number}
     * @memberof UserLibraryApiGetLatestMedia
     */
    readonly limit?: number

    /**
     * 
     * @type {boolean}
     * @memberof UserLibraryApiGetLatestMedia
     */
    readonly groupItems?: boolean
}

/**
 * Request parameters for getLocalTrailers operation in UserLibraryApi.
 * @export
 * @interface UserLibraryApiGetLocalTrailersRequest
 */
export interface UserLibraryApiGetLocalTrailersRequest {
    /**
     * 
     * @type {string}
     * @memberof UserLibraryApiGetLocalTrailers
     */
    readonly userId: string

    /**
     * 
     * @type {string}
     * @memberof UserLibraryApiGetLocalTrailers
     */
    readonly itemId: string
}

/**
 * Request parameters for getRootFolder operation in UserLibraryApi.
 * @export
 * @interface UserLibraryApiGetRootFolderRequest
 */
export interface UserLibraryApiGetRootFolderRequest {
    /**
     * 
     * @type {string}
     * @memberof UserLibraryApiGetRootFolder
     */
    readonly userId: string
}

/**
 * Request parameters for getSpecialFeatures operation in UserLibraryApi.
 * @export
 * @interface UserLibraryApiGetSpecialFeaturesRequest
 */
export interface UserLibraryApiGetSpecialFeaturesRequest {
    /**
     * 
     * @type {string}
     * @memberof UserLibraryApiGetSpecialFeatures
     */
    readonly userId: string

    /**
     * 
     * @type {string}
     * @memberof UserLibraryApiGetSpecialFeatures
     */
    readonly itemId: string
}

/**
 * Request parameters for markFavoriteItem operation in UserLibraryApi.
 * @export
 * @interface UserLibraryApiMarkFavoriteItemRequest
 */
export interface UserLibraryApiMarkFavoriteItemRequest {
    /**
     * 
     * @type {string}
     * @memberof UserLibraryApiMarkFavoriteItem
     */
    readonly userId: string

    /**
     * 
     * @type {string}
     * @memberof UserLibraryApiMarkFavoriteItem
     */
    readonly itemId: string
}

/**
 * Request parameters for unmarkFavoriteItem operation in UserLibraryApi.
 * @export
 * @interface UserLibraryApiUnmarkFavoriteItemRequest
 */
export interface UserLibraryApiUnmarkFavoriteItemRequest {
    /**
     * 
     * @type {string}
     * @memberof UserLibraryApiUnmarkFavoriteItem
     */
    readonly userId: string

    /**
     * 
     * @type {string}
     * @memberof UserLibraryApiUnmarkFavoriteItem
     */
    readonly itemId: string
}

/**
 * Request parameters for updateUserItemRating operation in UserLibraryApi.
 * @export
 * @interface UserLibraryApiUpdateUserItemRatingRequest
 */
export interface UserLibraryApiUpdateUserItemRatingRequest {
    /**
     * 
     * @type {string}
     * @memberof UserLibraryApiUpdateUserItemRating
     */
    readonly userId: string

    /**
     * 
     * @type {string}
     * @memberof UserLibraryApiUpdateUserItemRating
     */
    readonly itemId: string

    /**
     * 
     * @type {boolean}
     * @memberof UserLibraryApiUpdateUserItemRating
     */
    readonly likes?: boolean
}

/**
 * UserLibraryApi - object-oriented interface
 * @export
 * @class UserLibraryApi
 * @extends {BaseAPI}
 */
export class UserLibraryApi extends BaseAPI {
    /**
     * 
     * @param {UserLibraryApiDeleteUserItemRatingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserLibraryApi
     */
    public deleteUserItemRating(requestParameters: UserLibraryApiDeleteUserItemRatingRequest, options?: any) {
        return UserLibraryApiFp(this.configuration).deleteUserItemRating(requestParameters.userId, requestParameters.itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserLibraryApiGetIntrosRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserLibraryApi
     */
    public getIntros(requestParameters: UserLibraryApiGetIntrosRequest, options?: any) {
        return UserLibraryApiFp(this.configuration).getIntros(requestParameters.userId, requestParameters.itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserLibraryApiGetItemRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserLibraryApi
     */
    public getItem(requestParameters: UserLibraryApiGetItemRequest, options?: any) {
        return UserLibraryApiFp(this.configuration).getItem(requestParameters.userId, requestParameters.itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserLibraryApiGetLatestMediaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserLibraryApi
     */
    public getLatestMedia(requestParameters: UserLibraryApiGetLatestMediaRequest, options?: any) {
        return UserLibraryApiFp(this.configuration).getLatestMedia(requestParameters.userId, requestParameters.parentId, requestParameters.fields, requestParameters.includeItemTypes, requestParameters.isPlayed, requestParameters.enableImages, requestParameters.imageTypeLimit, requestParameters.enableImageTypes, requestParameters.enableUserData, requestParameters.limit, requestParameters.groupItems, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserLibraryApiGetLocalTrailersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserLibraryApi
     */
    public getLocalTrailers(requestParameters: UserLibraryApiGetLocalTrailersRequest, options?: any) {
        return UserLibraryApiFp(this.configuration).getLocalTrailers(requestParameters.userId, requestParameters.itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserLibraryApiGetRootFolderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserLibraryApi
     */
    public getRootFolder(requestParameters: UserLibraryApiGetRootFolderRequest, options?: any) {
        return UserLibraryApiFp(this.configuration).getRootFolder(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserLibraryApiGetSpecialFeaturesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserLibraryApi
     */
    public getSpecialFeatures(requestParameters: UserLibraryApiGetSpecialFeaturesRequest, options?: any) {
        return UserLibraryApiFp(this.configuration).getSpecialFeatures(requestParameters.userId, requestParameters.itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserLibraryApiMarkFavoriteItemRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserLibraryApi
     */
    public markFavoriteItem(requestParameters: UserLibraryApiMarkFavoriteItemRequest, options?: any) {
        return UserLibraryApiFp(this.configuration).markFavoriteItem(requestParameters.userId, requestParameters.itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserLibraryApiUnmarkFavoriteItemRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserLibraryApi
     */
    public unmarkFavoriteItem(requestParameters: UserLibraryApiUnmarkFavoriteItemRequest, options?: any) {
        return UserLibraryApiFp(this.configuration).unmarkFavoriteItem(requestParameters.userId, requestParameters.itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserLibraryApiUpdateUserItemRatingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserLibraryApi
     */
    public updateUserItemRating(requestParameters: UserLibraryApiUpdateUserItemRatingRequest, options?: any) {
        return UserLibraryApiFp(this.configuration).updateUserItemRating(requestParameters.userId, requestParameters.itemId, requestParameters.likes, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserViewsApi - axios parameter creator
 * @export
 */
export const UserViewsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupingOptions: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getGroupingOptions.');
            }
            const localVarPath = `/Users/{userId}/GroupingOptions`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {boolean} [includeExternalContent] 
         * @param {string} [presetViews] 
         * @param {boolean} [includeHidden] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserViews: async (userId: string, includeExternalContent?: boolean, presetViews?: string, includeHidden?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getUserViews.');
            }
            const localVarPath = `/Users/{userId}/Views`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (includeExternalContent !== undefined) {
                localVarQueryParameter['includeExternalContent'] = includeExternalContent;
            }

            if (presetViews !== undefined) {
                localVarQueryParameter['presetViews'] = presetViews;
            }

            if (includeHidden !== undefined) {
                localVarQueryParameter['includeHidden'] = includeHidden;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserViewsApi - functional programming interface
 * @export
 */
export const UserViewsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupingOptions(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SpecialViewOptionDto>>> {
            const localVarAxiosArgs = await UserViewsApiAxiosParamCreator(configuration).getGroupingOptions(userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {boolean} [includeExternalContent] 
         * @param {string} [presetViews] 
         * @param {boolean} [includeHidden] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserViews(userId: string, includeExternalContent?: boolean, presetViews?: string, includeHidden?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await UserViewsApiAxiosParamCreator(configuration).getUserViews(userId, includeExternalContent, presetViews, includeHidden, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UserViewsApi - factory interface
 * @export
 */
export const UserViewsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupingOptions(userId: string, options?: any): AxiosPromise<Array<SpecialViewOptionDto>> {
            return UserViewsApiFp(configuration).getGroupingOptions(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {boolean} [includeExternalContent] 
         * @param {string} [presetViews] 
         * @param {boolean} [includeHidden] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserViews(userId: string, includeExternalContent?: boolean, presetViews?: string, includeHidden?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return UserViewsApiFp(configuration).getUserViews(userId, includeExternalContent, presetViews, includeHidden, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getGroupingOptions operation in UserViewsApi.
 * @export
 * @interface UserViewsApiGetGroupingOptionsRequest
 */
export interface UserViewsApiGetGroupingOptionsRequest {
    /**
     * 
     * @type {string}
     * @memberof UserViewsApiGetGroupingOptions
     */
    readonly userId: string
}

/**
 * Request parameters for getUserViews operation in UserViewsApi.
 * @export
 * @interface UserViewsApiGetUserViewsRequest
 */
export interface UserViewsApiGetUserViewsRequest {
    /**
     * 
     * @type {string}
     * @memberof UserViewsApiGetUserViews
     */
    readonly userId: string

    /**
     * 
     * @type {boolean}
     * @memberof UserViewsApiGetUserViews
     */
    readonly includeExternalContent?: boolean

    /**
     * 
     * @type {string}
     * @memberof UserViewsApiGetUserViews
     */
    readonly presetViews?: string

    /**
     * 
     * @type {boolean}
     * @memberof UserViewsApiGetUserViews
     */
    readonly includeHidden?: boolean
}

/**
 * UserViewsApi - object-oriented interface
 * @export
 * @class UserViewsApi
 * @extends {BaseAPI}
 */
export class UserViewsApi extends BaseAPI {
    /**
     * 
     * @param {UserViewsApiGetGroupingOptionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserViewsApi
     */
    public getGroupingOptions(requestParameters: UserViewsApiGetGroupingOptionsRequest, options?: any) {
        return UserViewsApiFp(this.configuration).getGroupingOptions(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserViewsApiGetUserViewsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserViewsApi
     */
    public getUserViews(requestParameters: UserViewsApiGetUserViewsRequest, options?: any) {
        return UserViewsApiFp(this.configuration).getUserViews(requestParameters.userId, requestParameters.includeExternalContent, requestParameters.presetViews, requestParameters.includeHidden, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * VideoAttachmentsApi - axios parameter creator
 * @export
 */
export const VideoAttachmentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} videoId 
         * @param {string} mediaSourceId 
         * @param {number} index 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachment: async (videoId: string, mediaSourceId: string, index: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'videoId' is not null or undefined
            if (videoId === null || videoId === undefined) {
                throw new RequiredError('videoId','Required parameter videoId was null or undefined when calling getAttachment.');
            }
            // verify required parameter 'mediaSourceId' is not null or undefined
            if (mediaSourceId === null || mediaSourceId === undefined) {
                throw new RequiredError('mediaSourceId','Required parameter mediaSourceId was null or undefined when calling getAttachment.');
            }
            // verify required parameter 'index' is not null or undefined
            if (index === null || index === undefined) {
                throw new RequiredError('index','Required parameter index was null or undefined when calling getAttachment.');
            }
            const localVarPath = `/Videos/{videoId}/{mediaSourceId}/Attachments/{index}`
                .replace(`{${"videoId"}}`, encodeURIComponent(String(videoId)))
                .replace(`{${"mediaSourceId"}}`, encodeURIComponent(String(mediaSourceId)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VideoAttachmentsApi - functional programming interface
 * @export
 */
export const VideoAttachmentsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} videoId 
         * @param {string} mediaSourceId 
         * @param {number} index 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAttachment(videoId: string, mediaSourceId: string, index: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await VideoAttachmentsApiAxiosParamCreator(configuration).getAttachment(videoId, mediaSourceId, index, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * VideoAttachmentsApi - factory interface
 * @export
 */
export const VideoAttachmentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} videoId 
         * @param {string} mediaSourceId 
         * @param {number} index 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachment(videoId: string, mediaSourceId: string, index: number, options?: any): AxiosPromise<any> {
            return VideoAttachmentsApiFp(configuration).getAttachment(videoId, mediaSourceId, index, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getAttachment operation in VideoAttachmentsApi.
 * @export
 * @interface VideoAttachmentsApiGetAttachmentRequest
 */
export interface VideoAttachmentsApiGetAttachmentRequest {
    /**
     * 
     * @type {string}
     * @memberof VideoAttachmentsApiGetAttachment
     */
    readonly videoId: string

    /**
     * 
     * @type {string}
     * @memberof VideoAttachmentsApiGetAttachment
     */
    readonly mediaSourceId: string

    /**
     * 
     * @type {number}
     * @memberof VideoAttachmentsApiGetAttachment
     */
    readonly index: number
}

/**
 * VideoAttachmentsApi - object-oriented interface
 * @export
 * @class VideoAttachmentsApi
 * @extends {BaseAPI}
 */
export class VideoAttachmentsApi extends BaseAPI {
    /**
     * 
     * @param {VideoAttachmentsApiGetAttachmentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideoAttachmentsApi
     */
    public getAttachment(requestParameters: VideoAttachmentsApiGetAttachmentRequest, options?: any) {
        return VideoAttachmentsApiFp(this.configuration).getAttachment(requestParameters.videoId, requestParameters.mediaSourceId, requestParameters.index, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * VideoHlsApi - axios parameter creator
 * @export
 */
export const VideoHlsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} itemId 
         * @param {string} [container] 
         * @param {boolean} [_static] 
         * @param {string} [params] 
         * @param {string} [tag] 
         * @param {string} [deviceProfileId] 
         * @param {string} [playSessionId] 
         * @param {string} [segmentContainer] 
         * @param {number} [segmentLength] 
         * @param {number} [minSegments] 
         * @param {string} [mediaSourceId] 
         * @param {string} [deviceId] 
         * @param {string} [audioCodec] 
         * @param {boolean} [enableAutoStreamCopy] 
         * @param {boolean} [allowVideoStreamCopy] 
         * @param {boolean} [allowAudioStreamCopy] 
         * @param {boolean} [breakOnNonKeyFrames] 
         * @param {number} [audioSampleRate] 
         * @param {number} [maxAudioBitDepth] 
         * @param {number} [audioBitRate] 
         * @param {number} [audioChannels] 
         * @param {number} [maxAudioChannels] 
         * @param {string} [profile] 
         * @param {string} [level] 
         * @param {number} [framerate] 
         * @param {number} [maxFramerate] 
         * @param {boolean} [copyTimestamps] 
         * @param {number} [startTimeTicks] 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [videoBitRate] 
         * @param {number} [subtitleStreamIndex] 
         * @param {SubtitleDeliveryMethod} [subtitleMethod] 
         * @param {number} [maxRefFrames] 
         * @param {number} [maxVideoBitDepth] 
         * @param {boolean} [requireAvc] 
         * @param {boolean} [deInterlace] 
         * @param {boolean} [requireNonAnamorphic] 
         * @param {number} [transcodingMaxAudioChannels] 
         * @param {number} [cpuCoreLimit] 
         * @param {string} [liveStreamId] 
         * @param {boolean} [enableMpegtsM2TsMode] 
         * @param {string} [videoCodec] 
         * @param {string} [subtitleCodec] 
         * @param {string} [transcodingReasons] 
         * @param {number} [audioStreamIndex] 
         * @param {number} [videoStreamIndex] 
         * @param {EncodingContext} [context] 
         * @param {{ [key: string]: string; }} [streamOptions] 
         * @param {number} [maxWidth] 
         * @param {number} [maxHeight] 
         * @param {boolean} [enableSubtitlesInManifest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveHlsStream: async (itemId: string, container?: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, maxWidth?: number, maxHeight?: number, enableSubtitlesInManifest?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getLiveHlsStream.');
            }
            const localVarPath = `/Videos/{itemId}/live.m3u8`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (container !== undefined) {
                localVarQueryParameter['container'] = container;
            }

            if (_static !== undefined) {
                localVarQueryParameter['static'] = _static;
            }

            if (params !== undefined) {
                localVarQueryParameter['params'] = params;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (deviceProfileId !== undefined) {
                localVarQueryParameter['deviceProfileId'] = deviceProfileId;
            }

            if (playSessionId !== undefined) {
                localVarQueryParameter['playSessionId'] = playSessionId;
            }

            if (segmentContainer !== undefined) {
                localVarQueryParameter['segmentContainer'] = segmentContainer;
            }

            if (segmentLength !== undefined) {
                localVarQueryParameter['segmentLength'] = segmentLength;
            }

            if (minSegments !== undefined) {
                localVarQueryParameter['minSegments'] = minSegments;
            }

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['mediaSourceId'] = mediaSourceId;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (audioCodec !== undefined) {
                localVarQueryParameter['audioCodec'] = audioCodec;
            }

            if (enableAutoStreamCopy !== undefined) {
                localVarQueryParameter['enableAutoStreamCopy'] = enableAutoStreamCopy;
            }

            if (allowVideoStreamCopy !== undefined) {
                localVarQueryParameter['allowVideoStreamCopy'] = allowVideoStreamCopy;
            }

            if (allowAudioStreamCopy !== undefined) {
                localVarQueryParameter['allowAudioStreamCopy'] = allowAudioStreamCopy;
            }

            if (breakOnNonKeyFrames !== undefined) {
                localVarQueryParameter['breakOnNonKeyFrames'] = breakOnNonKeyFrames;
            }

            if (audioSampleRate !== undefined) {
                localVarQueryParameter['audioSampleRate'] = audioSampleRate;
            }

            if (maxAudioBitDepth !== undefined) {
                localVarQueryParameter['maxAudioBitDepth'] = maxAudioBitDepth;
            }

            if (audioBitRate !== undefined) {
                localVarQueryParameter['audioBitRate'] = audioBitRate;
            }

            if (audioChannels !== undefined) {
                localVarQueryParameter['audioChannels'] = audioChannels;
            }

            if (maxAudioChannels !== undefined) {
                localVarQueryParameter['maxAudioChannels'] = maxAudioChannels;
            }

            if (profile !== undefined) {
                localVarQueryParameter['profile'] = profile;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (framerate !== undefined) {
                localVarQueryParameter['framerate'] = framerate;
            }

            if (maxFramerate !== undefined) {
                localVarQueryParameter['maxFramerate'] = maxFramerate;
            }

            if (copyTimestamps !== undefined) {
                localVarQueryParameter['copyTimestamps'] = copyTimestamps;
            }

            if (startTimeTicks !== undefined) {
                localVarQueryParameter['startTimeTicks'] = startTimeTicks;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (videoBitRate !== undefined) {
                localVarQueryParameter['videoBitRate'] = videoBitRate;
            }

            if (subtitleStreamIndex !== undefined) {
                localVarQueryParameter['subtitleStreamIndex'] = subtitleStreamIndex;
            }

            if (subtitleMethod !== undefined) {
                localVarQueryParameter['subtitleMethod'] = subtitleMethod;
            }

            if (maxRefFrames !== undefined) {
                localVarQueryParameter['maxRefFrames'] = maxRefFrames;
            }

            if (maxVideoBitDepth !== undefined) {
                localVarQueryParameter['maxVideoBitDepth'] = maxVideoBitDepth;
            }

            if (requireAvc !== undefined) {
                localVarQueryParameter['requireAvc'] = requireAvc;
            }

            if (deInterlace !== undefined) {
                localVarQueryParameter['deInterlace'] = deInterlace;
            }

            if (requireNonAnamorphic !== undefined) {
                localVarQueryParameter['requireNonAnamorphic'] = requireNonAnamorphic;
            }

            if (transcodingMaxAudioChannels !== undefined) {
                localVarQueryParameter['transcodingMaxAudioChannels'] = transcodingMaxAudioChannels;
            }

            if (cpuCoreLimit !== undefined) {
                localVarQueryParameter['cpuCoreLimit'] = cpuCoreLimit;
            }

            if (liveStreamId !== undefined) {
                localVarQueryParameter['liveStreamId'] = liveStreamId;
            }

            if (enableMpegtsM2TsMode !== undefined) {
                localVarQueryParameter['enableMpegtsM2TsMode'] = enableMpegtsM2TsMode;
            }

            if (videoCodec !== undefined) {
                localVarQueryParameter['videoCodec'] = videoCodec;
            }

            if (subtitleCodec !== undefined) {
                localVarQueryParameter['subtitleCodec'] = subtitleCodec;
            }

            if (transcodingReasons !== undefined) {
                localVarQueryParameter['transcodingReasons'] = transcodingReasons;
            }

            if (audioStreamIndex !== undefined) {
                localVarQueryParameter['audioStreamIndex'] = audioStreamIndex;
            }

            if (videoStreamIndex !== undefined) {
                localVarQueryParameter['videoStreamIndex'] = videoStreamIndex;
            }

            if (context !== undefined) {
                localVarQueryParameter['context'] = context;
            }

            if (streamOptions !== undefined) {
                localVarQueryParameter['streamOptions'] = streamOptions;
            }

            if (maxWidth !== undefined) {
                localVarQueryParameter['maxWidth'] = maxWidth;
            }

            if (maxHeight !== undefined) {
                localVarQueryParameter['maxHeight'] = maxHeight;
            }

            if (enableSubtitlesInManifest !== undefined) {
                localVarQueryParameter['enableSubtitlesInManifest'] = enableSubtitlesInManifest;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VideoHlsApi - functional programming interface
 * @export
 */
export const VideoHlsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} itemId 
         * @param {string} [container] 
         * @param {boolean} [_static] 
         * @param {string} [params] 
         * @param {string} [tag] 
         * @param {string} [deviceProfileId] 
         * @param {string} [playSessionId] 
         * @param {string} [segmentContainer] 
         * @param {number} [segmentLength] 
         * @param {number} [minSegments] 
         * @param {string} [mediaSourceId] 
         * @param {string} [deviceId] 
         * @param {string} [audioCodec] 
         * @param {boolean} [enableAutoStreamCopy] 
         * @param {boolean} [allowVideoStreamCopy] 
         * @param {boolean} [allowAudioStreamCopy] 
         * @param {boolean} [breakOnNonKeyFrames] 
         * @param {number} [audioSampleRate] 
         * @param {number} [maxAudioBitDepth] 
         * @param {number} [audioBitRate] 
         * @param {number} [audioChannels] 
         * @param {number} [maxAudioChannels] 
         * @param {string} [profile] 
         * @param {string} [level] 
         * @param {number} [framerate] 
         * @param {number} [maxFramerate] 
         * @param {boolean} [copyTimestamps] 
         * @param {number} [startTimeTicks] 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [videoBitRate] 
         * @param {number} [subtitleStreamIndex] 
         * @param {SubtitleDeliveryMethod} [subtitleMethod] 
         * @param {number} [maxRefFrames] 
         * @param {number} [maxVideoBitDepth] 
         * @param {boolean} [requireAvc] 
         * @param {boolean} [deInterlace] 
         * @param {boolean} [requireNonAnamorphic] 
         * @param {number} [transcodingMaxAudioChannels] 
         * @param {number} [cpuCoreLimit] 
         * @param {string} [liveStreamId] 
         * @param {boolean} [enableMpegtsM2TsMode] 
         * @param {string} [videoCodec] 
         * @param {string} [subtitleCodec] 
         * @param {string} [transcodingReasons] 
         * @param {number} [audioStreamIndex] 
         * @param {number} [videoStreamIndex] 
         * @param {EncodingContext} [context] 
         * @param {{ [key: string]: string; }} [streamOptions] 
         * @param {number} [maxWidth] 
         * @param {number} [maxHeight] 
         * @param {boolean} [enableSubtitlesInManifest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLiveHlsStream(itemId: string, container?: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, maxWidth?: number, maxHeight?: number, enableSubtitlesInManifest?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await VideoHlsApiAxiosParamCreator(configuration).getLiveHlsStream(itemId, container, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, maxWidth, maxHeight, enableSubtitlesInManifest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * VideoHlsApi - factory interface
 * @export
 */
export const VideoHlsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} itemId 
         * @param {string} [container] 
         * @param {boolean} [_static] 
         * @param {string} [params] 
         * @param {string} [tag] 
         * @param {string} [deviceProfileId] 
         * @param {string} [playSessionId] 
         * @param {string} [segmentContainer] 
         * @param {number} [segmentLength] 
         * @param {number} [minSegments] 
         * @param {string} [mediaSourceId] 
         * @param {string} [deviceId] 
         * @param {string} [audioCodec] 
         * @param {boolean} [enableAutoStreamCopy] 
         * @param {boolean} [allowVideoStreamCopy] 
         * @param {boolean} [allowAudioStreamCopy] 
         * @param {boolean} [breakOnNonKeyFrames] 
         * @param {number} [audioSampleRate] 
         * @param {number} [maxAudioBitDepth] 
         * @param {number} [audioBitRate] 
         * @param {number} [audioChannels] 
         * @param {number} [maxAudioChannels] 
         * @param {string} [profile] 
         * @param {string} [level] 
         * @param {number} [framerate] 
         * @param {number} [maxFramerate] 
         * @param {boolean} [copyTimestamps] 
         * @param {number} [startTimeTicks] 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [videoBitRate] 
         * @param {number} [subtitleStreamIndex] 
         * @param {SubtitleDeliveryMethod} [subtitleMethod] 
         * @param {number} [maxRefFrames] 
         * @param {number} [maxVideoBitDepth] 
         * @param {boolean} [requireAvc] 
         * @param {boolean} [deInterlace] 
         * @param {boolean} [requireNonAnamorphic] 
         * @param {number} [transcodingMaxAudioChannels] 
         * @param {number} [cpuCoreLimit] 
         * @param {string} [liveStreamId] 
         * @param {boolean} [enableMpegtsM2TsMode] 
         * @param {string} [videoCodec] 
         * @param {string} [subtitleCodec] 
         * @param {string} [transcodingReasons] 
         * @param {number} [audioStreamIndex] 
         * @param {number} [videoStreamIndex] 
         * @param {EncodingContext} [context] 
         * @param {{ [key: string]: string; }} [streamOptions] 
         * @param {number} [maxWidth] 
         * @param {number} [maxHeight] 
         * @param {boolean} [enableSubtitlesInManifest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiveHlsStream(itemId: string, container?: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, maxWidth?: number, maxHeight?: number, enableSubtitlesInManifest?: boolean, options?: any): AxiosPromise<void> {
            return VideoHlsApiFp(configuration).getLiveHlsStream(itemId, container, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, maxWidth, maxHeight, enableSubtitlesInManifest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getLiveHlsStream operation in VideoHlsApi.
 * @export
 * @interface VideoHlsApiGetLiveHlsStreamRequest
 */
export interface VideoHlsApiGetLiveHlsStreamRequest {
    /**
     * 
     * @type {string}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly itemId: string

    /**
     * 
     * @type {string}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly container?: string

    /**
     * 
     * @type {boolean}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly _static?: boolean

    /**
     * 
     * @type {string}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly params?: string

    /**
     * 
     * @type {string}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly deviceProfileId?: string

    /**
     * 
     * @type {string}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly playSessionId?: string

    /**
     * 
     * @type {string}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly segmentContainer?: string

    /**
     * 
     * @type {number}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly segmentLength?: number

    /**
     * 
     * @type {number}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly minSegments?: number

    /**
     * 
     * @type {string}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly mediaSourceId?: string

    /**
     * 
     * @type {string}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly deviceId?: string

    /**
     * 
     * @type {string}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly audioCodec?: string

    /**
     * 
     * @type {boolean}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly enableAutoStreamCopy?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly allowVideoStreamCopy?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly allowAudioStreamCopy?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly breakOnNonKeyFrames?: boolean

    /**
     * 
     * @type {number}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly audioSampleRate?: number

    /**
     * 
     * @type {number}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly maxAudioBitDepth?: number

    /**
     * 
     * @type {number}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly audioBitRate?: number

    /**
     * 
     * @type {number}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly audioChannels?: number

    /**
     * 
     * @type {number}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly maxAudioChannels?: number

    /**
     * 
     * @type {string}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly profile?: string

    /**
     * 
     * @type {string}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly level?: string

    /**
     * 
     * @type {number}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly framerate?: number

    /**
     * 
     * @type {number}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly maxFramerate?: number

    /**
     * 
     * @type {boolean}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly copyTimestamps?: boolean

    /**
     * 
     * @type {number}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly startTimeTicks?: number

    /**
     * 
     * @type {number}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly width?: number

    /**
     * 
     * @type {number}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly height?: number

    /**
     * 
     * @type {number}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly videoBitRate?: number

    /**
     * 
     * @type {number}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly subtitleStreamIndex?: number

    /**
     * 
     * @type {SubtitleDeliveryMethod}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly subtitleMethod?: SubtitleDeliveryMethod

    /**
     * 
     * @type {number}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly maxRefFrames?: number

    /**
     * 
     * @type {number}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly maxVideoBitDepth?: number

    /**
     * 
     * @type {boolean}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly requireAvc?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly deInterlace?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly requireNonAnamorphic?: boolean

    /**
     * 
     * @type {number}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly transcodingMaxAudioChannels?: number

    /**
     * 
     * @type {number}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly cpuCoreLimit?: number

    /**
     * 
     * @type {string}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly liveStreamId?: string

    /**
     * 
     * @type {boolean}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly enableMpegtsM2TsMode?: boolean

    /**
     * 
     * @type {string}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly videoCodec?: string

    /**
     * 
     * @type {string}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly subtitleCodec?: string

    /**
     * 
     * @type {string}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly transcodingReasons?: string

    /**
     * 
     * @type {number}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly audioStreamIndex?: number

    /**
     * 
     * @type {number}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly videoStreamIndex?: number

    /**
     * 
     * @type {EncodingContext}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly context?: EncodingContext

    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly streamOptions?: { [key: string]: string; }

    /**
     * 
     * @type {number}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly maxWidth?: number

    /**
     * 
     * @type {number}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly maxHeight?: number

    /**
     * 
     * @type {boolean}
     * @memberof VideoHlsApiGetLiveHlsStream
     */
    readonly enableSubtitlesInManifest?: boolean
}

/**
 * VideoHlsApi - object-oriented interface
 * @export
 * @class VideoHlsApi
 * @extends {BaseAPI}
 */
export class VideoHlsApi extends BaseAPI {
    /**
     * 
     * @param {VideoHlsApiGetLiveHlsStreamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideoHlsApi
     */
    public getLiveHlsStream(requestParameters: VideoHlsApiGetLiveHlsStreamRequest, options?: any) {
        return VideoHlsApiFp(this.configuration).getLiveHlsStream(requestParameters.itemId, requestParameters.container, requestParameters._static, requestParameters.params, requestParameters.tag, requestParameters.deviceProfileId, requestParameters.playSessionId, requestParameters.segmentContainer, requestParameters.segmentLength, requestParameters.minSegments, requestParameters.mediaSourceId, requestParameters.deviceId, requestParameters.audioCodec, requestParameters.enableAutoStreamCopy, requestParameters.allowVideoStreamCopy, requestParameters.allowAudioStreamCopy, requestParameters.breakOnNonKeyFrames, requestParameters.audioSampleRate, requestParameters.maxAudioBitDepth, requestParameters.audioBitRate, requestParameters.audioChannels, requestParameters.maxAudioChannels, requestParameters.profile, requestParameters.level, requestParameters.framerate, requestParameters.maxFramerate, requestParameters.copyTimestamps, requestParameters.startTimeTicks, requestParameters.width, requestParameters.height, requestParameters.videoBitRate, requestParameters.subtitleStreamIndex, requestParameters.subtitleMethod, requestParameters.maxRefFrames, requestParameters.maxVideoBitDepth, requestParameters.requireAvc, requestParameters.deInterlace, requestParameters.requireNonAnamorphic, requestParameters.transcodingMaxAudioChannels, requestParameters.cpuCoreLimit, requestParameters.liveStreamId, requestParameters.enableMpegtsM2TsMode, requestParameters.videoCodec, requestParameters.subtitleCodec, requestParameters.transcodingReasons, requestParameters.audioStreamIndex, requestParameters.videoStreamIndex, requestParameters.context, requestParameters.streamOptions, requestParameters.maxWidth, requestParameters.maxHeight, requestParameters.enableSubtitlesInManifest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * VideosApi - axios parameter creator
 * @export
 */
export const VideosApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlternateSources: async (itemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling deleteAlternateSources.');
            }
            const localVarPath = `/Videos/{itemId}/AlternateSources`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdditionalPart: async (itemId: string, userId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getAdditionalPart.');
            }
            const localVarPath = `/Videos/{itemId}/AdditionalParts`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} container 
         * @param {boolean} [_static] 
         * @param {string} [params] 
         * @param {string} [tag] 
         * @param {string} [deviceProfileId] 
         * @param {string} [playSessionId] 
         * @param {string} [segmentContainer] 
         * @param {number} [segmentLength] 
         * @param {number} [minSegments] 
         * @param {string} [mediaSourceId] 
         * @param {string} [deviceId] 
         * @param {string} [audioCodec] 
         * @param {boolean} [enableAutoStreamCopy] 
         * @param {boolean} [allowVideoStreamCopy] 
         * @param {boolean} [allowAudioStreamCopy] 
         * @param {boolean} [breakOnNonKeyFrames] 
         * @param {number} [audioSampleRate] 
         * @param {number} [maxAudioBitDepth] 
         * @param {number} [audioBitRate] 
         * @param {number} [audioChannels] 
         * @param {number} [maxAudioChannels] 
         * @param {string} [profile] 
         * @param {string} [level] 
         * @param {number} [framerate] 
         * @param {number} [maxFramerate] 
         * @param {boolean} [copyTimestamps] 
         * @param {number} [startTimeTicks] 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [videoBitRate] 
         * @param {number} [subtitleStreamIndex] 
         * @param {SubtitleDeliveryMethod} [subtitleMethod] 
         * @param {number} [maxRefFrames] 
         * @param {number} [maxVideoBitDepth] 
         * @param {boolean} [requireAvc] 
         * @param {boolean} [deInterlace] 
         * @param {boolean} [requireNonAnamorphic] 
         * @param {number} [transcodingMaxAudioChannels] 
         * @param {number} [cpuCoreLimit] 
         * @param {string} [liveStreamId] 
         * @param {boolean} [enableMpegtsM2TsMode] 
         * @param {string} [videoCodec] 
         * @param {string} [subtitleCodec] 
         * @param {string} [transcodingReasons] 
         * @param {number} [audioStreamIndex] 
         * @param {number} [videoStreamIndex] 
         * @param {EncodingContext} [context] 
         * @param {{ [key: string]: string; }} [streamOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVideoStream: async (itemId: string, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getVideoStream.');
            }
            // verify required parameter 'container' is not null or undefined
            if (container === null || container === undefined) {
                throw new RequiredError('container','Required parameter container was null or undefined when calling getVideoStream.');
            }
            const localVarPath = `/Videos/{itemId}/stream`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"container"}}`, encodeURIComponent(String(container)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (_static !== undefined) {
                localVarQueryParameter['static'] = _static;
            }

            if (params !== undefined) {
                localVarQueryParameter['params'] = params;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (deviceProfileId !== undefined) {
                localVarQueryParameter['deviceProfileId'] = deviceProfileId;
            }

            if (playSessionId !== undefined) {
                localVarQueryParameter['playSessionId'] = playSessionId;
            }

            if (segmentContainer !== undefined) {
                localVarQueryParameter['segmentContainer'] = segmentContainer;
            }

            if (segmentLength !== undefined) {
                localVarQueryParameter['segmentLength'] = segmentLength;
            }

            if (minSegments !== undefined) {
                localVarQueryParameter['minSegments'] = minSegments;
            }

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['mediaSourceId'] = mediaSourceId;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (audioCodec !== undefined) {
                localVarQueryParameter['audioCodec'] = audioCodec;
            }

            if (enableAutoStreamCopy !== undefined) {
                localVarQueryParameter['enableAutoStreamCopy'] = enableAutoStreamCopy;
            }

            if (allowVideoStreamCopy !== undefined) {
                localVarQueryParameter['allowVideoStreamCopy'] = allowVideoStreamCopy;
            }

            if (allowAudioStreamCopy !== undefined) {
                localVarQueryParameter['allowAudioStreamCopy'] = allowAudioStreamCopy;
            }

            if (breakOnNonKeyFrames !== undefined) {
                localVarQueryParameter['breakOnNonKeyFrames'] = breakOnNonKeyFrames;
            }

            if (audioSampleRate !== undefined) {
                localVarQueryParameter['audioSampleRate'] = audioSampleRate;
            }

            if (maxAudioBitDepth !== undefined) {
                localVarQueryParameter['maxAudioBitDepth'] = maxAudioBitDepth;
            }

            if (audioBitRate !== undefined) {
                localVarQueryParameter['audioBitRate'] = audioBitRate;
            }

            if (audioChannels !== undefined) {
                localVarQueryParameter['audioChannels'] = audioChannels;
            }

            if (maxAudioChannels !== undefined) {
                localVarQueryParameter['maxAudioChannels'] = maxAudioChannels;
            }

            if (profile !== undefined) {
                localVarQueryParameter['profile'] = profile;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (framerate !== undefined) {
                localVarQueryParameter['framerate'] = framerate;
            }

            if (maxFramerate !== undefined) {
                localVarQueryParameter['maxFramerate'] = maxFramerate;
            }

            if (copyTimestamps !== undefined) {
                localVarQueryParameter['copyTimestamps'] = copyTimestamps;
            }

            if (startTimeTicks !== undefined) {
                localVarQueryParameter['startTimeTicks'] = startTimeTicks;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (videoBitRate !== undefined) {
                localVarQueryParameter['videoBitRate'] = videoBitRate;
            }

            if (subtitleStreamIndex !== undefined) {
                localVarQueryParameter['subtitleStreamIndex'] = subtitleStreamIndex;
            }

            if (subtitleMethod !== undefined) {
                localVarQueryParameter['subtitleMethod'] = subtitleMethod;
            }

            if (maxRefFrames !== undefined) {
                localVarQueryParameter['maxRefFrames'] = maxRefFrames;
            }

            if (maxVideoBitDepth !== undefined) {
                localVarQueryParameter['maxVideoBitDepth'] = maxVideoBitDepth;
            }

            if (requireAvc !== undefined) {
                localVarQueryParameter['requireAvc'] = requireAvc;
            }

            if (deInterlace !== undefined) {
                localVarQueryParameter['deInterlace'] = deInterlace;
            }

            if (requireNonAnamorphic !== undefined) {
                localVarQueryParameter['requireNonAnamorphic'] = requireNonAnamorphic;
            }

            if (transcodingMaxAudioChannels !== undefined) {
                localVarQueryParameter['transcodingMaxAudioChannels'] = transcodingMaxAudioChannels;
            }

            if (cpuCoreLimit !== undefined) {
                localVarQueryParameter['cpuCoreLimit'] = cpuCoreLimit;
            }

            if (liveStreamId !== undefined) {
                localVarQueryParameter['liveStreamId'] = liveStreamId;
            }

            if (enableMpegtsM2TsMode !== undefined) {
                localVarQueryParameter['enableMpegtsM2TsMode'] = enableMpegtsM2TsMode;
            }

            if (videoCodec !== undefined) {
                localVarQueryParameter['videoCodec'] = videoCodec;
            }

            if (subtitleCodec !== undefined) {
                localVarQueryParameter['subtitleCodec'] = subtitleCodec;
            }

            if (transcodingReasons !== undefined) {
                localVarQueryParameter['transcodingReasons'] = transcodingReasons;
            }

            if (audioStreamIndex !== undefined) {
                localVarQueryParameter['audioStreamIndex'] = audioStreamIndex;
            }

            if (videoStreamIndex !== undefined) {
                localVarQueryParameter['videoStreamIndex'] = videoStreamIndex;
            }

            if (context !== undefined) {
                localVarQueryParameter['context'] = context;
            }

            if (streamOptions !== undefined) {
                localVarQueryParameter['streamOptions'] = streamOptions;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} container 
         * @param {string} stream 
         * @param {boolean} [_static] 
         * @param {string} [params] 
         * @param {string} [tag] 
         * @param {string} [deviceProfileId] 
         * @param {string} [playSessionId] 
         * @param {string} [segmentContainer] 
         * @param {number} [segmentLength] 
         * @param {number} [minSegments] 
         * @param {string} [mediaSourceId] 
         * @param {string} [deviceId] 
         * @param {string} [audioCodec] 
         * @param {boolean} [enableAutoStreamCopy] 
         * @param {boolean} [allowVideoStreamCopy] 
         * @param {boolean} [allowAudioStreamCopy] 
         * @param {boolean} [breakOnNonKeyFrames] 
         * @param {number} [audioSampleRate] 
         * @param {number} [maxAudioBitDepth] 
         * @param {number} [audioBitRate] 
         * @param {number} [audioChannels] 
         * @param {number} [maxAudioChannels] 
         * @param {string} [profile] 
         * @param {string} [level] 
         * @param {number} [framerate] 
         * @param {number} [maxFramerate] 
         * @param {boolean} [copyTimestamps] 
         * @param {number} [startTimeTicks] 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [videoBitRate] 
         * @param {number} [subtitleStreamIndex] 
         * @param {SubtitleDeliveryMethod} [subtitleMethod] 
         * @param {number} [maxRefFrames] 
         * @param {number} [maxVideoBitDepth] 
         * @param {boolean} [requireAvc] 
         * @param {boolean} [deInterlace] 
         * @param {boolean} [requireNonAnamorphic] 
         * @param {number} [transcodingMaxAudioChannels] 
         * @param {number} [cpuCoreLimit] 
         * @param {string} [liveStreamId] 
         * @param {boolean} [enableMpegtsM2TsMode] 
         * @param {string} [videoCodec] 
         * @param {string} [subtitleCodec] 
         * @param {string} [transcodingReasons] 
         * @param {number} [audioStreamIndex] 
         * @param {number} [videoStreamIndex] 
         * @param {EncodingContext} [context] 
         * @param {{ [key: string]: string; }} [streamOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVideoStream2: async (itemId: string, container: string, stream: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getVideoStream2.');
            }
            // verify required parameter 'container' is not null or undefined
            if (container === null || container === undefined) {
                throw new RequiredError('container','Required parameter container was null or undefined when calling getVideoStream2.');
            }
            // verify required parameter 'stream' is not null or undefined
            if (stream === null || stream === undefined) {
                throw new RequiredError('stream','Required parameter stream was null or undefined when calling getVideoStream2.');
            }
            const localVarPath = `/Videos/{itemId}/{stream}.{container}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"container"}}`, encodeURIComponent(String(container)))
                .replace(`{${"stream"}}`, encodeURIComponent(String(stream)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (_static !== undefined) {
                localVarQueryParameter['static'] = _static;
            }

            if (params !== undefined) {
                localVarQueryParameter['params'] = params;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (deviceProfileId !== undefined) {
                localVarQueryParameter['deviceProfileId'] = deviceProfileId;
            }

            if (playSessionId !== undefined) {
                localVarQueryParameter['playSessionId'] = playSessionId;
            }

            if (segmentContainer !== undefined) {
                localVarQueryParameter['segmentContainer'] = segmentContainer;
            }

            if (segmentLength !== undefined) {
                localVarQueryParameter['segmentLength'] = segmentLength;
            }

            if (minSegments !== undefined) {
                localVarQueryParameter['minSegments'] = minSegments;
            }

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['mediaSourceId'] = mediaSourceId;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (audioCodec !== undefined) {
                localVarQueryParameter['audioCodec'] = audioCodec;
            }

            if (enableAutoStreamCopy !== undefined) {
                localVarQueryParameter['enableAutoStreamCopy'] = enableAutoStreamCopy;
            }

            if (allowVideoStreamCopy !== undefined) {
                localVarQueryParameter['allowVideoStreamCopy'] = allowVideoStreamCopy;
            }

            if (allowAudioStreamCopy !== undefined) {
                localVarQueryParameter['allowAudioStreamCopy'] = allowAudioStreamCopy;
            }

            if (breakOnNonKeyFrames !== undefined) {
                localVarQueryParameter['breakOnNonKeyFrames'] = breakOnNonKeyFrames;
            }

            if (audioSampleRate !== undefined) {
                localVarQueryParameter['audioSampleRate'] = audioSampleRate;
            }

            if (maxAudioBitDepth !== undefined) {
                localVarQueryParameter['maxAudioBitDepth'] = maxAudioBitDepth;
            }

            if (audioBitRate !== undefined) {
                localVarQueryParameter['audioBitRate'] = audioBitRate;
            }

            if (audioChannels !== undefined) {
                localVarQueryParameter['audioChannels'] = audioChannels;
            }

            if (maxAudioChannels !== undefined) {
                localVarQueryParameter['maxAudioChannels'] = maxAudioChannels;
            }

            if (profile !== undefined) {
                localVarQueryParameter['profile'] = profile;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (framerate !== undefined) {
                localVarQueryParameter['framerate'] = framerate;
            }

            if (maxFramerate !== undefined) {
                localVarQueryParameter['maxFramerate'] = maxFramerate;
            }

            if (copyTimestamps !== undefined) {
                localVarQueryParameter['copyTimestamps'] = copyTimestamps;
            }

            if (startTimeTicks !== undefined) {
                localVarQueryParameter['startTimeTicks'] = startTimeTicks;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (videoBitRate !== undefined) {
                localVarQueryParameter['videoBitRate'] = videoBitRate;
            }

            if (subtitleStreamIndex !== undefined) {
                localVarQueryParameter['subtitleStreamIndex'] = subtitleStreamIndex;
            }

            if (subtitleMethod !== undefined) {
                localVarQueryParameter['subtitleMethod'] = subtitleMethod;
            }

            if (maxRefFrames !== undefined) {
                localVarQueryParameter['maxRefFrames'] = maxRefFrames;
            }

            if (maxVideoBitDepth !== undefined) {
                localVarQueryParameter['maxVideoBitDepth'] = maxVideoBitDepth;
            }

            if (requireAvc !== undefined) {
                localVarQueryParameter['requireAvc'] = requireAvc;
            }

            if (deInterlace !== undefined) {
                localVarQueryParameter['deInterlace'] = deInterlace;
            }

            if (requireNonAnamorphic !== undefined) {
                localVarQueryParameter['requireNonAnamorphic'] = requireNonAnamorphic;
            }

            if (transcodingMaxAudioChannels !== undefined) {
                localVarQueryParameter['transcodingMaxAudioChannels'] = transcodingMaxAudioChannels;
            }

            if (cpuCoreLimit !== undefined) {
                localVarQueryParameter['cpuCoreLimit'] = cpuCoreLimit;
            }

            if (liveStreamId !== undefined) {
                localVarQueryParameter['liveStreamId'] = liveStreamId;
            }

            if (enableMpegtsM2TsMode !== undefined) {
                localVarQueryParameter['enableMpegtsM2TsMode'] = enableMpegtsM2TsMode;
            }

            if (videoCodec !== undefined) {
                localVarQueryParameter['videoCodec'] = videoCodec;
            }

            if (subtitleCodec !== undefined) {
                localVarQueryParameter['subtitleCodec'] = subtitleCodec;
            }

            if (transcodingReasons !== undefined) {
                localVarQueryParameter['transcodingReasons'] = transcodingReasons;
            }

            if (audioStreamIndex !== undefined) {
                localVarQueryParameter['audioStreamIndex'] = audioStreamIndex;
            }

            if (videoStreamIndex !== undefined) {
                localVarQueryParameter['videoStreamIndex'] = videoStreamIndex;
            }

            if (context !== undefined) {
                localVarQueryParameter['context'] = context;
            }

            if (streamOptions !== undefined) {
                localVarQueryParameter['streamOptions'] = streamOptions;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} container 
         * @param {boolean} [_static] 
         * @param {string} [params] 
         * @param {string} [tag] 
         * @param {string} [deviceProfileId] 
         * @param {string} [playSessionId] 
         * @param {string} [segmentContainer] 
         * @param {number} [segmentLength] 
         * @param {number} [minSegments] 
         * @param {string} [mediaSourceId] 
         * @param {string} [deviceId] 
         * @param {string} [audioCodec] 
         * @param {boolean} [enableAutoStreamCopy] 
         * @param {boolean} [allowVideoStreamCopy] 
         * @param {boolean} [allowAudioStreamCopy] 
         * @param {boolean} [breakOnNonKeyFrames] 
         * @param {number} [audioSampleRate] 
         * @param {number} [maxAudioBitDepth] 
         * @param {number} [audioBitRate] 
         * @param {number} [audioChannels] 
         * @param {number} [maxAudioChannels] 
         * @param {string} [profile] 
         * @param {string} [level] 
         * @param {number} [framerate] 
         * @param {number} [maxFramerate] 
         * @param {boolean} [copyTimestamps] 
         * @param {number} [startTimeTicks] 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [videoBitRate] 
         * @param {number} [subtitleStreamIndex] 
         * @param {SubtitleDeliveryMethod} [subtitleMethod] 
         * @param {number} [maxRefFrames] 
         * @param {number} [maxVideoBitDepth] 
         * @param {boolean} [requireAvc] 
         * @param {boolean} [deInterlace] 
         * @param {boolean} [requireNonAnamorphic] 
         * @param {number} [transcodingMaxAudioChannels] 
         * @param {number} [cpuCoreLimit] 
         * @param {string} [liveStreamId] 
         * @param {boolean} [enableMpegtsM2TsMode] 
         * @param {string} [videoCodec] 
         * @param {string} [subtitleCodec] 
         * @param {string} [transcodingReasons] 
         * @param {number} [audioStreamIndex] 
         * @param {number} [videoStreamIndex] 
         * @param {EncodingContext} [context] 
         * @param {{ [key: string]: string; }} [streamOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headVideoStream: async (itemId: string, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling headVideoStream.');
            }
            // verify required parameter 'container' is not null or undefined
            if (container === null || container === undefined) {
                throw new RequiredError('container','Required parameter container was null or undefined when calling headVideoStream.');
            }
            const localVarPath = `/Videos/{itemId}/stream`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"container"}}`, encodeURIComponent(String(container)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (_static !== undefined) {
                localVarQueryParameter['static'] = _static;
            }

            if (params !== undefined) {
                localVarQueryParameter['params'] = params;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (deviceProfileId !== undefined) {
                localVarQueryParameter['deviceProfileId'] = deviceProfileId;
            }

            if (playSessionId !== undefined) {
                localVarQueryParameter['playSessionId'] = playSessionId;
            }

            if (segmentContainer !== undefined) {
                localVarQueryParameter['segmentContainer'] = segmentContainer;
            }

            if (segmentLength !== undefined) {
                localVarQueryParameter['segmentLength'] = segmentLength;
            }

            if (minSegments !== undefined) {
                localVarQueryParameter['minSegments'] = minSegments;
            }

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['mediaSourceId'] = mediaSourceId;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (audioCodec !== undefined) {
                localVarQueryParameter['audioCodec'] = audioCodec;
            }

            if (enableAutoStreamCopy !== undefined) {
                localVarQueryParameter['enableAutoStreamCopy'] = enableAutoStreamCopy;
            }

            if (allowVideoStreamCopy !== undefined) {
                localVarQueryParameter['allowVideoStreamCopy'] = allowVideoStreamCopy;
            }

            if (allowAudioStreamCopy !== undefined) {
                localVarQueryParameter['allowAudioStreamCopy'] = allowAudioStreamCopy;
            }

            if (breakOnNonKeyFrames !== undefined) {
                localVarQueryParameter['breakOnNonKeyFrames'] = breakOnNonKeyFrames;
            }

            if (audioSampleRate !== undefined) {
                localVarQueryParameter['audioSampleRate'] = audioSampleRate;
            }

            if (maxAudioBitDepth !== undefined) {
                localVarQueryParameter['maxAudioBitDepth'] = maxAudioBitDepth;
            }

            if (audioBitRate !== undefined) {
                localVarQueryParameter['audioBitRate'] = audioBitRate;
            }

            if (audioChannels !== undefined) {
                localVarQueryParameter['audioChannels'] = audioChannels;
            }

            if (maxAudioChannels !== undefined) {
                localVarQueryParameter['maxAudioChannels'] = maxAudioChannels;
            }

            if (profile !== undefined) {
                localVarQueryParameter['profile'] = profile;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (framerate !== undefined) {
                localVarQueryParameter['framerate'] = framerate;
            }

            if (maxFramerate !== undefined) {
                localVarQueryParameter['maxFramerate'] = maxFramerate;
            }

            if (copyTimestamps !== undefined) {
                localVarQueryParameter['copyTimestamps'] = copyTimestamps;
            }

            if (startTimeTicks !== undefined) {
                localVarQueryParameter['startTimeTicks'] = startTimeTicks;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (videoBitRate !== undefined) {
                localVarQueryParameter['videoBitRate'] = videoBitRate;
            }

            if (subtitleStreamIndex !== undefined) {
                localVarQueryParameter['subtitleStreamIndex'] = subtitleStreamIndex;
            }

            if (subtitleMethod !== undefined) {
                localVarQueryParameter['subtitleMethod'] = subtitleMethod;
            }

            if (maxRefFrames !== undefined) {
                localVarQueryParameter['maxRefFrames'] = maxRefFrames;
            }

            if (maxVideoBitDepth !== undefined) {
                localVarQueryParameter['maxVideoBitDepth'] = maxVideoBitDepth;
            }

            if (requireAvc !== undefined) {
                localVarQueryParameter['requireAvc'] = requireAvc;
            }

            if (deInterlace !== undefined) {
                localVarQueryParameter['deInterlace'] = deInterlace;
            }

            if (requireNonAnamorphic !== undefined) {
                localVarQueryParameter['requireNonAnamorphic'] = requireNonAnamorphic;
            }

            if (transcodingMaxAudioChannels !== undefined) {
                localVarQueryParameter['transcodingMaxAudioChannels'] = transcodingMaxAudioChannels;
            }

            if (cpuCoreLimit !== undefined) {
                localVarQueryParameter['cpuCoreLimit'] = cpuCoreLimit;
            }

            if (liveStreamId !== undefined) {
                localVarQueryParameter['liveStreamId'] = liveStreamId;
            }

            if (enableMpegtsM2TsMode !== undefined) {
                localVarQueryParameter['enableMpegtsM2TsMode'] = enableMpegtsM2TsMode;
            }

            if (videoCodec !== undefined) {
                localVarQueryParameter['videoCodec'] = videoCodec;
            }

            if (subtitleCodec !== undefined) {
                localVarQueryParameter['subtitleCodec'] = subtitleCodec;
            }

            if (transcodingReasons !== undefined) {
                localVarQueryParameter['transcodingReasons'] = transcodingReasons;
            }

            if (audioStreamIndex !== undefined) {
                localVarQueryParameter['audioStreamIndex'] = audioStreamIndex;
            }

            if (videoStreamIndex !== undefined) {
                localVarQueryParameter['videoStreamIndex'] = videoStreamIndex;
            }

            if (context !== undefined) {
                localVarQueryParameter['context'] = context;
            }

            if (streamOptions !== undefined) {
                localVarQueryParameter['streamOptions'] = streamOptions;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} container 
         * @param {string} stream 
         * @param {boolean} [_static] 
         * @param {string} [params] 
         * @param {string} [tag] 
         * @param {string} [deviceProfileId] 
         * @param {string} [playSessionId] 
         * @param {string} [segmentContainer] 
         * @param {number} [segmentLength] 
         * @param {number} [minSegments] 
         * @param {string} [mediaSourceId] 
         * @param {string} [deviceId] 
         * @param {string} [audioCodec] 
         * @param {boolean} [enableAutoStreamCopy] 
         * @param {boolean} [allowVideoStreamCopy] 
         * @param {boolean} [allowAudioStreamCopy] 
         * @param {boolean} [breakOnNonKeyFrames] 
         * @param {number} [audioSampleRate] 
         * @param {number} [maxAudioBitDepth] 
         * @param {number} [audioBitRate] 
         * @param {number} [audioChannels] 
         * @param {number} [maxAudioChannels] 
         * @param {string} [profile] 
         * @param {string} [level] 
         * @param {number} [framerate] 
         * @param {number} [maxFramerate] 
         * @param {boolean} [copyTimestamps] 
         * @param {number} [startTimeTicks] 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [videoBitRate] 
         * @param {number} [subtitleStreamIndex] 
         * @param {SubtitleDeliveryMethod} [subtitleMethod] 
         * @param {number} [maxRefFrames] 
         * @param {number} [maxVideoBitDepth] 
         * @param {boolean} [requireAvc] 
         * @param {boolean} [deInterlace] 
         * @param {boolean} [requireNonAnamorphic] 
         * @param {number} [transcodingMaxAudioChannels] 
         * @param {number} [cpuCoreLimit] 
         * @param {string} [liveStreamId] 
         * @param {boolean} [enableMpegtsM2TsMode] 
         * @param {string} [videoCodec] 
         * @param {string} [subtitleCodec] 
         * @param {string} [transcodingReasons] 
         * @param {number} [audioStreamIndex] 
         * @param {number} [videoStreamIndex] 
         * @param {EncodingContext} [context] 
         * @param {{ [key: string]: string; }} [streamOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headVideoStream2: async (itemId: string, container: string, stream: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling headVideoStream2.');
            }
            // verify required parameter 'container' is not null or undefined
            if (container === null || container === undefined) {
                throw new RequiredError('container','Required parameter container was null or undefined when calling headVideoStream2.');
            }
            // verify required parameter 'stream' is not null or undefined
            if (stream === null || stream === undefined) {
                throw new RequiredError('stream','Required parameter stream was null or undefined when calling headVideoStream2.');
            }
            const localVarPath = `/Videos/{itemId}/{stream}.{container}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"container"}}`, encodeURIComponent(String(container)))
                .replace(`{${"stream"}}`, encodeURIComponent(String(stream)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (_static !== undefined) {
                localVarQueryParameter['static'] = _static;
            }

            if (params !== undefined) {
                localVarQueryParameter['params'] = params;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (deviceProfileId !== undefined) {
                localVarQueryParameter['deviceProfileId'] = deviceProfileId;
            }

            if (playSessionId !== undefined) {
                localVarQueryParameter['playSessionId'] = playSessionId;
            }

            if (segmentContainer !== undefined) {
                localVarQueryParameter['segmentContainer'] = segmentContainer;
            }

            if (segmentLength !== undefined) {
                localVarQueryParameter['segmentLength'] = segmentLength;
            }

            if (minSegments !== undefined) {
                localVarQueryParameter['minSegments'] = minSegments;
            }

            if (mediaSourceId !== undefined) {
                localVarQueryParameter['mediaSourceId'] = mediaSourceId;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (audioCodec !== undefined) {
                localVarQueryParameter['audioCodec'] = audioCodec;
            }

            if (enableAutoStreamCopy !== undefined) {
                localVarQueryParameter['enableAutoStreamCopy'] = enableAutoStreamCopy;
            }

            if (allowVideoStreamCopy !== undefined) {
                localVarQueryParameter['allowVideoStreamCopy'] = allowVideoStreamCopy;
            }

            if (allowAudioStreamCopy !== undefined) {
                localVarQueryParameter['allowAudioStreamCopy'] = allowAudioStreamCopy;
            }

            if (breakOnNonKeyFrames !== undefined) {
                localVarQueryParameter['breakOnNonKeyFrames'] = breakOnNonKeyFrames;
            }

            if (audioSampleRate !== undefined) {
                localVarQueryParameter['audioSampleRate'] = audioSampleRate;
            }

            if (maxAudioBitDepth !== undefined) {
                localVarQueryParameter['maxAudioBitDepth'] = maxAudioBitDepth;
            }

            if (audioBitRate !== undefined) {
                localVarQueryParameter['audioBitRate'] = audioBitRate;
            }

            if (audioChannels !== undefined) {
                localVarQueryParameter['audioChannels'] = audioChannels;
            }

            if (maxAudioChannels !== undefined) {
                localVarQueryParameter['maxAudioChannels'] = maxAudioChannels;
            }

            if (profile !== undefined) {
                localVarQueryParameter['profile'] = profile;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (framerate !== undefined) {
                localVarQueryParameter['framerate'] = framerate;
            }

            if (maxFramerate !== undefined) {
                localVarQueryParameter['maxFramerate'] = maxFramerate;
            }

            if (copyTimestamps !== undefined) {
                localVarQueryParameter['copyTimestamps'] = copyTimestamps;
            }

            if (startTimeTicks !== undefined) {
                localVarQueryParameter['startTimeTicks'] = startTimeTicks;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (videoBitRate !== undefined) {
                localVarQueryParameter['videoBitRate'] = videoBitRate;
            }

            if (subtitleStreamIndex !== undefined) {
                localVarQueryParameter['subtitleStreamIndex'] = subtitleStreamIndex;
            }

            if (subtitleMethod !== undefined) {
                localVarQueryParameter['subtitleMethod'] = subtitleMethod;
            }

            if (maxRefFrames !== undefined) {
                localVarQueryParameter['maxRefFrames'] = maxRefFrames;
            }

            if (maxVideoBitDepth !== undefined) {
                localVarQueryParameter['maxVideoBitDepth'] = maxVideoBitDepth;
            }

            if (requireAvc !== undefined) {
                localVarQueryParameter['requireAvc'] = requireAvc;
            }

            if (deInterlace !== undefined) {
                localVarQueryParameter['deInterlace'] = deInterlace;
            }

            if (requireNonAnamorphic !== undefined) {
                localVarQueryParameter['requireNonAnamorphic'] = requireNonAnamorphic;
            }

            if (transcodingMaxAudioChannels !== undefined) {
                localVarQueryParameter['transcodingMaxAudioChannels'] = transcodingMaxAudioChannels;
            }

            if (cpuCoreLimit !== undefined) {
                localVarQueryParameter['cpuCoreLimit'] = cpuCoreLimit;
            }

            if (liveStreamId !== undefined) {
                localVarQueryParameter['liveStreamId'] = liveStreamId;
            }

            if (enableMpegtsM2TsMode !== undefined) {
                localVarQueryParameter['enableMpegtsM2TsMode'] = enableMpegtsM2TsMode;
            }

            if (videoCodec !== undefined) {
                localVarQueryParameter['videoCodec'] = videoCodec;
            }

            if (subtitleCodec !== undefined) {
                localVarQueryParameter['subtitleCodec'] = subtitleCodec;
            }

            if (transcodingReasons !== undefined) {
                localVarQueryParameter['transcodingReasons'] = transcodingReasons;
            }

            if (audioStreamIndex !== undefined) {
                localVarQueryParameter['audioStreamIndex'] = audioStreamIndex;
            }

            if (videoStreamIndex !== undefined) {
                localVarQueryParameter['videoStreamIndex'] = videoStreamIndex;
            }

            if (context !== undefined) {
                localVarQueryParameter['context'] = context;
            }

            if (streamOptions !== undefined) {
                localVarQueryParameter['streamOptions'] = streamOptions;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} itemIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeVersions: async (itemIds: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemIds' is not null or undefined
            if (itemIds === null || itemIds === undefined) {
                throw new RequiredError('itemIds','Required parameter itemIds was null or undefined when calling mergeVersions.');
            }
            const localVarPath = `/Videos/MergeVersions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (itemIds !== undefined) {
                localVarQueryParameter['itemIds'] = itemIds;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VideosApi - functional programming interface
 * @export
 */
export const VideosApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAlternateSources(itemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await VideosApiAxiosParamCreator(configuration).deleteAlternateSources(itemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAdditionalPart(itemId: string, userId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await VideosApiAxiosParamCreator(configuration).getAdditionalPart(itemId, userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} container 
         * @param {boolean} [_static] 
         * @param {string} [params] 
         * @param {string} [tag] 
         * @param {string} [deviceProfileId] 
         * @param {string} [playSessionId] 
         * @param {string} [segmentContainer] 
         * @param {number} [segmentLength] 
         * @param {number} [minSegments] 
         * @param {string} [mediaSourceId] 
         * @param {string} [deviceId] 
         * @param {string} [audioCodec] 
         * @param {boolean} [enableAutoStreamCopy] 
         * @param {boolean} [allowVideoStreamCopy] 
         * @param {boolean} [allowAudioStreamCopy] 
         * @param {boolean} [breakOnNonKeyFrames] 
         * @param {number} [audioSampleRate] 
         * @param {number} [maxAudioBitDepth] 
         * @param {number} [audioBitRate] 
         * @param {number} [audioChannels] 
         * @param {number} [maxAudioChannels] 
         * @param {string} [profile] 
         * @param {string} [level] 
         * @param {number} [framerate] 
         * @param {number} [maxFramerate] 
         * @param {boolean} [copyTimestamps] 
         * @param {number} [startTimeTicks] 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [videoBitRate] 
         * @param {number} [subtitleStreamIndex] 
         * @param {SubtitleDeliveryMethod} [subtitleMethod] 
         * @param {number} [maxRefFrames] 
         * @param {number} [maxVideoBitDepth] 
         * @param {boolean} [requireAvc] 
         * @param {boolean} [deInterlace] 
         * @param {boolean} [requireNonAnamorphic] 
         * @param {number} [transcodingMaxAudioChannels] 
         * @param {number} [cpuCoreLimit] 
         * @param {string} [liveStreamId] 
         * @param {boolean} [enableMpegtsM2TsMode] 
         * @param {string} [videoCodec] 
         * @param {string} [subtitleCodec] 
         * @param {string} [transcodingReasons] 
         * @param {number} [audioStreamIndex] 
         * @param {number} [videoStreamIndex] 
         * @param {EncodingContext} [context] 
         * @param {{ [key: string]: string; }} [streamOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVideoStream(itemId: string, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await VideosApiAxiosParamCreator(configuration).getVideoStream(itemId, container, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} container 
         * @param {string} stream 
         * @param {boolean} [_static] 
         * @param {string} [params] 
         * @param {string} [tag] 
         * @param {string} [deviceProfileId] 
         * @param {string} [playSessionId] 
         * @param {string} [segmentContainer] 
         * @param {number} [segmentLength] 
         * @param {number} [minSegments] 
         * @param {string} [mediaSourceId] 
         * @param {string} [deviceId] 
         * @param {string} [audioCodec] 
         * @param {boolean} [enableAutoStreamCopy] 
         * @param {boolean} [allowVideoStreamCopy] 
         * @param {boolean} [allowAudioStreamCopy] 
         * @param {boolean} [breakOnNonKeyFrames] 
         * @param {number} [audioSampleRate] 
         * @param {number} [maxAudioBitDepth] 
         * @param {number} [audioBitRate] 
         * @param {number} [audioChannels] 
         * @param {number} [maxAudioChannels] 
         * @param {string} [profile] 
         * @param {string} [level] 
         * @param {number} [framerate] 
         * @param {number} [maxFramerate] 
         * @param {boolean} [copyTimestamps] 
         * @param {number} [startTimeTicks] 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [videoBitRate] 
         * @param {number} [subtitleStreamIndex] 
         * @param {SubtitleDeliveryMethod} [subtitleMethod] 
         * @param {number} [maxRefFrames] 
         * @param {number} [maxVideoBitDepth] 
         * @param {boolean} [requireAvc] 
         * @param {boolean} [deInterlace] 
         * @param {boolean} [requireNonAnamorphic] 
         * @param {number} [transcodingMaxAudioChannels] 
         * @param {number} [cpuCoreLimit] 
         * @param {string} [liveStreamId] 
         * @param {boolean} [enableMpegtsM2TsMode] 
         * @param {string} [videoCodec] 
         * @param {string} [subtitleCodec] 
         * @param {string} [transcodingReasons] 
         * @param {number} [audioStreamIndex] 
         * @param {number} [videoStreamIndex] 
         * @param {EncodingContext} [context] 
         * @param {{ [key: string]: string; }} [streamOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVideoStream2(itemId: string, container: string, stream: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await VideosApiAxiosParamCreator(configuration).getVideoStream2(itemId, container, stream, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} container 
         * @param {boolean} [_static] 
         * @param {string} [params] 
         * @param {string} [tag] 
         * @param {string} [deviceProfileId] 
         * @param {string} [playSessionId] 
         * @param {string} [segmentContainer] 
         * @param {number} [segmentLength] 
         * @param {number} [minSegments] 
         * @param {string} [mediaSourceId] 
         * @param {string} [deviceId] 
         * @param {string} [audioCodec] 
         * @param {boolean} [enableAutoStreamCopy] 
         * @param {boolean} [allowVideoStreamCopy] 
         * @param {boolean} [allowAudioStreamCopy] 
         * @param {boolean} [breakOnNonKeyFrames] 
         * @param {number} [audioSampleRate] 
         * @param {number} [maxAudioBitDepth] 
         * @param {number} [audioBitRate] 
         * @param {number} [audioChannels] 
         * @param {number} [maxAudioChannels] 
         * @param {string} [profile] 
         * @param {string} [level] 
         * @param {number} [framerate] 
         * @param {number} [maxFramerate] 
         * @param {boolean} [copyTimestamps] 
         * @param {number} [startTimeTicks] 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [videoBitRate] 
         * @param {number} [subtitleStreamIndex] 
         * @param {SubtitleDeliveryMethod} [subtitleMethod] 
         * @param {number} [maxRefFrames] 
         * @param {number} [maxVideoBitDepth] 
         * @param {boolean} [requireAvc] 
         * @param {boolean} [deInterlace] 
         * @param {boolean} [requireNonAnamorphic] 
         * @param {number} [transcodingMaxAudioChannels] 
         * @param {number} [cpuCoreLimit] 
         * @param {string} [liveStreamId] 
         * @param {boolean} [enableMpegtsM2TsMode] 
         * @param {string} [videoCodec] 
         * @param {string} [subtitleCodec] 
         * @param {string} [transcodingReasons] 
         * @param {number} [audioStreamIndex] 
         * @param {number} [videoStreamIndex] 
         * @param {EncodingContext} [context] 
         * @param {{ [key: string]: string; }} [streamOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headVideoStream(itemId: string, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await VideosApiAxiosParamCreator(configuration).headVideoStream(itemId, container, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} container 
         * @param {string} stream 
         * @param {boolean} [_static] 
         * @param {string} [params] 
         * @param {string} [tag] 
         * @param {string} [deviceProfileId] 
         * @param {string} [playSessionId] 
         * @param {string} [segmentContainer] 
         * @param {number} [segmentLength] 
         * @param {number} [minSegments] 
         * @param {string} [mediaSourceId] 
         * @param {string} [deviceId] 
         * @param {string} [audioCodec] 
         * @param {boolean} [enableAutoStreamCopy] 
         * @param {boolean} [allowVideoStreamCopy] 
         * @param {boolean} [allowAudioStreamCopy] 
         * @param {boolean} [breakOnNonKeyFrames] 
         * @param {number} [audioSampleRate] 
         * @param {number} [maxAudioBitDepth] 
         * @param {number} [audioBitRate] 
         * @param {number} [audioChannels] 
         * @param {number} [maxAudioChannels] 
         * @param {string} [profile] 
         * @param {string} [level] 
         * @param {number} [framerate] 
         * @param {number} [maxFramerate] 
         * @param {boolean} [copyTimestamps] 
         * @param {number} [startTimeTicks] 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [videoBitRate] 
         * @param {number} [subtitleStreamIndex] 
         * @param {SubtitleDeliveryMethod} [subtitleMethod] 
         * @param {number} [maxRefFrames] 
         * @param {number} [maxVideoBitDepth] 
         * @param {boolean} [requireAvc] 
         * @param {boolean} [deInterlace] 
         * @param {boolean} [requireNonAnamorphic] 
         * @param {number} [transcodingMaxAudioChannels] 
         * @param {number} [cpuCoreLimit] 
         * @param {string} [liveStreamId] 
         * @param {boolean} [enableMpegtsM2TsMode] 
         * @param {string} [videoCodec] 
         * @param {string} [subtitleCodec] 
         * @param {string} [transcodingReasons] 
         * @param {number} [audioStreamIndex] 
         * @param {number} [videoStreamIndex] 
         * @param {EncodingContext} [context] 
         * @param {{ [key: string]: string; }} [streamOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async headVideoStream2(itemId: string, container: string, stream: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await VideosApiAxiosParamCreator(configuration).headVideoStream2(itemId, container, stream, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} itemIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mergeVersions(itemIds: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await VideosApiAxiosParamCreator(configuration).mergeVersions(itemIds, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * VideosApi - factory interface
 * @export
 */
export const VideosApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlternateSources(itemId: string, options?: any): AxiosPromise<void> {
            return VideosApiFp(configuration).deleteAlternateSources(itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdditionalPart(itemId: string, userId?: string, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return VideosApiFp(configuration).getAdditionalPart(itemId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} container 
         * @param {boolean} [_static] 
         * @param {string} [params] 
         * @param {string} [tag] 
         * @param {string} [deviceProfileId] 
         * @param {string} [playSessionId] 
         * @param {string} [segmentContainer] 
         * @param {number} [segmentLength] 
         * @param {number} [minSegments] 
         * @param {string} [mediaSourceId] 
         * @param {string} [deviceId] 
         * @param {string} [audioCodec] 
         * @param {boolean} [enableAutoStreamCopy] 
         * @param {boolean} [allowVideoStreamCopy] 
         * @param {boolean} [allowAudioStreamCopy] 
         * @param {boolean} [breakOnNonKeyFrames] 
         * @param {number} [audioSampleRate] 
         * @param {number} [maxAudioBitDepth] 
         * @param {number} [audioBitRate] 
         * @param {number} [audioChannels] 
         * @param {number} [maxAudioChannels] 
         * @param {string} [profile] 
         * @param {string} [level] 
         * @param {number} [framerate] 
         * @param {number} [maxFramerate] 
         * @param {boolean} [copyTimestamps] 
         * @param {number} [startTimeTicks] 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [videoBitRate] 
         * @param {number} [subtitleStreamIndex] 
         * @param {SubtitleDeliveryMethod} [subtitleMethod] 
         * @param {number} [maxRefFrames] 
         * @param {number} [maxVideoBitDepth] 
         * @param {boolean} [requireAvc] 
         * @param {boolean} [deInterlace] 
         * @param {boolean} [requireNonAnamorphic] 
         * @param {number} [transcodingMaxAudioChannels] 
         * @param {number} [cpuCoreLimit] 
         * @param {string} [liveStreamId] 
         * @param {boolean} [enableMpegtsM2TsMode] 
         * @param {string} [videoCodec] 
         * @param {string} [subtitleCodec] 
         * @param {string} [transcodingReasons] 
         * @param {number} [audioStreamIndex] 
         * @param {number} [videoStreamIndex] 
         * @param {EncodingContext} [context] 
         * @param {{ [key: string]: string; }} [streamOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVideoStream(itemId: string, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any): AxiosPromise<void> {
            return VideosApiFp(configuration).getVideoStream(itemId, container, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} container 
         * @param {string} stream 
         * @param {boolean} [_static] 
         * @param {string} [params] 
         * @param {string} [tag] 
         * @param {string} [deviceProfileId] 
         * @param {string} [playSessionId] 
         * @param {string} [segmentContainer] 
         * @param {number} [segmentLength] 
         * @param {number} [minSegments] 
         * @param {string} [mediaSourceId] 
         * @param {string} [deviceId] 
         * @param {string} [audioCodec] 
         * @param {boolean} [enableAutoStreamCopy] 
         * @param {boolean} [allowVideoStreamCopy] 
         * @param {boolean} [allowAudioStreamCopy] 
         * @param {boolean} [breakOnNonKeyFrames] 
         * @param {number} [audioSampleRate] 
         * @param {number} [maxAudioBitDepth] 
         * @param {number} [audioBitRate] 
         * @param {number} [audioChannels] 
         * @param {number} [maxAudioChannels] 
         * @param {string} [profile] 
         * @param {string} [level] 
         * @param {number} [framerate] 
         * @param {number} [maxFramerate] 
         * @param {boolean} [copyTimestamps] 
         * @param {number} [startTimeTicks] 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [videoBitRate] 
         * @param {number} [subtitleStreamIndex] 
         * @param {SubtitleDeliveryMethod} [subtitleMethod] 
         * @param {number} [maxRefFrames] 
         * @param {number} [maxVideoBitDepth] 
         * @param {boolean} [requireAvc] 
         * @param {boolean} [deInterlace] 
         * @param {boolean} [requireNonAnamorphic] 
         * @param {number} [transcodingMaxAudioChannels] 
         * @param {number} [cpuCoreLimit] 
         * @param {string} [liveStreamId] 
         * @param {boolean} [enableMpegtsM2TsMode] 
         * @param {string} [videoCodec] 
         * @param {string} [subtitleCodec] 
         * @param {string} [transcodingReasons] 
         * @param {number} [audioStreamIndex] 
         * @param {number} [videoStreamIndex] 
         * @param {EncodingContext} [context] 
         * @param {{ [key: string]: string; }} [streamOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVideoStream2(itemId: string, container: string, stream: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any): AxiosPromise<void> {
            return VideosApiFp(configuration).getVideoStream2(itemId, container, stream, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} container 
         * @param {boolean} [_static] 
         * @param {string} [params] 
         * @param {string} [tag] 
         * @param {string} [deviceProfileId] 
         * @param {string} [playSessionId] 
         * @param {string} [segmentContainer] 
         * @param {number} [segmentLength] 
         * @param {number} [minSegments] 
         * @param {string} [mediaSourceId] 
         * @param {string} [deviceId] 
         * @param {string} [audioCodec] 
         * @param {boolean} [enableAutoStreamCopy] 
         * @param {boolean} [allowVideoStreamCopy] 
         * @param {boolean} [allowAudioStreamCopy] 
         * @param {boolean} [breakOnNonKeyFrames] 
         * @param {number} [audioSampleRate] 
         * @param {number} [maxAudioBitDepth] 
         * @param {number} [audioBitRate] 
         * @param {number} [audioChannels] 
         * @param {number} [maxAudioChannels] 
         * @param {string} [profile] 
         * @param {string} [level] 
         * @param {number} [framerate] 
         * @param {number} [maxFramerate] 
         * @param {boolean} [copyTimestamps] 
         * @param {number} [startTimeTicks] 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [videoBitRate] 
         * @param {number} [subtitleStreamIndex] 
         * @param {SubtitleDeliveryMethod} [subtitleMethod] 
         * @param {number} [maxRefFrames] 
         * @param {number} [maxVideoBitDepth] 
         * @param {boolean} [requireAvc] 
         * @param {boolean} [deInterlace] 
         * @param {boolean} [requireNonAnamorphic] 
         * @param {number} [transcodingMaxAudioChannels] 
         * @param {number} [cpuCoreLimit] 
         * @param {string} [liveStreamId] 
         * @param {boolean} [enableMpegtsM2TsMode] 
         * @param {string} [videoCodec] 
         * @param {string} [subtitleCodec] 
         * @param {string} [transcodingReasons] 
         * @param {number} [audioStreamIndex] 
         * @param {number} [videoStreamIndex] 
         * @param {EncodingContext} [context] 
         * @param {{ [key: string]: string; }} [streamOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headVideoStream(itemId: string, container: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any): AxiosPromise<void> {
            return VideosApiFp(configuration).headVideoStream(itemId, container, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} itemId 
         * @param {string} container 
         * @param {string} stream 
         * @param {boolean} [_static] 
         * @param {string} [params] 
         * @param {string} [tag] 
         * @param {string} [deviceProfileId] 
         * @param {string} [playSessionId] 
         * @param {string} [segmentContainer] 
         * @param {number} [segmentLength] 
         * @param {number} [minSegments] 
         * @param {string} [mediaSourceId] 
         * @param {string} [deviceId] 
         * @param {string} [audioCodec] 
         * @param {boolean} [enableAutoStreamCopy] 
         * @param {boolean} [allowVideoStreamCopy] 
         * @param {boolean} [allowAudioStreamCopy] 
         * @param {boolean} [breakOnNonKeyFrames] 
         * @param {number} [audioSampleRate] 
         * @param {number} [maxAudioBitDepth] 
         * @param {number} [audioBitRate] 
         * @param {number} [audioChannels] 
         * @param {number} [maxAudioChannels] 
         * @param {string} [profile] 
         * @param {string} [level] 
         * @param {number} [framerate] 
         * @param {number} [maxFramerate] 
         * @param {boolean} [copyTimestamps] 
         * @param {number} [startTimeTicks] 
         * @param {number} [width] 
         * @param {number} [height] 
         * @param {number} [videoBitRate] 
         * @param {number} [subtitleStreamIndex] 
         * @param {SubtitleDeliveryMethod} [subtitleMethod] 
         * @param {number} [maxRefFrames] 
         * @param {number} [maxVideoBitDepth] 
         * @param {boolean} [requireAvc] 
         * @param {boolean} [deInterlace] 
         * @param {boolean} [requireNonAnamorphic] 
         * @param {number} [transcodingMaxAudioChannels] 
         * @param {number} [cpuCoreLimit] 
         * @param {string} [liveStreamId] 
         * @param {boolean} [enableMpegtsM2TsMode] 
         * @param {string} [videoCodec] 
         * @param {string} [subtitleCodec] 
         * @param {string} [transcodingReasons] 
         * @param {number} [audioStreamIndex] 
         * @param {number} [videoStreamIndex] 
         * @param {EncodingContext} [context] 
         * @param {{ [key: string]: string; }} [streamOptions] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        headVideoStream2(itemId: string, container: string, stream: string, _static?: boolean, params?: string, tag?: string, deviceProfileId?: string, playSessionId?: string, segmentContainer?: string, segmentLength?: number, minSegments?: number, mediaSourceId?: string, deviceId?: string, audioCodec?: string, enableAutoStreamCopy?: boolean, allowVideoStreamCopy?: boolean, allowAudioStreamCopy?: boolean, breakOnNonKeyFrames?: boolean, audioSampleRate?: number, maxAudioBitDepth?: number, audioBitRate?: number, audioChannels?: number, maxAudioChannels?: number, profile?: string, level?: string, framerate?: number, maxFramerate?: number, copyTimestamps?: boolean, startTimeTicks?: number, width?: number, height?: number, videoBitRate?: number, subtitleStreamIndex?: number, subtitleMethod?: SubtitleDeliveryMethod, maxRefFrames?: number, maxVideoBitDepth?: number, requireAvc?: boolean, deInterlace?: boolean, requireNonAnamorphic?: boolean, transcodingMaxAudioChannels?: number, cpuCoreLimit?: number, liveStreamId?: string, enableMpegtsM2TsMode?: boolean, videoCodec?: string, subtitleCodec?: string, transcodingReasons?: string, audioStreamIndex?: number, videoStreamIndex?: number, context?: EncodingContext, streamOptions?: { [key: string]: string; }, options?: any): AxiosPromise<void> {
            return VideosApiFp(configuration).headVideoStream2(itemId, container, stream, _static, params, tag, deviceProfileId, playSessionId, segmentContainer, segmentLength, minSegments, mediaSourceId, deviceId, audioCodec, enableAutoStreamCopy, allowVideoStreamCopy, allowAudioStreamCopy, breakOnNonKeyFrames, audioSampleRate, maxAudioBitDepth, audioBitRate, audioChannels, maxAudioChannels, profile, level, framerate, maxFramerate, copyTimestamps, startTimeTicks, width, height, videoBitRate, subtitleStreamIndex, subtitleMethod, maxRefFrames, maxVideoBitDepth, requireAvc, deInterlace, requireNonAnamorphic, transcodingMaxAudioChannels, cpuCoreLimit, liveStreamId, enableMpegtsM2TsMode, videoCodec, subtitleCodec, transcodingReasons, audioStreamIndex, videoStreamIndex, context, streamOptions, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} itemIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeVersions(itemIds: string, options?: any): AxiosPromise<void> {
            return VideosApiFp(configuration).mergeVersions(itemIds, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deleteAlternateSources operation in VideosApi.
 * @export
 * @interface VideosApiDeleteAlternateSourcesRequest
 */
export interface VideosApiDeleteAlternateSourcesRequest {
    /**
     * 
     * @type {string}
     * @memberof VideosApiDeleteAlternateSources
     */
    readonly itemId: string
}

/**
 * Request parameters for getAdditionalPart operation in VideosApi.
 * @export
 * @interface VideosApiGetAdditionalPartRequest
 */
export interface VideosApiGetAdditionalPartRequest {
    /**
     * 
     * @type {string}
     * @memberof VideosApiGetAdditionalPart
     */
    readonly itemId: string

    /**
     * 
     * @type {string}
     * @memberof VideosApiGetAdditionalPart
     */
    readonly userId?: string
}

/**
 * Request parameters for getVideoStream operation in VideosApi.
 * @export
 * @interface VideosApiGetVideoStreamRequest
 */
export interface VideosApiGetVideoStreamRequest {
    /**
     * 
     * @type {string}
     * @memberof VideosApiGetVideoStream
     */
    readonly itemId: string

    /**
     * 
     * @type {string}
     * @memberof VideosApiGetVideoStream
     */
    readonly container: string

    /**
     * 
     * @type {boolean}
     * @memberof VideosApiGetVideoStream
     */
    readonly _static?: boolean

    /**
     * 
     * @type {string}
     * @memberof VideosApiGetVideoStream
     */
    readonly params?: string

    /**
     * 
     * @type {string}
     * @memberof VideosApiGetVideoStream
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof VideosApiGetVideoStream
     */
    readonly deviceProfileId?: string

    /**
     * 
     * @type {string}
     * @memberof VideosApiGetVideoStream
     */
    readonly playSessionId?: string

    /**
     * 
     * @type {string}
     * @memberof VideosApiGetVideoStream
     */
    readonly segmentContainer?: string

    /**
     * 
     * @type {number}
     * @memberof VideosApiGetVideoStream
     */
    readonly segmentLength?: number

    /**
     * 
     * @type {number}
     * @memberof VideosApiGetVideoStream
     */
    readonly minSegments?: number

    /**
     * 
     * @type {string}
     * @memberof VideosApiGetVideoStream
     */
    readonly mediaSourceId?: string

    /**
     * 
     * @type {string}
     * @memberof VideosApiGetVideoStream
     */
    readonly deviceId?: string

    /**
     * 
     * @type {string}
     * @memberof VideosApiGetVideoStream
     */
    readonly audioCodec?: string

    /**
     * 
     * @type {boolean}
     * @memberof VideosApiGetVideoStream
     */
    readonly enableAutoStreamCopy?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof VideosApiGetVideoStream
     */
    readonly allowVideoStreamCopy?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof VideosApiGetVideoStream
     */
    readonly allowAudioStreamCopy?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof VideosApiGetVideoStream
     */
    readonly breakOnNonKeyFrames?: boolean

    /**
     * 
     * @type {number}
     * @memberof VideosApiGetVideoStream
     */
    readonly audioSampleRate?: number

    /**
     * 
     * @type {number}
     * @memberof VideosApiGetVideoStream
     */
    readonly maxAudioBitDepth?: number

    /**
     * 
     * @type {number}
     * @memberof VideosApiGetVideoStream
     */
    readonly audioBitRate?: number

    /**
     * 
     * @type {number}
     * @memberof VideosApiGetVideoStream
     */
    readonly audioChannels?: number

    /**
     * 
     * @type {number}
     * @memberof VideosApiGetVideoStream
     */
    readonly maxAudioChannels?: number

    /**
     * 
     * @type {string}
     * @memberof VideosApiGetVideoStream
     */
    readonly profile?: string

    /**
     * 
     * @type {string}
     * @memberof VideosApiGetVideoStream
     */
    readonly level?: string

    /**
     * 
     * @type {number}
     * @memberof VideosApiGetVideoStream
     */
    readonly framerate?: number

    /**
     * 
     * @type {number}
     * @memberof VideosApiGetVideoStream
     */
    readonly maxFramerate?: number

    /**
     * 
     * @type {boolean}
     * @memberof VideosApiGetVideoStream
     */
    readonly copyTimestamps?: boolean

    /**
     * 
     * @type {number}
     * @memberof VideosApiGetVideoStream
     */
    readonly startTimeTicks?: number

    /**
     * 
     * @type {number}
     * @memberof VideosApiGetVideoStream
     */
    readonly width?: number

    /**
     * 
     * @type {number}
     * @memberof VideosApiGetVideoStream
     */
    readonly height?: number

    /**
     * 
     * @type {number}
     * @memberof VideosApiGetVideoStream
     */
    readonly videoBitRate?: number

    /**
     * 
     * @type {number}
     * @memberof VideosApiGetVideoStream
     */
    readonly subtitleStreamIndex?: number

    /**
     * 
     * @type {SubtitleDeliveryMethod}
     * @memberof VideosApiGetVideoStream
     */
    readonly subtitleMethod?: SubtitleDeliveryMethod

    /**
     * 
     * @type {number}
     * @memberof VideosApiGetVideoStream
     */
    readonly maxRefFrames?: number

    /**
     * 
     * @type {number}
     * @memberof VideosApiGetVideoStream
     */
    readonly maxVideoBitDepth?: number

    /**
     * 
     * @type {boolean}
     * @memberof VideosApiGetVideoStream
     */
    readonly requireAvc?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof VideosApiGetVideoStream
     */
    readonly deInterlace?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof VideosApiGetVideoStream
     */
    readonly requireNonAnamorphic?: boolean

    /**
     * 
     * @type {number}
     * @memberof VideosApiGetVideoStream
     */
    readonly transcodingMaxAudioChannels?: number

    /**
     * 
     * @type {number}
     * @memberof VideosApiGetVideoStream
     */
    readonly cpuCoreLimit?: number

    /**
     * 
     * @type {string}
     * @memberof VideosApiGetVideoStream
     */
    readonly liveStreamId?: string

    /**
     * 
     * @type {boolean}
     * @memberof VideosApiGetVideoStream
     */
    readonly enableMpegtsM2TsMode?: boolean

    /**
     * 
     * @type {string}
     * @memberof VideosApiGetVideoStream
     */
    readonly videoCodec?: string

    /**
     * 
     * @type {string}
     * @memberof VideosApiGetVideoStream
     */
    readonly subtitleCodec?: string

    /**
     * 
     * @type {string}
     * @memberof VideosApiGetVideoStream
     */
    readonly transcodingReasons?: string

    /**
     * 
     * @type {number}
     * @memberof VideosApiGetVideoStream
     */
    readonly audioStreamIndex?: number

    /**
     * 
     * @type {number}
     * @memberof VideosApiGetVideoStream
     */
    readonly videoStreamIndex?: number

    /**
     * 
     * @type {EncodingContext}
     * @memberof VideosApiGetVideoStream
     */
    readonly context?: EncodingContext

    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof VideosApiGetVideoStream
     */
    readonly streamOptions?: { [key: string]: string; }
}

/**
 * Request parameters for getVideoStream2 operation in VideosApi.
 * @export
 * @interface VideosApiGetVideoStream2Request
 */
export interface VideosApiGetVideoStream2Request {
    /**
     * 
     * @type {string}
     * @memberof VideosApiGetVideoStream2
     */
    readonly itemId: string

    /**
     * 
     * @type {string}
     * @memberof VideosApiGetVideoStream2
     */
    readonly container: string

    /**
     * 
     * @type {string}
     * @memberof VideosApiGetVideoStream2
     */
    readonly stream: string

    /**
     * 
     * @type {boolean}
     * @memberof VideosApiGetVideoStream2
     */
    readonly _static?: boolean

    /**
     * 
     * @type {string}
     * @memberof VideosApiGetVideoStream2
     */
    readonly params?: string

    /**
     * 
     * @type {string}
     * @memberof VideosApiGetVideoStream2
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof VideosApiGetVideoStream2
     */
    readonly deviceProfileId?: string

    /**
     * 
     * @type {string}
     * @memberof VideosApiGetVideoStream2
     */
    readonly playSessionId?: string

    /**
     * 
     * @type {string}
     * @memberof VideosApiGetVideoStream2
     */
    readonly segmentContainer?: string

    /**
     * 
     * @type {number}
     * @memberof VideosApiGetVideoStream2
     */
    readonly segmentLength?: number

    /**
     * 
     * @type {number}
     * @memberof VideosApiGetVideoStream2
     */
    readonly minSegments?: number

    /**
     * 
     * @type {string}
     * @memberof VideosApiGetVideoStream2
     */
    readonly mediaSourceId?: string

    /**
     * 
     * @type {string}
     * @memberof VideosApiGetVideoStream2
     */
    readonly deviceId?: string

    /**
     * 
     * @type {string}
     * @memberof VideosApiGetVideoStream2
     */
    readonly audioCodec?: string

    /**
     * 
     * @type {boolean}
     * @memberof VideosApiGetVideoStream2
     */
    readonly enableAutoStreamCopy?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof VideosApiGetVideoStream2
     */
    readonly allowVideoStreamCopy?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof VideosApiGetVideoStream2
     */
    readonly allowAudioStreamCopy?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof VideosApiGetVideoStream2
     */
    readonly breakOnNonKeyFrames?: boolean

    /**
     * 
     * @type {number}
     * @memberof VideosApiGetVideoStream2
     */
    readonly audioSampleRate?: number

    /**
     * 
     * @type {number}
     * @memberof VideosApiGetVideoStream2
     */
    readonly maxAudioBitDepth?: number

    /**
     * 
     * @type {number}
     * @memberof VideosApiGetVideoStream2
     */
    readonly audioBitRate?: number

    /**
     * 
     * @type {number}
     * @memberof VideosApiGetVideoStream2
     */
    readonly audioChannels?: number

    /**
     * 
     * @type {number}
     * @memberof VideosApiGetVideoStream2
     */
    readonly maxAudioChannels?: number

    /**
     * 
     * @type {string}
     * @memberof VideosApiGetVideoStream2
     */
    readonly profile?: string

    /**
     * 
     * @type {string}
     * @memberof VideosApiGetVideoStream2
     */
    readonly level?: string

    /**
     * 
     * @type {number}
     * @memberof VideosApiGetVideoStream2
     */
    readonly framerate?: number

    /**
     * 
     * @type {number}
     * @memberof VideosApiGetVideoStream2
     */
    readonly maxFramerate?: number

    /**
     * 
     * @type {boolean}
     * @memberof VideosApiGetVideoStream2
     */
    readonly copyTimestamps?: boolean

    /**
     * 
     * @type {number}
     * @memberof VideosApiGetVideoStream2
     */
    readonly startTimeTicks?: number

    /**
     * 
     * @type {number}
     * @memberof VideosApiGetVideoStream2
     */
    readonly width?: number

    /**
     * 
     * @type {number}
     * @memberof VideosApiGetVideoStream2
     */
    readonly height?: number

    /**
     * 
     * @type {number}
     * @memberof VideosApiGetVideoStream2
     */
    readonly videoBitRate?: number

    /**
     * 
     * @type {number}
     * @memberof VideosApiGetVideoStream2
     */
    readonly subtitleStreamIndex?: number

    /**
     * 
     * @type {SubtitleDeliveryMethod}
     * @memberof VideosApiGetVideoStream2
     */
    readonly subtitleMethod?: SubtitleDeliveryMethod

    /**
     * 
     * @type {number}
     * @memberof VideosApiGetVideoStream2
     */
    readonly maxRefFrames?: number

    /**
     * 
     * @type {number}
     * @memberof VideosApiGetVideoStream2
     */
    readonly maxVideoBitDepth?: number

    /**
     * 
     * @type {boolean}
     * @memberof VideosApiGetVideoStream2
     */
    readonly requireAvc?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof VideosApiGetVideoStream2
     */
    readonly deInterlace?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof VideosApiGetVideoStream2
     */
    readonly requireNonAnamorphic?: boolean

    /**
     * 
     * @type {number}
     * @memberof VideosApiGetVideoStream2
     */
    readonly transcodingMaxAudioChannels?: number

    /**
     * 
     * @type {number}
     * @memberof VideosApiGetVideoStream2
     */
    readonly cpuCoreLimit?: number

    /**
     * 
     * @type {string}
     * @memberof VideosApiGetVideoStream2
     */
    readonly liveStreamId?: string

    /**
     * 
     * @type {boolean}
     * @memberof VideosApiGetVideoStream2
     */
    readonly enableMpegtsM2TsMode?: boolean

    /**
     * 
     * @type {string}
     * @memberof VideosApiGetVideoStream2
     */
    readonly videoCodec?: string

    /**
     * 
     * @type {string}
     * @memberof VideosApiGetVideoStream2
     */
    readonly subtitleCodec?: string

    /**
     * 
     * @type {string}
     * @memberof VideosApiGetVideoStream2
     */
    readonly transcodingReasons?: string

    /**
     * 
     * @type {number}
     * @memberof VideosApiGetVideoStream2
     */
    readonly audioStreamIndex?: number

    /**
     * 
     * @type {number}
     * @memberof VideosApiGetVideoStream2
     */
    readonly videoStreamIndex?: number

    /**
     * 
     * @type {EncodingContext}
     * @memberof VideosApiGetVideoStream2
     */
    readonly context?: EncodingContext

    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof VideosApiGetVideoStream2
     */
    readonly streamOptions?: { [key: string]: string; }
}

/**
 * Request parameters for headVideoStream operation in VideosApi.
 * @export
 * @interface VideosApiHeadVideoStreamRequest
 */
export interface VideosApiHeadVideoStreamRequest {
    /**
     * 
     * @type {string}
     * @memberof VideosApiHeadVideoStream
     */
    readonly itemId: string

    /**
     * 
     * @type {string}
     * @memberof VideosApiHeadVideoStream
     */
    readonly container: string

    /**
     * 
     * @type {boolean}
     * @memberof VideosApiHeadVideoStream
     */
    readonly _static?: boolean

    /**
     * 
     * @type {string}
     * @memberof VideosApiHeadVideoStream
     */
    readonly params?: string

    /**
     * 
     * @type {string}
     * @memberof VideosApiHeadVideoStream
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof VideosApiHeadVideoStream
     */
    readonly deviceProfileId?: string

    /**
     * 
     * @type {string}
     * @memberof VideosApiHeadVideoStream
     */
    readonly playSessionId?: string

    /**
     * 
     * @type {string}
     * @memberof VideosApiHeadVideoStream
     */
    readonly segmentContainer?: string

    /**
     * 
     * @type {number}
     * @memberof VideosApiHeadVideoStream
     */
    readonly segmentLength?: number

    /**
     * 
     * @type {number}
     * @memberof VideosApiHeadVideoStream
     */
    readonly minSegments?: number

    /**
     * 
     * @type {string}
     * @memberof VideosApiHeadVideoStream
     */
    readonly mediaSourceId?: string

    /**
     * 
     * @type {string}
     * @memberof VideosApiHeadVideoStream
     */
    readonly deviceId?: string

    /**
     * 
     * @type {string}
     * @memberof VideosApiHeadVideoStream
     */
    readonly audioCodec?: string

    /**
     * 
     * @type {boolean}
     * @memberof VideosApiHeadVideoStream
     */
    readonly enableAutoStreamCopy?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof VideosApiHeadVideoStream
     */
    readonly allowVideoStreamCopy?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof VideosApiHeadVideoStream
     */
    readonly allowAudioStreamCopy?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof VideosApiHeadVideoStream
     */
    readonly breakOnNonKeyFrames?: boolean

    /**
     * 
     * @type {number}
     * @memberof VideosApiHeadVideoStream
     */
    readonly audioSampleRate?: number

    /**
     * 
     * @type {number}
     * @memberof VideosApiHeadVideoStream
     */
    readonly maxAudioBitDepth?: number

    /**
     * 
     * @type {number}
     * @memberof VideosApiHeadVideoStream
     */
    readonly audioBitRate?: number

    /**
     * 
     * @type {number}
     * @memberof VideosApiHeadVideoStream
     */
    readonly audioChannels?: number

    /**
     * 
     * @type {number}
     * @memberof VideosApiHeadVideoStream
     */
    readonly maxAudioChannels?: number

    /**
     * 
     * @type {string}
     * @memberof VideosApiHeadVideoStream
     */
    readonly profile?: string

    /**
     * 
     * @type {string}
     * @memberof VideosApiHeadVideoStream
     */
    readonly level?: string

    /**
     * 
     * @type {number}
     * @memberof VideosApiHeadVideoStream
     */
    readonly framerate?: number

    /**
     * 
     * @type {number}
     * @memberof VideosApiHeadVideoStream
     */
    readonly maxFramerate?: number

    /**
     * 
     * @type {boolean}
     * @memberof VideosApiHeadVideoStream
     */
    readonly copyTimestamps?: boolean

    /**
     * 
     * @type {number}
     * @memberof VideosApiHeadVideoStream
     */
    readonly startTimeTicks?: number

    /**
     * 
     * @type {number}
     * @memberof VideosApiHeadVideoStream
     */
    readonly width?: number

    /**
     * 
     * @type {number}
     * @memberof VideosApiHeadVideoStream
     */
    readonly height?: number

    /**
     * 
     * @type {number}
     * @memberof VideosApiHeadVideoStream
     */
    readonly videoBitRate?: number

    /**
     * 
     * @type {number}
     * @memberof VideosApiHeadVideoStream
     */
    readonly subtitleStreamIndex?: number

    /**
     * 
     * @type {SubtitleDeliveryMethod}
     * @memberof VideosApiHeadVideoStream
     */
    readonly subtitleMethod?: SubtitleDeliveryMethod

    /**
     * 
     * @type {number}
     * @memberof VideosApiHeadVideoStream
     */
    readonly maxRefFrames?: number

    /**
     * 
     * @type {number}
     * @memberof VideosApiHeadVideoStream
     */
    readonly maxVideoBitDepth?: number

    /**
     * 
     * @type {boolean}
     * @memberof VideosApiHeadVideoStream
     */
    readonly requireAvc?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof VideosApiHeadVideoStream
     */
    readonly deInterlace?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof VideosApiHeadVideoStream
     */
    readonly requireNonAnamorphic?: boolean

    /**
     * 
     * @type {number}
     * @memberof VideosApiHeadVideoStream
     */
    readonly transcodingMaxAudioChannels?: number

    /**
     * 
     * @type {number}
     * @memberof VideosApiHeadVideoStream
     */
    readonly cpuCoreLimit?: number

    /**
     * 
     * @type {string}
     * @memberof VideosApiHeadVideoStream
     */
    readonly liveStreamId?: string

    /**
     * 
     * @type {boolean}
     * @memberof VideosApiHeadVideoStream
     */
    readonly enableMpegtsM2TsMode?: boolean

    /**
     * 
     * @type {string}
     * @memberof VideosApiHeadVideoStream
     */
    readonly videoCodec?: string

    /**
     * 
     * @type {string}
     * @memberof VideosApiHeadVideoStream
     */
    readonly subtitleCodec?: string

    /**
     * 
     * @type {string}
     * @memberof VideosApiHeadVideoStream
     */
    readonly transcodingReasons?: string

    /**
     * 
     * @type {number}
     * @memberof VideosApiHeadVideoStream
     */
    readonly audioStreamIndex?: number

    /**
     * 
     * @type {number}
     * @memberof VideosApiHeadVideoStream
     */
    readonly videoStreamIndex?: number

    /**
     * 
     * @type {EncodingContext}
     * @memberof VideosApiHeadVideoStream
     */
    readonly context?: EncodingContext

    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof VideosApiHeadVideoStream
     */
    readonly streamOptions?: { [key: string]: string; }
}

/**
 * Request parameters for headVideoStream2 operation in VideosApi.
 * @export
 * @interface VideosApiHeadVideoStream2Request
 */
export interface VideosApiHeadVideoStream2Request {
    /**
     * 
     * @type {string}
     * @memberof VideosApiHeadVideoStream2
     */
    readonly itemId: string

    /**
     * 
     * @type {string}
     * @memberof VideosApiHeadVideoStream2
     */
    readonly container: string

    /**
     * 
     * @type {string}
     * @memberof VideosApiHeadVideoStream2
     */
    readonly stream: string

    /**
     * 
     * @type {boolean}
     * @memberof VideosApiHeadVideoStream2
     */
    readonly _static?: boolean

    /**
     * 
     * @type {string}
     * @memberof VideosApiHeadVideoStream2
     */
    readonly params?: string

    /**
     * 
     * @type {string}
     * @memberof VideosApiHeadVideoStream2
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof VideosApiHeadVideoStream2
     */
    readonly deviceProfileId?: string

    /**
     * 
     * @type {string}
     * @memberof VideosApiHeadVideoStream2
     */
    readonly playSessionId?: string

    /**
     * 
     * @type {string}
     * @memberof VideosApiHeadVideoStream2
     */
    readonly segmentContainer?: string

    /**
     * 
     * @type {number}
     * @memberof VideosApiHeadVideoStream2
     */
    readonly segmentLength?: number

    /**
     * 
     * @type {number}
     * @memberof VideosApiHeadVideoStream2
     */
    readonly minSegments?: number

    /**
     * 
     * @type {string}
     * @memberof VideosApiHeadVideoStream2
     */
    readonly mediaSourceId?: string

    /**
     * 
     * @type {string}
     * @memberof VideosApiHeadVideoStream2
     */
    readonly deviceId?: string

    /**
     * 
     * @type {string}
     * @memberof VideosApiHeadVideoStream2
     */
    readonly audioCodec?: string

    /**
     * 
     * @type {boolean}
     * @memberof VideosApiHeadVideoStream2
     */
    readonly enableAutoStreamCopy?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof VideosApiHeadVideoStream2
     */
    readonly allowVideoStreamCopy?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof VideosApiHeadVideoStream2
     */
    readonly allowAudioStreamCopy?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof VideosApiHeadVideoStream2
     */
    readonly breakOnNonKeyFrames?: boolean

    /**
     * 
     * @type {number}
     * @memberof VideosApiHeadVideoStream2
     */
    readonly audioSampleRate?: number

    /**
     * 
     * @type {number}
     * @memberof VideosApiHeadVideoStream2
     */
    readonly maxAudioBitDepth?: number

    /**
     * 
     * @type {number}
     * @memberof VideosApiHeadVideoStream2
     */
    readonly audioBitRate?: number

    /**
     * 
     * @type {number}
     * @memberof VideosApiHeadVideoStream2
     */
    readonly audioChannels?: number

    /**
     * 
     * @type {number}
     * @memberof VideosApiHeadVideoStream2
     */
    readonly maxAudioChannels?: number

    /**
     * 
     * @type {string}
     * @memberof VideosApiHeadVideoStream2
     */
    readonly profile?: string

    /**
     * 
     * @type {string}
     * @memberof VideosApiHeadVideoStream2
     */
    readonly level?: string

    /**
     * 
     * @type {number}
     * @memberof VideosApiHeadVideoStream2
     */
    readonly framerate?: number

    /**
     * 
     * @type {number}
     * @memberof VideosApiHeadVideoStream2
     */
    readonly maxFramerate?: number

    /**
     * 
     * @type {boolean}
     * @memberof VideosApiHeadVideoStream2
     */
    readonly copyTimestamps?: boolean

    /**
     * 
     * @type {number}
     * @memberof VideosApiHeadVideoStream2
     */
    readonly startTimeTicks?: number

    /**
     * 
     * @type {number}
     * @memberof VideosApiHeadVideoStream2
     */
    readonly width?: number

    /**
     * 
     * @type {number}
     * @memberof VideosApiHeadVideoStream2
     */
    readonly height?: number

    /**
     * 
     * @type {number}
     * @memberof VideosApiHeadVideoStream2
     */
    readonly videoBitRate?: number

    /**
     * 
     * @type {number}
     * @memberof VideosApiHeadVideoStream2
     */
    readonly subtitleStreamIndex?: number

    /**
     * 
     * @type {SubtitleDeliveryMethod}
     * @memberof VideosApiHeadVideoStream2
     */
    readonly subtitleMethod?: SubtitleDeliveryMethod

    /**
     * 
     * @type {number}
     * @memberof VideosApiHeadVideoStream2
     */
    readonly maxRefFrames?: number

    /**
     * 
     * @type {number}
     * @memberof VideosApiHeadVideoStream2
     */
    readonly maxVideoBitDepth?: number

    /**
     * 
     * @type {boolean}
     * @memberof VideosApiHeadVideoStream2
     */
    readonly requireAvc?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof VideosApiHeadVideoStream2
     */
    readonly deInterlace?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof VideosApiHeadVideoStream2
     */
    readonly requireNonAnamorphic?: boolean

    /**
     * 
     * @type {number}
     * @memberof VideosApiHeadVideoStream2
     */
    readonly transcodingMaxAudioChannels?: number

    /**
     * 
     * @type {number}
     * @memberof VideosApiHeadVideoStream2
     */
    readonly cpuCoreLimit?: number

    /**
     * 
     * @type {string}
     * @memberof VideosApiHeadVideoStream2
     */
    readonly liveStreamId?: string

    /**
     * 
     * @type {boolean}
     * @memberof VideosApiHeadVideoStream2
     */
    readonly enableMpegtsM2TsMode?: boolean

    /**
     * 
     * @type {string}
     * @memberof VideosApiHeadVideoStream2
     */
    readonly videoCodec?: string

    /**
     * 
     * @type {string}
     * @memberof VideosApiHeadVideoStream2
     */
    readonly subtitleCodec?: string

    /**
     * 
     * @type {string}
     * @memberof VideosApiHeadVideoStream2
     */
    readonly transcodingReasons?: string

    /**
     * 
     * @type {number}
     * @memberof VideosApiHeadVideoStream2
     */
    readonly audioStreamIndex?: number

    /**
     * 
     * @type {number}
     * @memberof VideosApiHeadVideoStream2
     */
    readonly videoStreamIndex?: number

    /**
     * 
     * @type {EncodingContext}
     * @memberof VideosApiHeadVideoStream2
     */
    readonly context?: EncodingContext

    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof VideosApiHeadVideoStream2
     */
    readonly streamOptions?: { [key: string]: string; }
}

/**
 * Request parameters for mergeVersions operation in VideosApi.
 * @export
 * @interface VideosApiMergeVersionsRequest
 */
export interface VideosApiMergeVersionsRequest {
    /**
     * 
     * @type {string}
     * @memberof VideosApiMergeVersions
     */
    readonly itemIds: string
}

/**
 * VideosApi - object-oriented interface
 * @export
 * @class VideosApi
 * @extends {BaseAPI}
 */
export class VideosApi extends BaseAPI {
    /**
     * 
     * @param {VideosApiDeleteAlternateSourcesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApi
     */
    public deleteAlternateSources(requestParameters: VideosApiDeleteAlternateSourcesRequest, options?: any) {
        return VideosApiFp(this.configuration).deleteAlternateSources(requestParameters.itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VideosApiGetAdditionalPartRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApi
     */
    public getAdditionalPart(requestParameters: VideosApiGetAdditionalPartRequest, options?: any) {
        return VideosApiFp(this.configuration).getAdditionalPart(requestParameters.itemId, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VideosApiGetVideoStreamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApi
     */
    public getVideoStream(requestParameters: VideosApiGetVideoStreamRequest, options?: any) {
        return VideosApiFp(this.configuration).getVideoStream(requestParameters.itemId, requestParameters.container, requestParameters._static, requestParameters.params, requestParameters.tag, requestParameters.deviceProfileId, requestParameters.playSessionId, requestParameters.segmentContainer, requestParameters.segmentLength, requestParameters.minSegments, requestParameters.mediaSourceId, requestParameters.deviceId, requestParameters.audioCodec, requestParameters.enableAutoStreamCopy, requestParameters.allowVideoStreamCopy, requestParameters.allowAudioStreamCopy, requestParameters.breakOnNonKeyFrames, requestParameters.audioSampleRate, requestParameters.maxAudioBitDepth, requestParameters.audioBitRate, requestParameters.audioChannels, requestParameters.maxAudioChannels, requestParameters.profile, requestParameters.level, requestParameters.framerate, requestParameters.maxFramerate, requestParameters.copyTimestamps, requestParameters.startTimeTicks, requestParameters.width, requestParameters.height, requestParameters.videoBitRate, requestParameters.subtitleStreamIndex, requestParameters.subtitleMethod, requestParameters.maxRefFrames, requestParameters.maxVideoBitDepth, requestParameters.requireAvc, requestParameters.deInterlace, requestParameters.requireNonAnamorphic, requestParameters.transcodingMaxAudioChannels, requestParameters.cpuCoreLimit, requestParameters.liveStreamId, requestParameters.enableMpegtsM2TsMode, requestParameters.videoCodec, requestParameters.subtitleCodec, requestParameters.transcodingReasons, requestParameters.audioStreamIndex, requestParameters.videoStreamIndex, requestParameters.context, requestParameters.streamOptions, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VideosApiGetVideoStream2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApi
     */
    public getVideoStream2(requestParameters: VideosApiGetVideoStream2Request, options?: any) {
        return VideosApiFp(this.configuration).getVideoStream2(requestParameters.itemId, requestParameters.container, requestParameters.stream, requestParameters._static, requestParameters.params, requestParameters.tag, requestParameters.deviceProfileId, requestParameters.playSessionId, requestParameters.segmentContainer, requestParameters.segmentLength, requestParameters.minSegments, requestParameters.mediaSourceId, requestParameters.deviceId, requestParameters.audioCodec, requestParameters.enableAutoStreamCopy, requestParameters.allowVideoStreamCopy, requestParameters.allowAudioStreamCopy, requestParameters.breakOnNonKeyFrames, requestParameters.audioSampleRate, requestParameters.maxAudioBitDepth, requestParameters.audioBitRate, requestParameters.audioChannels, requestParameters.maxAudioChannels, requestParameters.profile, requestParameters.level, requestParameters.framerate, requestParameters.maxFramerate, requestParameters.copyTimestamps, requestParameters.startTimeTicks, requestParameters.width, requestParameters.height, requestParameters.videoBitRate, requestParameters.subtitleStreamIndex, requestParameters.subtitleMethod, requestParameters.maxRefFrames, requestParameters.maxVideoBitDepth, requestParameters.requireAvc, requestParameters.deInterlace, requestParameters.requireNonAnamorphic, requestParameters.transcodingMaxAudioChannels, requestParameters.cpuCoreLimit, requestParameters.liveStreamId, requestParameters.enableMpegtsM2TsMode, requestParameters.videoCodec, requestParameters.subtitleCodec, requestParameters.transcodingReasons, requestParameters.audioStreamIndex, requestParameters.videoStreamIndex, requestParameters.context, requestParameters.streamOptions, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VideosApiHeadVideoStreamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApi
     */
    public headVideoStream(requestParameters: VideosApiHeadVideoStreamRequest, options?: any) {
        return VideosApiFp(this.configuration).headVideoStream(requestParameters.itemId, requestParameters.container, requestParameters._static, requestParameters.params, requestParameters.tag, requestParameters.deviceProfileId, requestParameters.playSessionId, requestParameters.segmentContainer, requestParameters.segmentLength, requestParameters.minSegments, requestParameters.mediaSourceId, requestParameters.deviceId, requestParameters.audioCodec, requestParameters.enableAutoStreamCopy, requestParameters.allowVideoStreamCopy, requestParameters.allowAudioStreamCopy, requestParameters.breakOnNonKeyFrames, requestParameters.audioSampleRate, requestParameters.maxAudioBitDepth, requestParameters.audioBitRate, requestParameters.audioChannels, requestParameters.maxAudioChannels, requestParameters.profile, requestParameters.level, requestParameters.framerate, requestParameters.maxFramerate, requestParameters.copyTimestamps, requestParameters.startTimeTicks, requestParameters.width, requestParameters.height, requestParameters.videoBitRate, requestParameters.subtitleStreamIndex, requestParameters.subtitleMethod, requestParameters.maxRefFrames, requestParameters.maxVideoBitDepth, requestParameters.requireAvc, requestParameters.deInterlace, requestParameters.requireNonAnamorphic, requestParameters.transcodingMaxAudioChannels, requestParameters.cpuCoreLimit, requestParameters.liveStreamId, requestParameters.enableMpegtsM2TsMode, requestParameters.videoCodec, requestParameters.subtitleCodec, requestParameters.transcodingReasons, requestParameters.audioStreamIndex, requestParameters.videoStreamIndex, requestParameters.context, requestParameters.streamOptions, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VideosApiHeadVideoStream2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApi
     */
    public headVideoStream2(requestParameters: VideosApiHeadVideoStream2Request, options?: any) {
        return VideosApiFp(this.configuration).headVideoStream2(requestParameters.itemId, requestParameters.container, requestParameters.stream, requestParameters._static, requestParameters.params, requestParameters.tag, requestParameters.deviceProfileId, requestParameters.playSessionId, requestParameters.segmentContainer, requestParameters.segmentLength, requestParameters.minSegments, requestParameters.mediaSourceId, requestParameters.deviceId, requestParameters.audioCodec, requestParameters.enableAutoStreamCopy, requestParameters.allowVideoStreamCopy, requestParameters.allowAudioStreamCopy, requestParameters.breakOnNonKeyFrames, requestParameters.audioSampleRate, requestParameters.maxAudioBitDepth, requestParameters.audioBitRate, requestParameters.audioChannels, requestParameters.maxAudioChannels, requestParameters.profile, requestParameters.level, requestParameters.framerate, requestParameters.maxFramerate, requestParameters.copyTimestamps, requestParameters.startTimeTicks, requestParameters.width, requestParameters.height, requestParameters.videoBitRate, requestParameters.subtitleStreamIndex, requestParameters.subtitleMethod, requestParameters.maxRefFrames, requestParameters.maxVideoBitDepth, requestParameters.requireAvc, requestParameters.deInterlace, requestParameters.requireNonAnamorphic, requestParameters.transcodingMaxAudioChannels, requestParameters.cpuCoreLimit, requestParameters.liveStreamId, requestParameters.enableMpegtsM2TsMode, requestParameters.videoCodec, requestParameters.subtitleCodec, requestParameters.transcodingReasons, requestParameters.audioStreamIndex, requestParameters.videoStreamIndex, requestParameters.context, requestParameters.streamOptions, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VideosApiMergeVersionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApi
     */
    public mergeVersions(requestParameters: VideosApiMergeVersionsRequest, options?: any) {
        return VideosApiFp(this.configuration).mergeVersions(requestParameters.itemIds, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * YearsApi - axios parameter creator
 * @export
 */
export const YearsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} year 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getYear: async (year: number, userId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'year' is not null or undefined
            if (year === null || year === undefined) {
                throw new RequiredError('year','Required parameter year was null or undefined when calling getYear.');
            }
            const localVarPath = `/Years/{year}`
                .replace(`{${"year"}}`, encodeURIComponent(String(year)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [startIndex] 
         * @param {number} [limit] 
         * @param {string} [sortOrder] 
         * @param {string} [parentId] 
         * @param {string} [fields] 
         * @param {string} [excludeItemTypes] 
         * @param {string} [includeItemTypes] 
         * @param {string} [mediaTypes] 
         * @param {string} [sortBy] 
         * @param {boolean} [enableUserData] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {string} [userId] 
         * @param {boolean} [recursive] 
         * @param {boolean} [enableImages] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getYears: async (startIndex?: number, limit?: number, sortOrder?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, mediaTypes?: string, sortBy?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, userId?: string, recursive?: boolean, enableImages?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/Years`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication CustomAuthentication required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Emby-Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Emby-Authorization"] = localVarApiKeyValue;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['startIndex'] = startIndex;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (parentId !== undefined) {
                localVarQueryParameter['parentId'] = parentId;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (excludeItemTypes !== undefined) {
                localVarQueryParameter['excludeItemTypes'] = excludeItemTypes;
            }

            if (includeItemTypes !== undefined) {
                localVarQueryParameter['includeItemTypes'] = includeItemTypes;
            }

            if (mediaTypes !== undefined) {
                localVarQueryParameter['mediaTypes'] = mediaTypes;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (enableUserData !== undefined) {
                localVarQueryParameter['enableUserData'] = enableUserData;
            }

            if (imageTypeLimit !== undefined) {
                localVarQueryParameter['imageTypeLimit'] = imageTypeLimit;
            }

            if (enableImageTypes !== undefined) {
                localVarQueryParameter['enableImageTypes'] = enableImageTypes;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (recursive !== undefined) {
                localVarQueryParameter['recursive'] = recursive;
            }

            if (enableImages !== undefined) {
                localVarQueryParameter['enableImages'] = enableImages;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * YearsApi - functional programming interface
 * @export
 */
export const YearsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} year 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getYear(year: number, userId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDto>> {
            const localVarAxiosArgs = await YearsApiAxiosParamCreator(configuration).getYear(year, userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} [startIndex] 
         * @param {number} [limit] 
         * @param {string} [sortOrder] 
         * @param {string} [parentId] 
         * @param {string} [fields] 
         * @param {string} [excludeItemTypes] 
         * @param {string} [includeItemTypes] 
         * @param {string} [mediaTypes] 
         * @param {string} [sortBy] 
         * @param {boolean} [enableUserData] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {string} [userId] 
         * @param {boolean} [recursive] 
         * @param {boolean} [enableImages] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getYears(startIndex?: number, limit?: number, sortOrder?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, mediaTypes?: string, sortBy?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, userId?: string, recursive?: boolean, enableImages?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseItemDtoQueryResult>> {
            const localVarAxiosArgs = await YearsApiAxiosParamCreator(configuration).getYears(startIndex, limit, sortOrder, parentId, fields, excludeItemTypes, includeItemTypes, mediaTypes, sortBy, enableUserData, imageTypeLimit, enableImageTypes, userId, recursive, enableImages, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * YearsApi - factory interface
 * @export
 */
export const YearsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {number} year 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getYear(year: number, userId?: string, options?: any): AxiosPromise<BaseItemDto> {
            return YearsApiFp(configuration).getYear(year, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [startIndex] 
         * @param {number} [limit] 
         * @param {string} [sortOrder] 
         * @param {string} [parentId] 
         * @param {string} [fields] 
         * @param {string} [excludeItemTypes] 
         * @param {string} [includeItemTypes] 
         * @param {string} [mediaTypes] 
         * @param {string} [sortBy] 
         * @param {boolean} [enableUserData] 
         * @param {number} [imageTypeLimit] 
         * @param {string} [enableImageTypes] 
         * @param {string} [userId] 
         * @param {boolean} [recursive] 
         * @param {boolean} [enableImages] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getYears(startIndex?: number, limit?: number, sortOrder?: string, parentId?: string, fields?: string, excludeItemTypes?: string, includeItemTypes?: string, mediaTypes?: string, sortBy?: string, enableUserData?: boolean, imageTypeLimit?: number, enableImageTypes?: string, userId?: string, recursive?: boolean, enableImages?: boolean, options?: any): AxiosPromise<BaseItemDtoQueryResult> {
            return YearsApiFp(configuration).getYears(startIndex, limit, sortOrder, parentId, fields, excludeItemTypes, includeItemTypes, mediaTypes, sortBy, enableUserData, imageTypeLimit, enableImageTypes, userId, recursive, enableImages, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getYear operation in YearsApi.
 * @export
 * @interface YearsApiGetYearRequest
 */
export interface YearsApiGetYearRequest {
    /**
     * 
     * @type {number}
     * @memberof YearsApiGetYear
     */
    readonly year: number

    /**
     * 
     * @type {string}
     * @memberof YearsApiGetYear
     */
    readonly userId?: string
}

/**
 * Request parameters for getYears operation in YearsApi.
 * @export
 * @interface YearsApiGetYearsRequest
 */
export interface YearsApiGetYearsRequest {
    /**
     * 
     * @type {number}
     * @memberof YearsApiGetYears
     */
    readonly startIndex?: number

    /**
     * 
     * @type {number}
     * @memberof YearsApiGetYears
     */
    readonly limit?: number

    /**
     * 
     * @type {string}
     * @memberof YearsApiGetYears
     */
    readonly sortOrder?: string

    /**
     * 
     * @type {string}
     * @memberof YearsApiGetYears
     */
    readonly parentId?: string

    /**
     * 
     * @type {string}
     * @memberof YearsApiGetYears
     */
    readonly fields?: string

    /**
     * 
     * @type {string}
     * @memberof YearsApiGetYears
     */
    readonly excludeItemTypes?: string

    /**
     * 
     * @type {string}
     * @memberof YearsApiGetYears
     */
    readonly includeItemTypes?: string

    /**
     * 
     * @type {string}
     * @memberof YearsApiGetYears
     */
    readonly mediaTypes?: string

    /**
     * 
     * @type {string}
     * @memberof YearsApiGetYears
     */
    readonly sortBy?: string

    /**
     * 
     * @type {boolean}
     * @memberof YearsApiGetYears
     */
    readonly enableUserData?: boolean

    /**
     * 
     * @type {number}
     * @memberof YearsApiGetYears
     */
    readonly imageTypeLimit?: number

    /**
     * 
     * @type {string}
     * @memberof YearsApiGetYears
     */
    readonly enableImageTypes?: string

    /**
     * 
     * @type {string}
     * @memberof YearsApiGetYears
     */
    readonly userId?: string

    /**
     * 
     * @type {boolean}
     * @memberof YearsApiGetYears
     */
    readonly recursive?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof YearsApiGetYears
     */
    readonly enableImages?: boolean
}

/**
 * YearsApi - object-oriented interface
 * @export
 * @class YearsApi
 * @extends {BaseAPI}
 */
export class YearsApi extends BaseAPI {
    /**
     * 
     * @param {YearsApiGetYearRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof YearsApi
     */
    public getYear(requestParameters: YearsApiGetYearRequest, options?: any) {
        return YearsApiFp(this.configuration).getYear(requestParameters.year, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {YearsApiGetYearsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof YearsApi
     */
    public getYears(requestParameters: YearsApiGetYearsRequest = {}, options?: any) {
        return YearsApiFp(this.configuration).getYears(requestParameters.startIndex, requestParameters.limit, requestParameters.sortOrder, requestParameters.parentId, requestParameters.fields, requestParameters.excludeItemTypes, requestParameters.includeItemTypes, requestParameters.mediaTypes, requestParameters.sortBy, requestParameters.enableUserData, requestParameters.imageTypeLimit, requestParameters.enableImageTypes, requestParameters.userId, requestParameters.recursive, requestParameters.enableImages, options).then((request) => request(this.axios, this.basePath));
    }
}


